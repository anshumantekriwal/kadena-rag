[
  {
    "content": "Summarizes the data models used for different elements and attributes in Chainweb nodes. Data models summarize the parameters that define important Chainweb node elements. The information in the data models is the same as the information covered in the endpoint documentation. It's duplicated here as a quick reference. Cut model | Parameter | Type | Description | --------- | ---- | ----------- | origin | object | Defines a peer information object that consists of an id string and an address object. The origin parameter is required to use the PUT /cut endpoint. For more information, see the Peer information data model. | height (required) | integer >= 0 | Defines the cut height. The cut height is the sum of the height of all blocks of the cut. You should avoid using this value in any applications or tools because its semantics might change. | weight (required) | string | Defines the cut weight. The cut weight is the sum of the weights from all of the blocks included in the cut. The weight string consists of 43 characters from the a-zA-Z0-9- character set. | hashes (required) | object | Defines an object that maps chain identifiers to their respective block hash and block height. The block hash property is a required string value with characters from the a-zA-Z0-9- character set. The block height property is a required integer value >= 0. The hashes object includes the height and hash properties for each chain, as illustrated for chains 0 and 1 in the truncated JSON example. | instance | string | Defines the network identifier for the cut. | id | string | Defines a cut identifier. Code example (json): { \"origin\": null, \"height\": 30798466, \"weight\": \"b0wYplmNiTBXCwAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\", \"hashes\": { \"0\": { \"height\": 1539923, \"hash\": \"qEaSmWttDcJC9AGbgWY9x12LW5VED7hGgfyz9xS3w\" }, \"1\": { \"height\": 1539923, \"hash\": \"TJuC6nfhamfD517gspAZmqD9umR71nAgttDOi1JbBHw\" }, }, \"id\": \"BBz7KeurYTeQ0hMGbwUbQC84cRbVcacoDQTye-3qkXI\", \"instance\": \"mainnet01\" } Block header model | Parameter | Type | Description | --------- | ---- | ----------- | creationTime (required) | integer >= 0 | Records the time the block was created. This timestamp is in microseconds since the start of the UNIX epoch. | parent (required) | string | Records the parent block hash. The block hash is a Base64Url-encoded string—without padding—that consists of 43 characters from the a-zA-Z0-9- character set. | height (required) | integer >= 0 | Identifies the block height for the block. The height of a block is the number of its predecessors in the block chain. | hash (required) | string | Block hash is a Base64Url-encoded string—without padding—that consists of 43 characters from the a-zA-Z0-9- character set. | chainId (required) | integer >= 0 | Specifies the Chainweb chain identifier. In Kadena, Chainweb chains are named by numbers starting from 0. Valid values depend on the current graph at the respective block height of the Chainweb version. | weight (required) | string | Specifies the block weight for the block. Block weight is a Base64Url-encoded string—without padding—that consists of 43 characters from the a-zA-Z0-9- character set. The weight of a block is the sum of the difficulties of the block and of all of its ancestors. The difficulty of a block is the maximum difficulty divided by the target. The string is a 256-bit little endian encoding of the numerical value. | featureFlags (required) | integer | Specifies a reserved value that must be 0. | epochStart (required) | integer >= 0 | Specifies a timestamp in microseconds since the start of the UNIX epoch. | adjacents (required) | object | Records the block hashes of the adjacent parents of the block. This is represented as an associative array that maps the adjacent chain ids to the respective block hash. Each block hash is a Base64Url-encoded string—without padding—that consists of 43 characters from the a-zA-Z0-9- character set. | payloadHash (required) | string | Specifies the block payload hash. The payload hash is a Base64Url-encoded string—without padding—that consists of 43 characters from the a-zA-Z0-9- character set. | chainwebVersion (required) | enum | Specifies the Chainweb network version identifier for the Kadena network. The valid values are \"test-singleton\", \"development\", \"mainnet01\", and \"testnet04\". | target (required) | string | Specifies the proof-of-work target for the block. The proof-of-work target for a block is a Base64Url-encoded string—without padding—that consists of 43 characters from the a-zA-Z0-9- character set. The string is a 256-bit little endian encoding of the numerical value. | nonce (required) | string | Specifies the proof-of-work nonce for the block. This value is computed by the miner such that the block hash is smaller than the target. Code example (json): { \"creationTime\": 1721071750065287, \"nonce\": \"16462985723698616006\", \"parent\": \"g-N8bZuyno0rkPyJZShFQzU5Den2rey1qlflnJuizzQ\", \"adjacents\": { \"19\": \"YlpdztdOQ-ChRklldcC2oHbZlAMIiYAGRgzTZBXvRgY\", \"14\": \"VosxlCQP8q0cPi3zdyD099Untb69bnIgIFlAioj9I\", \"9\": \"GXv0fxVXgDQTtRTxMjWfr6JXXrSscoaCaxEDPC93QIg\" }, \"target\": \"ikpunXJe5dbyqNaNMDhOWhBtJeLpVENWFQAAAAAAAAA\", \"payloadHash\": \"bVqvJPaU98NLqPCMmaBy2v67XnzFi6c1Ei6NLZjZVvI\", \"chainId\": 4, \"weight\": \"FahB1Biuxv0BSQEAAAA. . . [code continues] Payload model | Parameter | Type | Description | --------- | ---- | ----------- | transactions (required) | Array of strings | Array of Base64Url encoded strings without padding that represent signed Pact transactions in JSON format. | minerData (required) | string | Miner information is a Base64Url-encoded string—without padding—that consists of 43 characters from the a-zA-Z0-9- character set. This information is included as part of the payload in the JSON object. | transactionsHash (required) | string | The transaction hash is a SHA256 hash. The hash is a Base64Url-encoded string—without padding—that consists of 43 characters from the a-zA-Z0-9- character set. | outputsHash (required) | string | The output hash is a SHA256 hash. The hash is a Base64Url-encoded string—without padding—that consists of 43 characters from the a-zA-Z0-9- character set. | payloadHash (required) | string | The block payload hash is a Base64Url-encoded string—without padding—that consists of 43 characters from the a-zA-Z0-9- character set. Code example (json): { \"transactions\": [ \"eyJoYXNoIjoiMi16Q3dmRFZZR010WHljd2pTLXRlNzh5U3l3T3JXcjNSdUhiQlJnNDdhRSIsInNpZ3MiOlt7InNpZyI6ImZiMTVkNzkyYTNkNDM1MDI5ODJmOGQ1MGUyMzA1NTI5OWEwZjdhMWRmMWE4YjUyMmE5NTMxNWUyZDljY2MyNmE1MzI4M2I5YTNhNDM5ZWE0ZGY4MGM1ZTIwMjg4NDhjNjFhMWY0MGM5OWIyOTYzOWM0NGNkYTgwMzBmYmViYjBjIn1dLCJjbWQiOiJ7XCJuZXR3b3JrSWRcIjpcIm1haW5uZXQwMVwiLFwicGF5bG9hZFwiOntcImV4ZWNcIjp7XCJkYXRhXCI6e30sXCJjb2RlXCI6XCIoY29pbi50cmFuc2ZlciBcXFwiZTc1NzU4ZGQyYTFjNTk2NDRjMjJlMDQyYzZlYzA3NTI2ZWE0ZTU3MTU0ZjlkYmMyMDc2Z. . . [code continues] Payload with outputs model | Parameter | Type | Description | --------- | ---- | ----------- | transactions (required) | Array of strings | Array with pairs of strings that represent transactions and their outputs. Signed Pact transactions and their outputs are both Base64Url-encoded strings—without padding—that represent signed Pact transactions in JSON format. | minerData (required) | string | Miner information is a Base64Url-encoded string—without padding—that consists of characters from the a-zA-Z0-9- character set. This information is included as part of the payload JSON object. | transactionsHash (required) | string | The transaction hash is a SHA256 hash. The hash is a Base64Url-encoded string—without padding—that consists of 43 characters from the a-zA-Z0-9- character set. | outputsHash (required) | string | The output hash is a SHA256 hash. The hash is a Base64Url-encoded string—without padding—that consists of 43 characters from the a-zA-Z0-9- character set. | payloadHash (required) | string | The block payload hash is a Base64Url-encoded string—without padding—that consists of 43 characters from the a-zA-Z0-9- character set. | coinbase (required) | string | Coinbase output is a Base64Url-encoded string—without padding—that consists of characters from the a-zA-Z0-9- character set. This information is included as part of the payload output JSON object. Code example (json): { \"transactions\": [], \"minerData\": \"eyJhY2NvdW50IjoiYTFiMzE0MGNiN2NjODk1YzBlMDkxNzAyZWQwNTU3OWZiZTA1YzZlNjc0NWY4MmNlNjAzNzQ2YjQwMGM4MTU0OCIsInByZWRpY2F0ZSI6ImtleXMtYWxsIiwicHVibGljLWtleXMiOlsiYTFiMzE0MGNiN2NjODk1YzBlMDkxNzAyZWQwNTU3OWZiZTA1YzZlNjc0NWY4MmNlNjAzNzQ2YjQwMGM4MTU0OCJdfQ\", \"transactionsHash\": \"nT0j4xw2woMkdXXaopdurXIn24OG-jNMqQzUGfxVMA\", \"outputsHash\": \"4pXRrZ2K0V0iGAxQCKrKdLjQTBZHBOQS7P-47kdnhY\", \"payloadHash\": \"GpaWbHkHrCjRhY8hKE0qZ1WsBBaG3YzkFLV2sYumQA\", \"coinbase\": . . . [code continues] Peer information model | Parameter | Type | Description | --------- | ---- | ----------- | id (required) | string or null | The id is a Base64Url-encoded string—without padding—that consists of characters from the a-zA-Z0-9- character set. This string represents the SHA256 fingerprint of the SSL certificate of the node. The field can be null only if the node uses an official CA-signed certificate. | address (required) | object | The address contains a hostname and port number. The hostname is a required string value in the form of a domain name, IPv4 IP address, or IPv6 IP address. The hostname must be a domain name only if the node uses a valid CA-signed SSL certificate. The port is a required integer value [1. . 65535] that hosts the peer node. Code example (json): { \"address\": { \"hostname\": \"85. 238. 99. 91\", \"port\": 30004 }, \"id\": \"PRLmVUcc9AH3fyfMYiWeC4nV2i1iHwc0-aM7iAO8h18\" } Note that it is generally easier to query the peer information for a node using a GET query for the peer database. To get the Base64Url-encoded SHA256 fingerprint peer id for peers with self-signed certificates, run a command like this for the specified chainweb-node NODE: Code example (bash): echo | openssl sclient -showcerts -servername ${NODE} -connect ${NODE}: 443 2>/dev/null | openssl x509 -fingerprint -noout -sha256 | sed 's/: //g' | tail -c 65 | xxd -r -p | base64 | tr -d '=' | tr '/+' '-' For example, to get the peer id for a testnet bootstrap server: Code example (bash): echo | openssl sclient -showcerts -servername us-e1. chainweb. com -connect us-e1. chainweb. com: 443 2>/dev/null | openssl x509 -fingerprint -noout -sha256 | sed 's/: //g' | tail -c 65 | xxd -r -p | base64 | tr -d '=' | tr '/+' '-' The output from running this command is the peer id: Code example (bash): vPELrRZEn3km96owfL0ANJbOBeeUGnEBOx0AGCTZsdA Chainweb node information model | Parameter | Type | Description | --------- | ---- | ----------- | nodeNumberOfChains (required) | integer >= 10 | Number of chains in the network the node is part of. | nodeApiVersion (required) | string | Chainweb API version information for the node. | nodeChains (required) | Array of strings | Chain identifiers for the chains in the network the node is part of. | nodeVersion (required) | string | Network identifier for the network the node is part of. The valid values are \"test-singleton\", \"development\", \"mainnet01\", and \"testnet04\". | nodeGraphHistory (required) | Array of integers | Array of all chain graphs indexed by the height of the first block with the respective graph. Graphs are encoded as adjacency lists. Code example (json): { \"nodeNumberOfChains\": 20, \"nodeApiVersion\": \"0. 0\", \"nodeChains\": [ \"12\", \"13\", \". . . \"], \"nodeVersion\": \"mainnet01\", \"nodeGraphHistory\": [ [ 0, [ ] ], [ 852054, [ ] ] ] } Collection page model | Parameter | Type | Description | --------- | ---- | ----------- | limit (required) | integer >= 0 | The maximum number of items in the page. This number can be smaller but never be larger than the number of requested items. | next (required) | string or null | A cursor that can be used to query the next page. It should be used literally as the value for the next parameter in a follow-up request. | items (required) | any | The items in the page. Code example (json): { \"next\": \"inclusive: o1S4NNFhKWg8T1HEkmDvsTH9Ut9l3qHRpp00yRKZIk\", \"items\": [ \"AAAAAAAAAABRoiLHW7EFAB2lwAatTykipYZ3CZNPzLe-f5S-zUt8COtu0H12fOZAwAFAAAAMpic85rur2MYf3zli8s8bHxTFjriFoMPTr6ZPs8sjxMKAAAAVBKuhUhQmuvKlx88A5o-FH0rzNo59NsdxmOGNBQ-ycPAAAAMItdqgHZxf7j6l0oE8X-G9-VyMbnQmZrtSniuRe_EJ9CtyxsSb7daPIIYAaXMgSEsQ3dkxY5GjJjLwAAAAAAABqWlmx5B6wo0YWPIShNKmdVrAQWht2P85BS1drGLpkAAAAAADUJ-ARn7blgHgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEIPAAAAAAAFAAAA-na5gFuxBQAFL-3CY4YuAJNGp9KhDkbrKkIPWYyq8WvtAaNPoUFWC. . . [code continues] Miner information model | Parameter | Type | Description | --------- | ---- | ----------- | account | string | Account name is the miner account name. In most cases, the account name is the public key with the k: prefix. | predicate | enum | The key predicate guard for the account. For accounts with a single key, this is usually keys-all. | public&#8209; keys | Array of strings | Miner public key. Code example (json): { \"account\": \"miner\", \"predicate\": \"keys-all\", \"public-keys\": [ \"f880a433d6e2a13a32b6169030f56245efdd8c1b8a5027e9ce98a88e886bef27\" ] } Mining update event stream model The update event stream model describes the server-sent events that notify miners when new mining work becomes available. The stream is terminated by the server in regular intervals and it is up to the client to request a new stream. Each event consists of a single line. Events are separated by empty lines. | Parameter | Type | Description | --------- | ---- | ----------- | events | Array | Each event consists of the string value \"event: New Cut\". Code example (text): event: New Cut event: New Cut event: New Cut",
    "source": "api/chainweb-data-models.md",
    "title": "Data models"
  },
  {
    "content": "Provides reference information for the chainweb-node block header binary encoding. Block header binary encoding The binary format for chain graphs of degree three is defined in Chainweb. BlockHeader. | Size | Bytes | Value | ---- | ----- | ----- | 8 | 0-7 | flags | 8 | 8-15 | time | 32 | 16-47 | parent | 110 | 48-157 | adjacents | 32 | 158-189 | target | 32 | 190-221 | payload | 4 | 222-225 | chain | 32 | 226-257 | weight | 8 | 258-265 | height | 4 | 266-269 | version | 8 | 270-277 | epoch start | 8 | 278-285 | nonce | 32 | 286-317 | hash total: 318 bytes Adjacent parents record The binary format for adjacent parents (length 3): | Bytes | Value | ----- | ----- | 0-1 | length | 2-109 | adjacents total: 110 bytes Adjacent parent | Bytes | Value | ----- | ----- | 0-3 | chain | 4-35 | hash total: 36 bytes Proof of work and field values Arithmetic operations and comparisons on parent, target, weight, and hash interpret the value as unsigned 256-bit integral numbers in little endian encoding. All operations are performed using rational arithmetic of unlimited precision and the final result is rounded. For details about how the result is rounded, consult the source code directly. Time stamps The time and epoch start values are a little endian twos complement encoded integral numbers that count SI microseconds since the start of the POSIX/UNIX epoch (leap seconds are ignored). These numbers are always positive (highest bit is 0). Numbers The height is a little endian encoded unsigned integral 64 bit number. The length is a little endian encoded unsigned integral 16 bit number. Version The version field identifies the Chainweb version. It is a 32 bit value in little endian encoding. Values up to 0x0000FFFF are reserved for production versions, including includes development and testnets. | Value | Version | ----- | ------- | 0x00000005 | mainnet01 | 0x00000001 | development | 0x00000007 | testnet04 Other The nonce is any sequence of 8 bytes that is only compared for equality. The chain is any sequence of 4 bytes that identifies a chain and can be compared for equality. The payload is any sequence of 32 bytes that is a cryptographic hash of the payload associated with the block and can be compared for equality. flags are eight bytes of value 0x0 that are reserved for future use. Work header binary encoding The work bytes received from the /miner/work endpoint is slightly different than the above header format. These headers do not include the block hash, instead prefixing the header above (without hash) with chain id and hash target bytes. The first 36 bytes are informational. Only the bytes from position 36 to the end are the subject of the proof of work hash computation. The final 8 bytes are the nonce. The creation time is encoded in bytes 44-52 (see above for details of the encoding). Miners are allowed, but not required, to update the time to reflect the solve time for the block more closely. A larger value for the creation time increases the accuracy of the difficulty adjustment which is in the interest of miners. The high difficulty guarantees that the outcome of the race of winning blocks is determined by actual hash power. However, blocks that are predated (that is, have a creation time that is in the future) are rejected during block header validation. Leaving the time unchanged is a valid choice. Miners must not change or make any assumptions about the content of the \"reserved\" bytes. Defined in Chainweb. Miner. Core: | Size | Bytes | Work bytes | Value | ---- | ----- | ---------- | ----- | 4 | 0-3 | NA | chain | 32 | 4-35 | NA | hash-target | 8 | 36-43 | 0-7 | reserved | 8 | 44-51 | 8-15 | time | 298 | 52-313 | 16-277 | reserved | 8 | 314-321 | 278-285 | nonce total: 322 bytes For arithmetic comparisons the hash-target is interpreted as unsigned 256 bit integral number in little endian encoding. The time is a little endian twos complement encoded integral number that counts SI microseconds since the start of the POSIX/UNIX epoch (leap seconds are ignored). The value is always positive (highest bit is 0).",
    "source": "api/chainweb-encoding.md",
    "title": "Binary encoding"
  },
  {
    "content": "Provides reference information for the Pact /listen endpoint. Listen for a transaction result You can use the /listen endpoint to submit a blocking API request to return the results for a single transaction. The request must specify the request key that uniquely identifies the Pact transaction. Requests to the /listen endpoint keep the connection to the network open waiting for a response. Request format Use the POST https: //{baseURL}/chain/{chain}/pact/api/v1/listen endpoint to submit a blocking request for the results of a single transaction. Note that service API endpoints don't strictly require you to use secure connections (HTTPS). However, node operators can require it and connecting over HTTPS is strongly recommended to protect data in transit and to prevent potential browser issues. Path parameters | Parameter | Type | Description | --------- | ---- | ----------- | chain (required) | integer >= 0 | Specifies the chain identifier of the chain you want to send the request to. Valid values are 0 to 19. For example, to submit the command on the first chain (0), the request is POST https: //{baseURL}/chain/0/pact/api/v1/listen. Request body schema | Parameter | Type | Description | --------- | ---- | ----------- | listen (required) | string | Unique identifier for the Pact transaction. The transaction hash is a base64Url-encoded string that consists of 43 characters from the [a-zA-Z0-9-] character set. Responses Requests to POST https: //{baseURL}/chain/{chain}/pact/api/v1/listen return the following response codes: - 200 OK indicates that the request succeeded and the response body includes the transaction results. - 400 Bad Request indicates that the request failed. The response returns text/plain content with information about why the request failed. For example, the response might indicate that the command wasn't executed because the request body specified an invalid gas payer, was missing required metadata, or there were other environment issues. If the request is successful, the response returns application/json content with the following information for one or more of the request keys included in the request. | Parameter | Type | Description | --------- | ---- | ----------- | gas (required) | number | Gas consumed by the transaction. | result (required) | object | Success (object) or Failure (object). | reqKey (required) | string | Unique identifier for the Pact transaction. The transaction hash is a base64Url-encoded string that consists of 43 characters from the [a-zA-Z0-9-] character set. | logs (required) | string | Backend-specific value providing image of database logs. | events | Array of object | Array of event objects. | metaData (required) | object | Metadata included with the transaction. | continuation | object | Describes the result of a defpact execution. | txId | number | Database-internal transaction tracking identifier. Examples You can send a request to the Kadena test network and chain 1 by calling the /listen endpoint like this: Code example (Postman): POST https: //api. testnet. chainweb. com/chainweb/0. 0/testnet04/chain/1/pact/api/v1/listen For this example, the request body specifies one request key to listen for: Code example (json): { \"listen\": \"qTDh3o3Gp3rQI2XVzptSA5BwvT6w28B1RvSuHmNXtN4\" } This request returns the following results: Code example (json): { \"gas\": 710, \"result\": { \"status\": \"success\", \"data\": \"Write succeeded\" }, \"reqKey\": \"qTDh3o3Gp3rQI2XVzptSA5BwvT6w28B1RvSuHmNXtN4\", \"logs\": \"9BUxMgwkYJFU7fVAEfJKLYLEqx1gXdpwd-tSZhJRh3A\", \"events\": [ { \"params\": [ \"LG-testnet\", \"k: db776793be0fcf8e76c75bdb35a36e67f298111dc6145c66693b0133192e2616\", 5. 67503e-5 ], \"name\": \"TRANSFER\", \"module\": {. . . [code continues]",
    "source": "api/pact-api/listen.md",
    "title": "Listen for a single transaction"
  },
  {
    "content": "Provides reference information for the Pact /local endpoint. You can use the /local endpoint to submit a command to simulate the execution of a transaction. Requests sent to the /local endpoint don't change the blockchain state. Any database writes or changes to the environment are rolled back. You can use this type of call to perform a node-local “dirty read” for testing purposes or as a dry-run to validate a transaction. The request body must contain a properly-formatted Pact command. In response to the request, the endpoint returns the command result and hash. Request format Use the POST http: //{baseUrl}/chain/{chain}/pact/api/v1/local/ endpoint to submit a command to simulate the execution of a transaction. Path parameters | Parameter | Type | Description | --------- | ---- | ----------- | chain (required) | integer >= 0 | Specifies the chain identifier of the chain you want to send the request to. Valid values are 0 to 19. For example, to submit the command on the first chain (0), the request is POST http: //{baseURL}/chain/0/pact/api/v1/local. Query parameters | Parameter | Type | Description | --------- | ---- | ----------- | preflight | boolean | Trigger a fully-gassed mainnet transaction execution simulation and transaction metadata validation. | rewindDepth | integer >= 0 | Rewind transaction execution environment by a specified number of block heights. | signatureVerification | boolean | Require user signature verification when validating the transaction metadata. Request body schema | Parameter | Type | Description | --------- | ---- | ----------- | cmd (required) | string | Stringified JSON payload object with signed transaction data that can't be modified. | hash (required) | string | An unpadded base64Url-encoded string created using the Blake2s-256 hash function for the cmd field value. Serves as a command request key because each transaction must be unique. | sigs (required) | Array of objects | List of signatures corresponding one-to-one with the signers array in the payload. Responses Requests to POST http: //{baseURL}/chain/{chain}/pact/api/v1/local return the following response codes: - 200 OK indicates that the request succeeded and the response body includes either the command results or the preflight results. - 400 Bad Request indicates that the request failed. The response returns text/plain content with information about why the command couldn't be executed. For example, the response might indicate that the command wasn't executed because the request body specified an invalid gas payer, was missing required metadata, or there were other environment issues. If the request is successful, the response returns application/json content with the following information: | Parameter | Type | Description | --------- | ---- | ----------- | reqKey (required) | string | Unique identifier for the Pact transaction. The transaction hash is a base64Url-encoded string that consists of 43 characters from the [a-zA-Z0-9-] character set. | result (required) | object | Success (object) or Failure (object). | txId | number | Database-internal transaction tracking identifier. | logs (required) | string | Backend-specific value providing an image of database logs. | metaData (required) | object | Metadata included with the transaction. | events | Array of objects | Array of event objects. | continuation | object | Describes the result of a defpact execution. | gas (required) | number | Gas required to execute the transaction. If you specify the preflight query parameter, the command results include the following additional parameters: | Parameter | Type | Description | --------- | ---- | ----------- | preflightResult (required) | object | The result of attempting to execute a single well-formed Pact command. | preflightWarnings (required) | Array of strings | A list of warnings associated with deprecated features in upcoming Pact releases. Examples You can send a request to the Kadena test network and chain 1 by calling the /local endpoint like this: Code example (Postman): POST http: //api. testnet. chainweb. com/chainweb/0. 0/testnet04/chain/1/pact/api/v1/local/ The request body for this example looks like this: Code example (json): {\"cmd\": \"{\\\"signers\\\": [{\\\"pubKey\\\": \\\"1d5a5e10eb15355422ad66b6c12167bdbb23b1e1ef674ea032175d220b242ed4\\\", \\\"clist\\\": [{\\\"name\\\": \\\"coin. TRANSFER\\\", \\\"args\\\": [\\\"k: 1d5a5e10eb15355422ad66b6c12167bdbb23b1e1ef674ea032175d220b242ed4\\\", \\\"k: 4fe7981d36997c2a327d0d3ce961d3ae0b2d38185ac5e5cd98ad90140bc284d0\\\", 3]}, {\\\"name\\\": \\\"coin. GAS\\\", \\\"args\\\": []}]}], \\\"meta\\\": {\\\"creationTime\\\": 1726525836, \\\"ttl\\\": 32441, \\\"chainId\\\": \\\"1\\\", \\\"gasPrice\\\": 1. 9981e-7, \\\"gasLimit\\\": 2320, \\\"sender\\\": \\\"k: 1d5a5e10eb15355422ad66b6c12167bdbb23b. . . [code continues] The request returns command results similar to the following: Code example (json): { \"gas\": 509, \"result\": { \"status\": \"success\", \"data\": \"Write succeeded\" }, \"reqKey\": \"SLiinT5fAv8eCixT9qwbBHZgO4HxVB-p5rYytAxG94\", \"logs\": \"wsATyGqckuIvlm89hhd2j4t6RMkCrcwJeoeCYr7Th8\", \"events\": [ { \"params\": [ \"k: 1d5a5e10eb15355422ad66b6c12167bdbb23b1e1ef674ea032175d220b242ed4\", \"k: 4fe7981d36997c2a327d0d3ce961d3ae0b2d38185ac5e5cd98ad90140bc284d0\", 3 ], \"name\": \". . . [code continues] You can specify the preflight query parameter in the API request like this: Code example (Postman): http: //api. testnet. chainweb. com/chainweb/0. 0/testnet04/chain/1/pact/api/v1/local/? preflight=true The request returns preflight results similar to the following: Code example (json): { \"preflightResult\": { \"gas\": 734, \"result\": { \"status\": \"success\", \"data\": \"Write succeeded\" }, \"reqKey\": \"SLiinT5fAv8eCixT9qwbBHZgO4HxVB-p5rYytAxG94\", \"logs\": \"aN6GME-OeasmnQOrTozgww0Z81WFuu3env3k8ksEc\", \"events\": [ { \"params\": [ \"k: 1d5a5e10eb15355422ad66b6c12167bdbb23b1e1ef674ea032175d220b242ed4\", \"NoMiner\", 1. 4666054e-4. . . [code continues]",
    "source": "api/pact-api/local.md",
    "title": "Simulate a transaction"
  },
  {
    "content": "Provides reference information for the Pact /poll endpoint. You can use the /poll endpoint to check for one or more command results by request key. Request format Use the POST http: //{baseURL}/chain/{chain}/pact/api/v1/poll endpoint to check for one or more command results by request key. Path parameters | Parameter | Type | Description | --------- | ---- | ----------- | chain (required) | integer >= 0 | Specifies the chain identifier of the chain you want to send the request to. Valid values are 0 to 19. For example, to submit the command on the first chain (0), the request is POST http: //{baseURL}/chain/0/pact/api/v1/poll. Query parameters | Parameter | Type | Description | --------- | ---- | ----------- | confirmationDepth | integer >= 0 | Configures how many blocks should be mined before the requested transaction results should be considered to be confirmed. Request body schema | Parameter | Type | Description | --------- | ---- | ----------- | requestKeys (required) | Array of strings | Each request key is a base64Url-encoded string that consists of 43 characters from the [a-zA-Z0-9-] character set. Responses Requests to POST http: //{baseURL}/chain/{chain}/pact/api/v1/poll return the following response codes: - 200 OK indicates that the request succeeded and the response body includes the transaction results. - 400 Bad Request indicates that the request failed. The response returns text/plain content with information about why the request failed. For example, the response might indicate that the command wasn't executed because the request body specified an invalid gas payer, was missing required metadata, or there were other environment issues. If the request is successful, the response returns application/json content with the following information for one or more of the request keys included in the request. | Parameter | Type | Description | --------- | ---- | ----------- | gas (required) | number | Gas consumed by the transaction. | result (required) | object | Success (object) or Failure (object). | reqKey (required) | string | Unique identifier for the Pact transaction. The transaction hash is a base64Url-encoded string that consists of 43 characters from the [a-zA-Z0-9-] character set. | logs (required) | string | Backend-specific value providing image of database logs. | events | Array of object | Array of event objects. | metaData (required) | object | Metadata included with the transaction. | continuation | object | Describes the result of a defpact execution. | txId | number | Database-internal transaction tracking identifier. Examples You can send a request to the Kadena test network and chain 1 by calling the /poll endpoint like this: Code example (Postman): POST http: //api. testnet. chainweb. com/chainweb/0. 0/testnet04/chain/1/pact/api/v1/poll? confirmationDepth=6 For this example, the request body specifies one request key: Code example (json): { \"requestKeys\": [ \"vnelRuUfVvSGOu7Lczv1MluELMICdPrBaevJzKOj-oo\" ] } This request returns the following results: Code example (json): { \"vnelRuUfVvSGOu7Lczv1MluELMICdPrBaevJzKOj-oo\": { \"gas\": 734, \"result\": { \"status\": \"success\", \"data\": \"Write succeeded\" }, \"reqKey\": \"vnelRuUfVvSGOu7Lczv1MluELMICdPrBaevJzKOj-oo\", \"logs\": \"TtlN14Khzk6GhEx6JeeQsyPgeJ9ksGtFiA8-DxGiA\", \"events\": [ { \"params\": [ \"k: 58705e8699678bd15bbda2cf40fa236694895db614aafc82cf1c06c014ca963c\", \"k: db776793be0fcf8e76c7. . . [code continues]",
    "source": "api/pact-api/poll.md",
    "title": "Poll for transaction results"
  },
  {
    "content": "Provides reference information for the Pact /private endpoint. You can use the POST http: //{baseURL}/chain/{chain}/pact/api/v1/private endpoint for asynchronous submission of a single command transmitted with end-to-end encryption between addressed entity nodes. Private payload metadata is required. Request format Use the POST http: //{baseURL}/chain/{chain}/pact/api/v1/private endpoint for asynchronous submission of a single command transmitted with end-to-end encryption between addressed entity nodes. Request body schema | Parameter | Type | Description | --------- | ---- | ----------- | cmd (required) | string | Stringified JSON payload object with signed transaction data that can't be modified. | hash (required) | string | An unpadded base64Url-encoded string created using the Blake2s-256 hash function for the cmd field value. Serves as a command request key because each transaction must be unique. | sigs (required) | Array of objects | List of signatures corresponding one-to-one with the signers array in the payload. Responses Requests to POST http: //{baseURL}/chain/{chain}/pact/api/v1/private return the following response codes: - 200 OK indicates that the request succeeded and the response body includes the command results. - 400 Bad Request indicates that the request failed. The response returns text/plain content with information about why the request failed. For example, the response might indicate that the command wasn't executed because the request body specified an invalid gas payer, was missing required metadata, or there were other environment issues. If the request is successful and the command is accepted, the response returns application/json content with the following information: | Parameter | Type | Description | --------- | ---- | ----------- | requestKeys (required) | Array of strings | Unique identifier for the Pact transaction. The transaction hash is a base64Url-encoded string that consists of 43 characters from the [a-zA-Z0-9_-] character set. You can use the request key to call the poll or listen endpoint to retrieve results.",
    "source": "api/pact-api/private.md",
    "title": "Send a private Pact command"
  },
  {
    "content": "Provides reference information for the Pact /send endpoint. You can use the /send endpoint to submit one or more unencrypted Pact commands to the blockchain for execution. Request format Use the POST http: //{baseUrl}/chain/{chain}/pact/api/v1/send endpoint to submit one or more public unencrypted Pact commands to the blockchain for execution. Path parameters | Parameter | Type | Description | --------- | ---- | ----------- | chain (required) | integer >= 0 | Specifies the chain identifier of the chain you want to send the request to. Valid values are 0 to 19. For example, to submit the command on the first chain (0), the request is POST http: //{baseURL}/chain/0/pact/api/v1/send. Request body schema Content type: application/json | Parameter | Type | Description | --------- | ---- | ----------- | cmds (required) | Array of objects | Specifies an array of individual Pact command objects. Responses Requests to POST http: //{baseURL}/chain/{chain}/pact/api/v1/send return the following response codes: - 200 OK indicates that the request succeeded and the response body includes the request keys for each command successfully submitted. - 400 Bad Request indicates that the request failed. The response returns text/plain content with information about why the command couldn't be submitted for execution. For example, the response might indicate that the command wasn't executed because the request body specified an invalid gas payer, was missing required metadata, or there were other environment issues. If the request is successful, the response returns application/json content with the following information: | Parameter | Type | Description | --------- | ---- | ----------- | requestKeys (required) | Array of strings | Each request key is a base64Url-encoded string that consists of 43 characters from the [a-zA-Z0-9_-] character set. You can use these request keys with the poll or listen endpoints to retrieve transaction results. Examples You can send a request to the Kadena test network and chain 1 by calling the /send endpoint like this: Code example (Postman): POST http: //api. testnet. chainweb. com/chainweb/0. 0/testnet04/chain/1/pact/api/v1/send The request body for this example looks like this: Code example (json): { \"cmds\": [ { \"cmd\": \"{\\\"signers\\\": [{\\\"pubKey\\\": \\\"58705e8699678bd15bbda2cf40fa236694895db614aafc82cf1c06c014ca963c\\\", \\\"clist\\\": [{\\\"name\\\": \\\"coin. TRANSFER\\\", \\\"args\\\": [\\\"k: 58705e8699678bd15bbda2cf40fa236694895db614aafc82cf1c06c014ca963c\\\", \\\"k: 4fe7981d36997c2a327d0d3ce961d3ae0b2d38185ac5e5cd98ad90140bc284d0\\\", 2]}, {\\\"name\\\": \\\"coin. GAS\\\", \\\"args\\\": []}]}], \\\"meta\\\": {\\\"creationTime\\\": 1726775463, \\\"ttl\\\": 35628, \\\"chainId\\\": \\\"1\\\", \\\"gasPrice\\\": 7. 993e-8, \\\"gasLimit\\\": 2320, \\\"sender\\\": \\\"k: 587. . . [code continues] This API request returns the request key for the transaction: Code example (json): { \"requestKeys\": [ \"vnelRuUfVvSGOu7Lczv1MluELMICdPrBaevJzKOj-oo\" ] } You can use the request key returned to poll or listen for the transaction results.",
    "source": "api/pact-api/send.md",
    "title": "Send commands to be executed"
  },
  {
    "content": "Provides reference information for the Pact /spv endpoint. You can use the /spv endpoint to issue a blocking request to fetch a simple payment verification (spv) proof of a cross-chain transaction. The request must be sent to the chain where the transaction initiated. Request format Use the POST http: //{baseURL}/chain/{chain}/pact/api/v1/spv endpoint to issue a blocking request to fetch a simple payment verification (spv) proof of a cross-chain transaction. Path parameters | Parameter | Type | Description | --------- | ---- | ----------- | chain (required) | integer >= 0 | Specifies the chain identifier of the chain you want to send the request to. Valid values are 0 to 19. For example, to submit the command on the first chain (0), the request is POST http: //{baseURL}/chain/0/pact/api/v1/spv. Request body schema | Parameter | Type | Description | --------- | ---- | ----------- | requestKey (required) | string | Request key for the first step in a cross-chain transaction. This request key is the transaction hash generated on the source chain. | targetChainId (required) | string | Target chain identifier for the second step in the cross-chain transaction. Response Requests to POST http: //{baseURL}/chain/{chain}/pact/api/v1/spv return the following response codes: - 200 OK indicates that the request succeeded and the response body includes the requested payment verification proof. - 400 Bad Request indicates that the request failed. The response returns text/plain content with information about why the request failed. If the request is successful and the command is accepted, the response returns application/json content with the following information: | Parameter | Type | Description | --------- | ---- | ----------- | spv | string | Backend-specific data for continuing a cross-chain proof.",
    "source": "api/pact-api/spv.md",
    "title": "Get simple payment verification (spv)"
  },
  {
    "content": "Provides reference information for the chainweb-node peer endpoints. Add cut peer information For peer-to-peer connections, Chainweb nodes have two separate communication channels with specialized independent peer-to-peer networks that different nodes can be part of: - The /peer/cut peer-to-peer network is responsible for communicating the consensus state across the distributed network nodes. - The /peer/mempool peer-to-peer network is responsible for queuing and managing the pending transactions for each chain independently. Request format Use PUT https: //{baseURL}/cut/peer to add peer information to the peer database of the cut peer-to-peer network on the remote host. Request body schema Use the following parameters to specify the peer information you want to add to the peer database of the cut peer-to-peer network on the remote host. | Parameter | Type | Description | --------- | ---- | ----------- | id (required) | string or null | Specifies the Base64Url-encoded string—without padding—that represents the SHA256 fingerprint of the SSL certificate for the remote node. This field can only be null if the node uses an official certificate authority (CA) signed certificate. In all other cases, the id string consists of 43 characters from the a-zA-Z0-9- character set. | address (required) | object | Specifies the host and port number of the peer. Responses Requests to PUT https: //{baseURL}/cut/peer return the following response codes: - 204 No Content indicates that the request was successful and the peer was added to the peer database of the remote node. - 400 Bad Request indicates that the request itself is invalid or that the hostname and port provided for the peer is not reachable. Before a Chainweb node adds a peer to its peer database, the node checks whether the peer can be reached using the information provided. If this check fails, an error is returned. Examples You can send a request to add a peer to the peer node database with a call to the /peer endpoint similar to the following: Code example (Postman): PUT https: //us1. testnet. chainweb. com/chainweb/0. 0/testnet04/cut/peer` The request body for adding a peer contains parameters similar to the following: Code example (json): { \"id\": \"NE9g8dsqVF1OKwyqITXpIiEF4i9ReFzJQG9FhDEnQ\", \"address\": { \"hostname\": \"testnet-node. ajuba. io\", \"port\": 1789 } } If the request is successful, you'll see the 204 No Content response returned. If the host name or IP address wasn't reachable, you'll see an error message similar to the following: Code example (text): Invalid hostaddress: IsNotReachable \"ConnectionFailure Network. Socket. getAddrInfo (called with preferred socket type/protocol: AddrInfo {addrFlags = [AIADDRCONFIG], addrFamily = AF_UNSPEC, addrSocketType = Stream, addrProtocol = 0, addrAddress = 0. 0. 0. 0: 0, addrCanonName = Nothing}, host name: Just \\\"testnet-node. ajuba. io\\\", service name: Just \\\"1789\\\"): does not exist (Name or service not known)\"",
    "source": "api/peer-to-peer/add-cut-peers.md",
    "title": "Add cut peers"
  },
  {
    "content": "Provides reference information for the chainweb-node peer endpoints. Add mempool peer information For peer-to-peer connections, Chainweb nodes have two separate communication channels with specialized independent peer-to-peer networks that different nodes can be part of: - The /peer/cut peer-to-peer network is responsible for communicating the consensus state across the distributed network nodes. - The /peer/mempool peer-to-peer network is responsible for queuing and managing the pending transactions for each chain independently. Request format Use PUT https: //{baseURL}/chain/{chain}/mempool/peer to add peer information to the mempool peer-to-peer network for a specific chain. Path parameters | Parameter | Type | Description | --------- | ---- | ----------- | chain (required) | integer >= 0 | Specifies the chain identifier of the chain you want to send the request to. Valid values are 0 to 19. For example, to get block hashes for the first chain (0), the request is PUT https: //{baseURL}/chain/0/mempool/peer. Request body schema Use the following parameters to specify the peer information you want to add to the peer database of the memory pool peer-to-peer network on the remote host. | Parameter | Type | Description | --------- | ---- | ----------- | id (required) | string or null | Specifies the Base64Url-encoded string—without padding—that represents the SHA256 fingerprint of the SSL certificate for the remote node. This field can only be null if the node uses an official certificate authority (CA) signed certificate. In all other cases, the id string consists of 43 characters from the a-zA-Z0-9- character set. | address (required) | object | Specifies the host and port number of the peer you want to add to the peer database of the memory pool peer-to-peer network for the specified chain. Responses Requests to PUT https: //{baseURL}/chain/{chain}/mempool/peer return the following response codes: - 204 No Content indicates that the request was successful and the peer was added to the peer database of the remote node. - 400 Bad Request indicates that the request itself is invalid or that the hostname and port provided for the peer is not reachable. Before a Chainweb node adds a peer to its peer database, the node checks whether the peer can be reached using the information provided. If this check fails, an error is returned. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. | Parameter | Type | Description | --------- | ---- | ----------- | x-peer-addr | string | Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: \"10. 36. 1. 3: 42988\". | x-server&#8209; timestamp | integer >= 0 | Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: 1618597601. | x&#8209; chainweb&#8209; node&#8209; version | string | Specifies the version of the remote Chainweb node. For example: \"2. 23\". Examples You can send a request to add a peer to the peer node database with a call to the /peer endpoint similar to the following: Code example (Postman): PUT https: //us1. testnet. chainweb. com/chainweb/0. 0/testnet04/chain/4/mempool/peer` The request body for adding a peer contains parameters similar to the following: Code example (json): { \"id\": \"aEdeq9bOZws1X5IpBF5aGM6vV6ghEicHSMoPs5wb40\", \"address\": { \"hostname\": \"13. 251. 43. 216\", \"port\": 1789 } } If the request is successful, you'll see the 204 No Content response returned. If the host name or IP address wasn't reachable, you'll see an error message similar to the following: Code example (text): Invalid hostaddress: IsNotReachable \"ConnectionFailure Network. Socket. getAddrInfo (called with preferred socket type/protocol: AddrInfo {addrFlags = [AIADDRCONFIG], addrFamily = AFUNSPEC, addrSocketType = Stream, addrProtocol = 0, addrAddress = 0. 0. 0. 0: 0, addrCanonName = Nothing}, host name: Just \\\"us1. testnet. ajuba. io\\\", service name: Just \\\"1789\\\"): does not exist (Name or service not known)\"",
    "source": "api/peer-to-peer/add-mempool-peers.md",
    "title": "Add mempool peers"
  },
  {
    "content": "Provides reference information for the chainweb-node mempool endpoints. Request all transactions When transactions are submitted to the blockchain for processing, they are queued in the node memory pool to await delivery to a mining node as new work to be validated. Endpoints related to memory pool activity are peer-to-peer endpoints that enable communication between memory pools on different nodes. These API endpoints are included for reference but are not intended to be used directly. In most cases, you should use the appropriate Pact REST API endpoints to submit and check the status of transactions. With the /mempool/getPending endpoint, you can return all of the transaction hashes for the transactions found waiting in the memory pool. Request format Use POST https: //{baseURL}/chain/{chain}/mempool/getPending to retrieve pending transactions from the memory pool. Path parameters | Parameter | Type | Description | --------- | ---- | ----------- | chain (required) | integer >= 0 | Specifies the chain identifier of the chain you want to send the payload request to. Valid values are 0 to 19. For example, to get block payload for the first chain (0), the request is POST https: //{baseURL}/chain/0/mempool/getPending. Query parameters | Parameter | Type | Description | --------- | ---- | ----------- | nonce | integer >= 0 | Specifies the server nonce value. | since | integer 64&#8209; bit | Specifies the transaction identifier value to use as a starting point for retrieving pending transactions from the memory pool. Responses Requests to POST https: //{baseURL}/chain/{chain}/mempool/getPending return the following response code: - 200 OK indicates that the request succeeded and the response body returns the pending transactions matching the request criteria. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. | Parameter | Type | Description | --------- | ---- | ----------- | x-peer-addr | string | Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: \"10. 36. 1. 3: 42988\". | x-server&#8209; timestamp | integer >= 0 | Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: 1618597601. | x&#8209; chainweb&#8209; node&#8209; version | string | Specifies the version of the remote Chainweb node. For example: \"2. 23\". Successful response schema If the request is successful, the response returns application/json content with the following: | Parameter | Type | Description | --------- | ---- | ----------- | hashes | Array of strings | Lists the transaction hashes for pending transactions in the memory pool. The hash is a Base64Url-encoded string—without padding—that consists of 43 characters from the a-zA-Z0-9- character set. | highwaterMark | Array of integers | Specifies a two-element array with the server nonce value and the transaction identifier representing the last transaction mined out of the memory pool. Examples You can send a request to a bootstrap node for the Kadena main network and chain id 0 with a call like this: Code example (Postman): POST https: //us-e1. chainweb. com/chainweb/0. 0/mainnet01/chain/0/mempool/getPending The response body for this request returns information about the pending transactions similar to the following: Code example (json): { \"hashes\": [ \"a1VnNruJpIbwatGwHlZXtNYqPiani1UuM5l87NDQ-Hs\", \"akUQgcIGR2mi4StuiAMLtYgr9tTVg2Z0Oni4MbmlQ\", \"Ck-ltmAS7M0e1OFfzIHRSVRtV-zRP81Vw7gFcu3pCk\", \"LUU1i0dtHZHjY3BBcFcyZaxmwWL7E6eiAMH4TVisdT8\" ], \"highwaterMark\": [ 8354532306934176444, 1218762 ] }",
    "source": "api/peer-to-peer/all-pending-mempool.md",
    "title": "Request pending transactions"
  },
  {
    "content": "Provides reference information for the chainweb-node config endpoint. Use GET https: //{hostname}/config to return configuration information for a Chainweb node. The configuration details are returned as a JSON object with sensitive information removed from the result. The JSON schema depends on the version of the chainweb-node software running on the node and is not part of the stable chainweb-node API. Responses Requests to the /config endpoint return the following response code: - 200 OK returns the configuration details for the Chainweb node. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. | Parameter | Type | Description | --------- | ---- | ----------- | x-peer-addr | string | Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: \"10. 36. 1. 3: 42988\". | x-server&#8209; timestamp | integer >= 0 | Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: 1618597601. | x&#8209; chainweb&#8209; node&#8209; version | string | Specifies the version of the remote Chainweb node. For example: \"2. 23\". Response schema The content of the JSON schema depends on the version of the chainweb-node software running on the node and is not part of the stable chainweb-node API. Examples You can send a request to a Kadena main network bootstrap node by calling the /config endpoint. For example: Code example (Postman): GET https: //us-e1. chainweb. com/config You can send a request to a Kadena test network bootstrap node like this: Code example (Postman): GET https: //us1. testnet. chainweb. com/config These sample requests return the schema for chainweb-node version 2. 26. 1. For the bootstrap node, the response looks similar to the following: Code example (json): { \"allowReadsInLocal\": false, \"backup\": { \"api\": { \"configuration\": {}, \"enabled\": false }, \"directory\": null }, \"chainwebVersion\": \"mainnet01\", \"cuts\": { \"fastForwardBlockHeightLimit\": null, \"fetchTimeout\": 3000000, \"initialBlockHeightLimit\": null, \"pruneChainDatabase\": \"none\" }, \"enableLocalTimeout\": false, \"fullHistoricPactState\": true, \"gasLimitOfBlock\": 150000, \"headerStre. . . [code continues] To get configuration for a local development network, you can call the /config endpoint like this: Code example (Postman): GET https: //us-e1. chainweb. com/config",
    "source": "api/peer-to-peer/api-config.md",
    "title": "Configuration endpoint"
  },
  {
    "content": "Provides reference information for the chainweb-node mempool endpoints. When transactions are submitted to the blockchain for processing, they are queued in the node memory pool to await delivery to a mining node as new work to be validated. Endpoints related to memory pool activity are peer-to-peer endpoints that enable communication between memory pools on different nodes. With the /mempool/member endpoint, you can specify a list of transaction request keys to check the status of. The request returns true for each transaction found waiting in the mempool and false for each transaction that wasn't found in the mempool. Request format Use POST https: //{baseURL}/chain/{chain}/mempool/member to check the whether specific transactions are currently in the memory pool using their transaction request keys. Path parameters | Parameter | Type | Description | --------- | ---- | ----------- | chain (required) | integer >= 0 | Specifies the chain identifier of the chain you want to send the payload request to. Valid values are 0 to 19. For example, to get block payload for the first chain (0), the request is POST https: //{baseURL}/chain/0/mempool/member. Request body schema The request body consists of an array of transaction request keys to check for in the memory pool. Each request key for a Pact transaction is a Base64Url-encoded string—without padding—that consists of 43 characters from the a-zA-Z0-9- character set. The request body is an array of these strings. Responses Requests to POST https: //{baseURL}/chain/{chain}/mempool/member return the following response code: - 200 OK indicates that the request succeeded and the response body returns an array of boolean values that indicate whether each specified transaction is in the memory pool. The array has the same size as the request body. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. | Parameter | Type | Description | --------- | ---- | ----------- | x-peer-addr | string | Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: \"10. 36. 1. 3: 42988\". | x-server&#8209; timestamp | integer >= 0 | Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: 1618597601. | x&#8209; chainweb&#8209; node&#8209; version | string | Specifies the version of the remote Chainweb node. For example: \"2. 23\". Successful response schema If the request is successful, the response returns application/json content with an array of boolean values for each request key in the request body. Examples You can send a request to a bootstrap node for the Kadena main network and chain id 0 with a call like this: Code example (Postman): POST https: //us-e1. chainweb. com/chainweb/0. 0/mainnet01/chain/0/mempool/member For this example, the request body consists of one request key: Code example (request): [\"FCy9X1X7bVY-ls971GehpEh5kFwMVEZEfWYnPKKGxJg\"] If the transaction isn't found in the memory pool, the response body returns false: Code example (response): [ false ] You can send a request to a bootstrap node for the Kadena test network and chain id 1 with a call like this: Code example (postman): POST https: //us1. testnet. chainweb. com/chainweb/0. 0/testnet04/chain/1/mempool/member For this example, the request body consists of two request keys: Code example (request): [\"Qp4hyjjzCBgjCoOvncCLsTMsw-G0kM6LSM9XSxOVhU4\", \"Gc17hqzSZinUt-JCPvH6kGJFXEJtRwU1Bx4OtSnxWU\"] In this example, the second transaction was found in the memory pool: Code example (response): [ false, true ] Look up pending transactions in the mempool Use POST https: //{baseURL}/chain/{chain}/mempool/lookup to look up pending transactions in the memory pool. Path parameters | Parameter | Type | Description | --------- | ---- | ----------- | chain (required) | integer >= 0 | Specifies the chain identifier of the chain you want to send the payload request to. Valid values are 0 to 19. For example, to get block payload for the first chain (0), the request is POST https: //{baseURL}/chain/0/mempool/lookup. Request body schema The request body consists of an array of transaction request keys to check for in the memory pool. Each request key for a Pact transaction is a Base64Url-encoded string—without padding—that consists of 43 characters from the a-zA-Z0-9- character set. The request body is an array of these strings. Responses Requests to POST https: //{baseURL}/chain/{chain}/mempool/lookup return the following response code: - 200 OK indicates that the request succeeded and the response body returns an array of lookup results for each specified transaction. The array has the same size as the request body. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. | Parameter | Type | Description | --------- | ---- | ----------- | x-peer-addr | string | Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: \"10. 36. 1. 3: 42988\". | x-server&#8209; timestamp | integer >= 0 | Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: 1618597601. | x&#8209; chainweb&#8209; node&#8209; version | string | Specifies the version of the remote Chainweb node. For example: \"2. 23\". Successful response schema If the request is successful, the response returns application/json content with an array of lookup results for each request key in the request body. | Parameter | Type | Description | --------- | ---- | ----------- | tag | string | Specifies the lookup result. The valid return values are \"Missing\" or \"Pending\". | contents | string | Specifies the JSON-encoded text for a signed Pact transaction. Examples You can send a request to a bootstrap node for the Kadena test network and chain id 1 with a call like this: Code example (postman): POST https: //us1. testnet. chainweb. com/chainweb/0. 0/testnet04/chain/1/mempool/lookup For this example, the request body consists of two request keys: Code example (request): [\"ptI7wQeOmOt-BER2KQGVd0o6axBpqbhMPQVkkq5YAyE\", \"Gc17hqzSZinUt-JCPvH6kGJFXEJtRwU1Bx4OtSnxWU\"] In this example, the first transaction is \"Pending\" and the second transaction is \"Missing\" in the memory pool: Code example (response): [ { \"tag\": \"Pending\", \"contents\": \"{\\\"hash\\\": \\\"ptI7wQeOmOt-BER2KQGVd0o6axBpqbhMPQVkkq5YAyE\\\", \\\"sigs\\\": [{\\\"sig\\\": \\\"1569af1b56cddd4b853b7d49249c4c52d55e59e04910bfeb8aacbd02bfa0637bbe81b0f4b48ba8eb101fa0e8a276023fbfa57fa5a835741b346d574897052201\\\"}], \\\"cmd\\\": \\\"{\\\\\\\"signers\\\\\\\": [{\\\\\\\"pubKey\\\\\\\": \\\\\\\"1d5a5e10eb15355422ad66b6c12167bdbb23b1e1ef674ea032175d220b242ed4\\\\\\\", \\\\\\\"clist\\\\\\\": [{\\\\\\\"name\\\\\\\": \\\\\\\"coin. TRANSFER\\\\\\\", \\\\\\\"args\\\\\\\": [\\\\\\\"k: 1d5a5e10eb15355422ad66b6c12167bdbb23b1e1ef674. . . [code continues] Insert transactions into the mempool Nodes can use the PUT https: //{baseURL}/chain/{chain}/mempool/insert endpoint to move transactions into the memory pool. Information about this endpoint is included for reference. You shouldn't use this endpoint directly. Instead, you should use the appropriate Pact endpoints to submit transactions to the network. Path parameters | Parameter | Type | Description | --------- | ---- | ----------- | chain (required) | integer >= 0 | Specifies the chain identifier of the chain you want to send the payload request to. Valid values are 0 to 19. For example, to get block payload for the first chain (0), the request is POST https: //{baseURL}/chain/0/mempool/insert. Request body schema The request body consists of an array of JSON-encoded strings representing signed Pact transactions. Responses Requests to PUT https: //{baseURL}/chain/{chain}/mempool/insert return the following response code: - 200 OK indicates that the request succeeded and that transactions were inserted into the memory pool. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. | Parameter | Type | Description | --------- | ---- | ----------- | x-peer-addr | string | Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: \"10. 36. 1. 3: 42988\". | x-server&#8209; timestamp | integer >= 0 | Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: 1618597601. | x&#8209; chainweb&#8209; node&#8209; version | string | Specifies the version of the remote Chainweb node. For example: \"2. 23\". Examples The following example illustrates the content of the request body with an array that only contains one transaction: Code example (request): [ \"{\\\"hash\\\": \\\"y3aWL72-3wAy7vL9wcegGXnstH0lHi-q-cfxkhD5JCw\\\", \\\"sigs\\\": [{\\\"sig\\\": \\\"8ddc06b37c496f2cadc4f7412405a80faf3ab07482ff5553b9b5fcc73d1b4121275ad5948d9b4078e553b71f8b42eaf6b24135bf2fb4d5840c16bcdde0e35e0f\\\"}], \\\"cmd\\\": \\\"{\\\\\\\"networkId\\\\\\\": \\\\\\\"mainnet01\\\\\\\", \\\\\\\"payload\\\\\\\": {\\\\\\\"exec\\\\\\\": {\\\\\\\"data\\\\\\\": {\\\\\\\"account-keyset\\\\\\\": {\\\\\\\"pred\\\\\\\": \\\\\\\"keys-all\\\\\\\", \\\\\\\"keys\\\\\\\": [\\\\\\\"acc28032a1bb725b7ba0a3593ab86f393894fa6659281f3dfdfee0afe48559a2\\\\\\\"]}}, \\\\\\\"code\\\\\\\": \\\\\\\"(coin. transfer-create \\\\\\\\\\\\\\\"60. . . [code continues]",
    "source": "api/peer-to-peer/boolean-tx-mempool.md",
    "title": "Check request keys"
  },
  {
    "content": "Provides reference information for the chainweb-node peer endpoints. Get cut peer information For peer-to-peer connections, Chainweb nodes have two separate communication channels with specialized independent peer-to-peer networks that different nodes can be part of: - The /peer/cut peer-to-peer network is responsible for communicating the consensus state across the distributed network nodes. - The /peer/mempool peer-to-peer network is responsible for queuing and managing the pending transactions for each chain independently. Request format Use GET https: //{baseURL}/cut/peer to retrieve peer node information about the cut peer-to-peer network for a specific Chainweb node. Query parameters | Parameter | Type | Description | --------- | ---- | ----------- | limit | integer >= 0 | Specifies the maximum number of records that should be returned. The actual number of records returned might be lower than the value you specify. For example: limit=3. | next | string | Specifies the cursor value to retrieve the next page of results. You can find the value to specify in the next property returned by the previous page in a successful response. For example: \"inclusive: qgsxD1G5m8dGZ4W9nMKBotU2I10ilURkRIE3UKHlLM\". Responses Requests to GET https: //{baseURL}/cut/peer return the following response code: - 200 OK indicates that the request succeeded. The response body describes the peers from the peer database on the remote node. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. | Parameter | Type | Description | --------- | ---- | ----------- | x-peer-addr | string | Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: \"10. 36. 1. 3: 42988\". | x-server&#8209; timestamp | integer >= 0 | Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: 1618597601. | x&#8209; chainweb&#8209; node&#8209; version | string | Specifies the version of the remote Chainweb node. For example: \"2. 23\". Successful response schema If the request is successful, the response returns application/json content with the following: | Parameter | Type | Description | --------- | ---- | ----------- | items (required) | Array of objects | Returns an array of peer information objects. | limit (required) | integer >= 0 | Specifies the maximum number of items in the page. This number can be smaller but never larger than the number of requested items. | next (required) | string or null | Returns a value that can be used to query the next page. You can use this value for the next parameter in a follow-up request. The format for this parameter consists of two parts. The first part of the string can be inclusive, exclusive, or null. The second part is the value that calls the next page of results or null if there are no more results to query. Examples You can send a request to a Kadena main network bootstrap node by calling the peer-to-peer endpoint like this: Code example (Postman): GET https: //us-e1. chainweb. com/chainweb/0. 0/mainnet01/cut/peer? limit=2 This request returns two items with peer information in the response body: Code example (json): { \"limit\": 2, \"items\": [ { \"id\": \"70HnUJJN41Ee-miB5ZlsqDJW3TRcTV5fZ9vMGw332k\", \"address\": { \"hostname\": \"65. 109. 98. 245\", \"port\": 1789 } }, { \"id\": null, \"address\": { \"hostname\": \"fr1. chainweb. com\", \"port\": 443 } } ], \"next\": \"inclusive: 2\" } To send a follow-up request to get peer information for the next two peers, you can add the next parameter to the request: Code example (Postman): GET https: //us-e1. chainweb. com/chainweb/0. 0/mainnet01/cut/peer? limit=2&next=inclusive: 2 This request returns the next two items from the peer database in the response body: Code example (json): { \"limit\": 2, \"items\": [ { \"id\": \"YhmXbYrjrVwUEtIRkwroJ5RPB2tnPqH6qMPsXgi6BOg\", \"address\": { \"hostname\": \"47. 253. 46. 121\", \"port\": 8443 } }, { \"id\": \"tfgiwMyznf8M7p8mP99aEamD2mbvp9DLQCkRXyvsuFc\", \"address\": { \"hostname\": \"149. 154. 176. 34\", \"port\": 31350 } } ], \"next\": \"inclusive: 4\" } Add cut peer information Use PUT https: //{baseURL}/cut/peer to add peer information to the peer database of the cut peer-to-peer network on the remote host. Request body schema Use the following parameters to specify the peer information you want to add to the peer database of the cut peer-to-peer network on the remote host. | Parameter | Type | Description | --------- | ---- | ----------- | id (required) | string or null | Specifies the Base64Url-encoded string—without padding—that represents the SHA256 fingerprint of the SSL certificate for the remote node. This field can only be null if the node uses an official certificate authority (CA) signed certificate. In all other cases, the id string consists of 43 characters from the a-zA-Z0-9- character set. | address (required) | object | Specifies the host and port number of the peer. Responses Requests to PUT https: //{baseURL}/cut/peer return the following response codes: - 204 No Content indicates that the request was successful and the peer was added to the peer database of the remote node. - 400 Bad Request indicates that the request itself is invalid or that the hostname and port provided for the peer is not reachable. Before a Chainweb node adds a peer to its peer database, the node checks whether the peer can be reached using the information provided. If this check fails, an error is returned. Examples You can send a request to add a peer to the peer node database with a call to the /peer endpoint similar to the following: Code example (Postman): PUT https: //us1. testnet. chainweb. com/chainweb/0. 0/testnet04/cut/peer` The request body for adding a peer contains parameters similar to the following: Code example (json): { \"id\": \"NE9g8dsqVF1OKwyqITXpIiEF4i9ReFzJQG9FhDEnQ\", \"address\": { \"hostname\": \"testnet-node. ajuba. io\", \"port\": 1789 } } If the request is successful, you'll see the 204 No Content response returned. If the host name or IP address wasn't reachable, you'll see an error message similar to the following: Code example (text): Invalid hostaddress: IsNotReachable \"ConnectionFailure Network. Socket. getAddrInfo (called with preferred socket type/protocol: AddrInfo {addrFlags = [AIADDRCONFIG], addrFamily = AF_UNSPEC, addrSocketType = Stream, addrProtocol = 0, addrAddress = 0. 0. 0. 0: 0, addrCanonName = Nothing}, host name: Just \\\"testnet-node. ajuba. io\\\", service name: Just \\\"1789\\\"): does not exist (Name or service not known)\"",
    "source": "api/peer-to-peer/get-cut-peers.md",
    "title": "Get cut peers"
  },
  {
    "content": "Use the GET /cut endpoint to return the cut height for a Chainweb node. In the Kadena network, a cut height represents the distributed state from a Chainweb node. Each cut height—much like a database snapshot or a block height—references one block header for each chain, compared with concurrent blocks on other chains. Two blocks from two different chains are considered concurrent if either block is an adjacent parent and a direct dependency of the other or if the blocks do not depend at all on each other. Request format Use GET https: //{baseURL}/cut to query a Chainweb node for the current cut height on all chains. You can specify the following optional query parameter for the request: | Parameter | Type | Description | --------- | ---- | ----------- | maxheight | integer >= 0 | Maximum cut height of the returned cut. Responses Requests to GET https: //{baseURL}/cut return the following response code: - 200 OK indicates that the request succeeded and the response body returns the blockchain state for each chain at the specified block height. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. | Parameter | Type | Description | --------- | ---- | ----------- | x-peer-addr | string | Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: \"10. 36. 1. 3: 42988\". | x-server&#8209; timestamp | integer >= 0 | Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: 1618597601. | x&#8209; chainweb&#8209; node&#8209; version | string | Specifies the version of the remote Chainweb node. For example: \"2. 23\". Response schema The response returns application/json content with the following information: | Parameter | Type | Description | --------- | ---- | ----------- | origin | object | Describes a peer information object that consists of an id string and an address object for a Chainweb node. The origin parameter is required to use the PUT /cut endpoint. For more information, see the Peer information data model. | height (required) | integer >= 0 | Specifies the cut height. The cut height is the sum of the height for all of the blocks included in the cut. You should avoid using this value because its semantics may change in the future. | weight (required) | string | Specifies the cut weight. The cut weight is the sum of the weights from all of the blocks included in the cut. The weight string consists of 43 characters from the [a-zA-Z0-9-] character set. | hashes (required) | object | Specifies an object that maps chain identifiers 0-19 to their respective block hash and block height for the cut. | instance | string | Specifies the network identifier for the cut. | id | string | Specifies a cut identifier. The id string consists of 43 characters from the [a-zA-Z0-9-] character set. Examples You can send a request to a bootstrap node for the Kadena main network with a call like this: Code example (Postman): GET https: //us-e1. chainweb. com/chainweb/0. 0/mainnet01/cut? maxheight=4833114 The response header for this request looks like this: Code example (text): X-Server-Timestamp: 1717448611 X-Peer-Addr: 54. 86. 50. 139: 49795 X-Chainweb-Node-Version: 2. 24 Content-Type: application/json; charset=utf-8 The response body for this request returns the state for each chain with the maximum block height of 483314: Code example (json): { \"hashes\": { \"5\": { \"height\": 483311, \"hash\": \"3uC7pcfNDQLBnkSEXak5-SJDTQDzOcCu-hzLdZB5SZY\" }, \"4\": { \"height\": 483311, \"hash\": \"-J7wrfvBhTV4FMEwzcUczchURV3vR8X1Iw670Vdcw\" }, \"7\": { \"height\": 483311, \"hash\": \"Th5sqaG-czuzwwqJpljtqJrp9C09mFFESqpxZn5TM\" }, \"6\": { \"height\": 483311, \"hash\": \"jGXtsEywkJiDd0QdTou3vP-7-s5tf49DFq0BP0roBs\" }, \"1\": { \"height\": 483311, \"hash\": \"-vJ5dWJIsBa760sVDXg69OizfWvhK10VRtDDlG. . . [code continues] Note that this sample request was sent to a bootstrap node for the Kadena public blockchain, so the origin is null. If you want to publish a cut, you must send the request to a Chainweb node that returns a value for the origin property. Publish a cut Use PUT https: //{baseURL}/cut to publish a cut to a Chainweb node. The cut must contain an origin property that is not null. The receiving node will first try to obtain all missing dependencies from the node specified for the origin property before searching for the dependencies in the peer-to-peer network. Request body schema Use the following parameters to specify a cut with an origin property that is not null. | Parameter | Type | Description | --------- | ---- | ----------- | origin (required) | object | Describes a peer information object that consists of an id string and an address object for a Chainweb node. The origin parameter is required to use the PUT /cut endpoint. For more information, see the Peer information data model. | height (required) | integer >= 0 | Specifies the cut height to publish. The cut height is the sum of the height for all of the blocks included in the cut. You should avoid using this value because its semantics may change in the future. | weight (required) | string| Specifies the cut weight. The cut weight is the sum of the weights from all of the blocks included in the cut. The weight string consists of 43 characters from the [a-zA-Z0-9-] character set. | hashes (required) | object | Specifies an object that maps chain identifiers 0-19 to their respective block hash and block height for the cut. | instance | string | Specifies the network identifier for the cut. | id | string | Specifies a cut identifier. The id string consists of 43 characters from the [a-zA-Z0-9-] character set. Responses Requests to PUT https: //{baseURL}/cut return the following response codes: - 204 No Content indicates that the request was successful and the cut was added to the cut processing pipeline on the remote Chainweb node. - 401 Unauthorized indicates that the node where you are trying to publish the cut is not a peer of the node identified in the origin property, and therefore cannot process the cut you're attempting to publish. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. | Parameter | Type | Description | --------- | ---- | ----------- | x-peer-addr | string | Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: \"10. 36. 1. 3: 42988\". | x-server&#8209; timestamp | integer >= 0 | Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: 1618597601. | x&#8209; chainweb&#8209; node&#8209; version | string | Specifies the version of the remote Chainweb node. For example: \"2. 23\". Examples You can send a request to publish a cut on a node with a call to the /cut endpoint similar to the following: Code example (Postman): PUT https: //sfchainweb. example. com/chainweb/0. 0/testnet04/cut The request body for publishing a cut contains parameters similar to the following: Code example (json): { \"origin\": { \"address\": { \"hostname\": \"85. 238. 99. 91\", \"port\": 30004 }, \"id\": \"PRLmVUcc9AH3fyfMYiWeC4nV2i1iHwc0-aM7iAO8h18\" }, \"height\": 30798466, \"weight\": \"b0wYplmNiTBXCwAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\", \"hashes\": { \"0\": { \"height\": 1539923, \"hash\": \"qEaSmWttDcJC9AGbgWY9x12LW5VED7hGgfyz9xS3w\" }, \"1\": { \"height\": 1539923, \"hash\": \"TJuC6nfhamfD517gspAZmqD9umR71nAgttDOi1JbBHw\" }, \". . . [code continues] If the request is successful, you'll see the 204 No Content response returned.",
    "source": "api/peer-to-peer/get-cut.md",
    "title": "Query the current state"
  },
  {
    "content": "Provides reference information for the chainweb-node peer endpoints. Get mempool peer information For peer-to-peer connections, Chainweb nodes have two separate communication channels with specialized independent peer-to-peer networks that different nodes can be part of: - The /peer/cut peer-to-peer network is responsible for communicating the consensus state across the distributed network nodes. - The /peer/mempool peer-to-peer network is responsible for queuing and managing the pending transactions for each chain independently. Request format Use GET https: //{baseURL}/chain/{chain}/mempool/peer to retrieve peer information about the mempool peer-to-peer network for a specific Chainweb node and chain. Path parameters | Parameter | Type | Description | --------- | ---- | ----------- | chain (required) | integer >= 0 | Specifies the chain identifier of the chain you want to send the request to. Valid values are 0 to 19. For example, to get block hashes for the first chain (0), the request is GET https: //{baseURL}/chain/0/mempool/peer. Query parameters | Parameter | Type | Description | --------- | ---- | ----------- | limit | integer >= 0 | Specifies the maximum number of records that should be returned. The actual number of records returned might be lower than the value you specify. For example: limit=3. | next | string | Specifies the cursor value to retrieve the next page of results. You can find the value to specify in the next property returned by the previous page in a successful response. For example: \"inclusive: qgsxD1G5m8dGZ4W9nMKBotU2I10ilURkRIE3UKHlLM\". Responses Requests to GET https: //{baseURL}/chain/{chain}/mempool/peer return the following response code: - 200 OK indicates that the request succeeded and the response body returns the blockchain state for each chain at the specified block height. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. | Parameter | Type | Description | --------- | ---- | ----------- | x-peer-addr | string | Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: \"10. 36. 1. 3: 42988\". | x-server&#8209; timestamp | integer >= 0 | Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: 1618597601. | x&#8209; chainweb&#8209; node&#8209; version | string | Specifies the version of the remote Chainweb node. For example: \"2. 23\". Successful response schema If the request is successful, the response returns application/json content with the following: | Parameter | Type | Description | --------- | ---- | ----------- | items (required) | Array of objects | Returns an array of peer information objects. | limit (required) | integer >= 0 | Specifies the maximum number of items in the page. This number can be smaller but never larger than the number of requested items. | next (required) | string or null | Returns a value that can be used to query the next page. You can use this value for the next parameter in a follow-up request. The format for this parameter consists of two parts. The first part of the string can be inclusive, exclusive, or null. The second part is the value that calls the next page of results or null if there are no more results to query. Examples You can send a request to retrieve information about the memory pool peer-to-peer network with a call to the /peer endpoint similar to the following: Code example (Postman): GET https: //us1. testnet. chainweb. com/chainweb/0. 0/testnet04/chain/4/mempool/peer? limit=3 The response body for this request returns the peer information for the nodes in the mempool peer-to-peer network: Code example (json): { \"limit\": 3, \"items\": [ { \"id\": \"aEdeq9bOZws1X5IpBF5aGM6vV6ghEicHSMoPs5wb40\", \"address\": { \"hostname\": \"13. 251. 43. 216\", \"port\": 1789 } }, { \"id\": \"SMq0oMEVVBNNl3GfMBJfbHVBIRIVa0v6qwoKZflQtAA\", \"address\": { \"hostname\": \"34. 148. 233. 99\", \"port\": 1789 } }, { \"id\": \"AFqlaMJ8IfuwQiuyoqxa83U2DTkrJjhGftplwv. . . [code continues] Add peer information to the mempool peer-to-peer network Use PUT https: //{baseURL}/chain/{chain}/mempool/peer to add peer information to the mempool peer-to-peer network for a specific chain. Path parameters | Parameter | Type | Description | --------- | ---- | ----------- | chain (required) | integer >= 0 | Specifies the chain identifier of the chain you want to send the request to. Valid values are 0 to 19. For example, to get block hashes for the first chain (0), the request is PUT https: //{baseURL}/chain/0/mempool/peer. Request body schema Use the following parameters to specify the peer information you want to add to the peer database of the memory pool peer-to-peer network on the remote host. | Parameter | Type | Description | --------- | ---- | ----------- | id (required) | string or null | Specifies the Base64Url-encoded string—without padding—that represents the SHA256 fingerprint of the SSL certificate for the remote node. This field can only be null if the node uses an official certificate authority (CA) signed certificate. In all other cases, the id string consists of 43 characters from the a-zA-Z0-9- character set. | address (required) | object | Specifies the host and port number of the peer you want to add to the peer database of the memory pool peer-to-peer network for the specified chain. Responses Requests to PUT https: //{baseURL}/chain/{chain}/mempool/peer return the following response codes: - 204 No Content indicates that the request was successful and the peer was added to the peer database of the remote node. - 400 Bad Request indicates that the request itself is invalid or that the hostname and port provided for the peer is not reachable. Before a Chainweb node adds a peer to its peer database, the node checks whether the peer can be reached using the information provided. If this check fails, an error is returned. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. | Parameter | Type | Description | --------- | ---- | ----------- | x-peer-addr | string | Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: \"10. 36. 1. 3: 42988\". | x-server&#8209; timestamp | integer >= 0 | Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: 1618597601. | x&#8209; chainweb&#8209; node&#8209; version | string | Specifies the version of the remote Chainweb node. For example: \"2. 23\". Examples You can send a request to add a peer to the peer node database with a call to the /peer endpoint similar to the following: Code example (Postman): PUT https: //us1. testnet. chainweb. com/chainweb/0. 0/testnet04/chain/4/mempool/peer` The request body for adding a peer contains parameters similar to the following: Code example (json): { \"id\": \"aEdeq9bOZws1X5IpBF5aGM6vV6ghEicHSMoPs5wb40\", \"address\": { \"hostname\": \"13. 251. 43. 216\", \"port\": 1789 } } If the request is successful, you'll see the 204 No Content response returned. If the host name or IP address wasn't reachable, you'll see an error message similar to the following: Code example (text): Invalid hostaddress: IsNotReachable \"ConnectionFailure Network. Socket. getAddrInfo (called with preferred socket type/protocol: AddrInfo {addrFlags = [AIADDRCONFIG], addrFamily = AFUNSPEC, addrSocketType = Stream, addrProtocol = 0, addrAddress = 0. 0. 0. 0: 0, addrCanonName = Nothing}, host name: Just \\\"us1. testnet. ajuba. io\\\", service name: Just \\\"1789\\\"): does not exist (Name or service not known)\"",
    "source": "api/peer-to-peer/get-mempool-peers.md",
    "title": "Get mempool peers"
  },
  {
    "content": "Provides reference information for the chainweb-node block payload endpoints. Request multiple block payloads Use POST https: //{baseURL}/chain/{chain}/payload/batch to request multiple block payloads in a batch. Path parameters | Parameter | Type | Description | --------- | ---- | ----------- | chain (required) | integer >= 0 | Specifies the chain identifier of the chain you want to get the payload from. Valid values are 0 to 19. For example, to get block payload for the first chain (0), the request is POST https: //{baseURL}/chain/0/payload/batch. Request body schema Use an array of payload hash strings and an array of block heights in a JSON object to specify the payloads you want to include in your batch request. | Parameter | Type | Description | --------- | ---- | ----------- | hashes | Array of strings | Specifies the block payload hashes to include in the query request. Each block payload hash is a Base64Url-encoded string—without padding—that consists of 43 characters from the a-zA-Z0-9- character set. For example: GpaWbHkHrCjRhY8hKE0qZ1WsBBaG3YzkFLV2sYumQA. | heights | Array of integers | Specifies the block heights to include in the request. Responses Requests to POST https: //{baseURL}/chain/{chain}/payload/batch return the following response codes: - 200 OK indicates that the request succeeded and the response body returns some or all of the requested block payloads. The payloads are returned in any order. - 404 Not Found indicates that the no payloads matching the request criteria were found. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. | Parameter | Type | Description | --------- | ---- | ----------- | x-peer-addr | string | Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: \"10. 36. 1. 3: 42988\". | x-server&#8209; timestamp | integer >= 0 | Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: 1618597601. | x&#8209; chainweb&#8209; node&#8209; version | string | Specifies the version of the remote Chainweb node. For example: \"2. 23\". Successful response schema If the request is successful, the response returns application/json content with the following: | Parameter | Type | Description | --------- | ---- | ----------- | transactions (required) | Array of strings | An array of Base64Url-encoded strings—without padding—that describe signed Pact transactions in JSON format. | minerData (required) | string | Miner information is a Base64Url-encoded string—without padding—that consists of characters from the a-zA-Z0-9- character set. This information is included as part of the payload JSON object. | transactionsHash (required) | string | The transaction hash is a SHA256 hash. The hash is a Base64Url-encoded string—without padding—that consists of 43 characters from the a-zA-Z0-9- character set. | outputsHash (required) | string | The output hash is a SHA256 hash. The hash is a Base64Url-encoded string—without padding—that consists of 43 characters from the a-zA-Z0-9- character set. | payloadHash (required) | string | The block payload hash is a Base64Url-encoded string—without padding—that consists of 43 characters from the a-zA-Z0-9- character set. Examples You can send a request to a bootstrap node for the Kadena test network and chain id 18 with a call like this: Code example (Postman): POST https: //us1. chainweb. com/chainweb/0. 0/testnet04/chain/18/payload/batch In this example, the request body includes a payload hash array for two payloads and three blook heights like this: Code example (json): { \"hashes\": [\"KBs8f6ZK2UKDQRpEwNcm5I5c1HHW1SfOmwzOVVU9ic\", \"vVNA0B3LmES4gOP5iLE4e4R2eslwQvBzAmhFhuThZRs\"], \"heights\": [4460669, 4460682, 4460694] } If there are no payoads matching your query request, the endpoint returns an empty array. A successful response with two payloads looks similar to the following: Code example (json): [ { \"transactions\": [ \"eyJoYXNoIjoiZjE0cW9vRTNxbDFUT2U0cmFyNzBlZVRScWs1MjMtQi1VeDh4MnV5MWNGSSIsInNpZ3MiOlt7InNpZyI6Ijc1OWRlOGY4OTc2NjgxMmRmNzQ4YjQxYjY4MDBmOWNhZWI4OGUwYTU5MDQzZTQxN2I4YjBiNWU1ZDVkZGEwMWNjMDhkYTg3MTM0NjRiYTdmZTVmOTE0OTU5MDY0NjQxZDc0NjVlZmZkNGNlYjBhNDk0MDBjMWQ3ZTYwYTA0YzA2In1dLCJjbWQiOiJ7XCJuZXR3b3JrSWRcIjpcIm1haW5uZXQwMVwiLFwicGF5bG9hZFwiOntcImV4ZWNcIjp7XCJkYXRhXCI6e1wia2V5c2V0XCI6e1wicHJlZFwiOlwia2V5cy1hbGxcIixcImtleXNcIjpbXCJkYmUwNWY4YWQ3OTYzMjc3YjYwZWQ3Y2E1NDhhNDRiN. . . [code continues] Get block payload with outputs Use GET https: //{baseURL}/chain/{chain}/payload/{payloadHash}/outputs to get payload data with output. Path parameters | Parameter | Type | Description | --------- | ---- | ----------- | chain (required) | integer >= 0 | Specifies the chain identifier of the chain you want to send the payload request to. Valid values are 0 to 19. For example, to get block payload for the first chain (0), the request is GET https: //{baseURL}/chain/0/payload/{payloadHash}/outputs. | payloadHash (required) | string | The block payload hash is a Base64Url-encoded string—without padding—that consists of 43 characters from the a-zA-Z0-9- character set. For example: GpaWbHkHrCjRhY8hKE0qZ1WsBBaG3YzkFLV2sYumQA. Query parameters | Parameter | Type | Description | --------- | ---- | ----------- | height | integer >= 0 | Height of a block. For example: height=3000000. Responses Requests to GET https: //{baseURL}/chain/{chain}/payload/{payloadhash}/outputs return the following response codes: - 200 OK indicates that the request succeeded and the response body returns the payload data and output for the specified payload hash. - 404 Not Found indicates that the payload hash wasn't found. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. | Parameter | Type | Description | --------- | ---- | ----------- | x-peer-addr | string | Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: \"10. 36. 1. 3: 42988\". | x-server&#8209; timestamp | integer >= 0 | Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: 1618597601. | x&#8209; chainweb&#8209; node&#8209; version | string | Specifies the version of the remote Chainweb node. For example: \"2. 23\". Successful response schema If the request is successful, the response returns application/json content with the following: | Parameter | Type | Description | --------- | ---- | ----------- | transactions (required) | Array of strings | An array of Base64Url-encoded strings—without padding—that describe signed Pact transactions in JSON format. | minerData (required) | string | Miner information is a Base64Url-encoded string—without padding—that consists of characters from the a-zA-Z0-9- character set. This information is included as part of the payload JSON object. | transactionsHash (required) | string | The transaction hash is a SHA256 hash. The hash is a Base64Url-encoded string—without padding—that consists of 43 characters from the a-zA-Z0-9- character set. | outputsHash (required) | string | The output hash is a SHA256 hash. The hash is a Base64Url-encoded string—without padding—that consists of 43 characters from the a-zA-Z0-9- character set. | payloadHash (required) | string | The block payload hash is a Base64Url-encoded string—without padding—that consists of 43 characters from the a-zA-Z0-9- character set. | coinbase (required) | string | Coinbase output is a Base64Url-encoded string—without padding—that consists of characters from the a-zA-Z0-9- character set. This information is included as part of the payload output JSON object. Not found response schema If there are no results matching the request criteria, the response returns the following: Parameter | Type | Description key | string | Specifies the base64Url-encoded block hash without padding. The block hash consists of 43 characters from the a-zA-Z0-9- character set. reason | string | Provides a placeholder for specifying the reason that no block hashes were found. Examples You can send a request to a bootstrap node for the Kadena main network and chain id 4 with a call like this: Code example (Postman): GET https: //us-e1. chainweb. com/chainweb/0. 0/mainnet01/chain/4/payload/jafDpAgMCYnAqh-hweSjA6sWCAp-ADSDzIcUKyRwkq8/outputs This request returns a response body that looks like this: Code example (json): { \"transactions\": [ [ \"eyJoYXNoIjoiQXFtNTRlRWNmMkQtVGJQR3FYLURIYWFkdUF0VXp5dEVqVzhLaDJ6bWlRSSIsInNpZ3MiOlt7InNpZyI6IjY5MzYwYTlhZjZmOTVkMmQ4NjhiNDA4NmQ0ZTU1NjQ3NzRhOGU5NWY0ZDZmMGM0ZGI2MmE4YTgwMmI5YWNkODczOTRmNjNkN2FiMTFkNjA2NWU1MjEzYmYwMGRkNmVhYjliMWI0MzUwODU1MTFmYmRkNmE1ZDcxMzI1YjhmZTBiIn1dLCJjbWQiOiJ7XCJwYXlsb2FkXCI6e1wiZXhlY1wiOntcImNvZGVcIjpcIihuX2JmYjc2ZWFiMzdiZjhjODQzNTlkNjU1MmExZDk2YTMwOWUwMzBiNzEuZGlhLW9yYWNsZS5zZXQtbXVsdGlwbGUtdmFsdWVzIFtcXFwiR05PL1VTRFxcXCJdIFsod. . . [code continues] If there are no results matching the request criteria, the response body indicates the reason no results were found. For example: Code example (json): { \"key\": \"i3lwc38zLkSrHDn5wjLMFfA4VdofhTZ3crqZZ-5WJs\", \"reason\": \"key not found\" } Request multiple block payloads with outputs Use POST https: //{baseURL}/chain/{chain}/payload/outputs/batch to request multiple block payloads with output in a batch. Path parameters | Parameter | Type | Description | --------- | ---- | ----------- | chain (required) | integer >= 0 | Specifies the chain identifier of the chain you want to get the payload from. Valid values are 0 to 19. For example, to get block payload for the first chain (0), the request is POST https: //{baseURL}/chain/0/payload/outputs/batch. Request body schema Use an array of payload hash strings in a JSON object to specify the payloads you want to include in your batch request, with or without heights. | Parameter | Type | Description | --------- | ---- | ----------- | hashes (required) | Array of strings | Each block payload hash is a Base64Url-encoded string—without padding—that consists of 43 characters from the a-zA-Z0-9- character set. For example: GpaWbHkHrCjRhY8hKE0qZ1WsBBaG3YzkFLV2sYumQA. | heights (required) | Array of integers | Specifies the block heights to include in the request. Responses Requests to POST https: //{baseURL}/chain/{chain}/payload/outputs/batch return the following response codes: - 200 OK indicates that the request succeeded and the response body includes some or all of the requested block payloads. The payloads are returned in any order. - 404 Not Found indicates that no payloads mateching the request criteris were found. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. | Parameter | Type | Description | --------- | ---- | ----------- | x-peer-addr | string | Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: \"10. 36. 1. 3: 42988\". | x-server&#8209; timestamp | integer >= 0 | Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: 1618597601. | x&#8209; chainweb&#8209; node&#8209; version | string | Specifies the version of the remote Chainweb node. For example: \"2. 23\". Successful response schema If the request is successful, the response returns application/json content with the following: | Parameter | Type | Description | --------- | ---- | ----------- | transactions (required) | Array of strings | An array of Base64Url-encoded strings—without padding—that describe signed Pact transactions in JSON format. | minerData (required) | string | Miner information is a Base64Url-encoded string—without padding—that consists of characters from the a-zA-Z0-9- character set. This information is included as part of the payload JSON object. | transactionsHash (required) | string | The transaction hash is a SHA256 hash. The hash is a Base64Url-encoded string—without padding—that consists of 43 characters from the a-zA-Z0-9- character set. | outputsHash (required) | string | The output hash is a SHA256 hash. The hash is a Base64Url-encoded string—without padding—that consists of 43 characters from the a-zA-Z0-9- character set. | payloadHash (required) | string | The block payload hash is a Base64Url-encoded string—without padding—that consists of 43 characters from the a-zA-Z0-9- character set. | coinbase (required) | string | Coinbase output is a Base64Url-encoded string—without padding—that consists of characters from the a-zA-Z0-9- character set. This information is included as part of the payload output JSON object. Examples You can send a request to a bootstrap node for the Kadena main public blockchain network and chain id 4 with a call like this: Code example (Postman): POST https: //us-e1. chainweb. com/chainweb/0. 0/mainnet01/chain/4/payload/outputs/batch In this example, the batch request includes three payload hashes and two block heights like this: Code example (json): { \"hashes\": [\"R464YmQdiNCakRluZb2oJDGuJBqUSAZpANNktJRQko\", \"nrPYG6PSkE40eYuf4LLrPFRADp2Uq7EI9d4OOIqeOMs\", \"JerYnYUPUWavDKO1plBuVTi62PHcAsgICIA0IRSGA8s\"], \"heights\": [4953820, 4953821] } The request returns the results matching the request criteria like this: Code example (json): [ { \"transactions\": [ [ \"eyJoYXNoIjoiQmJHc0J6RTNhcW9ObmstOUt6U3FwSnFDc3duSEFuWHFJa21JUFV4RjVidyIsInNpZ3MiOlt7InNpZyI6Ijc2NjU1NjM0N2MzYzY1YzMwMmM0OTYwMWVlY2E2Yzk3ZTg1ODdmMDk3M2E5ZjlkOWY0N2YyM2NhZjJhMGZiMTMwN2Y1OGNhM2FiYzNlNjEyZTM3NTE3NWMyNWQ3ZjViY2FjZmEwOTQzN2NkZDI1MjU1YTM2ZmQwOGEzYjI0ZTA2In1dLCJjbWQiOiJ7XCJwYXlsb2FkXCI6e1wiZXhlY1wiOntcImNvZGVcIjpcIihuX2JmYjc2ZWFiMzdiZjhjODQzNTlkNjU1MmExZDk2YTMwOWUwMzBiNzEuZGlhLW9yYWNsZS5zZXQtbXVsdGlwbGUtdmFsdWVzIFtcXFwiQlR. . . [code continues]",
    "source": "api/peer-to-peer/get-payload-batch.md",
    "title": "Request multiple payloads"
  },
  {
    "content": "Provides reference information for the chainweb-node block payload endpoints. You can use the /payload endpoint to return raw block payloads in the same form as they are stored on the chain. By default, only the payload data is returned. The raw payload data is sufficient for validating the blockchain Merkle tree and to use as input to Pact for executing the Pact transactions of the block and recomputing the outputs. You can also send requests to query the transaction outputs along with the payload data. Request format Use GET https: //{baseURL}/chain/{chain}/payload/{payloadHash} to get the raw payload data for the specified payload hash. Path parameters | Parameter | Type | Description | --------- | ---- | ----------- | chain (required) | integer >= 0 | Specifies the chain identifier of the chain you want to send the payload request to. Valid values are 0 to 19. For example, to get block payload for the first chain (0), the request is GET https: //{baseURL}/chain/0/payload. | payloadHash (required) | string | Specifies the payload hash for the request. The block payload hash is a Base64Url-encoded string—without padding—that consists of 43 characters from the a-zA-Z0-9- character set. For example: GpaWbHkHrCjRhY8hKE0qZ1WsBBaG3YzkFLV2sYumQA. Query parameters | Parameter | Type | Description | --------- | ---- | ----------- | height | integer >= 0 | Height of a block. For example: height=3000000. Responses Requests to GET https: //{baseURL}/chain/{chain}/payload/{payloadhash} return the following response codes: - 200 OK indicates that the request succeeded and the response body returns the payload data for the specified payload hash. - 404 Not Found indicates that the payload hash wasn't found. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. | Parameter | Type | Description | --------- | ---- | ----------- | x-peer-addr | string | Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: \"10. 36. 1. 3: 42988\". | x-server&#8209; timestamp | integer >= 0 | Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: 1618597601. | x&#8209; chainweb&#8209; node&#8209; version | string | Specifies the version of the remote Chainweb node. For example: \"2. 23\". Successful response schema If the request is successful, the response returns application/json content with the following: | Parameter | Type | Description | --------- | ---- | ----------- | transactions (required) | Array of strings | An array of Base64Url-encoded strings—without padding—that describe signed Pact transactions in JSON format. | minerData (required) | string | Miner information is a Base64Url-encoded string—without padding—that consists of characters from the a-zA-Z0-9- character set. This information is included as part of the payload JSON object. | transactionsHash (required) | string | The transaction hash is a SHA256 hash. The hash is a Base64Url-encoded string—without padding—that consists of 43 characters from the a-zA-Z0-9- character set. | outputsHash (required) | string | The output hash is a SHA256 hash. The hash is a Base64Url-encoded string—without padding—that consists of 43 characters from the a-zA-Z0-9- character set. | payloadHash (required) | string | The block payload hash is a Base64Url-encoded string—without padding—that consists of 43 characters from the a-zA-Z0-9- character set. Not found response schema If there are no results matching the request criteria, the response returns the following: Parameter | Type | Description key | string | Specifies the base64Url-encoded block hash without padding. The block hash consists of 43 characters from the a-zA-Z0-9- character set. reason | string | Provides a placeholder for specifying the reason that no block hashes were found. Examples You can send a payload request to a bootstrap node for the Kadena test network and chain id 18 with a call like this: Code example (Postman): GET https: //us1. testnet. chainweb. com/chainweb/0. 0/testnet04/chain/18/payload/BKFz8a2AZGtZQPlp2xPRfe7ohlnOuzV2NbIEB3cFwI8 The response header for this request looks like this for chainweb-node version 2. 26. 1: Code example (text): X-Server-Timestamp: 1720805685 X-Peer-Addr: 54. 86. 50. 139: 16853 X-Chainweb-Node-Version: 2. 26. 1 Content-Type: application/json; charset=utf-8 The response body for this request returns the payload data. In this example, the payload data includes three transactions: Code example (json): { \"transactions\": [ \"eyJoYXNoIjoicXl1UE00V0F3UFEyeHUtTmxZYVVNcVhzLTBmNG5mR2oyOE12YjFvclN4ayIsInNpZ3MiOlt7InNpZyI6ImMwNWI0NjU5ZTAyOWM2ZTcwNzAwNGFiZjNjMDE1OTY4YjZlMDgzZWI1YzU5YTIyMWUyYWMzMThkYTljZDlmMjdhOTliNzIwYjZkMmNjMDE1M2JkODYxYmZlY2RkZTY2YzcyNmQzOTZhNWQ4MTRiMWQ0YmZhYWNjMzdjYWQzNjBmIn1dLCJjbWQiOiJ7XCJuZXR3b3JrSWRcIjpcInRlc3RuZXQwNFwiLFwicGF5bG9hZFwiOntcImV4ZWNcIjp7XCJkYXRhXCI6e30sXCJjb2RlXCI6XCIobl9jNTE3NTY4Yjg5ZWViNWI2ZTZhYjE0NTYwZTcxMGYyODcwMzJlNjcyLmJyby1sb3R0ZXJ5LWhlbHBlcnMuYnV. . . [code continues] In the following example, the payload hash doesn't include any transactions: Code example (Postman): GET https: //us1. testnet. chainweb. com/chainweb/0. 0/testnet04/chain/18/payload/PB4yVhQo7vosXUH9Pik2zOyJznfH0ChH-WOygOKuw The response body indicates the empty block payload like this: Code example (json): { \"transactions\": [], \"minerData\": \"eyJhY2NvdW50IjoidGVzdG4zdCIsInByZWRpY2F0ZSI6ImtleXMtYWxsIiwicHVibGljLWtleXMiOlsiZGI3NzY3OTNiZTBmY2Y4ZTc2Yzc1YmRiMzVhMzZlNjdmMjk4MTExZGM2MTQ1YzY2NjkzYjAxMzMxOTJlMjYxNiJdfQ\", \"transactionsHash\": \"v0-mUfeOoSLCuFyKMMwoTW7-4JZHBqjqS2NNPOYBbWg\", \"outputsHash\": \"-afV95tCPIrMvk2yGoOxcjS4DAX0moG6gURByqf6Y\", \"payloadHash\": \"PB4yVhQo7vosXUH9Pik2zOyJznfH0ChH-WOygOKuw\" } If there are no results matching the request criteria, the response body indicates the reason no results were found. For example: Code example (json): { \"key\": \"k1H3DsInAPvJ0WzPxnrpkeSNdPUT0S9U8bqDLG739w\", \"reason\": \"key not found\" }",
    "source": "api/peer-to-peer/get-payload.md",
    "title": "Get payload"
  },
  {
    "content": "Provides reference information for the chainweb-node mempool endpoints. When transactions are submitted to the blockchain for processing, they are queued in the node memory pool to await delivery to a mining node as new work to be validated. Endpoints related to memory pool activity are peer-to-peer endpoints that enable communication between memory pools on different nodes. The /mempool/insert endpoint is included for reference. However, you shouldn't use this endpoint to insert transactions into the memory pool directly. You should always use the appropriate Pact REST API endpoints to submit and check the status of transactions. Request format Nodes can use the PUT https: //{baseURL}/chain/{chain}/mempool/insert endpoint to move transactions into the memory pool. You shouldn't use this endpoint directly. Path parameters | Parameter | Type | Description | --------- | ---- | ----------- | chain (required) | integer >= 0 | Specifies the chain identifier of the chain you want to send the payload request to. Valid values are 0 to 19. For example, to get block payload for the first chain (0), the request is POST https: //{baseURL}/chain/0/mempool/insert. Request body schema The request body consists of an array of JSON-encoded strings representing signed Pact transactions. Responses Requests to PUT https: //{baseURL}/chain/{chain}/mempool/insert return the following response code: - 200 OK indicates that the request succeeded and that transactions were inserted into the memory pool. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. | Parameter | Type | Description | --------- | ---- | ----------- | x-peer-addr | string | Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: \"10. 36. 1. 3: 42988\". | x-server&#8209; timestamp | integer >= 0 | Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: 1618597601. | x&#8209; chainweb&#8209; node&#8209; version | string | Specifies the version of the remote Chainweb node. For example: \"2. 23\". Examples The following example illustrates the content of the request body with an array that only contains one transaction: Code example (request): [ \"{\\\"hash\\\": \\\"y3aWL72-3wAy7vL9wcegGXnstH0lHi-q-cfxkhD5JCw\\\", \\\"sigs\\\": [{\\\"sig\\\": \\\"8ddc06b37c496f2cadc4f7412405a80faf3ab07482ff5553b9b5fcc73d1b4121275ad5948d9b4078e553b71f8b42eaf6b24135bf2fb4d5840c16bcdde0e35e0f\\\"}], \\\"cmd\\\": \\\"{\\\\\\\"networkId\\\\\\\": \\\\\\\"mainnet01\\\\\\\", \\\\\\\"payload\\\\\\\": {\\\\\\\"exec\\\\\\\": {\\\\\\\"data\\\\\\\": {\\\\\\\"account-keyset\\\\\\\": {\\\\\\\"pred\\\\\\\": \\\\\\\"keys-all\\\\\\\", \\\\\\\"keys\\\\\\\": [\\\\\\\"acc28032a1bb725b7ba0a3593ab86f393894fa6659281f3dfdfee0afe48559a2\\\\\\\"]}}, \\\\\\\"code\\\\\\\": \\\\\\\"(coin. transfer-create \\\\\\\\\\\\\\\"60. . . [code continues]",
    "source": "api/peer-to-peer/insert-tx-mempool.md",
    "title": "Insert transactions"
  },
  {
    "content": "Provides reference information for the chainweb-node mempool endpoints. When transactions are submitted to the blockchain for processing, they are queued in the node memory pool to await delivery to a mining node as new work to be validated. Endpoints related to memory pool activity are peer-to-peer endpoints that enable communication between memory pools on different nodes. With the /mempool/lookup endpoint, you can specify a list of transaction request keys to look for in the mempool. For each transaction request key, the endpoint returns the Pending tag and details about the transaction or the Missing tag. Request format Use POST https: //{baseURL}/chain/{chain}/mempool/lookup to look up pending transactions in the memory pool. Path parameters | Parameter | Type | Description | --------- | ---- | ----------- | chain (required) | integer >= 0 | Specifies the chain identifier of the chain you want to send the payload request to. Valid values are 0 to 19. For example, to get block payload for the first chain (0), the request is POST https: //{baseURL}/chain/0/mempool/lookup. Request body schema The request body consists of an array of transaction request keys to check for in the memory pool. Each request key for a Pact transaction is a Base64Url-encoded string—without padding—that consists of 43 characters from the a-zA-Z0-9- character set. The request body is an array of these strings. Responses Requests to POST https: //{baseURL}/chain/{chain}/mempool/lookup return the following response code: - 200 OK indicates that the request succeeded and the response body returns an array of lookup results for each specified transaction. The array has the same size as the request body. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. | Parameter | Type | Description | --------- | ---- | ----------- | x-peer-addr | string | Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: \"10. 36. 1. 3: 42988\". | x-server&#8209; timestamp | integer >= 0 | Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: 1618597601. | x&#8209; chainweb&#8209; node&#8209; version | string | Specifies the version of the remote Chainweb node. For example: \"2. 23\". Successful response schema If the request is successful, the response returns application/json content with an array of lookup results for each request key in the request body. | Parameter | Type | Description | --------- | ---- | ----------- | tag | string | Specifies the lookup result. The valid return values are \"Missing\" or \"Pending\". | contents | string | Specifies the JSON-encoded text for a signed Pact transaction. Examples You can send a request to a bootstrap node for the Kadena test network and chain id 1 with a call like this: Code example (postman): POST https: //us1. testnet. chainweb. com/chainweb/0. 0/testnet04/chain/1/mempool/lookup For this example, the request body consists of two request keys: Code example (request): [\"ptI7wQeOmOt-BER2KQGVd0o6axBpqbhMPQVkkq5YAyE\", \"Gc17hqzSZinUt-JCPvH6kGJFXEJtRwU1Bx4OtSnxWU\"] In this example, the first transaction is \"Pending\" and the second transaction is \"Missing\" in the memory pool: Code example (response): [ { \"tag\": \"Pending\", \"contents\": \"{\\\"hash\\\": \\\"ptI7wQeOmOt-BER2KQGVd0o6axBpqbhMPQVkkq5YAyE\\\", \\\"sigs\\\": [{\\\"sig\\\": \\\"1569af1b56cddd4b853b7d49249c4c52d55e59e04910bfeb8aacbd02bfa0637bbe81b0f4b48ba8eb101fa0e8a276023fbfa57fa5a835741b346d574897052201\\\"}], \\\"cmd\\\": \\\"{\\\\\\\"signers\\\\\\\": [{\\\\\\\"pubKey\\\\\\\": \\\\\\\"1d5a5e10eb15355422ad66b6c12167bdbb23b1e1ef674ea032175d220b242ed4\\\\\\\", \\\\\\\"clist\\\\\\\": [{\\\\\\\"name\\\\\\\": \\\\\\\"coin. TRANSFER\\\\\\\", \\\\\\\"args\\\\\\\": [\\\\\\\"k: 1d5a5e10eb15355422ad66b6c12167bdbb23b1e1ef674. . . [code continues]",
    "source": "api/peer-to-peer/lookup-tx-mempool.md",
    "title": "Look up transactions"
  },
  {
    "content": "Use the POST /cut endpoint to publish the cut height for a Chainweb node. In the Kadena network, a cut height represents the distributed state from a Chainweb node. Each cut height—much like a database snapshot or a block height—references one block header for each chain, compared with concurrent blocks on other chains. Two blocks from two different chains are considered concurrent if either block is an adjacent parent and a direct dependency of the other or if the blocks do not depend at all on each other. Request format Use PUT https: //{baseURL}/cut to publish a cut to a Chainweb node. The cut must contain an origin property that is not null. The receiving node will first try to obtain all missing dependencies from the node specified for the origin property before searching for the dependencies in the peer-to-peer network. Use the following parameters to specify a cut with an origin property that is not null. | Parameter | Type | Description | --------- | ---- | ----------- | origin (required) | object | Describes a peer information object that consists of an id string and an address object for a Chainweb node. The origin parameter is required to use the PUT /cut endpoint. For more information, see the Peer information data model. | height (required) | integer >= 0 | Specifies the cut height to publish. The cut height is the sum of the height for all of the blocks included in the cut. You should avoid using this value because its semantics may change in the future. | weight (required) | string| Specifies the cut weight. The cut weight is the sum of the weights from all of the blocks included in the cut. The weight string consists of 43 characters from the [a-zA-Z0-9-] character set. | hashes (required) | object | Specifies an object that maps chain identifiers 0-19 to their respective block hash and block height for the cut. | instance | string | Specifies the network identifier for the cut. | id | string | Specifies a cut identifier. The id string consists of 43 characters from the [a-zA-Z0-9-] character set. Responses Requests to PUT https: //{baseURL}/cut return the following response codes: - 204 No Content indicates that the request was successful and the cut was added to the cut processing pipeline on the remote Chainweb node. - 401 Unauthorized indicates that the node where you are trying to publish the cut is not a peer of the node identified in the origin property, and therefore cannot process the cut you're attempting to publish. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. | Parameter | Type | Description | --------- | ---- | ----------- | x-peer-addr | string | Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: \"10. 36. 1. 3: 42988\". | x-server&#8209; timestamp | integer >= 0 | Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: 1618597601. | x&#8209; chainweb&#8209; node&#8209; version | string | Specifies the version of the remote Chainweb node. For example: \"2. 23\". Examples You can send a request to publish a cut on a node with a call to the /cut endpoint similar to the following: Code example (Postman): PUT https: //sfchainweb. example. com/chainweb/0. 0/testnet04/cut The request body for publishing a cut contains parameters similar to the following: Code example (json): { \"origin\": { \"address\": { \"hostname\": \"85. 238. 99. 91\", \"port\": 30004 }, \"id\": \"PRLmVUcc9AH3fyfMYiWeC4nV2i1iHwc0-aM7iAO8h18\" }, \"height\": 30798466, \"weight\": \"b0wYplmNiTBXCwAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\", \"hashes\": { \"0\": { \"height\": 1539923, \"hash\": \"qEaSmWttDcJC9AGbgWY9x12LW5VED7hGgfyz9xS3w\" }, \"1\": { \"height\": 1539923, \"hash\": \"TJuC6nfhamfD517gspAZmqD9umR71nAgttDOi1JbBHw\" }, \". . . [code continues] If the request is successful, you'll see the 204 No Content response returned.",
    "source": "api/peer-to-peer/publish-cut.md",
    "title": "Publish the current state"
  },
  {
    "content": "Send a health check API request to check the availability of a node. The /health-check endpoint checks whether chainweb-node is running and responding to service API requests. To check the state of consensus, you should use the GET https: //{baseURL}/cut endpoint instead of this endpoint. Request format Use GET http: //{baseURL}/health-check to check whether chainweb-node is running and responding to API requests. Responses Requests to the /health-check endpoint return the following response code: - 200 OK indicates that the node is running and responding to API requests. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. | Parameter | Type | Description | --------- | ---- | ----------- | x-peer-addr | string | Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: \"10. 36. 1. 3: 42988\". | x-server&#8209; timestamp | integer >= 0 | Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: 1618597601. | x&#8209; chainweb&#8209; node&#8209; version | string | Specifies the version of the remote Chainweb node. For example: \"2. 23\". Response schema The response returns text/plain content with the following information: | Parameter | Type | Description | --------- | ---- | ----------- | check | string | Health check OK. Examples You can send a health check request to a node like this: Code example (Postman): GET http: //api. chainweb. com/health-check This request returns a plain text message like this: Code example (text): Health check OK. Get general node information Use GET http: //{baseURL}/info to return general information about the node and the Chainweb version. Responses Requests to the GET http: //{baseURL}/info endpoint return the following response code: - 200 OK indicates that the request succeeded and the response body returns general information about the node and the chains in the network. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. | Parameter | Type | Description | --------- | ---- | ----------- | x-peer-addr | string | Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: \"10. 36. 1. 3: 42988\". | x-server&#8209; timestamp | integer >= 0 | Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: 1618597601. | x&#8209; chainweb&#8209; node&#8209; version | string | Specifies the version of the remote Chainweb node. For example: \"2. 23\". Response schema If the request is successful, the response returns application/json content with the following: Parameter | Type | Description nodeApiVersion (required) | string | Specifies the Chainweb API version information for the node. nodeBlockDelay (required) | integer >= 0 | Specifies the number of seconds to delay between blocks. nodeChains (required) | Array of strings | Specifies the chain identifiers for the chains in the network the node is part of. nodeGenesisHeights (required) | Array of integers | Specifies the block height for the first block of each chain in the network. | nodeGraphHistory (required) | Array of integers | Specifies the block height and adjacent chains for all chain graphs indexed by the height of the first block with the respective graph. Graphs are encoded as adjacency lists. nodeHistoricalChains (required) | Array of integers | Specifies the block height and adjacent chains for all chain graphs indexed by the height of the first block for the graph. Graphs are encoded as adjacency lists. nodeLatestBehaviorHeight (required) | integer | Specifies the latest block height for the node. nodeNumberOfChains (required) | integer >= 10 | Specifies the number of chains in the network the node is part of. nodePackageVersion (required) | string | Specifies the release package version for the chainweb-node software package running on the node. nodeServiceDate (required) | string | Specifies the next service date for updating the chainweb-node software package running on the node. nodeVersion (required) | string | Specifies the network identifier for the network the node is part of. The valid values are \"test-singleton\", \"development\", \"mainnet01\", and \"testnet04\". Examples You can send a request for general information to a node like this: Code example (Postman): GET http: //api. chainweb. com/info This request returns information similar to the following truncated excerpt: Code example (json): { \"nodeApiVersion\": \"0. 0\", \"nodeBlockDelay\": 30000000, \"nodeChains\": [ \"17\", \"16\", \"19\", ], \"nodeGenesisHeights\": [ [ \"17\", 852054 ], [ \"16\", 852054 ], [ \"19\", 852054 ], ], \"nodeGraphHistory\": [ [ 852054, [ [ 17, [ 1. . . [code continues] Blocks event stream Use GET http: //{baseURL}/header/updates to connect to a source of server events that emits a BlockHeader event for each new block header that is added to the chain database of the remote node. The stream can contain blocks that might later become orphaned. To address this potential issue, you should buffer events on the client side for the most recent block heights to allow for a desired confirmation depth to be reached. You should note that the server might terminate this event stream from time to time. It is up to the client to restart event streaming with a new request. Responses - 200 OK indicates a successful requests and results in a stream of BlockHeader events. Each event consists of an event property and a data property and are separated by empty lines. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. | Parameter | Type | Description | --------- | ---- | ----------- | x-peer-addr | string | Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: \"10. 36. 1. 3: 42988\". | x-server&#8209; timestamp | integer >= 0 | Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: 1618597601. | x&#8209; chainweb&#8209; node&#8209; version | string | Specifies the version of the remote Chainweb node. For example: \"2. 23\". Response schema If the request is successful, the response returns text/event-stream content with the following: | Parameter | Type | Description | | --------- | ---- | ----------- | event | string | Specifies the type of event with the event property value of \"BlockHeader\". | data | object | Specifies the data properties for the event. Examples You can send a request for block header updates from the Kadena main network like this: Code example (Postman): GET http: //api. chainweb. com/chainweb/0. 0/mainnet01/header/updates This request returns a stream of events with the BlockHeader event property and a data property: <! --! BlockHeader event stream --> If you expand the data property for an event, the event includes details similar to the folloiwng: Code example (json): { \"header\": { \"adjacents\": { \"12\": \"RUP5XpRIFJK7-xhClDzBIwRD3LCkNzhNTi4M05uPY\", \"14\": \"tzNb2bnWkGM9Qh3u4Pxna-NU2RYBYEuZE3cwu2m1k\", \"3\": \"6auRG8JDj4S4IYMF8G-d47dkwVAfX8XmOOg6isofr_M\" }, \"chainId\": 13, \"chainwebVersion\": \"mainnet01\", \"creationTime\": 1722966936274259, \"epochStart\": 1722966541117672, \"featureFlags\": 0, \"hash\": \"mb-Tn9AyDYuP5TgqaAlBu9VgR6eSZdWgKz9qtAGbrDA\", \"height\": 50. . . [code continues]",
    "source": "api/service-api/check-node-health.md",
    "title": "Check node health"
  },
  {
    "content": "Send an API request to check the status of a database backup job. Check the status of a database backup Use GET http: //{baseURL}/check-backup/{backupId} to check the status of a backup job. Path parameters | Parameter | Type | Description | --------- | ---- | ----------- | backupId (required) | string | Specifies the backup job identifier with a UNIX timestamp from the a-zA-Z0-9_- character set. For example: 1648665437000 Responses Requests to the GET http: //{baseURL}/check-backup endpoint can return the following response codes: - 200 OK indicates that a backup job with the specified identifier exists and returns its current status. - 404 Not Found indicates that there were no backup jobs matching the specified identifier. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. | Parameter | Type | Description | --------- | ---- | ----------- | x-peer-addr | string | Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: \"10. 36. 1. 3: 42988\". | x-server&#8209; timestamp | integer >= 0 | Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: 1618597601. | x&#8209; chainweb&#8209; node&#8209; version | string | Specifies the version of the remote Chainweb node. For example: \"2. 23\". Response schema The response returns text/plain content with the following information: | Parameter | Type | Description | --------- | ---- | ----------- | status | string | Specifies the status of the backup job with the specified identifier. There are three possible status messages: backup-done, backup-in-progress, and backup-failed.",
    "source": "api/service-api/check-status-backup-job.md",
    "title": "Check a database backup"
  },
  {
    "content": "Provides reference information for the chainweb-node service API block endpoints. You can use the /block/branch API endpoint to return full blocks—that is, headers and payloads—from the specified chain database in descending order starting from the leafs of branches of the blockchain. Blocks are returned in only one format, with block headers and payloads in JSON encoding. Note that this endpoint uses the POST method so you can specify lower and upper bounds for retrieving blocks in the request body. Request format Use POST http: //{baseURL}/chain/{chain}/block/branch to return blocks from branches of the block chain in descending order. A request sent to this endpoint returns blocks that are ancestors of any block specified for the upper bounds and that are not ancestors of any block specified for the lower bounds. Path parameters | Parameter | Type | Description | --------- | ---- | ----------- | chain (required) | integer >= 0 | Specifies the chain identifier of the chain you want to send the request to. Valid values are 0 to 19. For example, to get block hashes for the first chain (0), the request is GET http: //{baseURL}/chain/0/block/branch. Query parameters | Parameter | Type | Description | --------- | ---- | ----------- | limit | integer >= 0 | Specifies the maximum number of records that should be returned. The actual number of records returned might be lower than the value you specify. For example: limit=3. | next | string | Specifies the cursor value to retrieve the next page of results. You can find the value to specify in the next property returned by the previous page in a successful response. For example: \"inclusive: qgsxD1G5m8dGZ4W9nMKBotU2I10ilURkRIE3UKHlLM\". | minheight | integer >= 0 | Specifies the minimum block height for the blocks to return. For example: minheight=4471908. | maxheight | integer >= 0 | Specifies the maximum block height for the blocks to return. For example: maxheight=4953816. Request body schema Use the following parameters to specify the upper and lower bounds for the queried branches. | Parameter | Type | Description | --------- | ---- | ----------- | lower | Array of strings | Specifies the lower bound for the query. No block hashes are returned that are predecessors of any block with a hash from this array. Each block hash consists of 43 characters from the a-zA-Z0-9- character set. | upper | Array of strings | Specifies the upper bound for the query. All returned block hashes are predecessors of a block with an hash from this array. Each block hash consists of 43 characters from the a-zA-Z0-9- character set. Responses Requests to GET http: //{baseURL}/chain/{chain}/block/branch can return the following response codes: - 200 OK indicates that the request succeeded. The response body includes all of the blocks matching the criteria specified. - 400 Bad Request indicates that the branch bounds were exceeded. - 404 Not Found indicates that no blocks matching the request criteria were found or that the next or maxheight parameter wasn't valid. - 406 Not Acceptable indicates that the endpoint can't generate content in the format specified by the Accept header. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. | Parameter | Type | Description | --------- | ---- | ----------- | x-peer-addr | string | Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: \"10. 36. 1. 3: 42988\". | x-server&#8209; timestamp | integer >= 0 | Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: 1618597601. | x&#8209; chainweb&#8209; node&#8209; version | string | Specifies the version of the remote Chainweb node. For example: \"2. 23\". Successful response schema If the request is successful, the response returns application/json content with the following: | Parameter | Type | Description | --------- | ---- | ----------- | items (required) | Array of objects | Returns an array of JSON-encoded objects representing full blocks. | limit (required) | integer >= 0 | Specifies the maximum number of items in the page. This number can be smaller but never larger than the number of requested items. | next (required) | string or null | Returns a value that can be used to query the next page. You can use this value for the next parameter in a follow-up request. The format for this parameter consists of two parts. The first part of the string can be inclusive, exclusive or null. The second part is the value that calls the next page of results or null if there are no more results to query. Examples You can send a request to the Kadena main network—mainnet01—and chain 19 by calling the main network service endpoint like this: Code example (Postman): POST http: //api. chainweb. com/chainweb/0. 0/mainnet01/chain/19/block/branch? limit=1 In this example, the request returns the ancestors for a specific upper bound: Code example (json): { \"lower\": [ ], \"upper\": [\"y76dr78dPJlFDMPzCc-aEz97iRyimv5Ij3psdVlC64c\"] } This request returns a whole block similar to the following excerpt: Code example (json): { \"limit\": 1, \"items\": [ { \"header\": { \"nonce\": \"0\", \"creationTime\": 1572393660000000, \"parent\": \"az5Y9U7gziz1nghnTMCR9pqZHApM5bqoqoU-PhWdrCU\", \"adjacents\": { \"18\": \"uNzV6l3JEfRSbG8xI-W7dexgUR3RRbdpDzdfrJKyaZ8\", \"4\": \"Ou6kxMXpuwpm9uiIVhiEFHSbTdhanjHyiEh2G0EZVw\", \"10\": \"QGPuG9FMAW15eqGOWSGcDna32l8oBnYFmvVBwHFNrg4\" }, . . . [code continues]",
    "source": "api/service-api/get-block-branch.md",
    "title": "Retrieve full branch blocks"
  },
  {
    "content": "Provides reference information for the chainweb-node block hash endpoints. Block hash endpoints return block hashes from the specified chain database. Generally, block hashes are returned in ascending order and include hashes from orphaned blocks. If you only want to query for blocks that are included in the canonical version of the chain, you can use this /hash/branch endpoint. The /hash/branch endpoint returns blocks in descending order starting from the leafs of branches of the block chain. Note that this endpoint uses the POST method so you can specify lower and upper bounds for retrieving blocks in the request body. Request format Use POST http: //{baseURL}/chain/{chain}/hash/branch to get block hashes from the branches of the block chain in descending order. This call only returns blocks that are ancestors of the same block in the set of upper bounds and that are not ancestors of any block in the set of lower bounds. Path parameters | Parameter | Type | Description | --------- | ---- | ----------- | chain (required) | integer >= 0 | Specifies the chain identifier of the chain you want to send the request to. Valid values are 0 to 19. For example, to get block hashes for the first chain (0), the request is POST http: //{baseURL}/chain/0/hash/branch. Query parameters | Parameter | Type | Description | --------- | ---- | ----------- | limit | integer >= 0 | Specifies the maximum number of records that should be returned. The actual number of records returned might be lower than the limit you set. For example: limit=3. | next | string | Specifies the cursor value to retrieve the next page of results. You can find the value to specify in the next property returned by the previous page in a successful response. For example: \"inclusive: qgsxD1G5m8dGZ4W9nMKBotU2I10ilURkRIE3UKHlLM\". | minheight | integer >= 0 | Specifies the minimum block height for the returned hashes. For example: minheight=4471908. | maxheight | integer >= 0 | Specifies the maximum block height for the returned hashes. For example: maxheight=4953816. Request body schema Use the following parameters to specify the upper and lower bounds for the queried branches. | Parameter | Type | Description | --------- | ---- | ----------- | lower | Array of strings | Specifies the lower bound for the query. No block hashes are returned that are predecessors of any block with a hash from this array. Each block hash consists of 43 characters from the a-zA-Z0-9- character set. | upper | Array of strings | Specifies the upper bound for the query. All returned block hashes are predecessors of a block with an hash from this array. Each block hash consists of 43 characters from the a-zA-Z0-9- character set. The following examples illustrate setting lower and upper bounds for the query parameters. To return all of the ancestors of the \"w5pM1MLEpJcBdMS5KT3tcxEj86hCO4Qv-q-xMysGmOw\" block: Code example (json): { \"upper\": [\"w5pM1MLEpJcBdMS5KT3tcxEj86hCO4Qv-q-xMysGmOw\"] } To return all of the ancestors of the \"QxGCAz5AY1Y41nh1yWtgqhKhZ9pPiPRagFdIKNqBH74\" block that are not ancestors of the \"RClyuyZAacwvPpmLXKbTwrIRXWeUSjiNhJVP2esH8KM\" block, you might specify bounds similar to the following: Code example (json): { \"lower\": [ \"RClyuyZAacwvPpmLXKbTwrIRXWeUSjiNhJVP2esH8KM\" ], \"upper\": [ \"QxGCAz5AY1Y41nh1yWtgqhKhZ9pPiPRagFdIKNqBH74\" ] } Responses Requests to POST http: //{baseURL}/chain/{chain}/hash/branch return the following response codes: - 200 OK indicates that the request succeeded and returns the requested block hashes. All block hashes that match the specified criteria are returned from the chain database, including hashes for orphaned blocks. - 404 Not Found indicates that the requested block hashes could not be found. Response headers The response header parameters are the same for all successful and unsuccessful Chainweb node requests. | Parameter | Type | Description | --------- | ---- | ----------- | x-peer-addr | string | Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: \"10. 36. 1. 3: 42988\". | x-server&#8209; timestamp | integer >= 0 | Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: 1618597601. | x&#8209; chainweb&#8209; node&#8209; version | string | Specifies the version of the remote Chainweb node. For example: \"2. 23\". Successful response schema If the request is successful, the response returns application/json content with the following: | Parameter | Type | Description | --------- | ---- | ----------- | items (required) | Array of strings | Returns an array of block hashes. Each block hash consists of 43 characters from the [a-zA-Z0-9-] character set. | limit (required) | integer >= 0 | Specifies the maximum number of items in the page. This number can be smaller but never larger than the number of requested items. | next (required) | string or null | Returns a value that can be used to query the next page. You can use this values for the next parameter in a follow-up request. The format for this parameter consists of two parts. The first part of the string can be inclusive, exclusive or null. The second part is the value that calls the next page of results or null if there are no more results to query. Not found response schema If there are no results matching the request criteria, the response returns the following: Parameter | Type | Description key | string | Specifies the base64Url-encoded block hash without padding. The block hash consists of 43 characters from the [a-zA-Z0-9-] character set. reason | string | Provides a placeholder for specifying the reason that no block hashes were found. Examples You can send a request to the Kadena main network—mainnet01—and chain 0 by calling the main network service endpoint: Code example (Postman): POST http: //api. chainweb. com/chainweb/0. 0/mainnet01/chain/0/hash/branch The request body for this query is: Code example (json): { \"lower\": [\"RClyuyZAacwvPpmLXKbTwrIRXWeUSjiNhJVP2esH8KM\"], \"upper\": [\"QxGCAz5AY1Y41nh1yWtgqhKhZ9pPiPRagFdIKNqBH74\"] } This request returns one item in the response body: Code example (json): { \"limit\": 1, \"items\": [ \"QxGCAz5AY1Y41nh1yWtgqhKhZ9pPiPRagFdIKNqBH74\" ], \"next\": null } You can send a request to the Kadena test network—testnet04—and chain 18 by calling the testnet service endpoint like this: Code example (Postman): POST http: //api. testnet. chainweb. com/chainweb/0. 0/testnet04/chain/18/hash/branch The request body for this query is: Code example (json): { \"lower\": [\"egzXuuj9EWIadpIQipb59N1DFPgDE6Gdlo2LmReGAfI\"], \"upper\": [\"w5pM1MLEpJcBdMS5KT3tcxEj86hCO4Qv-q-xMysGmOw\"] } This request returns four items in the response body: Code example (json): { \"limit\": 4, \"items\": [ \"w5pM1MLEpJcBdMS5KT3tcxEj86hCO4Qv-q-xMysGmOw\", \"LfjtkAgRa6jt6al0VACE4Gylu8McHf34233qZjqETuo\", \"DRKyE0T42ajfqC7kmBEn07pTMZbshFBWGzWT27cqwg\", \"5o4nHHmcDnfmXDnp9XqRU5qWcpaKGdfECMZB0CQ8s\" ], \"next\": null } If you specify an upper or lower bound doesn't exist on the chain where you're sending the request, the response body indicates the reason no results matching the request criteria were found. For example: Code example (json): { \"key\": \"w5pM1MLEpJcBdMS5KT3tcxEj86hCO4Qv-q-xMysGmOw\", \"reason\": \"key not found\" }",
    "source": "api/service-api/get-block-hash-branch.md",
    "title": "Get branch block hashes"
  },
  {
    "content": "Provides reference information for the chainweb-node block hash endpoints. Block hash endpoints return block hashes from the specified chain database. Generally, block hashes are returned in ascending order and include hashes from orphaned blocks. If you only want to query for blocks that are included in the canonical version of the chain, you can use the /hash/branch endpoint. The /hash/branch endpoint returns blocks in descending order starting from the leafs of branches of the block chain. Request format Use GET http: //{baseURL}/chain/{chain}/hash to get block hashes for the specified chain. Path parameters | Parameter | Type | Description | --------- | ---- | ----------- | chain (required) | integer >= 0 | Specifies the chain identifier of the chain you want to send the request to. Valid values are 0 to 19. For example, to get block hashes for the first chain (0), the request is GET http: //{baseURL}/chain/0/hash. Query parameters | Parameter | Type | Description | --------- | ---- | ----------- | limit | integer >= 0 | Specifies the maximum number of records that should be returned. The actual number of records returned might be lower than the value you specify. For example: limit=3. | next | string | Specifies the cursor value to retrieve the next page of results. You can find the value to specify in the next property returned by the previous page in a successful response. For example: \"inclusive: qgsxD1G5m8dGZ4W9nMKBotU2I10ilURkRIE3UKHlLM\". | minheight | integer >= 0 | Specifies the minimum block height for the returned hashes. For example: minheight=4471908. | maxheight | integer >= 0 | Specifies the maximum block height for the returned hashes. For example: maxheight=4953816. Responses Requests to GET http: //{baseURL}/chain/{chain}/hash return the following response codes: - 200 OK indicates that the request succeeded and the response body includes the collection of block hashes matching the request criteria in ascending order. All block hashes that match the specified criteria are returned from the chain database, including hashes for orphaned blocks. - 404 Not Found indicates that the request failed to find any block hashes matching the request criteria. For example, if you specify a Chainweb node version or chain identifier that doesn't exist, you'll see this response code. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. | Parameter | Type | Description | --------- | ---- | ----------- | x-peer-addr | string | Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: \"10. 36. 1. 3: 42988\". | x-server&#8209; timestamp | integer >= 0 | Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: 1618597601. | x&#8209; chainweb&#8209; node&#8209; version | string | Specifies the version of the remote Chainweb node. For example: \"2. 23\". Successful response schema If the request is successful, the response returns application/json content with the following information: | Parameter | Type | Description | --------- | ---- | ----------- | items (required) | Array of strings | Lists the block hashes matching the request criteria. Each block hash string consists of 43 characters from the [a-zA-Z0-9-] character set. | limit (required) | integer >= 0 | Specifies the maximum number of items to include in the page of results. This number can be smaller but never larger than the number of requested items. | next (required) | string or null | Returns a value that can be used to query the next page. You can use this value for the next parameter in a follow-up request. The format for this parameter consists of two parts. The first part of the string can be inclusive, exclusive or null. The second part is the value that calls the next page of results or null if there are no more results to query. Examples You can send a request to the Kadena main network and chain 19 by calling the service endpoint like this: Code example (Postman): GET http: //api. chainweb. com/chainweb/0. 0/mainnet01/chain/19/hash? limit=3 This request returns a maximum of three items in the response body like this: Code example (json): { \"limit\": 3, \"items\": [ \"y76dr78dPJlFDMPzCc-aEz97iRyimv5Ij3psdVlC64c\", \"1ETD2LKFgmJ92-q1fqAJY2eZerhhZA2kLxM1BC5hKE\", \"1B3UJuYNx0LHqtgbJsSpJl5h-77pMfvjBBy85e2K8w\" ], \"next\": \"inclusive: qgsxD1G5m8dGZ4W9nMKBotU2I10ilURkRIE3UKHlLM\" } To send a follow-up request to get block hashes for the next three blocks, you can add the next parameter to the request. In this example, the follow-up request looks like this: Code example (Postman): GET http: //api. chainweb. com/chainweb/0. 0/mainnet01/chain/19/hash? limit=3&next=inclusive: qgsxD1G5m8dGZ4W9nMKBotU2I10ilURkRIE3UKHlLM The follow-up request returns three more hashes and a new next value: Code example (json): { \"limit\": 3, \"items\": [ \"qgsxD1G5m8dGZ4W9nMKBotU2I10ilURkRIE3UKHlLM\", \"nN3fl9FaF2sD3zJSa1fY2rtoJMw33bFfzxK-25qKtT4\", \"2lqldW8MEeOzvApgJnmSIUaUT4CihoL9OMpdYbBAmg\" ], \"next\": \"inclusive: 01Dhx9c9mfbP7t0k0CztGi8IrE81u4ljd2NQ0UvXSZM\" }",
    "source": "api/service-api/get-block-hash.md",
    "title": "Get block hashes"
  },
  {
    "content": "Provides reference information for the chainweb-node block header endpoints. You can request only blocks that are included in the canonical branch of the chain by using the /header/branch endpoint. The /header/branch endpoint returns blocks in descending order starting from the leafs of branches of the blockchain. Block headers are returned in three different formats depending on the content type specified in the Accept header of the request: - application/json returns block headers in as a base64Url-encoded strings without padding. - application/json; blockheader-encoding=object returns block headers as JSON-encoded objects. - application/octet-stream returns block headers as binary data if supported by the endpoint. Note that this endpoint uses the POST method so you can specify lower and upper bounds for retrieving blocks in the request body. Request format Use POST http: //{baseURL}/chain/{chain}/header/branch to return a page of block headers from branches of the block chain in descending order. Only blocks that are ancestors of the same block in the set of upper bounds and are not ancestors of any block in the set of lower bounds are returned. Path parameters | Parameter | Type | Description | --------- | ---- | ----------- | chain (required) | integer >= 0 | Specifies the chain identifier of the chain you want to send the request to. Valid values are 0 to 19. For example, to get block headers for the first chain (0), the request is POST http: //{baseURL}/chain/0/header/branch. Query parameters | Parameter | Type | Description | --------- | ---- | ----------- | limit | integer >= 0 | Specifies the maximum number of records that should be returned. The actual number of records might be lower. For example: limit=3. | next | string | Specifies the cursor to retrieve the next page of results. This value can be found as the value of the next property of the previous page. For example: \"inclusive: qgsxD1G5m8dGZ4W9nMKBotU2I10ilURkRIE3UKHlLM\". | minheight | integer >= 0 | Specifies the minimum block height for the returned headers. For example: minheight=4471908. | maxheight | integer >= 0 | Specifies the maximum block height for the returned headers. For example: maxheight=4953816. Request schema These parameters specify the upper and lower bounds for the queried branches. Parameter | Type | Description lower | Array of strings | Specifies the lower bound block header hash for the query. No block headers are returned that are predecessors of any block with a hash from this array. The block hash consists of 43 characters from the a-zA-Z0-9- character set. upper | Array of strings | Specifies the upper bound block header for the query. All block hashes returned are predecessors of a block with a hash from this array. The block hash consists of 43 characters from the a-zA-Z0-9- character set. The following examples illustrate the results to expect based on setting the lower and upper bound parameters. To return all ancestors of one block: Code example (json): { \"lower\": [], \"upper\": [ \"QxGCAz5AY1Y41nh1yWtgqhKhZ9pPiPRagFdIKNqBH74\" ] } For example, to return all of the ancestors of a block that are not ancestors of another block, you might specify bounds similar to the following: Code example (json): { \"lower\": [ \"RClyuyZAacwvPpmLXKbTwrIRXWeUSjiNhJVP2esH8KM\" ], \"upper\": [ \"QxGCAz5AY1Y41nh1yWtgqhKhZ9pPiPRagFdIKNqBH74\" ] } Responses Requests to http: //{baseURL}/chain/{chain}/header/branch return the following response codes: - 200 OK indicates that the request succeeded and returns the block headers matching the specified criteria as base64Url-encoded or JSON-encoded. - 400 Bad Request indicates that the branch bounds were exceeded. - 404 Not Found indicates that the block header indicated by a required parameter was not found. - 406 Not Acceptable indicates that the value of the Accept header is not supported. Response headers The response header parameters are the same for all successful and unsuccessful Chainweb node requests. | Parameter | Type | Description | --------- | ---- | ----------- | x-peer-addr | string | Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: \"10. 36. 1. 3: 42988\". | x-server&#8209; timestamp | integer >= 0 | Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: 1618597601. | x&#8209; chainweb&#8209; node&#8209; version | string | Specifies the version of the remote Chainweb node. For example: \"2. 23\". Successful response schemas The format of the information returned in the response depends on the content type specified in the Accept header of the request. | Parameter | Type | Description | --------- | ---- | ----------- | items (required) | Array of block headers | Returns an array of block headers as base64Url-encoded strings (application/json), JSON-encoded objects (application/json; blockheader-encoding=object), or a binary data stream (application/octet-stream, if supported) | limit (required) | integer >= 0 | Specifies the number of items in the page. This number can be smaller but never be larger than the number of requested items. | next (required) | string or null | Returns a cursor that can be used in a follow up request to query the next page. It should be used literally as the value for the next parameter in the follow-up request. It can be specified as inclusive or exclusive. Examples You can send a request to the Kadena main network—mainnet01—and chain 4 with a limit of three items per request and a minimum block height of 4953300 by calling the service endpoint like this: Code example (Postman): POST http: //api. chainweb. com/chainweb/0. 0/mainnet01/chain/4/header/branch? limit=3&minheight=4953300 With the Accept header set to application/json, this request returns the block headers as a base64Url-encoded strings without padding: Code example (json): { \"limit\": 3, \"items\": [ \"AAAAAAAAAACHrEs-Th0GAIPjfG2bsp6NK5D8iWUoRUM1OQ3p9q3stapX5Zybos80AwAJAAAAGXv0fxVXgDQTtRTxMjWfr6JXXrSscoaCaxEDPC93QIgOAAAAVosxlCQP8q0cPi3zdyD099Untb69bnIgIFlAioj9ITAAAAYlpdztdOQ-ChRklldcC2oHbZlAMIiYAGRgzTZBXvRgaKSm6dcl7l1vKo1o0wOE5aEG0l4ulUQ1YVAAAAAAAAAG1aryT2lPfDS6jwjJmgctr-u158xYunNRIujS2Y2VbyBAAAABWoQdQYrsb9AUkBAAAAAAAAAAAAAAAAAAAAAAAAAAAA2JZLAAAAAAAFAAAAcRDzfU0dBgDGFmKDSkZ45LbBZMajR8v1m3Zww07plf9jBYzEE8ia82PvnTt5I4z\", \"AAAAAAAAAAAlIk6Th0GAK. . . [code continues] With the Accept header set to application/json; blockheader-encoding=object, the request returns the block headers as JSON-encoded objects like this: Code example (json): { \"limit\": 3, \"items\": [ { \"nonce\": \"16462985723698616006\", \"creationTime\": 1721071750065287, \"parent\": \"g-N8bZuyno0rkPyJZShFQzU5Den2rey1qlflnJuizzQ\", \"adjacents\": { \"19\": \"YlpdztdOQ-ChRklldcC2oHbZlAMIiYAGRgzTZBXvRgY\", \"14\": \"VosxlCQP8q0cPi3zdyD_099Untb69bnIgIFlAioj9I\", \"9\": \"GXv0fxVXgDQTtRTxMjWfr6JXXrSscoaCaxEDPC93QIg\" }, \"target\": \"ikpunXJe5dbyqNaNMDhOWhBtJeL. . . [code continues] If you set the Accept header to application/octet-stream and the content type is supported, the request returns a binary representation of the block header. If the content type isn't support, the reguest fails with a 406 Not Acceptable response code.",
    "source": "api/service-api/get-block-header-branch.md",
    "title": "Get branch block headers"
  },
  {
    "content": "Provides reference information for the chainweb-node block header endpoints. You can request a specific block header by using the block header hash. Request format Use GET http: //{baseURL}/chain/{chain}/header/{blockHash} to get a block header by using its hash. Path parameters | Parameter | Type | Description | --------- | ---- | ----------- | chain (required) | integer >= 0 | Specifies the chain identifier of the chain you want to send the request to. Valid values are 0 to 19. For example, to get block headers for the first chain (0), the request is GET http: //{baseURL}/chain/0/header/{blockHash}. | blockHash (required) | string | Specifies the block hash of a block. The block hash consists of 43 characters from the a-zA-Z0-9- character set. For example: k0an0qEORusqQg9ZjKrxa-0Bo0-hQVYLXqWi5LHxg3k. Responses Requests to http: //{baseURL}/chain/{chain}/header/{blockHash} return the following response codes: - 200 OK indicates that the request succeeded and returns the block header matching the specified hash. - 404 Not Found indicates that no block header with the specified block hash was found. - 406 Not Acceptable indicates the endpoint can't generate content in the format specified by the Accept header. Response headers The response header parameters are the same for all successful and unsuccessful Chainweb node requests. | Parameter | Type | Description | --------- | ---- | ----------- | x-peer-addr | string | Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: \"10. 36. 1. 3: 42988\". | x-server&#8209; timestamp | integer >= 0 | Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: 1618597601. | x&#8209; chainweb&#8209; node&#8209; version | string | Specifies the version of the remote Chainweb node. For example: \"2. 23\". Successful response schemas The format of the information returned in the response depends on the content type specified in the Accept header of the request. Not found response schema If you specified application/json in the Accept header of the request and there are no results matching the request criteria, the response returns the following: Parameter | Type | Description key | string | Specifies the base64Url-encoded block hash (without padding). The block hash consists of 43 characters from the a-zA-Z0-9- character set. reason | string | Provides a placeholder for specifying the reason that no block headers were found. Examples You can send a request to the Kadena main network—mainnet01—and chain 4 by calling the service endpoint like this: Code example (Postman): GET http: //api. chainweb. com/chainweb/0. 0/mainnet01/chain/4/header/tsFkxqNHyWbdnDDTumV2MFjMQTyJrzb8--dO3kjjM With the Accept header set to application/json, this request returns the block header as a base64Url-encoded string without padding: Code example (text): \"AAAAAAAAAACHrEs-Th0GAIPjfG2bsp6NK5D8iWUoRUM1OQ3p9q3stapX5Zybos80AwAJAAAAGXv0fxVXgDQTtRTxMjWfr6JXXrSscoaCaxEDPC93QIgOAAAAVosxlCQP8q0cPi3zdyD099Untb69bnIgIFlAioj9ITAAAAYlpdztdOQ-ChRklldcC2oHbZlAMIiYAGRgzTZBXvRgaKSm6dcl7l1vKo1o0wOE5aEG0l4ulUQ1YVAAAAAAAAAG1aryT2lPfDS6jwjJmgctr-u158xYunNRIujS2Y2VbyBAAAABWoQdQYrsb9AUkBAAAAAAAAAAAAAAAAAAAAAAAAAAAA2JZLAAAAAAAFAAAAcRDzfU0dBgDGFmKDSkZ45LbBZMajR8v1m3Zww07plf9jBYzEE8ia82PvnTt5I4z\" With the Accept header set to application/json; blockheader-encoding=object, the request returns the block header as a JSON-encoded object like this: Code example (json): { \"nonce\": \"16462985723698616006\", \"creationTime\": 1721071750065287, \"parent\": \"g-N8bZuyno0rkPyJZShFQzU5Den2rey1qlflnJuizzQ\", \"adjacents\": { \"19\": \"YlpdztdOQ-ChRklldcC2oHbZlAMIiYAGRgzTZBXvRgY\", \"14\": \"VosxlCQP8q0cPi3zdyD099Untb69bnIgIFlAioj9I\", \"9\": \"GXv0fxVXgDQTtRTxMjWfr6JXXrSscoaCaxEDPC93QIg\" }, \"target\": \"ikpunXJe5dbyqNaNMDhOWhBtJeLpVENWFQAAAAAAAAA\", \"payloadHash\": \"bVqvJPaU98NLqPCMmaBy2v67XnzFi6c1Ei6NLZjZVvI\", \"chainId\": 4, \"weigh. . . [code continues] If you set the Accept header to application/octet-stream and the content type is supported, the request returns a binary representation of the block header. If the content type isn't support, the reguest fails with a 406 Not Acceptable response code. If there are no results matching the request criter, the response body indicates the reason no results matching the request criteria were found. For example: Code example (json): { \"key\": \"WjPVpdhdS9NFU1rPHVDiLI74a-wKs1g4CZSN6z5gHY\", \"reason\": \"key not found\" } Get block header branches Use POST http: //{baseURL}/chain/{chain}/header/branch to return a page of block headers from branches of the block chain in descending order. Only blocks that are ancestors of the same block in the set of upper bounds and are not ancestors of any block in the set of lower bounds are returned. Path parameters | Parameter | Type | Description | --------- | ---- | ----------- | chain (required) | integer >= 0 | Specifies the chain identifier of the chain you want to send the request to. Valid values are 0 to 19. For example, to get block headers for the first chain (0), the request is POST http: //{baseURL}/chain/0/header/branch. Query parameters | Parameter | Type | Description | --------- | ---- | ----------- | limit | integer >= 0 | Specifies the maximum number of records that should be returned. The actual number of records might be lower. For example: limit=3. | next | string | Specifies the cursor to retrieve the next page of results. This value can be found as the value of the next property of the previous page. For example: \"inclusive: qgsxD1G5m8dGZ4W9nMKBotU2I10ilURkRIE3UKHlLM\". | minheight | integer >= 0 | Specifies the minimum block height for the returned headers. For example: minheight=4471908. | maxheight | integer >= 0 | Specifies the maximum block height for the returned headers. For example: maxheight=4953816. Request schema These parameters specify the upper and lower bounds for the queried branches. Parameter | Type | Description lower | Array of strings | Specifies the lower bound block header hash for the query. No block headers are returned that are predecessors of any block with a hash from this array. The block hash consists of 43 characters from the a-zA-Z0-9- character set. upper | Array of strings | Specifies the upper bound block header for the query. All block hashes returned are predecessors of a block with a hash from this array. The block hash consists of 43 characters from the a-zA-Z0-9- character set. The following examples illustrate the results to expect based on setting the lower and upper bound parameters. To return all ancestors of one block: Code example (json): { \"lower\": [], \"upper\": [ \"QxGCAz5AY1Y41nh1yWtgqhKhZ9pPiPRagFdIKNqBH74\" ] } For example, to return all of the ancestors of a block that are not ancestors of another block, you might specify bounds similar to the following: Code example (json): { \"lower\": [ \"RClyuyZAacwvPpmLXKbTwrIRXWeUSjiNhJVP2esH8KM\" ], \"upper\": [ \"QxGCAz5AY1Y41nh1yWtgqhKhZ9pPiPRagFdIKNqBH74\" ] } Responses Requests to http: //{baseURL}/chain/{chain}/header/branch return the following response codes: - 200 OK indicates that the request succeeded and returns the block headers matching the specified criteria as base64Url-encoded or JSON-encoded. - 400 Bad Request indicates that the branch bounds were exceeded. - 404 Not Found indicates that the block header indicated by a required parameter was not found. - 406 Not Acceptable indicates that the value of the Accept header is not supported. Response headers The response header parameters are the same for all successful and unsuccessful Chainweb node requests. | Parameter | Type | Description | --------- | ---- | ----------- | x-peer-addr | string | Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: \"10. 36. 1. 3: 42988\". | x-server&#8209; timestamp | integer >= 0 | Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: 1618597601. | x&#8209; chainweb&#8209; node&#8209; version | string | Specifies the version of the remote Chainweb node. For example: \"2. 23\". Successful response schemas The format of the information returned in the response depends on the content type specified in the Accept header of the request. | Parameter | Type | Description | --------- | ---- | ----------- | items (required) | Array of block headers | Returns an array of block headers as base64Url-encoded strings (application/json), JSON-encoded objects (application/json; blockheader-encoding=object), or a binary data stream (application/octet-stream, if supported) | limit (required) | integer >= 0 | Specifies the number of items in the page. This number can be smaller but never be larger than the number of requested items. | next (required) | string or null | Returns a cursor that can be used in a follow up request to query the next page. It should be used literally as the value for the next parameter in the follow-up request. It can be specified as inclusive or exclusive. Examples You can send a request to the Kadena main network—mainnet01—and chain 4 with a limit of three items per request and a minimum block height of 4953300 by calling the service endpoint like this: Code example (Postman): POST http: //api. chainweb. com/chainweb/0. 0/mainnet01/chain/4/header/branch? limit=3&minheight=4953300 With the Accept header set to application/json, this request returns the block headers as a base64Url-encoded strings without padding: Code example (json): { \"limit\": 3, \"items\": [ \"AAAAAAAAAACHrEs-Th0GAIPjfG2bsp6NK5D8iWUoRUM1OQ3p9q3stapX5Zybos80AwAJAAAAGXv0fxVXgDQTtRTxMjWfr6JXXrSscoaCaxEDPC93QIgOAAAAVosxlCQP8q0cPi3zdyD099Untb69bnIgIFlAioj9ITAAAAYlpdztdOQ-ChRklldcC2oHbZlAMIiYAGRgzTZBXvRgaKSm6dcl7l1vKo1o0wOE5aEG0l4ulUQ1YVAAAAAAAAAG1aryT2lPfDS6jwjJmgctr-u158xYunNRIujS2Y2VbyBAAAABWoQdQYrsb9AUkBAAAAAAAAAAAAAAAAAAAAAAAAAAAA2JZLAAAAAAAFAAAAcRDzfU0dBgDGFmKDSkZ45LbBZMajR8v1m3Zww07plf9jBYzEE8ia82PvnTt5I4z\", \"AAAAAAAAAAAlIk6Th0GAK. . . [code continues] With the Accept header set to application/json; blockheader-encoding=object, the request returns the block headers as JSON-encoded objects like this: Code example (json): { \"limit\": 3, \"items\": [ { \"nonce\": \"16462985723698616006\", \"creationTime\": 1721071750065287, \"parent\": \"g-N8bZuyno0rkPyJZShFQzU5Den2rey1qlflnJuizzQ\", \"adjacents\": { \"19\": \"YlpdztdOQ-ChRklldcC2oHbZlAMIiYAGRgzTZBXvRgY\", \"14\": \"VosxlCQP8q0cPi3zdyD_099Untb69bnIgIFlAioj9I\", \"9\": \"GXv0fxVXgDQTtRTxMjWfr6JXXrSscoaCaxEDPC93QIg\" }, \"target\": \"ikpunXJe5dbyqNaNMDhOWhBtJeL. . . [code continues] If you set the Accept header to application/octet-stream and the content type is supported, the request returns a binary representation of the block header. If the content type isn't support, the reguest fails with a 406 Not Acceptable response code.",
    "source": "api/service-api/get-block-header-by-hash.md",
    "title": "Get a block header by hash"
  },
  {
    "content": "Provides reference information for the chainweb-node block header endpoints. Block header endpoints return block headers from the specified chain database. Similar to the block service and block hash endpoints, block headers are generally returned in ascending order and include headers of orphaned blocks. If you only want to query for blocks that are included in the canonical branch of the chain, you can use the /header/branch endpoint. The /header/branch endpoint returns blocks in descending order starting from the leafs of branches of the block chain. Block headers are returned in three different formats depending on the content type specified in the Accept header of the request: - application/json returns block headers in as a base64Url-encoded strings without padding. - application/json; blockheader-encoding=object returns block headers as JSON-encoded objects. - application/octet-stream returns block headers as binary data if supported by the endpoint. Request format Use GET http: //{baseURL}/chain/{chain}/header to get block headers for the specified chain. This call returns a collection of block headers in ascending order that satisfies the query parameters. All block headers that match the query criteria are returned from the chain database, including headers for orphaned blocks. Path parameters | Parameter | Type | Description |: --------- |: ---- |: ----------- | chain (required) | integer >= 0 | Specifies the chain identifier of the chain you want to send the request to. Valid values are 0 to 19. For example, to get block headers for the first chain (0), the request is GET http: //{baseURL}/chain/0/header. Query parameters | Parameter | Type | Description | --------- | ---- | ----------- | limit | integer >= 0 | Specifies the maximum number of records that should be returned. The actual number of records returned might be lower than the limit you set. For example: limit=3. | next | string | Specifies the cursor to retrieve the next page of results. This value can be found as the value of the next property of the previous page. For example: \"inclusive: qgsxD1G5m8dGZ4W9nMKBotU2I10ilURkRIE3UKHlLM\". | minheight | integer >= 0 | Specifies the minimum block height for the returned headers. For example: minheight=4471908. | maxheight | integer >= 0 | Specifies the maximum block height for the returned headers. For example: maxheight=4953816. Responses Requests to http: //{baseURL}/chain/{chain}/header return the following response codes: - 200 OK indicates that the request succeeded and returns a collection of block headers in ascending order. All block headers that match the specified criteria are returned from the chain database, including headers for orphaned blocks. - 404 Not Found indicates that the next or maxheight parameter specifies a nonexistent block height. - 406 Not Acceptable indicates that the endpoint can't generate content in the format specified by the Accept header. Response headers The response header parameters are the same for all successful and unsuccessful Chainweb node requests. | Parameter | Type | Description | --------- | ---- | ----------- | x-peer-addr | string | Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: \"10. 36. 1. 3: 42988\". | x-server&#8209; timestamp | integer >= 0 | Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: 1618597601. | x&#8209; chainweb&#8209; node&#8209; version | string | Specifies the version of the remote Chainweb node. For example: \"2. 23\". Successful response schemas The format of the information returned in the response depends on the content type specified in the Accept header of the request. | Parameter | Type | Description | --------- | ---- | ----------- | items (required) | Array of block headers | Returns an array of block headers as base64Url-encoded strings (application/json), JSON-encoded objects (application/json; blockheader-encoding=object), or a binary data stream (application/octet-stream, if supported). | limit (required) | integer >= 0 | Specifies the number of items in the page. This number can be smaller but never be larger than the number of requested items. | next (required) | string or null | Returns a cursor that can be used in a follow up request to query the next page. It should be used literally as the value for the next parameter in the follow-up request. It can be specified as inclusive or exclusive. Not found response schema If you specified application/json in the Accept header of the request and there are no results matching the request criteria, the response returns the following: Parameter | Type | Description key | string | Specifies the base64Url-encoded block hash (without padding). The block hash consists of 43 characters from the ^a-zA-Z0-9-{43}$ character set. reason | string | Provides a placeholder for specifying the reason that no block headers were found. Examples You can send a request to the Kadena test network—testnet04—and chain 18 by calling the testnet service endpoint like this: Code example (Postman): GET http: //api. testnet. chainweb. com/chainweb/0. 0/testnet04/chain/18/header? limit=5 With the Accept header set to application/json, this request returns five items in the response body and each item is a base64Url-encoded string like this: Code example (json): { \"limit\": 5, \"items\": [ \"AAAAAAAAAAAIfWWp5I0FACxINuh5jyNOJ9Ty5BpWjH7nOcJNC4ascVq1RHEaS5T1AwADAAAArvcGOcdozdWaDSgaRFcfK1n5v41BFIHF4Ji0RCGs4RAAAAb5qGjOICdYykrSpEbBSgAQDqJFEliNDBN-Bp9eyZw5kTAAAAdJruo-NqQvbBAP-sMWPuZNC3ehk2BIMawncfRFFdXc1kiSWlbrG6NI-tfeDKFcidHE5LokOORb8ZsbAAAAAB1PmYXX7EAok638Y7W5K-TB5o6LpDreiDagdr7mIhd4EgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPBMFAAAAAAAHAAAACH1lqeSNBQAAAAAAAAAAAFbA3wN38oaSnT0filswQEZoeYbbgS50Hu2V3CyKYUms\", \"AAAAAAAAAACnVe9fhKsFAF. . . [code continues] With the Accept header set to application/json; blockheader-encoding=object, each item in the response body is a JSON-encoded object like this: Code example (json): { \"limit\": 1, \"items\": [ { \"nonce\": \"0\", \"creationTime\": 1563388117613832, \"parent\": \"LEg26HmPI04n1PLkGlaMfuc5wk0LhqxxWrVEcRpLlPU\", \"adjacents\": { \"17\": \"b5qGjOICdYykrSpEbBSgAQDqJFEliNDBN-Bp9eyZw5k\", \"19\": \"dJruo-NqQvbBAP-sMWPuZNC3ehk2BIMawncfRFFdXc\", \"3\": \"rvcGOcdozdWaDSgaRFcfK1n5v41BFIHF4Ji0RCGs4\" }, \"target\": \"NZIklpW6xujSPrX3gyhXInfxxOS6JDjkWGbGwAAAAA\", . . . [code continues] If there are no results matching the request criteria, the response body indicates the reason no results matching the request criteria were found. For example: Code example (json): { \"key\": \"QxGCAz5AY1Y41nh1yWtgqhKhZ9pPiPRagFdIKNqBH7\", \"reason\": \"key not found\" } Get block header by hash Use GET http: //{baseURL}/chain/{chain}/header/{blockHash} to get a block header by using its hash. Path parameters | Parameter | Type | Description | --------- | ---- | ----------- | chain (required) | integer >= 0 | Specifies the chain identifier of the chain you want to send the request to. Valid values are 0 to 19. For example, to get block headers for the first chain (0), the request is GET http: //{baseURL}/chain/0/header/{blockHash}. | blockHash (required) | string | Specifies the block hash of a block. The block hash consists of 43 characters from the a-zA-Z0-9- character set. For example: k0an0qEORusqQg9ZjKrxa-0Bo0-hQVYLXqWi5LHxg3k. Responses Requests to http: //{baseURL}/chain/{chain}/header/{blockHash} return the following response codes: - 200 OK indicates that the request succeeded and returns the block header matching the specified hash. - 404 Not Found indicates that no block header with the specified block hash was found. - 406 Not Acceptable indicates the endpoint can't generate content in the format specified by the Accept header. Response headers The response header parameters are the same for all successful and unsuccessful Chainweb node requests. | Parameter | Type | Description | --------- | ---- | ----------- | x-peer-addr | string | Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: \"10. 36. 1. 3: 42988\". | x-server&#8209; timestamp | integer >= 0 | Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: 1618597601. | x&#8209; chainweb&#8209; node&#8209; version | string | Specifies the version of the remote Chainweb node. For example: \"2. 23\". Successful response schemas The format of the information returned in the response depends on the content type specified in the Accept header of the request. Not found response schema If you specified application/json in the Accept header of the request and there are no results matching the request criteria, the response returns the following: Parameter | Type | Description key | string | Specifies the base64Url-encoded block hash (without padding). The block hash consists of 43 characters from the a-zA-Z0-9- character set. reason | string | Provides a placeholder for specifying the reason that no block headers were found. Examples You can send a request to the Kadena main network—mainnet01—and chain 4 by calling the service endpoint like this: Code example (Postman): GET http: //api. chainweb. com/chainweb/0. 0/mainnet01/chain/4/header/tsFkxqNHyWbdnDDTumV2MFjMQTyJrzb8--dO3kjjM With the Accept header set to application/json, this request returns the block header as a base64Url-encoded string without padding: Code example (text): \"AAAAAAAAAACHrEs-Th0GAIPjfG2bsp6NK5D8iWUoRUM1OQ3p9q3stapX5Zybos80AwAJAAAAGXv0fxVXgDQTtRTxMjWfr6JXXrSscoaCaxEDPC93QIgOAAAAVosxlCQP8q0cPi3zdyD099Untb69bnIgIFlAioj9ITAAAAYlpdztdOQ-ChRklldcC2oHbZlAMIiYAGRgzTZBXvRgaKSm6dcl7l1vKo1o0wOE5aEG0l4ulUQ1YVAAAAAAAAAG1aryT2lPfDS6jwjJmgctr-u158xYunNRIujS2Y2VbyBAAAABWoQdQYrsb9AUkBAAAAAAAAAAAAAAAAAAAAAAAAAAAA2JZLAAAAAAAFAAAAcRDzfU0dBgDGFmKDSkZ45LbBZMajR8v1m3Zww07plf9jBYzEE8ia82PvnTt5I4z\" With the Accept header set to application/json; blockheader-encoding=object, the request returns the block header as a JSON-encoded object like this: Code example (json): { \"nonce\": \"16462985723698616006\", \"creationTime\": 1721071750065287, \"parent\": \"g-N8bZuyno0rkPyJZShFQzU5Den2rey1qlflnJuizzQ\", \"adjacents\": { \"19\": \"YlpdztdOQ-ChRklldcC2oHbZlAMIiYAGRgzTZBXvRgY\", \"14\": \"VosxlCQP8q0cPi3zdyD099Untb69bnIgIFlAioj9I\", \"9\": \"GXv0fxVXgDQTtRTxMjWfr6JXXrSscoaCaxEDPC93QIg\" }, \"target\": \"ikpunXJe5dbyqNaNMDhOWhBtJeLpVENWFQAAAAAAAAA\", \"payloadHash\": \"bVqvJPaU98NLqPCMmaBy2v67XnzFi6c1Ei6NLZjZVvI\", \"chainId\": 4, \"weigh. . . [code continues] If you set the Accept header to application/octet-stream and the content type is supported, the request returns a binary representation of the block header. If the content type isn't support, the reguest fails with a 406 Not Acceptable response code. If there are no results matching the request criter, the response body indicates the reason no results matching the request criteria were found. For example: Code example (json): { \"key\": \"WjPVpdhdS9NFU1rPHVDiLI74a-wKs1g4CZSN6z5gHY\", \"reason\": \"key not found\" } Get block header branches Use POST http: //{baseURL}/chain/{chain}/header/branch to return a page of block headers from branches of the block chain in descending order. Only blocks that are ancestors of the same block in the set of upper bounds and are not ancestors of any block in the set of lower bounds are returned. Path parameters | Parameter | Type | Description | --------- | ---- | ----------- | chain (required) | integer >= 0 | Specifies the chain identifier of the chain you want to send the request to. Valid values are 0 to 19. For example, to get block headers for the first chain (0), the request is POST http: //{baseURL}/chain/0/header/branch. Query parameters | Parameter | Type | Description | --------- | ---- | ----------- | limit | integer >= 0 | Specifies the maximum number of records that should be returned. The actual number of records might be lower. For example: limit=3. | next | string | Specifies the cursor to retrieve the next page of results. This value can be found as the value of the next property of the previous page. For example: \"inclusive: qgsxD1G5m8dGZ4W9nMKBotU2I10ilURkRIE3UKHlLM\". | minheight | integer >= 0 | Specifies the minimum block height for the returned headers. For example: minheight=4471908. | maxheight | integer >= 0 | Specifies the maximum block height for the returned headers. For example: maxheight=4953816. Request schema These parameters specify the upper and lower bounds for the queried branches. Parameter | Type | Description lower | Array of strings | Specifies the lower bound block header hash for the query. No block headers are returned that are predecessors of any block with a hash from this array. The block hash consists of 43 characters from the a-zA-Z0-9- character set. upper | Array of strings | Specifies the upper bound block header for the query. All block hashes returned are predecessors of a block with a hash from this array. The block hash consists of 43 characters from the a-zA-Z0-9- character set. The following examples illustrate the results to expect based on setting the lower and upper bound parameters. To return all ancestors of one block: Code example (json): { \"lower\": [], \"upper\": [ \"QxGCAz5AY1Y41nh1yWtgqhKhZ9pPiPRagFdIKNqBH74\" ] } For example, to return all of the ancestors of a block that are not ancestors of another block, you might specify bounds similar to the following: Code example (json): { \"lower\": [ \"RClyuyZAacwvPpmLXKbTwrIRXWeUSjiNhJVP2esH8KM\" ], \"upper\": [ \"QxGCAz5AY1Y41nh1yWtgqhKhZ9pPiPRagFdIKNqBH74\" ] } Responses Requests to http: //{baseURL}/chain/{chain}/header/branch return the following response codes: - 200 OK indicates that the request succeeded and returns the block headers matching the specified criteria as base64Url-encoded or JSON-encoded. - 400 Bad Request indicates that the branch bounds were exceeded. - 404 Not Found indicates that the block header indicated by a required parameter was not found. - 406 Not Acceptable indicates that the value of the Accept header is not supported. Response headers The response header parameters are the same for all successful and unsuccessful Chainweb node requests. | Parameter | Type | Description | --------- | ---- | ----------- | x-peer-addr | string | Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: \"10. 36. 1. 3: 42988\". | x-server&#8209; timestamp | integer >= 0 | Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: 1618597601. | x&#8209; chainweb&#8209; node&#8209; version | string | Specifies the version of the remote Chainweb node. For example: \"2. 23\". Successful response schemas The format of the information returned in the response depends on the content type specified in the Accept header of the request. | Parameter | Type | Description | --------- | ---- | ----------- | items (required) | Array of block headers | Returns an array of block headers as base64Url-encoded strings (application/json), JSON-encoded objects (application/json; blockheader-encoding=object), or a binary data stream (application/octet-stream, if supported) | limit (required) | integer >= 0 | Specifies the number of items in the page. This number can be smaller but never be larger than the number of requested items. | next (required) | string or null | Returns a cursor that can be used in a follow up request to query the next page. It should be used literally as the value for the next parameter in the follow-up request. It can be specified as inclusive or exclusive. Examples You can send a request to the Kadena main network—mainnet01—and chain 4 with a limit of three items per request and a minimum block height of 4953300 by calling the service endpoint like this: Code example (Postman): POST http: //api. chainweb. com/chainweb/0. 0/mainnet01/chain/4/header/branch? limit=3&minheight=4953300 With the Accept header set to application/json, this request returns the block headers as a base64Url-encoded strings without padding: Code example (json): { \"limit\": 3, \"items\": [ \"AAAAAAAAAACHrEs-Th0GAIPjfG2bsp6NK5D8iWUoRUM1OQ3p9q3stapX5Zybos80AwAJAAAAGXv0fxVXgDQTtRTxMjWfr6JXXrSscoaCaxEDPC93QIgOAAAAVosxlCQP8q0cPi3zdyD099Untb69bnIgIFlAioj9ITAAAAYlpdztdOQ-ChRklldcC2oHbZlAMIiYAGRgzTZBXvRgaKSm6dcl7l1vKo1o0wOE5aEG0l4ulUQ1YVAAAAAAAAAG1aryT2lPfDS6jwjJmgctr-u158xYunNRIujS2Y2VbyBAAAABWoQdQYrsb9AUkBAAAAAAAAAAAAAAAAAAAAAAAAAAAA2JZLAAAAAAAFAAAAcRDzfU0dBgDGFmKDSkZ45LbBZMajR8v1m3Zww07plf9jBYzEE8ia82PvnTt5I4z\", \"AAAAAAAAAAAlIk6Th0GAK. . . [code continues] With the Accept header set to application/json; blockheader-encoding=object, the request returns the block headers as JSON-encoded objects like this: Code example (json): { \"limit\": 3, \"items\": [ { \"nonce\": \"16462985723698616006\", \"creationTime\": 1721071750065287, \"parent\": \"g-N8bZuyno0rkPyJZShFQzU5Den2rey1qlflnJuizzQ\", \"adjacents\": { \"19\": \"YlpdztdOQ-ChRklldcC2oHbZlAMIiYAGRgzTZBXvRgY\", \"14\": \"VosxlCQP8q0cPi3zdyD_099Untb69bnIgIFlAioj9I\", \"9\": \"GXv0fxVXgDQTtRTxMjWfr6JXXrSscoaCaxEDPC93QIg\" }, \"target\": \"ikpunXJe5dbyqNaNMDhOWhBtJeL. . . [code continues] If you set the Accept header to application/octet-stream and the content type is supported, the request returns a binary representation of the block header. If the content type isn't support, the reguest fails with a 406 Not Acceptable response code.",
    "source": "api/service-api/get-block-header.md",
    "title": "Get block headers"
  },
  {
    "content": "Send API requests to this endpoint to monitor a node for new blocks. The block updates endpoint enables you to connect to a server-side event stream to be notified when new blocks are added to the blockchain. The stream can contain blocks that might later become orphaned. To address this potential issue, you should buffer events on the client side for the most recent block heights to allow for a desired confirmation depth to be reached. You should note that the server might terminate this event stream from time to time. It is up to the client to restart event streaming with a new request. Request format Use GET http: //{baseURL}/header/updates to connect to a source of server events that emits a BlockHeader event for each new block header that is added to the chain database of the remote node. Responses - 200 OK indicates a successful requests and results in a stream of BlockHeader events. Each event consists of an event property and a data property and are separated by empty lines. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. | Parameter | Type | Description | --------- | ---- | ----------- | x-peer-addr | string | Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: \"10. 36. 1. 3: 42988\". | x-server&#8209; timestamp | integer >= 0 | Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: 1618597601. | x&#8209; chainweb&#8209; node&#8209; version | string | Specifies the version of the remote Chainweb node. For example: \"2. 23\". Response schema If the request is successful, the response returns text/event-stream content with the following: | Parameter | Type | Description | | --------- | ---- | ----------- | event | string | Specifies the type of event with the event property value of \"BlockHeader\". | data | object | Specifies the data properties for the event. Examples You can send a request for block header updates from the Kadena main network like this: Code example (Postman): GET http: //api. chainweb. com/chainweb/0. 0/mainnet01/header/updates This request returns a stream of events with the BlockHeader event property and a data property: <! --! BlockHeader event stream --> If you expand the data property for an event, the event includes details similar to the folloiwng: Code example (json): { \"header\": { \"adjacents\": { \"12\": \"RUP5XpRIFJK7-xhClDzBIwRD3LCkNzhNTi4M05uPY\", \"14\": \"tzNb2bnWkGM9Qh3u4Pxna-NU2RYBYEuZE3cwu2m1k\", \"3\": \"6auRG8JDj4S4IYMF8G-d47dkwVAfX8XmOOg6isofr_M\" }, \"chainId\": 13, \"chainwebVersion\": \"mainnet01\", \"creationTime\": 1722966936274259, \"epochStart\": 1722966541117672, \"featureFlags\": 0, \"hash\": \"mb-Tn9AyDYuP5TgqaAlBu9VgR6eSZdWgKz9qtAGbrDA\", \"height\": 50. . . [code continues]",
    "source": "api/service-api/get-block-updates.md",
    "title": "Stream block header events"
  },
  {
    "content": "Provides reference information for the chainweb-node service API block endpoints. You can use the /block API endpoint to return full blocks—that is, headers and payloads—from the specified chain database. Generally, blocks are returned in ascending order and include orphaned blocks. If you only want to retrieve blocks that are included in the winning branch of the chain, you can call the /block/branch endpoint. Branch endpoints return blocks in descending order starting from the leafs of branches of the block chain. Blocks are returned in only one format, with block headers and payloads in JSON encoding. Request format Use GET http: //{baseURL}/chain/{chain}/block to return blocks matching the request criteria in ascending order. All blocks that match the criteria are returned from the chain database, including orphaned blocks. Path parameters | Parameter | Type | Description | --------- | ---- | ----------- | chain (required) | integer >= 0 | Specifies the chain identifier of the chain you want to send the request to. Valid values are 0 to 19. For example, to get block hashes for the first chain (0), the request is GET http: //{baseURL}/chain/0/block. Query parameters | Parameter | Type | Description | --------- | ---- | ----------- | limit | integer >= 0 | Specifies the maximum number of records that should be returned. The actual number of records returned might be lower than the value you specify. For example: limit=3. | next | string | Specifies the cursor value to retrieve the next page of results. You can find the value to specify in the next property returned by the previous page in a successful response. For example: \"inclusive: qgsxD1G5m8dGZ4W9nMKBotU2I10ilURkRIE3UKHlLM\". | minheight | integer >= 0 | Specifies the minimum block height for the blocks to return. For example: minheight=4471908. | maxheight | integer >= 0 | Specifies the maximum block height for the blocks to return. For example: maxheight=4953816. Responses Requests to GET http: //{baseURL}/chain/{chain}/block can return the following response codes: - 200 OK indicates that the request succeeded. The response body includes all of the blocks matching the criteria specified, including any orphaned blocks. - 404 Not Found indicates that no blocks matching the request criteria were found or that the next or maxheight parameter wasn't valid. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. | Parameter | Type | Description | --------- | ---- | ----------- | x-peer-addr | string | Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: \"10. 36. 1. 3: 42988\". | x-server&#8209; timestamp | integer >= 0 | Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: 1618597601. | x&#8209; chainweb&#8209; node&#8209; version | string | Specifies the version of the remote Chainweb node. For example: \"2. 23\". Successful response schema If the request is successful, the response returns application/json content with the following: | Parameter | Type | Description | --------- | ---- | ----------- | items (required) | Array of objects | Returns an array of JSON-encoded objects representing full blocks. | limit (required) | integer >= 0 | Specifies the maximum number of items in the page. This number can be smaller but never larger than the number of requested items. | next (required) | string or null | Returns a value that can be used to query the next page. You can use this value for the next parameter in a follow-up request. The format for this parameter consists of two parts. The first part of the string can be inclusive, exclusive or null. The second part is the value that calls the next page of results or null if there are no more results to query. Examples You can send a request to the Kadena main network—mainnet01—and chain 19 by calling the main network service endpoint like this: Code example (Postman): GET http: //api. chainweb. com/chainweb/0. 0/mainnet01/chain/19/block? limit=1 This request returns one whole block in the response body: Code example (json): { \"limit\": 1, \"items\": [ { \"header\": { \"nonce\": \"0\", \"creationTime\": 1572393660000000, \"parent\": \"az5Y9U7gziz1nghnTMCR9pqZHApM5bqoqoU-PhWdrCU\", \"adjacents\": { \"18\": \"uNzV6l3JEfRSbG8xI-W7dexgUR3RRbdpDzdfrJKyaZ8\", \"4\": \"Ou6kxMXpuwpm9uiIVhiEFHSbTdhanjHyiEh2G0EZVw\", \"10\": \"QGPuG9FMAW15eqGOWSGcDna32l8oBnYFmvVBwHFNrg4\" }, . . . [code continues] Get block branches Use POST http: //{baseURL}/chain/{chain}/block/branch to return blocks from branches of the block chain in descending order. A request sent to this endpoint returns blocks that are ancestors of any block specified for the upper bounds and that are not ancestors of any block specified for the lower bounds. Path parameters | Parameter | Type | Description | --------- | ---- | ----------- | chain (required) | integer >= 0 | Specifies the chain identifier of the chain you want to send the request to. Valid values are 0 to 19. For example, to get block hashes for the first chain (0), the request is GET http: //{baseURL}/chain/0/block/branch. Query parameters | Parameter | Type | Description | --------- | ---- | ----------- | limit | integer >= 0 | Specifies the maximum number of records that should be returned. The actual number of records returned might be lower than the value you specify. For example: limit=3. | next | string | Specifies the cursor value to retrieve the next page of results. You can find the value to specify in the next property returned by the previous page in a successful response. For example: \"inclusive: qgsxD1G5m8dGZ4W9nMKBotU2I10ilURkRIE3UKHlLM\". | minheight | integer >= 0 | Specifies the minimum block height for the blocks to return. For example: minheight=4471908. | maxheight | integer >= 0 | Specifies the maximum block height for the blocks to return. For example: maxheight=4953816. Request body schema Use the following parameters to specify the upper and lower bounds for the queried branches. | Parameter | Type | Description | --------- | ---- | ----------- | lower | Array of strings | Specifies the lower bound for the query. No block hashes are returned that are predecessors of any block with a hash from this array. Each block hash consists of 43 characters from the a-zA-Z0-9- character set. | upper | Array of strings | Specifies the upper bound for the query. All returned block hashes are predecessors of a block with an hash from this array. Each block hash consists of 43 characters from the a-zA-Z0-9- character set. Responses Requests to GET http: //{baseURL}/chain/{chain}/block/branch can return the following response codes: - 200 OK indicates that the request succeeded. The response body includes all of the blocks matching the criteria specified. - 400 Bad Request indicates that the branch bounds were exceeded. - 404 Not Found indicates that no blocks matching the request criteria were found or that the next or maxheight parameter wasn't valid. - 406 Not Acceptable indicates that the endpoint can't generate content in the format specified by the Accept header. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. | Parameter | Type | Description | --------- | ---- | ----------- | x-peer-addr | string | Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: \"10. 36. 1. 3: 42988\". | x-server&#8209; timestamp | integer >= 0 | Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: 1618597601. | x&#8209; chainweb&#8209; node&#8209; version | string | Specifies the version of the remote Chainweb node. For example: \"2. 23\". Successful response schema If the request is successful, the response returns application/json content with the following: | Parameter | Type | Description | --------- | ---- | ----------- | items (required) | Array of objects | Returns an array of JSON-encoded objects representing full blocks. | limit (required) | integer >= 0 | Specifies the maximum number of items in the page. This number can be smaller but never larger than the number of requested items. | next (required) | string or null | Returns a value that can be used to query the next page. You can use this value for the next parameter in a follow-up request. The format for this parameter consists of two parts. The first part of the string can be inclusive, exclusive or null. The second part is the value that calls the next page of results or null if there are no more results to query. Examples You can send a request to the Kadena main network—mainnet01—and chain 19 by calling the main network service endpoint like this: Code example (Postman): POST http: //api. chainweb. com/chainweb/0. 0/mainnet01/chain/19/block/branch? limit=1 In this example, the request returns the ancestors for a specific upper bound: Code example (json): { \"lower\": [ ], \"upper\": [\"y76dr78dPJlFDMPzCc-aEz97iRyimv5Ij3psdVlC64c\"] } This request returns a whole block similar to the following excerpt: Code example (json): { \"limit\": 1, \"items\": [ { \"header\": { \"nonce\": \"0\", \"creationTime\": 1572393660000000, \"parent\": \"az5Y9U7gziz1nghnTMCR9pqZHApM5bqoqoU-PhWdrCU\", \"adjacents\": { \"18\": \"uNzV6l3JEfRSbG8xI-W7dexgUR3RRbdpDzdfrJKyaZ8\", \"4\": \"Ou6kxMXpuwpm9uiIVhiEFHSbTdhanjHyiEh2G0EZVw\", \"10\": \"QGPuG9FMAW15eqGOWSGcDna32l8oBnYFmvVBwHFNrg4\" }, . . . [code continues]",
    "source": "api/service-api/get-block.md",
    "title": "Retrieve full blocks"
  },
  {
    "content": "Provides reference information for the chainweb-node block endpoints. The Chainweb node mining API is disabled by default. You must enable and configure the mining API in the node configuration file before you can use any of the mining endpoints. Get mining work Use GET https: //{baseURL}/mining/work to request a new block header to work on. Request body schema Use the following parameters to specify the miner information. | Parameter | Type | Description | --------- | ---- | ----------- | account | string | Specifies the miner account name. Usually, this is the same as the public key. | predicate | key predicate | Specifies the number of keys required from the enumerated values of the \"keys-all\", \"keys-any\", and \"keys-2\" key predicate options. For accounts with a single key, the predicate is usually \"keys-all\". | public&#8209; keys | Array of strings | Lists one or more miner public keys. Responses Requests to GET https: //{baseURL}/minig/work return the following response codes: - 200 OK indicates that the request was successful and the response is an encoded stream of data. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. | Parameter | Type | Description | --------- | ---- | ----------- | x-peer-addr | string | Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: \"10. 36. 1. 3: 42988\". | x-server&#8209; timestamp | integer >= 0 | Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: 1618597601. | x&#8209; chainweb&#8209; node&#8209; version | string | Specifies the version of the remote Chainweb node. For example: \"2. 23\". Successful response schema If the request is successful, the response returns application/octet-stream content with the following: | Parameter | Type | Description | --------- | ---- | ----------- | chainBytes | string binary | Identifies the chain selected by the node with four chain identifier bytes. This is informational. Generally, miners shouldn't care about the chain. | targetBytes | string binary | Specifies the proof-of-work target for the current block in 32 proof-of-work target bytes. The proof-of-work hash of a valid block must not be larger than this value. For arithmetic comparisons, the hash-target and the proof-of-work hash are interpreted as unsigned 256-bit integral number in little endian encoding. | headerBytes | string binary | Specifies the proof-of-work in 286 work header bytes. The last 8 bytes are the nonce. The creation time is encoded in bytes 44-52. Miners must not change or make any assumption about the other bytes. The creation time is encoded as little endian two complement integral number that counts SI microseconds since the start of the UNIX epoch (leap seconds are ignored). It always positive (highest bit is 0). Miners are free but not required to update the creation time. The value must be strictly larger than the creation time of the parent block and must not be in the future. Examples If you have enabled mining, you can send a request for work like this: Code example (Postman): GET https: //us-e1. chainweb. com/chainweb/0. 0/mainnet01/mining/work The request body should contain parameters similar to the following: Code example (json): { \"account\": \"miner\", \"predicate\": \"keys-all\", \"public-keys\": [ \"f880a433d6e2a13a32b6169030f56245efdd8c1b8a5027e9ce98a88e886bef27\" ] } If the request is successful, the response is an octet stream with: Work bytes - (ChainBytes4 + TargetBytes32 + HeaderBytes286) This is the minimum information required to perform proof-of-work validation. No knowledge of Chainweb internals is necessary. For information about the encoding of work bytes, see Binary encoding. Solved mining work Use POST https: //{basseURL}/mining/solved to submit a solution for a new block. Request body schema The request body should be application/octet-stream content with the solved proof-of-work work header bytes. The solved proof-of-work binary string of 286 bytes should consist of the original work received from the /mining/work endpoint with updated nonce value such that it satisfies the proof-of-work puzzle. The nonce is defined in the last 8 bytes of the work header bytes. The proof-of-work hash of a valid block is computed using blake2s. It must not be larger than the proof-of-work target for the current block. The target was received along with the work header bytes from the /mining/work endpoint. For arithmetic comparisons, the hash-target and the proof-of-work hash are interpreted as an unsigned 256-bit integral number in little endian encoding. Miners can also update the creation time. However, the value must be strictly larger than the creation time of the parent block and must not be in the future. Responses Requests to POST https: //{baseURL}/mining/solved return the following response codes: - 204 No Content indicates that the request was successful and the proof-of-work solution is valid. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. | Parameter | Type | Description | --------- | ---- | ----------- | x-peer-addr | string | Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: \"10. 36. 1. 3: 42988\". | x-server&#8209; timestamp | integer >= 0 | Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: 1618597601. | x&#8209; chainweb&#8209; node&#8209; version | string | Specifies the version of the remote Chainweb node. For example: \"2. 23\". Examples If you have enabled mining, you can submit a proof-of-work solution like this: Code example (Postman): POST https: //us-e1. chainweb. com/chainweb/0. 0/mainnet01/mining/solved The request body should be 286 bytes from the original work received from the /mining/work endpoint with updated the nonce. If the request is successful, you'll see the 204 No Content response returned. Notification of updated work Use GET https: //{baseURL}/mining/updates to receive notifications from a server when new mining work becomes available. This server-sent event stream is terminated by the server in regular intervals. It's the responsibility of the miner to periodically request a new stream. Request body The request body should be application/octet-stream content with the first four bytes—the chain identifier bytes—received from a call to the /mining/work endpoint. With this request body, Node only informs the miner of a new cut when the chain identified by the first four bytes has updated. Responses Requests to GET https: //{baseURL}/mining/updates return the following response code: - 200 OK for each update event. Each event consists of a single line with the message event: New Cut. Events are separated by empty lines. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. | Parameter | Type | Description | --------- | ---- | ----------- | x-peer-addr | string | Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: \"10. 36. 1. 3: 42988\". | x-server&#8209; timestamp | integer >= 0 | Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: 1618597601. | x&#8209; chainweb&#8209; node&#8209; version | string | Specifies the version of the remote Chainweb node. For example: \"2. 23\". Successful response schema If the request is successful, the response returns text/event-stream content with the following: | Parameter | Type | Description | --------- | ---- | ----------- | event | string | Indicates a chain update with the message event: New Cut on a single line. Examples If you have enabled mining, you can request notification for chain updates like this: Code example (Postman): GET https: //us-e1. chainweb. com/chainweb/0. 0/mainnet01/mining/updates The request body should be application/octet-stream content with the first four chain identifier bytes from a work header. The server-send events look like this: Code example (text): [ event: New Cut event: New Cut event: New Cut ]",
    "source": "api/service-api/get-mining-work.md",
    "title": "Mining endpoints"
  },
  {
    "content": "Send a health check API request to check the availability of a node. The /info endpoint enables you to request general information about the state of a node, including adjacent chains and the graph history for a node. Request format Use GET http: //{baseURL}/info to return general information about the node and the Chainweb version. Responses Requests to the GET http: //{baseURL}/info endpoint return the following response code: - 200 OK indicates that the request succeeded and the response body returns general information about the node and the chains in the network. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. | Parameter | Type | Description | --------- | ---- | ----------- | x-peer-addr | string | Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: \"10. 36. 1. 3: 42988\". | x-server&#8209; timestamp | integer >= 0 | Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: 1618597601. | x&#8209; chainweb&#8209; node&#8209; version | string | Specifies the version of the remote Chainweb node. For example: \"2. 23\". Response schema If the request is successful, the response returns application/json content with the following: Parameter | Type | Description nodeApiVersion (required) | string | Specifies the Chainweb API version information for the node. nodeBlockDelay (required) | integer >= 0 | Specifies the number of seconds to delay between blocks. nodeChains (required) | Array of strings | Specifies the chain identifiers for the chains in the network the node is part of. nodeGenesisHeights (required) | Array of integers | Specifies the block height for the first block of each chain in the network. | nodeGraphHistory (required) | Array of integers | Specifies the block height and adjacent chains for all chain graphs indexed by the height of the first block with the respective graph. Graphs are encoded as adjacency lists. nodeHistoricalChains (required) | Array of integers | Specifies the block height and adjacent chains for all chain graphs indexed by the height of the first block for the graph. Graphs are encoded as adjacency lists. nodeLatestBehaviorHeight (required) | integer | Specifies the latest block height for the node. nodeNumberOfChains (required) | integer >= 10 | Specifies the number of chains in the network the node is part of. nodePackageVersion (required) | string | Specifies the release package version for the chainweb-node software package running on the node. nodeServiceDate (required) | string | Specifies the next service date for updating the chainweb-node software package running on the node. nodeVersion (required) | string | Specifies the network identifier for the network the node is part of. The valid values are \"test-singleton\", \"development\", \"mainnet01\", and \"testnet04\". Examples You can send a request for general information to a node like this: Code example (Postman): GET http: //api. chainweb. com/info This request returns information similar to the following truncated excerpt: Code example (json): { \"nodeApiVersion\": \"0. 0\", \"nodeBlockDelay\": 30000000, \"nodeChains\": [ \"17\", \"16\", \"19\", ], \"nodeGenesisHeights\": [ [ \"17\", 852054 ], [ \"16\", 852054 ], [ \"19\", 852054 ], ], \"nodeGraphHistory\": [ [ 852054, [ [ 17, [ 1. . . [code continues]",
    "source": "api/service-api/get-node-information.md",
    "title": "Get general node information"
  },
  {
    "content": "Send an API request to start a database backup job if you have enabled the backup API for a node. job You can configure a Chainweb node to support database backup jobs. If you enable the backup API for a node, you can use the backup endpoints to a start backup job and check the status of a previously started backup job. Enable backups The /make-backup and /check-backup endpoints are only valid if you enable the backup API for a node. You can enable the backup API by starting the node with the --enable-backup-api and --backup-directory command-line options or by specifying the following configuration settings in the node configuration file: Code example (yaml): backup: api: enabled: true directory: path-to-backups-directory Select a backup directory If you enable the backup API, sending a request the POST http: //{baseURL}/make-backup endpoint always backs up the RocksDB portion of the Chainweb database. In most cases, you should locate the backup directory in the same partition as the active RocksDB database. Storing RocksDB backups in the same partition as the active RocksDB database minimizes the space required and the time it takes to complete backups initially. Over time—as the active database diverges from the backup copy—the space required will increase. If you store the backup on another partition, the backup operation takes longer and the backup copy requires as much disk space as the active RocksDB database. Back up the Pact database Chainweb nodes have two separate databases. One database—the RocksDB database—stores information about blocks and chains. A second database—the Pact Sqlite database—stores information about smart contracts and state. While backup jobs always back up the RocksDB database, backing up the Pact Sqlite database is optional. If you include the backupPact parameter in your request, the backup job backs up both databases. Backing up both databases takes much longer than only backing up the RockDB database. In addition, Pact database backups always require as much space as the active Pact database. Define a retention policy Database backup jobs don't provide any type of automatic backup retention policy. You should define your own policy and delete old backup copies, as appropriate. Request format Use POST http: //{baseURL}/make-backup to start a backup job for a Chainweb node. Starting a backup job creates a UNIX timestamp identifier for the job. You can then use the identifier to check the status of the job to determine if the job is still in progress or the backup has been completed. If a backup job is already in progress, this endpoint returns the UNIX timestamp job identifier instead of starting a new backup job. Query parameters | Parameter | Description | --------- | ----------- | backupPact | Indicates that you want to back up both the RockDB database and the Pact database. This option requires additional disk space and increases the time required to complete the backup. Responses Requests to the POST http: //{baseURL}/make-backup endpoint return the following response code: - 200 OK indicates that a backup job has been created. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. | Parameter | Type | Description | --------- | ---- | ----------- | x-peer-addr | string | Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: \"10. 36. 1. 3: 42988\". | x-server&#8209; timestamp | integer >= 0 | Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: 1618597601. | x&#8209; chainweb&#8209; node&#8209; version | string | Specifies the version of the remote Chainweb node. For example: \"2. 23\". Response schema The response returns text/plain content with the following information: | Parameter | Type | Description | --------- | ---- | ----------- | backupId | string | Specifies the backup job identifier with a UNIX timestamp from the a-zA-Z0-9- character set. Check the status of a backup job Use GET http: //{baseURL}/check-backup/{backupId} to check the status of a backup job. Path parameters | Parameter | Type | Description | --------- | ---- | ----------- | backupId (required) | string | Specifies the backup job identifier with a UNIX timestamp from the a-zA-Z0-9- character set. For example: 1648665437000 Responses Requests to the GET http: //{baseURL}/check-backup endpoint can return the following response codes: - 200 OK indicates that a backup job with the specified identifier exists and returns its current status. - 404 Not Found indicates that there were no backup jobs matching the specified identifier. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. | Parameter | Type | Description | --------- | ---- | ----------- | x-peer-addr | string | Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: \"10. 36. 1. 3: 42988\". | x-server&#8209; timestamp | integer >= 0 | Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: 1618597601. | x&#8209; chainweb&#8209; node&#8209; version | string | Specifies the version of the remote Chainweb node. For example: \"2. 23\". Response schema The response returns text/plain content with the following information: | Parameter | Type | Description | --------- | ---- | ----------- | status | string | Specifies the status of the backup job with the specified identifier. There are three possible status messages: backup-done, backup-in-progress, and backup-failed. Check node health Use GET http: //{baseURL}/health-check to check whether chainweb-node is running and responding to API requests. To check the state of consensus, you should use the GET https: //{baseURL}/cut endpoint instead of this endpoint. Responses Requests to the /health-check endpoint return the following response code: - 200 OK indicates that the node is running and responding to API requests. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. | Parameter | Type | Description | --------- | ---- | ----------- | x-peer-addr | string | Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: \"10. 36. 1. 3: 42988\". | x-server&#8209; timestamp | integer >= 0 | Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: 1618597601. | x&#8209; chainweb&#8209; node&#8209; version | string | Specifies the version of the remote Chainweb node. For example: \"2. 23\". Response schema The response returns text/plain content with the following information: | Parameter | Type | Description | --------- | ---- | ----------- | check | string | Health check OK. Examples You can send a health check request to a node like this: Code example (Postman): GET http: //api. chainweb. com/health-check This request returns a plain text message like this: Code example (text): Health check OK. Get general node information Use GET http: //{baseURL}/info to return general information about the node and the Chainweb version. Responses Requests to the GET http: //{baseURL}/info endpoint return the following response code: - 200 OK indicates that the request succeeded and the response body returns general information about the node and the chains in the network. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. | Parameter | Type | Description | --------- | ---- | ----------- | x-peer-addr | string | Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: \"10. 36. 1. 3: 42988\". | x-server&#8209; timestamp | integer >= 0 | Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: 1618597601. | x&#8209; chainweb&#8209; node&#8209; version | string | Specifies the version of the remote Chainweb node. For example: \"2. 23\". Response schema If the request is successful, the response returns application/json content with the following: Parameter | Type | Description nodeApiVersion (required) | string | Specifies the Chainweb API version information for the node. nodeBlockDelay (required) | integer >= 0 | Specifies the number of seconds to delay between blocks. nodeChains (required) | Array of strings | Specifies the chain identifiers for the chains in the network the node is part of. nodeGenesisHeights (required) | Array of integers | Specifies the block height for the first block of each chain in the network. | nodeGraphHistory (required) | Array of integers | Specifies the block height and adjacent chains for all chain graphs indexed by the height of the first block with the respective graph. Graphs are encoded as adjacency lists. nodeHistoricalChains (required) | Array of integers | Specifies the block height and adjacent chains for all chain graphs indexed by the height of the first block for the graph. Graphs are encoded as adjacency lists. nodeLatestBehaviorHeight (required) | integer | Specifies the latest block height for the node. nodeNumberOfChains (required) | integer >= 10 | Specifies the number of chains in the network the node is part of. nodePackageVersion (required) | string | Specifies the release package version for the chainweb-node software package running on the node. nodeServiceDate (required) | string | Specifies the next service date for updating the chainweb-node software package running on the node. nodeVersion (required) | string | Specifies the network identifier for the network the node is part of. The valid values are \"test-singleton\", \"development\", \"mainnet01\", and \"testnet04\". Examples You can send a request for general information to a node like this: Code example (Postman): GET http: //api. chainweb. com/info This request returns information similar to the following truncated excerpt: Code example (json): { \"nodeApiVersion\": \"0. 0\", \"nodeBlockDelay\": 30000000, \"nodeChains\": [ \"17\", \"16\", \"19\", ], \"nodeGenesisHeights\": [ [ \"17\", 852054 ], [ \"16\", 852054 ], [ \"19\", 852054 ], ], \"nodeGraphHistory\": [ [ 852054, [ [ 17, [ 1. . . [code continues] Blocks event stream Use GET http: //{baseURL}/header/updates to connect to a source of server events that emits a BlockHeader event for each new block header that is added to the chain database of the remote node. The stream can contain blocks that might later become orphaned. To address this potential issue, you should buffer events on the client side for the most recent block heights to allow for a desired confirmation depth to be reached. You should note that the server might terminate this event stream from time to time. It is up to the client to restart event streaming with a new request. Responses - 200 OK indicates a successful requests and results in a stream of BlockHeader events. Each event consists of an event property and a data property and are separated by empty lines. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. | Parameter | Type | Description | --------- | ---- | ----------- | x-peer-addr | string | Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: \"10. 36. 1. 3: 42988\". | x-server&#8209; timestamp | integer >= 0 | Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: 1618597601. | x&#8209; chainweb&#8209; node&#8209; version | string | Specifies the version of the remote Chainweb node. For example: \"2. 23\". Response schema If the request is successful, the response returns text/event-stream content with the following: | Parameter | Type | Description | | --------- | ---- | ----------- | event | string | Specifies the type of event with the event property value of \"BlockHeader\". | data | object | Specifies the data properties for the event. Examples You can send a request for block header updates from the Kadena main network like this: Code example (Postman): GET http: //api. chainweb. com/chainweb/0. 0/mainnet01/header/updates This request returns a stream of events with the BlockHeader event property and a data property: ! BlockHeader event stream If you expand the data property for an event, the event includes details similar to the following: Code example (json): { \"header\": { \"adjacents\": { \"12\": \"RUP5XpRIFJK7-xhClDzBIwRD3LCkNzhNTi4M05uPY\", \"14\": \"tzNb2bnWkGM9Qh3u4Pxna-NU2RYBYEuZE3cwu2m1k\", \"3\": \"6auRG8JDj4S4IYMF8G-d47dkwVAfX8XmOOg6isofr_M\" }, \"chainId\": 13, \"chainwebVersion\": \"mainnet01\", \"creationTime\": 1722966936274259, \"epochStart\": 1722966541117672, \"featureFlags\": 0, \"hash\": \"mb-Tn9AyDYuP5TgqaAlBu9VgR6eSZdWgKz9qtAGbrDA\", \"height\": 50. . . [code continues]",
    "source": "api/service-api/start-db-backup-job.md",
    "title": "Start a database backup"
  },
  {
    "content": "Learn how to build smart contracts that allow users to authorize and make payments using multiple Pact modules. The Contract interactions project is designed to demonstrate how you can import and use functions defined in one module in another module. For this project, you'll build a smart contract with separate modules to handle user authorization and payments with secure interactions between the modules. Secure contract interaction is a fundamental requirement for setting up more complex smart contracts. For this project, you'll create two Pact modules: - An auth module for authorizing operations based on the id stored for the user in a table. - A payments module for managing account balances and transferring value between accounts. The following diagram provides an overview of the interaction between the modules. ! Contract interaction overview To demonstrate contract interoperation, you'll also create test accounts for an administrator and two users, Sarah and James. In this tutorial, you'll learn about the following topics: - Calling contract functions defined in one module for use in another module. - Setting up separate modules for authorization and payments. - Testing contract interactions in the REPL environment. Before you begin Before starting this project, verify your environment meets the following basic requirements: - You have a GitHub account and can run git commands. - You have installed the Pact programming language and command-line interpreter. - You have installed the kadena-cli package and have a working directory with initial configuration settings. - You have a local development node that you can connect to that runs the chainweb-node program, either in a Docker container or on a physical or virtual computer. - You must have at least one account that's funded with KDA on at least one chain for deployment on the local development network or the Kadena test network. - You should be familiar with the basics for defining modules and using keysets. Get the starter code To get started: 1. Open a terminal shell on your computer. 2. Clone the pact-coding-projects repository by running the following command: ``bash git clone https: //github. com/kadena-docs/pact-coding-projects. git ` 3. Change to the 03-contract-interactions directory by running the following command: `bash cd pact-coding-projects/03-contract-interactions ` If you list the contents of this directory, you'll see that there are folders for starter-contracts and finished-contracts. The starter-contracts folder includes the following files: - auth. pact provides the basic framework for coding the auth module. - payments. pact provides the basic framework for coding the payments module. - starter-contract-interaction. pact provides a framework overview of the complete coding project. - contract-interaction. repl provides the basic framework for building a. repl file with test cases for verifying module interactions. 4. Open and review the starter-contract-interaction. pact file for an overview of the tasks you need to complete for the Contract Interactions project. Yo can follow the embedded instructions to work through the coding challenges on your own or use the detailed instructions provided in the next sections. Key concepts for contract interaction In Pact, modules can call functions from other modules, enabling more complex contract setups. You’ll be using the following key Pact features: - load to load and evaluate a module. - use to import an existing module into a namespace. - function calls to invoke functions in the one module that are defined in another module. Getting started You’ll work with three main files: - auth. pact - Responsible for authorizing users. - payments. pact - Manages payments between users. - payments. repl - Coordinates interactions between the modules. Define the auth module As you might have seen in other coding projects, modules are defined in a namespace and are governed by either an administrative keyset or a governance capability. To simplify the initial code required, this coding project assumes you are defining a custom dev namespace for local development. As an alternative, you could use the free namespace. The free namespace is a publicly-available namespace that you can use to deploy smart contracts on the Kadena test network. The best practice is to create a unique principal namespace where you can deploy all of your modules. If you have a principal namespace, use that namespace string instead of using the dev namespace. To define the auth module: 1. Create an auth. pact file, then define and enter a custom, principal, or existing namespace. For example, add the following code to define a new dev namespace and make it your active namespace: `pact (define-namespace \"dev\" (read-keyset \"module-admin-keyset\") (read-keyset \"module-admin-keyset\")) (namespace \"dev\") ` 2. Define two keysets in the auth. pact file to identify the keysets that have access to module operations. `pact (define-keyset \"dev. module-admin\" (read-keyset \"module-admin-keyset\")) (define-keyset \"dev. operate-admin\" (read-keyset \"module-operate-keyset\")) ` These keysets will help manage access control throughout the contract. 3. Create the auth module with a governance capability that enforces the module-admin keyset guard. `pact (module auth AUTH (defcap AUTH () (enforce-guard \"dev. module-admin\")) ` 4. Define the schema and table for managing user data. `pact (defschema user nickname: string keyset: guard) (deftable users: {user}) ` 5. Define the create-user function that operate-admin keyset owners can execute to add new users to the auth module. `pact (defun create-user: string (id: string nickname: string keyset: guard) (enforce-guard \"dev. operate-admin\") (insert users id { \"keyset\": keyset, \"nickname\": nickname }) ) ` 6. Define the enforce-user-auth function that ensures a user is authorized for a specific operation. `pact (defun enforce-user-auth: guard (id: string) (with-read users id { \"keyset\": = k } (enforce-guard k) k) ) ` 7. Complete the auth module by closing the module declaration and create the users table. `pact ) (create-table users) ` Define the payments module 1. Create a payments. pact file, then define and enter the same custom, principal, or existing namespace you're using for the auth module. 2. Define a keyset in the payments. pact file that will manage this module. `pact (define-keyset \"dev. module-admin\" (read-keyset \"module-admin-keyset\")) ` 3. Start the payments module declaration and import the auth module with the Pact use keyword. `pact (module payments ADMIN (defcap ADMIN () (enforce-guard \"dev. module-admin\")) (use auth) ) ` 4. Define the schema and table for account management. `pact (defschema account balance: decimal) (deftable accounts: {account}) ` 1. Define the create-account function to set up a new account, ensuring the user is authorized. `pact (defun create-account: string (userId: string initial-balance: decimal) \"Create a new account for ID with INITIAL-BALANCE funds, must be administrator. \" (enforce-user-auth userId) (enforce (>= initial-balance 0. 0) \"Initial balances must be >= 0. \") (insert accounts userId { \"balance\": initial-balance}) ) ` 2. Define the get-balance function to retrieve the balance for an account from the database for an authorized user. `pact (defun get-balance: decimal (userId: string) \"Only admin can read balance. \" (enforce-user-auth \"admin\") (with-read accounts userId { \"balance\": = balance } balance) ) ` 3. Define the pay function to allow for transferring funds between accounts. `pact (defun pay: string (from: string to: string amount: decimal) (with-read accounts from { \"balance\": = from-bal } (enforce-user-auth from) (with-read accounts to { \"balance\": = to-bal } (enforce (> amount 0. 0) \"Transaction amount cannot be negative. \") (enforce (>= from-bal amount) \"Insufficient funds\") (update accounts from { \"balance\": (- from-bal amount) }) (update accounts to { \"balance\": (+ to-bal amount) }) (format \"{} paid {} {}\" [from to amount]))) ) ` 4. Complete the payments module by closing the module declaration and create the accounts table. `pact ) (create-table accounts) ` Test interactions with the REPL File To test contract interaction: 1. Create a payments. repl file and add a transaction that loads the auth. pact module. `pact (begin-tx) (load \"auth. pact\") (commit-tx) ` 2. Add a transaction that loads the payments. pact module. `pact (begin-tx) (load \"payments. pact\") (commit-tx) ` 3. Add a transaction that uses the auth module to create user accounts. `pact (begin-tx) (use auth) (env-data { \"admin-keyset\": [\"admin\"], \"sarah-keyset\": [\"sarah\"], \"james-keyset\": [\"james\"]}) (create-user \"admin\" \"Administrator\" (read-keyset \"admin-keyset\")) (create-user \"sarah\" \"Sarah\" (read-keyset \"sarah-keyset\")) (create-user \"james\" \"James\" (read-keyset \"james-keyset\")) (commit-tx) ` 1. Add a transaction that uses the payments module to test transactions. `pact (begin-tx) (use payments) (env-keys [\"sarah\"]) (create-account \"Sarah\" 100. 25) (env-keys [\"james\"]) (create-account \"James\" 250. 0) (pay \"Sarah\" \"James\" 25. 0) (commit-tx) ` 2. Execute the payments. repl file with the following command: `bash pact payments. repl --trace ` Ensure that the REPL output aligns with expected results. Review You have now built and tested contract interoperability using separate user authorization and payment modules. In this tutorial, you learned how to import functions defined in one module so they can be used in another module and tested transactions that required both modules to successfully complete tasks. The tutorial introduced the Pact load and use` keywords and demonstrated the basics of using them in your own modules.",
    "source": "coding-projects/contract-interactions.md",
    "title": "Contract interactions"
  },
  {
    "content": "Calculate the approximate cost to execute a specific transaction. Because transaction fees vary depending on the resources required to execute specific operations, it can use useful to calculate potential fees by testing contract functions using the Pact REPL and. repl files. This coding project demonstrates the basic steps for calculating the gas required to execute any method in a. repl file. This coding project assumes you're familiar with the basic built-in functions for testing smart contracts in your local development environment using. repl files. As an extension of the Local testing, the project demonstrates how to gas-related built-in functions with the loans-estimate. pact module as the sample smart contract to test. In this coding project, you'll learn about: - Using the built-in environment configuration functions. - Setting and updating gas limits. - Testing the gas consumed for individual functions. - Combining functions in transaction blocks. Before you begin Before starting this project, verify your environment meets the following basic requirements: - You have a GitHub account and can run git commands. - You have installed the Pact programming language and command-line interpreter. - You have installed the kadena-cli package and have a working directory with initial configuration settings. - You have a local development node that you can connect to that runs the chainweb-node program, either in a Docker container or on a physical or virtual computer. - You should be familiar with defining modules and using keysets. Get the starter code To get started: 1. Open a terminal shell on your computer. 2. Clone the pact-coding-projects repository by running the following command: Code example (bash): git clone https: //github. com/kadena-docs/pact-coding-projects. git `` 3. Change to the 07-estimate-gas directory by running the following command: `bash cd pact-coding-projects/07-estimate-gas ` If you list the contents of this directory, you'll see the following files: - starter-estimate-gas. repl provides a starting point testing the loans module. - loans-estimate. pact provides the final code for the loans module with the functions that you'll estimate gas. . . [code continues]pact; ; ===================================================================; ; 3 Call each function to retrieve the gas consumed; ; =================================================================== (begin-tx \"Call create-a-loan to estimate gas\") (use free. loans) (create-a-loan \"loanId-1\" \"Ponderosa\" \"Valley Credit\" 16000); ; loanId, loanName, entity, amount (env-gas) (commit-tx) (env-gas 0) (begin-tx \"Call assign-a-loan to estimate gas\") (use free. loans) (assign-a-loan \"txid-1\" \"loanId-1\" \"Studio Funding\" 10000); ; txid, loanId, buyer, amount (env-gas) (commit-tx) (env-gas 0) (begin-tx \"Call sell-a-loan to estimate gas\") (use free. loans) (sell-a-loan \"txid-2\" \"loanId-1\" \"buyer2\" \"Studio Funding\" 2000); ; txid, loanId, seller, buyer, amount (env-gas) (commit-tx) (env-gas 0) (begin-tx \"Call read-a-loan to estimate gas\") (use free. loans) (read-a-loan \"loanId-1\"); ; loanId (env-gas) (commit-tx) (env-gas 0) (begin-tx \"Call read-all-loans to estimate gas\") (use free. loans) (read-all-loans) (env-gas) (commit-tx) (env-gas 0) Code example (): As before, you can test that the gas consumed is returned for each function by running the following command: pact pact --trace loans-estimate. repl Code example (): In this example, the functions from the loans module returned the following results: pact. . . . . . \"Begin Tx 3 Call create-a-loan to estimate gas\" loans-estimate. repl: 26: 2-26: 11: 88. . . Begin Tx 4 Call assign-a-loan to estimate gas\" loans-estimate. repl: 33: 2-33: 11: 168. . . \"Begin Tx 5 Call sell-a-loan to estimate gas\" loans-estimate. repl: 40: 2-40: 11: 132. . . \"Begin Tx 6 Call read-a-loan to estimate gas\" loans-estimate. repl: 47: 2-47: 11: 19. . . \"Begin Tx 7 Call read-all-loans to estimate gas\" loans-estimate. repl: 54: 2-54: 11: 40004. . . Code example (): ## Combine multiple functions In some cases, you might want to estimate the gas required to execute a set of functions instead of individual functions. You can do so by combining the functions into a single transaction. The following example demonstrates combining several function into a single transaction then retrieving the gas consumed. Note that you might need to increase the value you set for the env-gaslimit built-in function when you are returning the gas for multiple functions in a si. . . [code continues]pact; ; ===================================================================; ; 4 Combine multiple functions in a transaction and retrieve gas; ; =================================================================== (begin-tx \"Call multiple functions in a transaction\") (use free. loans) (create-a-loan \"loanId-2\" \"Renovation\" \"RiverBank\" 140000) (read-a-loan \"loanId-2\") (read-all-loans) (read-loan-inventory) (read-loans-with-status INITIATED) (env-gaslimit 280000) (read-loans-with-status ASSIGNED) (env-gas) (commit-tx) `` Review This project introduced several of the built-in REPL-only functions for calculating gas. The project included examples of the following use-cases: - Calculating the gas required to execute individual functions. - Calculating the gas required to execute a transaction that combined multiple functions. Through these examples, you learned how to: - Initiate table-based gas modeling. - Set an initial gas limit. - Report the gas consumed. - Reset the gas to zero. You also learned that you can update the gas limit, if needed.",
    "source": "coding-projects/estimate-gas.md",
    "title": "Estimate gas"
  },
  {
    "content": "Create and configure a gas station account to pay for transactions submitted by application users. In the Gas station account coding project, you'll learn how to create a smart contract that allows application users to complete a transaction on the blockchain without having an account or any tokens to pay the transaction fee. With this smart contract, an autonomous account is used to pay transaction fees on behalf of users. The autonomous account—often referred to as a gas station—simplifies the user experience and eliminates the friction associated with onboarding users who are new to blockchain technology, digital wallets, transaction signing, and managing public and secret keys. Gas station accounts make it easier for new users to interact with applications, but require some extra work by the application developer. For example, you'll most likely want to set limits on how and when the funds in the gas station account can be used to prevent the account balance from being drained too quickly or funding transactions that require a lot of computational overhead. In this coding project, you'll see a simple example of how to create a coin contract account that pays transaction fees—that is, the gas fees—on behalf of users. This coding project explores how to: - Create a gas station principal account with a capability guard. - Implement the interface required to allow the account to pay transaction fees for any type of transaction. - Scope the gas station account to only pay transaction fees for transactions that meet specific criteria. By completing this project, you'll have a basic understanding of the functions used to create a secure gas station account and how to set limits to protect the account from misuse. Principal accounts and guards A gas station account is similar to any other coin contract account. It must have an account name, guard, and balance, so that it can be uniquely identified, sign transactions securely, and hold funds for paying fees. However, it's important for you to restrict access to the gas station account to ensure it's only used as intended. The primary way to secure access to the gas station account is by creating it as a principal account with a unique guard. For an introduction to principal accounts, see Accounts, keys, and principals. For information about the different types of guards, see Guards. The following example illustrates how to use the create-user-guard and create-principal functions to create a coin account with a user guard for the allow function: Code example (pact): (namespace \"free\") (module test-gas GOV (defcap GOV() true) (defun allow() true) ) (let ((guard (create-user-guard (test-gas. allow)))) (coin. create-account (create-principal guard) guard) ) The coin. create-account function creates a new principal account with a user guard in the coin-table with a default balance of 0. 0. You can use similar code to create a new account that makes use of a capability guard. For example: Code example (pact): (namespace \"free\") (module test-gas GOV (defcap GOV() true) (defcap ALLOW-ALL() true) ) (let ((guard (create-capability-guard (test-gas. ALLOW-ALL)))) (coin. create-account (create-principal guard) guard) ) A capability guard is an essential part of the code that makes creating a gas station principal account possible. In the next step, you'll implement the gas-payer-v1 interface to add a GASPAYER capability and guard to your module. Before you begin Before starting this project, verify your environment meets the following basic requirements: - You have a GitHub account and can run git commands. - You have installed the Pact programming language and command-line interpreter. - You have installed the kadena-cli package and have a working directory with initial configuration settings. - You have a local development node that you can connect to that runs the chainweb-node program, either in a Docker container or on a physical or virtual computer. - You must have at least one account that's funded with KDA on at least one chain for deployment on the local development network or the Kadena test network. - You should be familiar with the basics for defining modules and using keysets. Get the starter code To get started: 1. Open a terminal shell on your computer. 2. Clone the pact-coding-projects repository by running the following command: ``bash git clone https: //github. com/kadena-docs/pact-coding-projects. git ` 3. Change to the 04-gas-station directory by running the following command: `bash cd pact-coding-projects/04-gas-station ` If you list the contents of this directory, you'll see the following files: - starter-gas-account. pact provides a framework for the project code in comments. - gas-account. pact contains the final module code for the sample gas account. - gas-account. repl provides the complete test file for testing the final gas-account. pact file. 4. Open and review the starter-gas-account. pact file. This file describes all of the tasks that you need to complete for the Gas station accounts coding project. You can follow the instructions embedded in the file to try to tackle this coding project on your own without looking at the solutions to each step, or follow the instructions in the next sections if you need additional guidance. Implement the gas payer interface Because paying gas fees is a common operation, the gas-payer-v1 interface is defined in a module that's deployed by default on the Kadena development, test, and main networks. For this coding project, you'll implement this interface in a new Pact module—the test-gas module—in a gas-account. pact file. To create the gas station module: 1. Open the code editor on your computer. 2. Create a new gas-account. pact file. 3. Add the minimal Pact code required to define a module. Remember that a module requires the following information: - namespace - governing keyset or capability - at least one function The function in this case is an implementation of the gas-payer-v1 interface as defined in the gas-payer-v1. pact file. For example: `pact (namespace \"free\") (define-keyset \"free. dev-account\" (read-keyset \"dev-account\" )) (module test-gas GOVERNANCE (defcap GOVERNANCE () (enforce-guard \"free. pistolas-dev-account\")) (implements gas-payer-v1) ) ` To deploy the gas station module, you must use an existing namespace such as your principal namespace or the \"free\" namespace. For local testing, you can create the test-gas module in a custom namespace that you define for the local development network. After you issue the implements gas-payer-v1 statement, you must implement the capabilities, types, and functions that are defined in the gas-payer-v1. pact file in the test-gas module. The interface definition looks like this: `pact (interface gas-payer-v1 (defcap GASPAYER: bool ( user: string limit: integer price: decimal ) @doc \" Provide a capability indicating that declaring module supports \\ \\ gas payment for USER for gas LIMIT and PRICE. Functionality \\ \\ should require capability (coin. FUNDTX), and should validate \\ \\ the spend of (limit price), possibly updating some database \\ \\ entry. \\ \\ Should compose capability required for 'create-gas-payer-guard'. \" ) (defun create-gas-payer-guard: guard () @doc \" Provide a guard suitable for controlling a coin account that can \\ \\ pay gas via GASPAYER mechanics. Generally this is accomplished \\ \\ by having GASPAYER compose a capability without parameters, \\ \\ that is required in this guard. Thus, if coin contract is able to \\ \\ successfully acquire GASPAYER, the composed 'anonymous' cap required \\ \\ here will be in scope, and gas buy will succeed. \" ) ) ` 4. Implement the GASPAYER capability as defined in the gas-payer-v1. pact file and compose an inner capability called ALLOWGAS to use as a guard for the account used to pay transaction fees: `pact (defcap GASPAYER: bool ( user: string limit: integer price: decimal ) (compose-capability (ALLOWGAS)) ) (defcap ALLOWGAS () true) (defun create-gas-payer-guard: guard () (create-capability-guard (ALLOWGAS)) ) ` With this code, an account granted the GASPAYER capability can pay gas fees for any transaction. In addition, the create-gas-payer-guard function uses the built-in create-capability-guard function to return a guard for the ALLOWGAS capability. Test the gas payer implementation At this point, you have a basic implementation of the gas-payer-v1 interface that can be used to pay transaction fees but without any other scoping or restrictions. Before deploying the new module or updating it to be more restrictive, you should prepare a script for testing operations locally. To test the module locally, you'll need to add the contracts that the gas station module depends on to your local environment. To prepare a test file: 1. Open the code editor on your computer. 2. Copy the following required files to your working directory: `bash coin-v5. pact fungible-v2. pact fungible-xchain-v1. pact gas-payer-v1. pact ` Copying these files to your local environment is required because the contracts aren't deployed in the Pact REPL by default. 3. Create a new gas-account. repl file to provide all of the environment data required for the module, including the namespace, keys, signatures, and contracts. For example, the initial environment information for the gas-account might look similar to the following: `pact (env-data { \"dev-account\": { \"keys\": [ \"58705e8699678bd15bbda2cf40fa236694895db614aafc82cf1c06c014ca963c\" ], \"pred\": \"keys-all\" } } ) (env-sigs [{ \"key\": \"58705e8699678bd15bbda2cf40fa236694895db614aafc82cf1c06c014ca963c\", \"caps\": [] }] ) (begin-tx \"Define principal namespace\") (define-namespace \"free\" (read-keyset \"dev-account\" ) (read-keyset \"dev-account\" )) (commit-tx) (begin-tx \"Define admin-keyset\") (namespace \"free\") (define-keyset \"free. dev-account\" (read-keyset \"dev-account\" )) (commit-tx) (begin-tx \"Load required modules\") (load \"fungible-v2. pact\") (load \"fungible-xchain-v1. pact\") (load \"coin-v5. pact\") (create-table coin-table) (create-table allocation-table) (load \"gas-payer-v1. pact\") (commit-tx) ` 4. Add a call to load the gas-account. pact file: `pact (begin-tx \"Load gas station module\") (load \"gas-account. pact\") (commit-tx) ` 5. Execute the gas-account. repl file using the pact command-line interpreter and the --trace option: `pact pact gas-account. repl --trace ` You should see that the operations are successful with output similar to the following: `bash gas-account. repl: 1: 0: Trace: Setting transaction data gas-account. repl: 8: 2: Trace: Setting transaction signatures/caps gas-account. repl: 14: 0: Trace: Begin Tx 0: Define principal namespace gas-account. repl: 15: 2: Trace: Namespace defined: free gas-account. repl: 16: 0: Trace: Commit Tx 0: Define principal namespace gas-account. repl: 18: 0: Trace: Begin Tx 1: Define admin-keyset gas-account. repl: 19: 2: Trace: Namespace set to free gas-account. repl: 20: 2: Trace: Keyset defined gas-account. repl: 21: 0: Trace: Commit Tx 1: Define admin-keyset gas-account. repl: 23: 0: Trace: Begin Tx 2: Load required modules gas-account. repl: 24: 3: Trace: Loading fungible-v2. pact. . . fungible-v2. pact: 1: 0: Trace: Loaded interface fungible-v2 gas-account. repl: 25: 3: Trace: Loading fungible-xchain-v1. pact. . . fungible-xchain-v1. pact: 1: 0: Trace: Loaded interface fungible-xchain-v1 gas-account. repl: 26: 3: Trace: Loading coin-v5. pact. . . coin-v5. pact: 1: 0: Trace: Loaded module coin, hash rE7DU8jlQL9xMPYuniZJf5ICBTAEHAIFQCB4blofP4 gas-account. repl: 27: 3: Trace: TableCreated gas-account. repl: 28: 3: Trace: TableCreated gas-account. repl: 29: 3: Trace: Loading gas-payer-v1. pact. . . gas-payer-v1. pact: 1: 0: Trace: Loaded interface gas-payer-v1 gas-account. repl: 30: 0: Trace: Commit Tx 2: Load required modules gas-account. repl: 32: 0: Trace: Begin Tx 3: Load gas station module gas-account. repl: 33: 3: Trace: Loading gas-account. pact. . . gas-account. pact: 1: 0: Trace: Namespace set to free gas-account. pact: 3: 0: Trace: Loaded module free. test-gas, hash rqS8Y5Rp-DxlTQHSKgeDJrRTlGFfoA5eaIKtcctwYN0 gas-account. repl: 34: 0: Trace: Commit Tx 3: Load gas station module Load successful ` Create the capability-guarded account To make the gas station account more secure, you can create it using a principal account name and guard access to it by using the ALLOWGAS capability. Because the gas station account is a capability-guarded account, the create-principal Pact function creates the principal account name with a c: prefix. You can then define the gas station account name as a constant in the gas-account. pact file. To create a capability-guarded account: 1. Open the gas-account. pact file in the code editor. 2. Add a GASACCOUNT constant to store the gas station principal account in the module declaration: `pact (defconst GASACCOUNT (create-principal (create-gas-payer-guard))) ` 3. Add an init function that uses the coin. create-account function to create the gas station account in the module declaration: `pact (defun init () (coin. create-account GASACCOUNT (create-gas-payer-guard)) ) ` In this code: - The first argument of the function is the account name you defined using the GASACCOUNT constant. - The second argument is the guard for the account. 4. Add an expression after the module declaration that calls the init function if the module is deployed with { \"init\": true } in the environment data: `pact (if (read-msg \"init\") [(init)] [\"Not creating the gas station account\"] ) ` 5. Save your changes to the gas-account. pact file. 6. Open the gas-account. repl file in the code editor. 7. Update the gas-account. repl file to set init to true by adding the following lines of code before loading the gas-account. pact file: `pact (env-data { \"init\": true } ) ` 8. Update the load transaction to display the capability-guarded gas station account name when you execute the file: `pact (begin-tx \"Load gas station module\") (load \"gas-account. pact\") [GASACCOUNT] (commit-tx) ` 9. Execute the gas-account. repl file: `pact pact gas-account. repl --trace ` You should see that the transaction completes with output similar to the following: `bash. . . gas-account. repl: 36: 0: Trace: Begin Tx 3: Load gas station module gas-account. repl: 37: 3: Trace: Loading 01-gas-account. pact. . . gas-account. pact: 1: 0: Trace: Namespace set to free gas-account. pact: 3: 0: Trace: Loaded module free. test-gas, hash q1bMc2SzjAJrbhUyZJ5t4u8Zktvi9HxOZqsxZljTA4 gas-account. pact: 28: 0: Trace: [\"Write succeeded\"] gas-account. repl: 38: 3: Trace: [\"c: J1yaCWrdEbhKekMRhF5WjOgvzUayxTD24q7UWHwaa9I\"] gas-account. repl: 39: 0: Trace: Commit Tx 3: Load gas station module Load successful ` Verify the gas station account In the previous output, the \"Write succeeded\" message indicates that you have successfully created the principal account for the gas station to use. You can verify the account information by adding another transaction to the gas-account. repl file that calls the coin. details function with the account name for the capability-guarded gas station account. To verify the gas account: 1. Open the gas-account. repl file in your code editor. 2. Add a transaction similar to the following after loading the gas-account. pact file: `pact (begin-tx \"Verify account\") (coin. details free. test-gas. GASACCOUNT) (commit-tx) ` 3. Execute the gas-account. repl file: `pact pact gas-account. repl --trace ` You should see that the transaction completes with output similar to the following: `bash. . . gas-account. repl: 37: 3: Trace: Loading 01-gas-account. pact. . . gas-account. pact: 1: 0: Trace: Namespace set to free gas-account. pact: 3: 0: Trace: Loaded module free. test-gas, hash q1bMc2SzjAJrbhUyZJ5t4u8Zktvi9HxOZqsxZljTA4 gas-account. pact: 28: 0: Trace: [\"Write succeeded\"] gas-account. repl: 38: 3: Trace: [\"c: J1yaCWrdEbhKekMRhF5WjOgvzUayxTD24q7UWHwaa9I\"] gas-account. repl: 39: 0: Trace: Commit Tx 3: Load gas station module gas-account. repl: 41: 0: Trace: Begin Tx 4: Verify account gas-account. repl: 42: 3: Trace: {\"account\": \"c: J1yaCWrdEbhKekMRhF5WjOgvzUayxTD24q7UWHwaa9I\", \"balance\": 0. 0, \"guard\": CapabilityGuard {name: free. test-gas. ALLOWGAS, args: [], pactId: }} gas-account. repl: 43: 0: Trace: Commit Tx 4: Verify account Load successful ` Scope to specific transactions Now that you have a capability-guarded gas station account that can be used to pay transaction fees, you can further scope it to only pay for specific transactions or only when specific conditions are met. For example, you might want enforce an upper limit for transaction fees to help ensure that funds in a gas station account aren't drained too quickly. The following example illustrates how to enforce specific conditions for the use the gas station account. In this example, the gas station administrator can use the gas station account for any transaction. Other users can only use the gas station account to pay transaction fees if the gas price is less than a specified price. To enforce specific conditions for transactions using the gas station account: 1. Open the gas-account. pact file in the code editor. 2. Add the enforce-one function to the GASPAYER capability to specify two conditions: `pact (enforce-one \"Allow the administrator to use the gas station account for any transaction. \" [ (enforce-guard \"free. dev-account\" ) (enforce (<= 0. 00000001 (at 'gas-price (chain-data))) \"Gas price must be less than 0. 00000001\" ) ] ) ` In this example, the enforce-guard function allows the owner of the free. dev-account keyset to the use the gas station account to pay for any transaction. For all other transactions and users, the gas price must be less the specified 0. 00000001. You can use a similar approach to limit access to gas station funds based on other conditions. For example, you can set a limit for transaction fees using a function to get the current gas price instead of using a hard-coded value. You can also create conditions that prevent the gas station account from being used to submit continuation requests, that exclude specific module or function calls, or that set time boundaries for paying transaction fees. Display account details Before deploying the gas station smart contract, add a function to display the account details when the contract is deployed. You'll need this information to transfer funds to the new account on the network and chain where you deploy the contract. To add a function that displays the account information: 1. Open the gas-account. pact file in the code editor. 2. Add the display function to call the coin. details function for the GASACCOUNT: `pact (defun display: object () (coin. details free. test-gas. GASACCOUNT) ) ` 3. Add a call to the display function to the end of the smart contract: `pact (if (read-msg \"init\") [(init)] [\"Not creating the gas station account\"] ) (free. test-gas. display) ` 1. Open the gas-account. repl file in the code editor and add a test for the display function. `pact (begin-tx \"Test account display\") (free. test-gas. display) (commit-tx) ` 3. Execute the gas-account. repl file: `pact pact gas-account. repl --trace ` You should see that the transaction completes with output similar to the following: `bash. . . gas-account. repl: 45: 0: Trace: Begin Tx 5: Test account display gas-account. repl: 46: 3: Trace: {\"account\": \"c: J1yaCWrdEbhKekMRhF5WjOgvzUayxTD24q7UWHwaa9I\", \"balance\": 0. 0, \"guard\": CapabilityGuard {name: free. test-gas. ALLOWGAS, args: [], pactId: }} gas-account. repl: 47: 0: Trace: Commit Tx 5: Test account display ` Deploy the contract After you've updated and tested the module, you can deploy it on a chain on your local development network or the Kadena test network. For this example, the contract is deployed in the free namespace using an administrative account that has funds on chain 3 in the development network. To deploy in the free namespace, the module name and keyset name must be unique across all of the modules that exist in the free namespace. Prepare to deploy To prepare to deploy the gas station module on the development network: - The development network is currently running on your local computer. - You have at least one account with funds on at least one chain in the development network. If you don't have keys and at least one account on any chain on the network, you need to generate keys, create an account, and fund the account on at least one chain before continuing. - You have the public key for the account on the chain where you have funds. Create a deployment transaction You can deploy the gas-account. pact module on the local development network using a transaction template. To deploy the module: 1. Create a new transaction template named deploy-contract. ktpl in the ~/. kadena/transaction-templates folder. `sh cd ~/. kadena/transaction-templates touch deploy-contract. ktpl ` 2. Open the deploy-contract. ktpl file in a code editor and create a reusable transaction request in YAML format similar to the following to specify the path to the gas-account. pact file that contains your Pact module code. `pact codeFile: \"{{path-to-pact-code}}\" data: admin-keyset: keys: [\"{{public-key}}\"] pred: \"keys-all\" init: true meta: chainId: \"{{chain-id}}\" sender: \"{{{sender-account}}}\" gasLimit: 80300 gasPrice: 0. 000001 ttl: 600 signers: - public: \"{{public-key}}\" caps: [] networkId: \"{{network-id}}\" ` 3. Create a transaction that uses the template by running the kadena tx add command and following the prompts displayed. For example: `sh? Which template do you want to use: deploy-contract. ktpl? File path of data to use for template. json or. yaml (optional): ? Template value path-to-pact-code: . . /. . /gas-account. pact? Template value public-key: 58705e8699678bd15bbda2cf40fa236694895db614aafc82cf1c06c014ca963c? Template value chain-id: 3? Template value sender-account: k: 58705e8699678bd15bbda2cf40fa236694895db614aafc82cf1c06c014ca963c? Template value network-id: development? Where do you want to save the output: GasStationAccount ` In this example, the unsigned transaction is saved in a GasStationAccount. json file. 4. Sign the transaction by running the kadena tx sign command and following the prompts displayed to sign with a wallet account or a public and secret key pair. For example: `sh? Select an action: Sign with wallet? Select a transaction file: Transaction: GasStationAccount. json? 1 wallets found containing the keys for signing this transaction, please select a wallet to sign this transaction with first: Wallet: chainweaver-web-legacy? Enter the wallet password: **** ` 5. Send the transaction by running the kadena tx send command and following the prompts displayed. After the transaction is complete, you should see the account created in the transaction results. For example: ! Gas station account Fund the gas station account Now that you have created and deployed the gas station account, you're ready to fund the account to pay transaction fees. You can use the kadena tx commands to create, sign, and send a transfer transaction to the development network. To fund the gas station account: 1. Verify the development network is currently running on your local computer. 2. Create a new unsigned transaction using the kadena tx add command and the transfer. ktpl template and follow the prompts displayed to select the sender, receiver, and amount to transfer. - For the account: from template value, specify the administrative account that is providing funds to the gas station account. In this example, it's the Chainweaver wallet account k: 58705e8699678bd15bbda2cf40fa236694895db614aafc82cf1c06c014ca963c. - For the account: to template value, specify the gas station principal account that you created with the capability guard. In this example, it's the principal account c: J1yaCWrdEbhKekMRhF5WjOgvzUayxTD24q7UWHwaa9I. - For the decimal: amount template value, specify the number of coins to transfer as a decimal value. In this example, the transfer amount is 2. 0. For example, the prompts and output for creating the transaction look similar to the following: `bash ➜ ~ kadena tx add? Which template do you want to use: transfer. ktpl? File path of data to use for template. json or. yaml (optional): ? Select account alias for template value account: from: k-58705e > Using account name k: 58705e8699678bd15bbda2cf40fa236694895db614aafc82cf1c06c014ca963c? Select account alias for template value account: to: Enter account manually? Manual entry for account for template value account: to: c: J1yaCWrdEbhKekMRhF5WjOgvzUayxTD24q7UWHwaa9I? Template value decimal: amount: 2. 0? Template value chain-id: 3? Template key \"key: from\" matches account \"account: from\". Use public account's key? Account public key: 58705e8699678bd15bbda2cf40fa236694895db614aafc82cf1c06c014ca963c? Select network id for template value networkId: development? Where do you want to save the output: fund-gas ` 3. Sign the unsigned transaction using the kadena tx sign command and the transaction file name generated by the kadena tx add command. For example, the prompts and output for the transaction look similar to the following: `bash ➜ ~ kadena tx sign? Select an action: Sign with wallet? Select a transaction file: Transaction: fund-gas. json? 1 wallets found containing the keys for signing this transaction, please select a wallet to sign this transaction with first: Wallet: chainweaver-web-legacy? Enter the wallet password: ***** ` 4. Send the signed transaction using the kadena tx send command and the signed transaction file name generated by the kadena tx sign command. For example, the prompts and output for the transaction look similar to the following: `bash ➜ ~ kadena tx send? Select a transaction file: Transaction: transaction-6DWOi5enSt-signed. json ⠋ Sending transactions. . . Transaction detail for command with hash: 6DWOi5enStLe6WjaUOMJfv-RTm3TSrfe0m1IAH4yac Network ID Chain ID development 3 ✔ Completed Transaction: 6DWOi5enStLe6WjaUOMJfv-RTm3TSrfe0m1IAH4yac submitted with request key: 6DWOi5enStLe6WjaUOMJfv-RTm3TSrfe0m1IAH4yac `` After the transaction is completed, you can check the results in the block explorer using the request key. For example, you can open the local block explorer for the development network to view recent transactions: ! Explore recent transactions You can click the link matching the transaction request key to see the details about the funding transaction: ! Fund gas account transaction details Review This project demonstrated how to create a capability-guarded principal account to hold funds. This account can be used to pay for transactions on behalf of other users. The project also provided a simple example for restricting the use of the gas station account based on a specific condition. In this example project, the gas station module was deployed on the development network and chain 3 with funds from a Chainweaver wallet account.",
    "source": "coding-projects/gas-station.md",
    "title": "Gas station accounts"
  },
  {
    "content": "Start coding with the Pact smart contract programming language by creating a 'Hello, World!' project. Hello, World! revisited In the Quick start, you were introduced to a simple greeting module. Modules provide the basic foundation for all Pact smart contracts. In fact, the term module is a reserved keyword that you use to define and install a module with a specified name, The greeting module defined a single function—one very much like the traditional Hello, World! program you see when learning any new programming language. In the 00-hello-world project folder, you'll take a closer look at the hello-world module, extend its functionality, and deploy it on the local development network. Before you begin Before starting this project, verify your environment meets the following basic requirements: - You have a GitHub account and can run git commands. - You have installed the Pact programming language and command-line interpreter. - You have installed the kadena-cli package and have a working directory with initial configuration settings. - You have a local development node that you can connect to that runs the chainweb-node program, either in a Docker container or on a physical or virtual computer. If you have these basics covered, you're ready to go. Get the starter code To get started: 1. Open a terminal shell on your computer. 2. Clone the pact-coding-projects repository by running the following command: ``bash git clone https: //github. com/kadena-docs/pact-coding-projects. git ` 3. Change to the 00-hello-world directory by running the following command: `bash cd pact-coding-projects/00-hello-world ` 4. Open the hello-world. pact file in your code editor. `pact; ; ; ; \"Hello, world! \" module; ; ; ; -----------------------------------------------------------------------; ; ; ; Use semicolons (; ) for comments in smart contracts. ; ; By convention, use: ; ; ; ; - A single semicolon (; ) for short notes on a single line of code. ; ; - Two semicolons (; ; ) to describe functions or other top-level forms. ; ; - Three semicolons (; ; ; ) to separate larger sections of code. ; ; ; ; ----------------------------------------------------------------------- (module helloWorld GOVERNANCE \"You can also embed comments in smart contracts by using quoted strings. \" (defcap GOVERNANCE () true) (defun say-hello(name: string) (format \"Hello, {}! ~ from Kadena\" [name]) ) ) ` A few things you should note about this starter code: - The module being defined is named helloWorld. - Every module is governed by either a keyset or a capability. In this example, the GOVERNANCE capability is used to control access to the module. This capability must evaluate to true to grant access. - The defun reserved keyword signals the start of a function definition. In this example, the function being defined is named say-hello and the function takes one variable, name, with a data type of string. - The say-hello function uses the built-in format function that allows you to format messages using a placeholder and a variable or a specified value. The curly braces ({}) indicate the location of the value to be inserted and the [name] is the variable to be inserted in place of the curly braces ({}). To learn more, see the following topics: - Syntax and keywords - Built-in functions Load and test the module The Pact command-line interpreter provides a read-evaluate-print-loop (REPL) for interactive testing of Pact commands and for executing tests defined in files. To load and test the helloWorld module interactively: 1. Add a call to the say-hello function at the bottom of the hello-world. pact file in your code editor. `pact; ; ; ; \"Hello, world! \" module; ; ; ; -----------------------------------------------------------------------; ; ; ; Use semicolons (; ) for comments in smart contracts. ; ; By convention, use: ; ; ; ; - A single semicolon (; ) for short notes on a single line of code. ; ; - Two semicolons (; ; ) to describe functions or other top-level forms. ; ; - Three semicolons (; ; ; ) to separate larger sections of code. ; ; ; ; ----------------------------------------------------------------------- (module helloWorld GOVERNANCE \"You can also embed comments in smart contracts by using quoted strings. \" (defcap GOVERNANCE () true) (defun say-hello(name: string) (format \"Hello, {}! ~ from Kadena\" [name]) ) ) (say-hello \"Pistolas\") ` 2. Open a terminal shell on your computer. 3. Start the Pact interpreter by running the following command: `bash pact ` After running this command, the terminal displays the pact > prompt: `pact pact > ` 4. Copy and paste the helloWorld module code into the terminal with the pact > prompt, then press Return on the keyboard to load the module. You should see that the module loads and the call to the say-hello function is executed with output similar to the following: `pact \"Loaded module helloWorld, hash fsYJQuzCtzdocWkgjS9yXFz6WAJlV0Aor1RmWhyfgc0\" pact> pact> (say-hello \"Pistolas\") \"Hello, Pistolas! ~ from Kadena\" ` 1. Exit the Pact interpreter by pressing control-d on the keyboard. Create a hello-world. repl file The Pact REPL environment accepts many built-in functions that are specifically for testing and debugging your Pact code. You can use these built-in functions in files that are similar to. pact files, like the hello-world. pact file you've been working with so far. However, the files you create for testing Pact functionality use the. repl file extension. To create a basic hello-world. repl file: 1. Create a new file named hello-world. repl file in your code editor. 1. Use the built-in (begin-tx) and (commit-tx) functions to define a transaction that loads the hello-world. pact file: `pact (begin-tx) (load \"hello-world. pact\") (commit-tx) ` 2. Open a terminal shell and execute the hello-world. repl file by running the following command: `pact pact --trace hello-world. repl ` Notice that you are executing the file in a terminal shell and not in the Pact command-line interpreter. This command executes the functions defined in the hello-world. repl file and displays output in the terminal similar to the following: `bash hello-world. repl: 1: 0: Trace: Begin Tx 0 hello-world. repl: 2: 0: Trace: Loading hello-world. pact. . . hello-world. pact: 15: 0: Trace: Loaded module helloWorld, hash Nci-2EJkgvvHnVLyfOJG-WKGuQ6-tLAYWRYVGPGW2cc hello-world. pact: 24: 0: Trace: Hello, Pistolas! ~ from Kadena hello-world. repl: 3: 0: Trace: Commit Tx 0 Load successful ` To learn more, see the following topics: - Testing Pact programs - REPL-only functions Modify the module to store names One way to make the helloWorld module a more interesting sample project is to enable the contract to store greetings in a table. To modify the helloWorld module: 1. Copy the hello-world. pact file to create a new file named 2-hello-world. pact file in your code editor. 1. Modify the module code to create a schema and table for storing greeting recipient values and add functions to write and read the value from the table. For example: `pact; ; ; ; Modified \"Hello, world! \" module; ; ; ; -----------------------------------------------------------------------; ; ; ; Use semicolons (; ) for comments in smart contracts. ; ; By convention, use: ; ; ; ; - A single semicolon (; ) for short notes on a single line of code. ; ; - Two semicolons (; ; ) to describe functions or other top-level forms. ; ; - Three semicolons (; ; ; ) to separate larger sections of code. ; ; ; ; In this example, the module defines a table for storing greeting; ; names and two functions: ; ; ; ; - (say-hello-to \"name\"); ; - (greet); ; ; ; ----------------------------------------------------------------------- (module helloWorld-mod GOVERNANCE @doc \"Update the hello-world project to store names. \" (defcap GOVERNANCE () true) (defschema hello-schema @doc \"Add a schema to store the 'name' variable for the greeting recipient. \" name: string) (deftable names: {hello-schema}) (defun say-hello-to (name) @doc \"Store 'name' to say hello with. \" (write names \"name\" { 'name: name })) (defun greet () @doc \"Say hello using the stored 'name' from the hellos table. \" (with-read names \"name\" { \"name\": = name } (format \"Hello, {}! \" [name]))) ) (create-table names) (say-hello-to \"world\"); store greeting recipient \"world\" in the names table (greet); say hello! ` 1. Create a new file named 2-hello-world. repl file in your code editor. 1. Use the built-in (begin-tx) and (commit-tx) functions to define a transaction that executes the 2-hello-world. pact module: `pact (begin-tx) (load \"2-hello-world. pact\") (commit-tx) (begin-tx) (helloWorld-mod. say-hello-to \"Las Pistolas\") (helloWorld-mod. greet) (commit-tx) ` 2. Open a terminal shell and execute the 2-hello-world. repl file by running the following command: `pact pact --trace 2-hello-world. repl ` `bash 2-hello-world. repl: 1: 0: Trace: Begin Tx 0 2-hello-world. repl: 2: 0: Trace: Loading 2-hello-world. pact. . . 2-hello-world. pact: 15: 0: Trace: Loaded module helloWorld-mod, hash ZcpdtgW86UIwvwTjlgNreTErM2ECGEjh1m9nLu3AwA 2-hello-world. pact: 36: 0: Trace: TableCreated 2-hello-world. pact: 38: 0: Trace: Write succeeded 2-hello-world. pact: 39: 0: Trace: Hello, world! 2-hello-world. repl: 3: 0: Trace: Commit Tx 0 2-hello-world. repl: 4: 0: Trace: Begin Tx 1 2-hello-world. repl: 5: 0: Trace: Write succeeded 2-hello-world. repl: 6: 0: Trace: Hello, Las Pistolas! 2-hello-world. repl: 7: 0: Trace: Commit Tx 1 Load successful ` Deploy the contract After testing the contract using the Pact interpreter and the REPL file, you can deploy the contract on your development network or the Kadena test network. If you wanted to deploy this contract on the Kadena test network or a production network, you would first need to identify a namespace_ for deploying the contract and ensure that the module name is unique across all of the modules that exist in that namespace. For simplicity, you can deploy this project locally on your development network without selecting a namespace or updating the module name. However, even on the local development network, you must have an account with funds and a key to sign the transaction that deploys the contract. You can use kadena account commands to configure and fund accounts for the local development network. You can also use kadena tx commands to create transactions to deploy contracts. However, one of the simplest ways to generate keys, manage accounts, and deploy contracts is by using the Chainweaver desktop or web-based application and its integrated development environment. To complete the 00-hello-world project, you can use Chainweaver to deploy the hello-world contract on the Kadena test network. To deploy the contract on the Kadena test network using Chainweaver: 1. Open the contract you want to deploy in your code editor. For example, open the 2-hello-world. pact file in your code editor. 2. Add the free namespace before the module definition in the file and update the module name to be unique. For example: `pact (namespace \"free\") (module helloWorld-mod-pistolas GOVERNANCE. . . ) `` 3. Save the changes in the code editor. 4. Open Chainweaver and select the testnet network. 5. Click Accounts in the Chainweaver navigation pane and verify that you have at least one account with funds on at least one chain in the test network. For example: ! You must have an account with funds on a chain to continue If you don't have keys and at least one account on any chain on the test network, you need to generate keys, create an account, and fund the account on at least one chain before continuing. 6. Click Contracts in the Chainweaver navigation pane, then click Open File to select the contract you want to deploy. 7. Click Deploy to display the Configuration tab: - Select the Chain identifier for the chain where you want to deploy the contract. - Select a Transaction Sender. - Click Next. 8. On the Sign tab, select an Unrestricted Signing Key, then click Next. 9. On the Preview tab, scroll to see the Raw Response is \"Hello, world! \", then click Submit. After you click Submit, the transaction is sent to the blockchain. You can use the block explorer and the transaction request key to view the transaction results or wait for the transaction to be included in a block before closing the transaction submission dialog by clicking Done. When the transaction is mined into a block, you will have deployed your Hello World smart contract on the Kadena test network. Call the deployed contract After you deploy a contract, you can view its details and call its functions using Chainweaver. To view and call your contract: 1. Click Contracts in the Chainweaver navigation pane, if necessary, then click Module Explorer. 2. Under Deployed Contracts, search for your module name in the free namespace and chain where you deployed, then click Refresh to update the list of deployed contracts to display only your just-deployed contract. In this example, the unique module name is free. helloWorld-mod-pistolas and the contract was deployed on the testnet chain 1. ! Search for and view your deployed contract 3. Click View to display the functions and capabilities defined in your contract. 4. Click Call to call the contract functions. - Click Call for the hello function to specify a new string in quotes, then click Next. - Click Next, select an Unrestricted Signing Key for this call, then click Next. - Click Submit to submit the transaction and commit the change. After the transaction is included in a block: - Click Call for the greet function, then click Next. - Select an Unrestricted Signing Key for this call, then click Next. - Scroll to see the Raw Response uses the string you specified for the hello function. - Click Submit if you want to submit the transaction to the blockchain or close the function call without submitting the transaction. ! Call the greet function",
    "source": "coding-projects/hello-world.md",
    "title": "Hello world, revisited"
  },
  {
    "content": "Learn how to build smart contracts that allow users to create, distribute, and manage loan information. The Loans and database management project is designed to demonstrate working with multiple tables and writing more complex functions to build more complete applications. For this project, you'll build a smart contract with tables for adding and manipulating loan information with secure interactions for module administrators. For this project, you'll create three tables in the loans module: - A loans table for storing loan holder information. - A loan-history table for tracking loan history. - A loan-inventory table for holding the loan inventory balance. ! Loans project overview Before you begin Before starting this project, verify your environment meets the following basic requirements: - You have a GitHub account and can run git commands. - You have installed the Pact programming language and command-line interpreter. - You have installed the kadena-cli package and have a working directory with initial configuration settings. - You have a local development node that you can connect to that runs the chainweb-node program, either in a Docker container or on a physical or virtual computer. - You should be familiar with defining modules and using keysets. Get the starter code To get started: 1. Open a terminal shell on your computer. 2. Clone the pact-coding-projects repository by running the following command: ``bash git clone https: //github. com/kadena-docs/pact-coding-projects. git ` 3. Change to the 05-loans directory by running the following command: `bash cd pact-coding-projects/05-loans ` If you list the contents of this directory, you'll see the following files: - starter-loans. pact provides a starting point with the framework for building the loans module. - project-steps provides solutions and test cases for completing each part of the coding project. - finished-contracts provides the final code for the loans. pact module and the final loans. repl test cases for verifying module functions. 4. Open and review the starter-loans. pact file. This file outlines the tasks you need to complete for the Loans project. Follow the embedded instructions to work through the coding challenges on your own or use the detailed instructions and code provided in the next sections. Define the module and keyset As you might have seen in other coding projects, the first step in creating a new module requires defining or identifying a namespace and an administrative owner for the module. To start the module declaration: 1. Open the starter-loans. pact file in your code editor and save it as loans. pact. 1. Specify the namespace and a define a keyset for the module to use. `pact (namespace \"free\") (define-keyset \"free. loans-admin\" (read-keyset \"loan-admin-keyset\")) ` 1. Define the loans module governed by the LOANADMIN capability and enforced to use the free. loans-admin keyset: `pact (module loans LOANADMIN (defcap LOAN_ADMIN () (enforce-guard \"free. loans. loans-admin\")) ) ` 2. Create a loans. repl file in you code editor to prepare the environment for testing the loans module. For example, add test keys and data to define the namespace in your working environment and to load the module: `pact (env-keys [\"loan-admin-keyset\"]) (env-data { \"loans-admin\": { \"keys\": [\"loan-admin-keyset\"], \"pred\": \"keys-all\" } }) (begin-tx \"Define namespace\") (define-namespace \"free\" (read-keyset \"loans-admin\" ) (read-keyset \"loans-admin\" )) (commit-tx) (begin-tx) (load \"loans. pact\") (commit-tx) ` Define the schemas and tables To define the schemas and tables: 1. Open the loans. pact file in your code editor. 2. Define the loan schema and the table that uses the loan schema. `pact (defschema loan loanName: string entityName: string loanAmount: integer status: string ) (deftable loans: {loan}) ` 2. Define the loan-history schema and the table that uses the loan-history schema. `pact (defschema loan-history loanId: string buyer: string seller: string amount: integer ) (deftable loan-history-table: {loan-history}) ` 2. Define the loan-inventory schema and the table that uses the loan-inventory schema. `pact (defschema loan-inventory balance: integer ) (deftable loan-inventory-table: {loan-inventory}) ` Define constants To define the constants for loan status: 1. Define an INITIATED constant that contains the status description for loans that have been initiated using the \"initiated\" comment. `pact (defconst INITIATED \"initiated\") ` 2. Define an ASSIGNED constant that contains the status description for loans that have been assigned using the \"assigned\" comment. `pact (defconst ASSIGNED \"assigned\") ` Define functions For this coding project, the loans module provides nine functions to provide comprehensive features for loan management. You can define them in any order. - inventory-key takes loanId: string and owner: stringto create a composite key of loanId: owner. - create-a-loan takes loanId, loanName, entityName, and loanAmount to create a loan entry. - assign-a-loan takes txid, loanId, buyer, and amount to assign a loan. - sell-a-loan takes txid, loanId, buyer, seller, and amount to sell a loan. - read-a-loan takes loanId to read values from the loans table for a given loanId. - read-all-loans select all values from the loans table with constantly set to true. - read-inventory-pair takes key to set inventory-key and balance for the provided key. - read-loan-inventory maps the value of read-inventory-pair to the keys of the loan-inventory-table. - read-loans-with-status takes status to select all values from the loans-table where status equals the provided status. Define the inventory-key function To define the inventory-key function: 1. Open the loans. pact file in your code editor. 2. Start the inventory-key function definition with the keyword defun and add the parameters loanId: string owner: string. `pact (defun inventory-key (loanId: string owner: string) ) ` 3. Create a composite key from the owner and loanId in the format loanId: owner. `pact (defun inventory-key (loanId: string owner: string) (format \"{}: {}\" [loanId owner]) ) ` Define the create-a-loan function To define the create-a-loan function: 1. Open the loans. pact file in your code editor. 2. Start the create-a-loan function with the parameters loanId, loanName, entityName, and loanAmount. 3. Insert the values for the new loan loanId into the loans table. `pact (defun create-a-loan (loanId: string loanName: string entityName: string loanAmount: integer) (insert loans loanId { \"loanName\": loanName, \"entityName\": entityName, \"loanAmount\": loanAmount, \"status\": INITIATED }) ) ` 4. Insert the values for a new loan into the loan-inventory table. `pact (defun create-a-loan (loanId: string loanName: string entityName: string loanAmount: integer) (insert loans loanId { \"loanName\": loanName, \"entityName\": entityName, \"loanAmount\": loanAmount, \"status\": INITIATED }) (insert loan-inventory-table (inventory-key: string loanId: string entityName: string){ \"balance\": loanAmount }) ) ` Define the assign-a-loan function To define the assign-a-loan function: 1. Open the loans. pact file in your code editor. 2. Start the assign-a-loan function with the parameters txid, loanId, buyer, and amount. 3. Read from the loans table using loanId and bind variables to the column values. `pact (defun assign-a-loan (txid loanId buyer amount) (with-read loans loanId { \"entityName\": = entityName, \"loanAmount\": = issuerBalance } ) ` 1. Insert values into loan-history-table using the value of the txid parameter. `pact (insert loan-history-table txid { \"loanId\": loanId, \"buyer\": buyer, \"seller\": entityName, \"amount\": amount} ) ` 1. Insert values into the loan-inventory-table with the parameters inventory-key, loanId, and buyer. `pact (insert loan-inventory-table (inventory-key loanId buyer) { \"balance\": amount }) 1. Update the loan-inventory-table for the row matching the parameters inventory-key, loanId, and entityName with the new balance of the issuer. `pact (update loan-inventory-table (inventory-key loanId entityName){ \"balance\": (- issuerBalance amount) })) ` 2. Update the status in the loans table for the specified loanId. `pact (update loans-table loanId { \"status\": ASSIGNED }) ` If you want to test the functions that you've defined so far, you can update the loans. pact file to create the tables and the loans. repl file with transactions that call the functions. If you aren't sure how to make these changes, continue defining the functions, then follow the steps in Test functions in the REPL. Define the sell-a-loan function To define the sell-a-loan function: 1. Open the loans. pact file in your code editor. 2. Start the sell-a-loan function with the parameters txid, loanId, buyer, seller, and amount. 3. Read from the loan-inventory-table table using the parameters inventory-key, loanId, and seller and bind balance to value of prev-seller-balance. `pact (defun sell-a-loan (txid loanId buyer seller amount) (with-read loan-inventory-table (inventory-key loanId seller) {\"balance\": = prev-seller-balance} 1. Read from the loan-inventory-table using the parameters inventory-key, loanId, and buyer, assign balance to 0, and bind balance to value of prev-buyer-balance. `pact (with-default-read loan-inventory-table (inventory-key loanId buyer) {\"balance\": 0} {\"balance\": = prev-buyer-balance} ` 1. Insert values into the loan-history-table at the given txid. `pact (insert loan-history-table txid { \"loanId\": loanId, \"buyer\": buyer, \"seller\": seller, \"amount\": amount }) ` 1. Update the loan-inventory-table with the parameters inventory-key, loanId, and seller, and set the balance to the previous-seller-balance minus the amount. `pact (update loan-inventory-table (inventory-key loanId seller) {\"balance\": (- prev-seller-balance amount)}) ` 1. Write to the loan-inventory-table with the parameters inventory-key, loanId, and buyer, set the balance to the previous-buyer-balance plus the amount. `pact (write loan-inventory-table (inventory-key loanId buyer) {\"balance\": (+ prev-buyer-balance amount)}))) ) ` Define the read-a-loan function To define the read-a-loan function: 1. Open the loans. pact file in your code editor. 2. Start the read-a-loan function with the parameter loanId. 3. Read all of the values from the loans table at the given loanId. `pact (defun read-a-loan (loanId: string) (read loans loanId)) ` Define the read-all-loans function To define the read-all-loans function: 1. Open the loans. pact file in your code editor. 2. Start the read-all-loans function with no parameters. 1. Select all values from the loans table that have constantly set to true. `pact (defun read-all-loans () (select loans (constantly true))) ` Define the read-inventory-pair function To define the read-inventory-pair function: 1. Open the loans. pact file in your code editor. 2. Start the read-inventory-pair function with the parameter key. 3. Set the inventory-key to the provided key. 4. Set the balance value of the balance in the loan-inventory-table to the value of the key. `pact (defun read-inventory-pair (key) {\"inventory-key\": key, \"balance\": (at 'balance (read loan-inventory-table key))} ) ` Define the read-loan-inventory function To define the read-loan-inventory function: 1. Open the loans. pact file in your code editor. 2. Start the read-loan-inventory function with no parameters. 3. Map the value of the read-inventory-pair to the keys in the loan-inventory-table. `pact (defun read-loan-inventory () (map (read-inventory-pair) (keys loan-inventory-table))) ` Define the read-loans-with-status function To define the read-loans-with-status function: 1. Open the loans. pact file in your code editor. 2. Start the read-loans-with-status function that takes the parameter status. 3. Select all values from the loans table where the status equals the status parameter. `pact (defun read-loans-with-status (status) (select loans-table (where \"status\" (= status))) ` Complete the module declaration Complete the loans module by closing the module declaration and create the tables. To complete the loans module: 1. Finish the module declaration with a closing parenthesis, if you haven't already done so. `pact ) (create-table accounts-table) ` 2. Create the tables defined for the module declaration, if you haven't already done so. `pact (create-table loans) (create-table loan-inventory-table) (create-table loan-history-table) ` Test functions in the REPL To test the loans module, you need to add transactions to the loans. repl file. To test the functions in the loans. pact file: 1. Open the loans. repl file. 2. Add a transaction that loads the loans. pact file and then calls the functions that update the loan tables similar to the following: `pact (begin-tx \"Call functions that update loan tables\") (load \"loans. pact\") (inventory-key \"loanId-1\" \"Las Pistolas\"); ; loanId, owner (create-a-loan \"loanId-1\" \"Ponderosa\" \"Valley Credit\" 16000); ; loanId, loanName, entity, amount (assign-a-loan \"txid-1\" \"loanId-1\" \"Studio Funding\" 10000); ; loanId, buyer, amount (sell-a-loan \"txid-2\" \"loanId-1\" \"buyer2\" \"Studio Funding\" 2000); ; loanId, seller, buyer, amount (commit-tx) ` Because you're loading the module and calling the functions in the same transaction, you don't need to include the namespace and module name to call the functions. 3. Add a transaction that calls the functions that read loan information from the loan tables similar to the following: `pact (begin-tx \"Call functions that read loan information\") (use free. loans) (create-a-loan \"loanId-2\" \"Renovation\" \"RiverBank\" 140000) (read-a-loan \"loanId-1\") (read-all-loans) (read-loan-inventory) (read-loans-with-status INITIATED) (read-loans-with-status ASSIGNED) (commit-tx) ` In this example, you first specify that you want to use the module where the functions are defined using its namespace and module name. Similar to loading the module, you can then call individual function without including the namespace and module name. 4. Add transactions that call the individual functions similar to the following: `pact (begin-tx \"Test inventory-key function\") (free. loans. inventory-key \"loanId-3\" \"Pistolas\") (commit-tx) (begin-tx \"Test create-a-loan function\") (free. loans. create-a-loan \"loanId-3\" \"Pistolas\" \"Capital Bank\" 11000) (commit-tx) (begin-tx \"Test assign-a-loan function\") (free. loans. assign-a-loan \"txid-3\" \"loanId-3\" \"Buyer 1\" 10000); ; loanId, buyer, amount (commit-tx) ` In this example, you must specify the module where the functions are defined using the namespace and module name. 5. Open a terminal shell on your computer and test execution by running the following command: `bash pact --trace loans. repl ` You should see that the transactions are successful with output similar to the following: `pact. . . loans. pact: 4: 3: Trace: Loaded module free. loans, hash 6SCj9hDm0ANSVOqbmY3gwF4SXg9BaRi-7cV8-FbqJDY loans. pact: 162: 0: Trace: TableCreated loans. pact: 163: 0: Trace: TableCreated loans. pact: 164: 0: Trace: TableCreated loans. repl: 11: 2: Trace: loanId-1: Las Pistolas loans. repl: 12: 2: Trace: Write succeeded loans. repl: 13: 2: Trace: Write succeeded loans. repl: 14: 2: Trace: Write succeeded loans. repl: 15: 0: Trace: Commit Tx 1: Call functions that update loan tables loans. repl: 17: 0: Trace: Begin Tx 2: Call functions that read loan information loans. repl: 18: 3: Trace: Using free. loans loans. repl: 19: 3: Trace: Write succeeded loans. repl: 20: 3: Trace: {\"entityName\": \"Valley Credit\", \"loanAmount\": 16000, \"loanName\": \"Ponderosa\", \"status\": \"assigned\"} loans. repl: 21: 3: Trace: [{\"entityName\": \"Valley Credit\", \"loanAmount\": 16000, \"loanName\": \"Ponderosa\", \"status\": \"assigned\"} {\"entityName\": \"RiverBank\", \"loanAmount\": 140000, \"loanName\": \"Renovation\", \"status\": \"initiated\"}] loans. repl: 22: 3: Trace: [{\"inventory-key\": \"loanId-1: Studio Funding\", \"balance\": 8000} {\"inventory-key\": \"loanId-1: Valley Credit\", \"balance\": 6000} {\"inventory-key\": \"loanId-1: buyer2\", \"balance\": 2000} {\"inventory-key\": \"loanId-2: RiverBank\", \"balance\": 140000}] loans. repl: 23: 3: Trace: [{\"entityName\": \"RiverBank\", \"loanAmount\": 140000, \"loanName\": \"Renovation\", \"status\": \"initiated\"}] loans. repl: 24: 3: Trace: [{\"entityName\": \"Valley Credit\", \"loanAmount\": 16000, \"loanName\": \"Ponderosa\", \"status\": \"assigned\"}] loans. repl: 25: 0: Trace: Commit Tx 2: Call functions that read loan information loans. repl: 27: 0: Trace: Begin Tx 3: Test inventory-key function loans. repl: 28: 2: Trace: loanId-3: Pistolas loans. repl: 29: 0: Trace: Commit Tx 3: Test inventory-key function loans. repl: 31: 0: Trace: Begin Tx 4: Test create-a-loan function loans. repl: 32: 2: Trace: Write succeeded loans. repl: 33: 0: Trace: Commit Tx 4: Test create-a-loan function loans. repl: 35: 0: Trace: Begin Tx 5: Test assign-a-loan function loans. repl: 36: 2: Trace: Write succeeded loans. repl: 37: 0: Trace: Commit Tx 5: Test assign-a-loan function Load successful `` 6. Ensure that the REPL output aligns with expected results. Review You have now built and tested a smart contract that manipulates loan information in three tables with a robust set of functions.",
    "source": "coding-projects/loans.md",
    "title": "Loans in multiple tables"
  },
  {
    "content": "This coding project demonstrates how to use built-in functions for testing smart contracts using the Pact command-line interpreter REPL. The Local testing coding project demonstrates how to use built-in functions for testing smart contracts using the Pact command-line interpreter REPL. If you've explored other coding projects, you might be familiar with some of the most basic functions, such as the begin-tx and commit-tx built-in functions. This coding project introduces a more complete set of common functions for testing smart contracts in your local development environment. For this project, you'll use the loans. pact module as the sample smart contract to test. The loans module defines three tables and ten functions, making it a good candidate for learning about writing test cases. In this coding project, you'll learn about: - Using the Pact read-evaluate-print-loop (REPL) for interactive testing. - Using Pact REPL-only built-in functions. - Loading and resetting environment data. - Defining transaction blocks - Loading and using Pact modules. - Testing success and failure cases. Before you begin Before starting this project, verify your environment meets the following basic requirements: - You have a GitHub account and can run git commands. - You have installed the Pact programming language and command-line interpreter. - You have installed the kadena-cli package and have a working directory with initial configuration settings. - You have a local development node that you can connect to that runs the chainweb-node program, either in a Docker container or on a physical or virtual computer. - You should be familiar with defining modules and using keysets. Get the starter code To get started: 1. Open a terminal shell on your computer. 2. Clone the pact-coding-projects repository by running the following command: Code example (bash): git clone https: //github. com/kadena-docs/pact-coding-projects. git `` 3. Change to the 06-local-testing directory by running the following command: `bash cd pact-coding-projects/06-local-testing ` If you list the contents of this directory, you'll see the following files: - starter-testing-loans. repl provides a starting point with the framework for building the loans module. - project-steps provides test cases for completing each part of the coding project. . . . [code continues]pact (env-data { \"loans-admin\": { \"keys\": [\"loan-admin-keyset\"], \"pred\": \"keys-all\" } } ) Code example (): Similarly, you can use the env-sigs function simulate a signing key and capabilities. pact (env-sigs [ { \"key\": \"marmalade-admin\", \"caps\": [] }]) Code example (): ## Defining transaction blocks In. repl files, you define tests within transaction blocks that start with the begin-tx function and end with the commit-tx function. Within a transaction block that starts with the begin-tx function and ends with the commit-tx function, you can make as many calls to the Pact code as you like. Any command sent to the blockchain is a transaction, but a command can have multiple function calls. For example, a single transaction block is treated as one. . . [code continues]bash (begin-tx \"Test the inventory-key function\") (free. loans. inventory-key \"loanId-3\" \"Pistolas\") (commit-tx) (begin-tx \"Test the create-a-loan function\") (free. loans. create-a-loan \"loanId-3\" \"Pistolas\" \"Capital Bank\" 11000) (commit-tx) (begin-tx \"Test the assign-a-loan function\") (free. loans. assign-a-loan \"txid-3\" \"loanId-3\" \"Buyer 1\" 10000); ; loanId, buyer, amount (commit-tx) Code example (): Transactions can be grouped together however is most convenient for your testing. However, you should try to maintain a logical order in your transactions for maintenance and readability. Load a module from a Pact file Pact files are not run by your computer directly. Instead, they’re loaded into the. repl file and run from there. After you have defined environment data, such as the namespace and keyset for a module, you must load the. pact file into the. repl file using a load st. . . [code continues]bash (load \"loans. pact\") Code example (): Typically, . pact and. repl file are located in the same folder, so you only need to specify the name of the. pact file. However, if you place the files in different file locations, you must provide an absolute or relative path to the. pact file you want to load. Call module functions After the. pact file is loaded in the. repl file, you are ready to start calling module functions. Depending on how you define your transaction blocks, there are a few possible ways to call the func. . . [code continues]bash (begin-tx) (use free. loans) (create-a-loan \"loanId-2\" \"Renovation\" \"RiverBank\" 140000) (commit-tx) Code example (): For this coding project, edit the. repl file to call the following functions defined in the loans module: Function | Purpose create-a-loan | Accepts parameters to add the appropriate information to each table assign-a-loan | Assigns a loan to an entity. sell-a-loan | Sell a loan and log details in the loan history table. After calling the functions used to create, assign, and sell a loan, add tests to read some of the data that you created. For example, edit the. repl file to call the fol. . . [code continues]pact pact> (expect \"Test that addition is correct\" 4 (+ 2 2)) \"Expect: success: Test that addition is correct\" pact> (expect \"Test that addition is correct\" 4 (+ 3 2)) \"FAILURE: Test that addition is correct: expected 4: integer, received 5: integer\" Code example (): The following example demonstrates how to use the expect-failure function to evaluate whether an expression fails as an expected result: pact pact> (expect-failure \"Enforce fails on false\" (enforce false \"Expected error\")) \"Expect failure: success: Enforce fails on false\" Code example (): The following example demonstrates how to use the expect-that function to evaluate whether an expression returns the expected result: pact pact> (expect-that \"addition result is greater than 2\" (< 2) (+ 1 2)) \"Expect-that: success: addition result is greater than 2\" pact> (expect-that \"addition result is greater than 2\" (> 2) (+ 1 2)) \"FAILURE: Expect-that: Did not satisfy condition: addition result is greater than 2\" Code example (): You can find additional examples of. pact and. repl test files in the pact-examples repository. Both the expect and expect-failure functions enable you to test whether the outcome of an expression is what you expect it to be. For example, the keysets. repl demonstrates using the env-data function and expect-failure function to test use cases that are. . . [code continues]pact (expect-failure \"real keyset should fail\" (enforce-keyset \"keyset-real\")) ` Review In this coding project, you learned the basics of testing by creating transaction blocks in. repl files. Defining tests in. repl files is the most common approach to testing smart contracts locally. From these basic building blocks, you can experiment with adding and modifying tests and function calls in. repl or. pact` files to learn more.",
    "source": "coding-projects/local-testing.md",
    "title": "Local testing"
  },
  {
    "content": "This coding project demonstrates how to use the Pact built-in REST API endpoints for testing transactions on a local server. The Pact built-in server coding project demonstrates how to use the Pact built-in REST API endpoints for testing transactions on a local server. This coding project focuses on how to: - Create a YAML configuration file for the Pact built-in local server. - Create YAML execution API requests to submit transactions. - Format YAML execution requests as JSON objects. - Submit YAML requests using the Pact REST API endpoints. By becoming familiar with how to perform these tasks, you'll be better prepared to develop a full stack application that combines a Pact smart contract backend with a Javascript-based frontend. ! Pact REST API and local server Before you begin Before starting this project, verify your environment meets the following basic requirements: - You have a GitHub account and can run git commands. - You have installed the Pact programming language and command-line interpreter. - You have installed the kadena-cli package and have a working directory with initial configuration settings. - You have a local development node that you can connect to that runs the chainweb-node program, either in a Docker container or on a physical or virtual computer. - You should be familiar with defining modules and using keysets. Create a local working environment For this coding project, there's no starter code. Instead, you'll create a local working environment that includes the following: - A local project directory. - A local server configuration file. - A sample transaction execution request using the YAML API request format. - A directory for storing log files. Create a project folder To create a project folder: 1. Open a terminal shell on your computer. 2. Create a new directory named local-project to hold the project files. Code example (bash): mkdir deploy-tutorial `` 3. Change the directory to make the local-project folder your current working directory: `bash cd local-project ` Create a configuration file To create a server configuration file: 1. Create a new pact-config. yaml file for the local server configuration settings: `bash touch pact-config. yaml ` 1. Open the pact-config. yaml file in your code editor and define the following configuration settings: `bash # Configuration. . . [code continues]bash curl -H \"Content-Type: application/json\" -d '{\"listen\": \"Mvn7OBApUVCck9lPzvNJjwd2gBeq6ZFEJnXTI-R0hQQ\"}' -X POST http: //localhost: 8080/api/v1/listen Code example (): This command returns the result of the request with output similar to the following: bash {\"gas\": 0, \"result\": {\"status\": \"success\", \"data\": 3}, \"reqKey\": \"Mvn7OBApUVCck9lPzvNJjwd2gBeq6ZFEJnXTI-R0hQQ\", \"logs\": \"wsATyGqckuIvlm89hhd2j4t6RMkCrcwJeoeCYr7Th8\", \"metaData\": null, \"continuation\": null, \"txId\": 1} Code example (): ### Poll You can use the /poll endpoint to request the transaction results for multiple transactions with a single call. The /poll endpoint is similar to the /listen endpoint except that the connection is intended to run at an interval instead of remain open and accepts multiple request key hashes in the request and returns multiple transaction results. The format for calling the /poll endpoint looks similar to the following with a list of the request keys you received in response from. . . [code continues]bash curl -H \"Content-Type: application/json\" -d '{\"requestKeys\": [\"Mvn7OBApUVCck9lPzvNJjwd2gBeq6ZFEJnXTI-R0hQQ\", \"5Fu1m0crUk7MKL0Yyjg3gMPGcKuC0U4dx5Z5kBEQUz8\", \"18CToCaJXDvOPIHF-CceDw9gCpEMbpJKgLmot7I9M\", \"pdjiSC6INenbolWiuLVynXYVv1os8E9YfptltXjckU\"]}' -X POST http: //localhost: 8080/api/v1/poll Code example (): This command returns the result of the request with output similar to the following: bash {\"5Fu1m0crUk7MKL0Yyjg3gMPGcKuC0U4dx5Z5kBEQUz8\": {\"gas\": 0, \"result\": {\"status\": \"success\", \"data\": 3}, \"reqKey\": \"5Fu1m0crUk7MKL0Yyjg3gMPGcKuC0U4dx5Z5kBEQUz8\", \"logs\": \"wsATyGqckuIvlm89hhd2j4t6RMkCrcwJeoeCYr7Th8\", \"metaData\": null, \"continuation\": null, \"txId\": 1}} Code example (): The difference between the /listen and /poll endpoints is subtle, but important. You only use the /listen endpoint if you are working with a single hash to return the result. You use the /poll endpoint if you want to request the results for multiple transactions. Local You can use the /local endpoint to submit queries to the blockchain without affecting the blockchain state. The /local endpoint is similar to the /send endpoint in that it includes a cmd object with code in the. . . [code continues]bash pact --apireq transaction. yaml --local | curl -H \"Content-Type: application/json\" -d @- http: //localhost: 8080/api/v1/local Code example (): This command returns output that's similar to the output from the /send endpoint: bash {\"gas\": 0, \"result\": {\"status\": \"success\", \"data\": 3}, \"reqKey\": \"ch8h1qrsqpOtt9mIhwi1vGXM8QKc53OIGEpKUF3Yz80\", \"logs\": \"wsATyGqckuIvlm89hhd2j4t6RMkCrcwJeoeCYr7Th8\", \"metaData\": null, \"continuation\": null, \"txId\": null} Code example (): The /local endpoint is particularly useful if you want to execute a function that doesn’t need to change the state of the blockchain. In general, you should use the /local endpoint if you want to call functions that retrieve information from tha blockchain. Yoi should use the /send endpoint if you want to update information stored in the blockchain or to deploy smart contracts on the blockchain. Write and execute YAML requests At this point, you have learned how to start a local Pact. . . [code continues]pact (module helloWorld GOVERNANCE \"You can also embed comments in smart contracts by using quoted strings. \" (defcap GOVERNANCE () true) (defun say-hello(name: string) (format \"Hello, {}! ~ from Kadena\" [name]) ) ) Code example (): If you list the contents of the local-project folder, you should see the following files and folder: bash total 24 -rw-r--r-- 1 pistolas staff 236 Jan 7 10: 11 hello-world. pact drwxr-xr-x 4 pistolas staff 128 Jan 6 16: 19 http-log -rw-r--r-- 1 pistolas staff 279 Jan 6 15: 33 pact-config. yaml -rw-r--r-- 1 pistolas staff 218 Jan 6 15: 31 transaction. yaml ` To write and execute YAML requests: 1. Generate a public and secret key pair to sign transactions using a command similar to the following: `bash pact --genkey > pistolas. keys ` This command create a pistolas. keys file with a public and secret key. For example: `bash public: 6392582fe63bd6bb28d55f02e8ec75d0a668ba7b1065076ca1a630f470009f68 secret: 06fe72b8deaf96ba21734535bfb8c7e062d64b672b1c7d5179d67b7d363a3b13 ` Note that, in this example, you’re submitting requests to the built-in Pact server endpoints. If you were deploying contracts or calling functions on the Kadena development, test, or production network, your YAML request file would need to include additional information such as the network identifier and chain identifier. You can find examples of more complete YAML request files in the How to guides. 2. Write a minimal deploy-hello-world. yaml file that deploys the hello-world. pact file. `yaml # Deploy ‘Hello, world! smart contract’ codeFile: hello-world. pact data: keyPairs: - public: 6392582fe63bd6bb28d55f02e8ec75d0a668ba7b1065076ca1a630f470009f68 secret: 06fe72b8deaf96ba21734535bfb8c7e062d64b672b1c7d5179d67b7d363a3b13 ` 1. Deploy the contract by calling the /send endpoint. `bash pact --apireq deploy-hello-world. yaml | curl -H \"Content-Type: application/json\" -d @- http: //localhost: 8080/api/v1/send ` The command returns the request key. For example: `bash {\"requestKeys\": [\"7tq7i9cqTdTOA4GDoBkMDtq8aXFD3xXeiR85NWsQdA\"]} ` 2. Listen for the transaction result by calling the /listen endpoint. `bash curl -H \"Content-Type: application/json\" -d '{\"listen\": \"7tq7i9cqTdTOA4GDoBkMDtq8aXFD3xXeiR85NWsQdA\"}' -X POST http: //localhost: 8080/api/v1/listen ` The command returns the transaction result. For example: `bash {\"gas\": 0, \"result\": {\"status\": \"success\", \"data\": \"Loaded module helloWorld, hash JzE-eJ5v2GdSBbcrv5eHUN0zBARx31RpiQfAXKmLDs\"}, \"reqKey\": \"7tq7i9cqTdTOA4GDoBkMDtq8aXFD3xXeiR85NWsQdA\", \"logs\": \"PWOYLBV0TVmcdaTl3FnwEeYFETdE6Cs6pvB9I4kZGA\", \"metaData\": null, \"continuation\": null, \"txId\": 1} ` 3. Write a call-say-hello. yaml file that calls the say-hello function. `yaml # Call the say-hello-function code: (helloWorld. say-hello \"San Francisco, CA\") data: keyPairs: - public: 6392582fe63bd6bb28d55f02e8ec75d0a668ba7b1065076ca1a630f470009f68 secret: 06fe72b8deaf96ba21734535bfb8c7e062d64b672b1c7d5179d67b7d363a3b13 ` 1. Submit a transaction that calls the function by using the /send endpoint. `bash pact --apireq call-say-hello. yaml | curl -H \"Content-Type: application/json\" -d @- http: //localhost: 8080/api/v1/send ` The command returns the request key. For example: `bash {\"requestKeys\": [\"5HW7PI3eqrKt4zKVTk5HdFVO0GGmtQJr7AJwZxOto\"]} ` 2. Listen for the transaction result by calling the /listen endpoint with the request key returned. `bash curl -H \"Content-Type: application/json\" -d '{\"listen\": \"5HW7PI3eqrKt4zKVTk5HdFVO0GGmtQJr7AJwZxOto\"}' -X POST http: //localhost: 8080/api/v1/listen ` The command returns the transaction result. For example: `bash {\"gas\": 0, \"result\": {\"status\": \"success\", \"data\": \"Hello, San Francisco, CA! ~ from Kadena\"}, \"reqKey\": \"5HW7PI3eqrKt4zKVTk5HdFVO0GGmtQJr7AJwZxOto\", \"logs\": \"wsATyGqckuIvlm89hhd2j4t6RMkCrcwJeoeCYr7Th8\", \"metaData\": null, \"continuation\": null, \"txId\": 4} ` Review In this coding project, you created a project directory with a local server configuration file and a sample transaction YAML request file. You also created a http-log folder for SQLite data from the Pact server and started the Pact server locally on port number 8080. After starting the server, you used the pact --apireq command to convert the sample YAML request file into a JSON cmd object and used curl commands to send the cmd` object to the Pact server. Now that you know how to write and submit transaction requests and how to look up transaction results and submit local queries, you can begin developing more sophisticated applications to run on the Kadena blockchain.",
    "source": "coding-projects/pact-server-api.md",
    "title": "Pact built-in server"
  },
  {
    "content": "Develop a smart contract that allows users to change their account name and rotate authorized keys. The Rotate authorized keys coding project demonstrates how to create a smart contract with rotatable authorization keys and how to enforce row level permissions. This project continues to build on concepts and challenges presented in other coding projects and covered in Smart contracts topics. Specifically, this project demonstrates the following: - How you can use keysets as row level guards for assets. - How to allow users to update information in tables based on their keyset. - How to change ownership by rotating keyset values to authorize a new owner. To implement these features, you'll create an auth module with four functions, one table, and two keysets: ! Rotate authorized keys overview Before you begin Before starting this project, verify your environment meets the following basic requirements: - You have a GitHub account and can run git commands. - You have installed the Pact programming language and command-line interpreter. - You have installed the kadena-cli package and have a working directory with initial configuration settings. - You have a local development node that you can connect to that runs the chainweb-node program, either in a Docker container or on a physical or virtual computer. - You must have at least one account that's funded with KDA on at least one chain for deployment on the local development network or the Kadena test network. - You should be familiar with the basics for defining modules and using keysets. Get the starter code To get started: 1. Open a terminal shell on your computer. 2. Clone the pact-coding-projects repository by running the following command: Code example (bash): git clone https: //github. com/kadena-docs/pact-coding-projects. git `` 3. Change to the 02-rotate-auth directory by running the following command: `bash cd pact-coding-projects/02-rotate-auth ` If you list the contents of this directory, you'll see the following files: - starter-auth. pact provides a starting point with the framework for the project code and comments for every challenge. - auth. pact contains the final solution code that can be deployed. - aut. . . [code continues]pact (defun enforce-keyset-of-id (id) (with-read table id { \"keyset\": = keyset } (enforce-guard keyset) keyset) ) Code example (): The purpose of this function is only to identify the keyset associated with the specified id key-row. This function doesn’t provide access to any of the data in the row. However, other functions can call this function if they want to act on the information, for example, to place row-level restrictions on the data. To define the enforce-user-auth function: 1. Open the modified auth. pact file in your code editor. 2. Start the enforce-user-auth function definition that takes the paramete. . . [code continues]pact (defun update-data (id new-data) (enforce-keyset-of-id id) (update example-table id { \"data\": new-data }) (format \"Data updated in row {} to {}\" [id new-data])) Code example (): By calling the enforce-keyset-of-id function, this function allows users with a specific keyset to make updates to restricted information. To define the change-nickname function: 1. Open the modified auth. pact file in your code editor. 2. Start the change-nickname function definition that takes the parameters id and new-name. ``pact (defun change-nickname: string (id: string new-name: string) ) ` 2. Within the function, use the enforce-user-auth function to enforce au. . . [code continues]yaml code: |- (define-namespace (ns. create-principal-namespace (read-keyset \"k\")) (read-keyset \"k\") (read-keyset \"k\")) data: { \"k\": [ \"{{public-key}}\" ] } meta: chainId: \"{{chain-id}}\" sender: \"{{{sender-account}}}\" gasLimit: 80300 gasPrice: 0. 000001 ttl: 600 signers: - public: \"{{public-key}}\" caps: - name: \"coin. GAS\" args: [] networkId: \"{{network-id}}\" Code example (): You can use kadena tx add to replace the variables in the template with the values for your public key, sender account, chain, and network. For example: sh? Which template do you want to use: simple-define-namespace. ktpl? File path of data to use for template. json or. yaml (optional): ? Template value public-key: a6731ce7. . . 93119689? Template value chain-id: 3? Template value sender-account: k: a6731ce7. . . 93119689? Template value network-id: development? Where do you want to save the output: myNamespace Code example (): After you save the transaction to a file, you can use kadena tx sign to sign the transaction with your wallet password or public and secret keys. After signing the transaction, you can use kadena tx send to send the transaction to the blockchain network. After the transaction is complete, copy the principal namespace from the transaction results and use it to replace all occurrences of the original \"dev\" namespace. pact (namespace \"n1cc1f83c56f53b8865cc23a61e36d4b17e73ce9e\") (define-keyset \"n1cc1f83c56f53b8865cc23a61e36d4b17e73ce9e. admin-keyset\" (read-keyset \"admin-keyset\")) (module payments \"n1cc1f83c56f53b8865cc23a61e36d4b17e73ce9e. admin-keyset\". . . ) Code example (): ### Create a deployment transaction You can deploy the auth. pact module on the local development network using the same workflow of kadena tx add, sign, and send commands that you used to execute the define-namespace transaction. To deploy the module: 1. Create a new transaction template named coding-project. ktpl in the ~/. kadena/transaction-templates folder. `sh cd ~/. kadena/transaction-templates touch coding-project. ktpl ` 2. Open the coding-project. ktpl. . . [code continues]yaml code: |- (n1cc1f83c56f53b8865cc23a61e36d4b17e73ce9e. auth. create-user \"{{user-id}}\" \"{{user-nickname}}\" (read-keyset \"{{user-guard}}\")) data: {{user-guard}}: keys: - \"{{user-publicKey}}\" pred: \"{{user-predicate}}\" meta: chainId: \"{{chain-id}}\" sender: \"{{sender-account}}\" gasLimit: 2000 gasPrice: 0. 00000001 ttl: 7200 signers: - public: \"{{signer-public-key}}\" caps: [] networkId: \"{{networkId}}\" type: exec Code example (): With this template, you can create a transaction that adds the specified user id, nickname, and guard to the users-table. For example, this template prompts you to provide the user details when you run kadena tx add: sh Which template do you want to use: create-user. ktpl? File path of data to use for template. json or. yaml (optional): ? Template value user-id: sarah? Template value user-nickname: Sarah Rae Foster? Template value user-guard: sarah-keyset? Template value user-publicKey: 1d5a5e10. . . 0b242ed4? Template value user-predicate: keys-all? Template value chain-id: 3? Template value sender-account: k: 1d5a5e10. . . 0b242ed4? Template value signer-public-key: 1d5a5e10. . . 0b242ed4? Template value networkId: development? Where do you want to save the output: SARAH ``",
    "source": "coding-projects/rotate-auth.md",
    "title": "Rotate authorized keys"
  },
  {
    "content": "Build a simple contract that transfers value between two accounts, one of the most common and most important operations that smart contracts are use to perform. The Simple payments project is designed to help you build a simple contract that transfers value between two accounts. Because a blockchain acts as a digital ledger, transferring value between accounts is one of the most common blockchain operations. Knowing how to create a smart contract that can securely transfer assets is one of the most important building blocks that will enable you to create more complex applications. For this project, you'll create one Pact payments module smart contract that consists of three functions: - create-account - get-balance - pay These functions store information in a payments-table database table. The payments-table manages payments between two test accounts named Sarah and James. ! Simple payments project overview Before you begin Before starting this project, verify your environment meets the following basic requirements: - You have a GitHub account and can run git commands. - You have installed the Pact programming language and command-line interpreter. - You have installed the kadena-cli package and have a working directory with initial configuration settings. - You have a local development node that you can connect to that runs the chainweb-node program, either in a Docker container or on a physical or virtual computer. - You must have at least one account that's funded with KDA on at least one chain for deployment on the local development network or the Kadena test network. - You should be familiar with the basics for defining modules and using keysets. Get the starter code To get started: 1. Open a terminal shell on your computer. 2. Clone the pact-coding-projects repository by running the following command: Code example (bash): git clone https: //github. com/kadena-docs/pact-coding-projects. git `` 3. Change to the 01-simple-payment directory by running the following command: `bash cd pact-coding-projects/01-simple-payment ` If you list the contents of this directory, you'll see the following files: - starter-simple-payment. pact provides a starting point with the framework for the project code and comments for every challenge. - simple-payment. pact contains the final solution code that. . . [code continues]yaml code: |- (define-namespace (ns. create-principal-namespace (read-keyset \"k\")) (read-keyset \"k\") (read-keyset \"k\")) data: { \"k\": [ \"{{public-key}}\" ] } meta: chainId: \"{{chain-id}}\" sender: \"{{{sender-account}}}\" gasLimit: 80300 gasPrice: 0. 000001 ttl: 600 signers: - public: \"{{public-key}}\" caps: - name: \"coin. GAS\" args: [] networkId: \"{{network-id}}\" Code example (): You can use kadena tx add to replace the variables in the template with the values for your public key, sender account, chain, and network. For example: sh? Which template do you want to use: simple-define-namespace. ktpl? File path of data to use for template. json or. yaml (optional): ? Template value public-key: a6731ce787ece3941fcf28ce6ccf58150b55a23310e242f4bcb0498c93119689? Template value chain-id: 3? Template value sender-account: k: a6731ce787ece3941fcf28ce6ccf58150b55a23310e242f4bcb0498c93119689? Template value network-id: development? Where do you want to save the output: myNamespace Code example (): After you save the transaction to a file, you can use kadena tx sign to sign the transaction with your wallet password or public and secret keys. After signing the transaction, you can use kadena tx send to send the transaction to the blockchain network. After the transaction is complete, copy the principal namespace from the transaction results and use it to replace all occurrences of the original \"dev\" namespace. pact (namespace \"n1cc1f83c56f53b8865cc23a61e36d4b17e73ce9e\") (define-keyset \"n1cc1f83c56f53b8865cc23a61e36d4b17e73ce9e. admin-keyset\" (read-keyset \"admin-keyset\")) (module payments \"n1cc1f83c56f53b8865cc23a61e36d4b17e73ce9e. admin-keyset\". . . ) Code example (): ### Create a deployment transaction You can deploy the simple-payment. pact module on the local development network using the same workflow of kadena tx add, sign, and send commands that you used to execute the define-namespace transaction. To deploy the module: 1. Create a new transaction template named simple-payment. ktpl in the ~/. kadena/transaction-templates folder. `sh cd ~/. kadena/transaction-templates touch simple-payment. ktpl ` 2. Open the simple-pay. . . [code continues]yaml code: |- (n1cc1f83c56f53b8865cc23a61e36d4b17e73ce9e. payments. create-account \"{{{new-account-name}}}\" {{balance}} (read-keyset \"account-guard\")) data: account-guard: keys: - {{{publicKey}}} pred: \"keys-all\" meta: chainId: \"{{chain-id}}\" sender: \"k: a6731ce787ece3941fcf28ce6ccf58150b55a23310e242f4bcb0498c93119689\" gasLimit: 2000 gasPrice: 0. 00000001 ttl: 7200 signers: - public: \"a6731ce787ece3941fcf28ce6ccf58150b55a23310e242f4bcb0498c93119689\" caps: [] networkId: \"{{network: networkId}}\" type: exec Code example (): With this template, you can create an account for Sarah with an initial balance of 100. 25 and an account for James with an initial balance of 250. 0, equivalent to executing calls like the following in the Pact REPL: pact (dev. payments. create-account \"Sarah\" 100. 25 (read-keyset \"sarah-keyset\")) \"Write succeeded\" (dev. payments. create-account \"James\" 250. 0 (read-keyset \"james-keyset\")) \"Write succeeded\" Code example (): You can also create transaction templates for the pay and get-balance functions. For example, you can create a transaction for the pay function with a template similar to the following: yaml code: |- (n1cc1f83c56f53b8865cc23a61e36d4b17e73ce9e. payments. pay \"{{sender-id}}\" \"{{receiver-id}}\" {{amount}}) data: meta: chainId: \"{{chain-id}}\" sender: \"{{sender-k-account}}\" gasLimit: 2000 gasPrice: 0. 00000001 ttl: 7200 signers: - public: \"{{sender-publicKey}}\" caps: [] networkId: \"{{network: networkId}}\" type: exec Code example (): With this template, you can create an transaction for Sarah to pay James 25. 0, equivalent to executing the following call in the Pact REPL: pact (dev. payments. pay \"Sarah\" \"James\" 25. 0) \"Sarah paid James 25. 0\" Code example (): However, this transaction requires the account associated with Sarah to have an account and funds to pay for the transaction on the chain you specify. The account must also be associated with a wallet that you've created or imported into the Kadena CLI local development environment. Similarly, you can create a transaction for the get-balance function with a template similar to the following: yaml code: |- (format \"Sarah's balance is {}\" [(n1cc1f83c56f53b8865cc23a61e36d4b17e73ce9e. payments. get-balance \"{{simple-payments-id}}\")]) data: meta: chainId: \"{{chain-id}}\" sender: \"{{sender-k-account}}\" gasLimit: 2000 gasPrice: 0. 00000001 ttl: 7200 signers: - public: \"{{sender-publicKey}}\" caps: [] networkId: \"{{network: networkId}}\" type: exec Code example (): With this template, you can create separate transactions for getting the balance for Sarah and getting the balance for James, equivalent to executing the following calls in the Pact REPL: pact (format \"Sarah's balance is {}\" [(dev. payments. get-balance \"Sarah\")]) \"Sarah's balance is 75. 25\" (format \"James's balance is {}\" [(dev. payments. get-balance \"James\")]) \"James's balance is 275. 0\" ``` Next steps Congratulations, you've just completed the Simple payments coding project. You'll see similar patterns in other coding projects, with each project introducing new features, Pact syntax, or alternative coding models. The coding projects are also intended to complement and reinforce concepts and examples presented in other parts of the documentation. Follow the links embedded in each project to learn more.",
    "source": "coding-projects/simple-payments.md",
    "title": "Simple payments"
  },
  {
    "content": "How to create a new Kadena account without transferring any digital assets into it using the coin contract function s, Kadena CLI, and Kadena client library functions. import Link from '@docusaurus/Link'; import CodeBlock from '@theme/CodeBlock'; Create new accounts This guide provides instructions and examples for creating an on-chain account without an account balance. If you want to create a new account without transferring any digital assets (KDA) into it, you can create the account with a zero balance by using an API call, the Kadena CLI, or the Kadena client TypeScript library. These examples illustrate how you can construct calls to the blockchain to create new accounts—an important operation if you're building a wallet, exchange, game, or other application where you need to register before creating transactions or interacting with your application. If you're using Chainweaver or another wallet or frontend application, this information is typically available directly through the user interface, with the application performing an operation similar to these examples behind the scenes. Note that regardless of the method you use to create new accounts, accounts must be funded on at least one network chain before you can do more than list account names and keys. Using a YAML request and curl One way you can create a new account without transferring any assets is by calling the create-account function that's defined in the coin contract deployed on the Kadena development, test, or main network. To make this call, you need to know the following information: - The account name for the account you want to create. In most cases, the account name is a public key with either the k: prefix for accounts with a single key or the w: prefix for accounts with more than one key. - The account guard for the account you want to create. For this example, you can create the request using the YAML execution file format, convert the request to JSON, then submit the API request using a curl command. You could also submit the request using Postman or other tools that enable you to call API endpoints. To create a new account: 1. Open a terminal on your local computer. 2. Check that you have curl installed by running the following command: ``bash which curl ` You should see the path to the file similar to the following: `bash /usr/bin/curl ` 3. Create a YAML execution request in a create-new-account. yaml file with content similar to the following: `yaml code: |- (coin. create-account \"k: 3e7e7db00e2e575a5260b8705ab7663574b186657451d6990316af6bc5108b59\" (read-keyset \"dev-account\")) data: dev-account: keys: [3e7e7db00e2e575a5260b8705ab7663574b186657451d6990316af6bc5108b59] pred: \"keys-all\" sigs: - public: 3e7e7db00e2e575a5260b8705ab7663574b186657451d6990316af6bc5108b59 caps: [] networkId: development publicMeta: chainId: \"3\" sender: \"k: 3e7e7db00e2e575a5260b8705ab7663574b186657451d6990316af6bc5108b59\" gasLimit: 100000, gasPrice: 0. 0000001, ttl: 7200, type: exec ` As you can see in this example: - The transaction request calls the coin. create-account function. - The account name is k: 3e7e7db00e2e575a5260b8705ab7663574b186657451d6990316af6bc5108b59. - The network identifier is development. - The chain identifier for the account balance is chain 3. The gasLimit, gasPrice, and ttl values represent reasonable settings. 4. Convert the YAML execution request to a JSON object with proper formatting using the pact --apireq command with a command similar to the following: `bash pact --apireq create-new-account. yaml --local ` This command displays the resulting JSON as standard output. For example: `bash {\"hash\": \"mEwOLFgd1rpFQVywNrFU5uDr6vu6nNuYe76Sy30yZks\", \"sigs\": [], \"cmd\": \"{\\\"networkId\\\": \\\"development\\\", \\\"payload\\\": {\\\"exec\\\": {\\\"data\\\": {\\\"dev-account\\\": {\\\"pred\\\": \\\"keys-all\\\", \\\"keys\\\": [\\\"3e7e7db00e2e575a5260b8705ab7663574b186657451d6990316af6bc5108b59\\\"]}}, \\\"code\\\": \\\"(coin. create-account \\\\\\\"k: 3e7e7db00e2e575a5260b8705ab7663574b186657451d6990316af6bc5108b59\\\\\\\" (read-keyset \\\\\\\"dev-account\\\\\\\"))\\\"}}, \\\"signers\\\": [], \\\"meta\\\": {\\\"creationTime\\\": 1731622872, \\\"ttl\\\": 7200, \\\"gasLimit\\\": 100000, \\\"chainId\\\": \\\"3\\\", \\\"gasPrice\\\": 1. 0e-7, \\\"sender\\\": \\\"k: 3e7e7db00e2e575a5260b8705ab7663574b186657451d6990316af6bc5108b59\\\"}, \\\"nonce\\\": \\\"2024-11-14 22: 21: 12. 353978 UTC\\\"}\"} ` 5. Connect to the Pact /local endpoint for the appropriate network with a command similar to the following: `bash curl -X POST \"localhost: 8080/chainweb/0. 0/development/chain/3/pact/api/v1/local\" \\ -H \"Content-Type: application/json\" \\ -d '{\"hash\": \"M0QiiKfHiqQxTjjac42ogaOZRq5ayJ3gJzaa-zSO8dY\", \"sigs\": [], \"cmd\": \"{\\\"networkId\\\": \\\"development\\\", \\\"payload\\\": {\\\"exec\\\": {\\\"data\\\": {\\\"ks\\\": {\\\"pred\\\": \\\"keys-all\\\", \\\"keys\\\": [\\\"3e7e7db00e2e575a5260b8705ab7663574b186657451d6990316af6bc5108b59\\\"]}}, \\\"code\\\": \\\"(coin. create-account \\\\\\\"k: 3e7e7db00e2e575a5260b8705ab7663574b186657451d6990316af6bc5108b59\\\\\\\" (read-keyset \\\\\\\"dev-account\\\\\\\"))\\\"}}, \\\"signers\\\": [], \\\"meta\\\": {\\\"creationTime\\\": 1731622251, \\\"ttl\\\": 7200, \\\"gasLimit\\\": 100000, \\\"chainId\\\": \\\"3\\\", \\\"gasPrice\\\": 1. 0e-7, \\\"sender\\\": \\\"k: 3e7e7db00e2e575a5260b8705ab7663574b186657451d6990316af6bc5108b59\\\"}, \\\"nonce\\\": \\\"2024-11-14 22: 10: 51. 406013 UTC\\\"}\"}' ` The command returns JSON output similar to the following: `json {\"gas\": 207, \"result\": {\"status\": \"success\", \"data\": \"Write succeeded\"}, \"reqKey\": \"mEwOLFgd1rpFQVywNrFU5uDr6vu6nNuYe76Sy30yZks\", \"logs\": \"wsATyGqckuIvlm89hhd2j4t6RMkCrcwJe_oeCYr7Th8\", \"metaData\": {\"publicMeta\": {\"creationTime\": 1731622872, \"ttl\": 7200, \"gasLimit\": 100000, \"chainId\": \"3\", \"gasPrice\": 1. 0e-7, \"sender\": \"k: 3e7e7db00e2e575a5260b8705ab7663574b186657451d6990316af6bc5108b59\"}, \"blockTime\": 1731623003519300, \"prevBlockHash\": \"RwovCQazuph9FHvpUKRO8eUNfWHuabpgXBrDFWB0m3g\", \"blockHeight\": 240}, \"continuation\": null, \"txId\": null} ` Using kadena-cli commands If you have installed the kadena-cli package in your development environment, you can use the kadena account add command to add a new account to the local development environment for interacting with the development, test, or main network. To add an account balance using kadena-cli: 1. Open a terminal on your local computer. 2. Check that you have kadena installed by running the following command: `bash which kadena ` You should see the path to the file similar to the following: `bash /usr/local/bin/kadena ` 3. Add the account with interactive prompting by running the following command: `bash kadena account add ` You can add the account by manually providing a public key or add an account from a wallet. Follow the prompts displayed to enter an account alias, account name, fungible type, public key, network, and chain. After you provide the information required, the command returns confirmation of the account. For example: `bash The account configuration \"sf-devnet\" has been saved in /Users/pistolas/. kadena/accounts/sf-devnet. yaml ` Using the Kadena client library If you're familiar with JavaScript or TypeScript, you can use the @kadena/client library to write scripts for common tasks. The @kadena/client library implements a TypeScript-based API for interacting with smart contracts and Chainweb nodes. The library provides functions that simplify building transactions with Pact commands and connecting to blockchain nodes. You should note that creating the client connection is separate from using the Pact. builder` function to construct transactions. For an example of creating a new account using the Kadena client (@kadena) library functions in a TypeScript program, see the create-account sample code.",
    "source": "guides/accounts/create-new-accounts.md",
    "title": "Create new accounts"
  },
  {
    "content": "How to create a new Kadena account by transferring digital assets into it using the coin contract function, Kadena CLI, and Kadena client library. --- title: Fund on-chain accounts description: \"How to create a new Kadena account by transferring digital assets into it using the coin contract function, Kadena CLI, and Kadena client library. \" id: howto-fund-accounts --- import Link from '@docusaurus/Link'; import CodeBlock from '@theme/CodeBlock'; Fund on-chain accounts The Kadena coin contract provides two functions for funding an on-chain account: - transfer-create - transfer You can use the transfer-create function to create and fund new accounts in a single step if you have access to funds and control a keyset with access to the funds. You can use the transfer function any time you want to transfer assets between existing accounts. This guide provides instructions and examples for creating an on-chain account by transferring digital assets (KDA) into the account using an API call, Kadena CLI with YAML configuration, and the Kadena client TypeScript library. Using a YAML request and curl One way you can create and fund a new account is by calling the transfer-create function that's defined in the coin contract deployed on the Kadena development, test, and main network. To make this call, you need to know the following information: - The account name for a funding account with funds that you control. - The public key for the receiving account you want to create. - The guard for the receiving account and the amount to transfer. For this example, you can create the request using the YAML execution file format, convert the request to JSON, then submit the API request using a curl command. You could also submit the request using Postman or other tools that enable you to call API endpoints. To create and fund a new account: 1. Open a terminal on your local computer. 2. Check that you have curl installed by running the following command: Code example (bash): which curl `` You should see the path to the file similar to the following: `bash /usr/bin/curl ` 3. Create a YAML execution request in a fund-new-account. yaml file with content similar to the following: `yaml code: |- (coin. transfer-create \"k: 3e7e7db00e2e575a5260b8705ab7663574b186657451d6990316af6bc5108b59\" \"9a23bf6a61f753d3ffa45c02b33c65b9dc80b8fb63857debcfe21fdb170fcd99\"(read-keyset \"receiver-guard\") 1. 0) data: receiver-guard: key. . . [code continues]javascript import { Pact, createClient } from '@kadena/client'; const transferKDA = async (from, to, amount, pubKey) => { const client = createClient('https: //api. chainweb. com/chainweb/0. 0/mainnet01/chain/1/pact'); const transaction = Pact. builder. execution((coin. transfer \"${from}\" \"${to}\" ${amount})). addSigner(pubKey, (signFor) => [ signFor('coin. TRANSFER', from, to, amount), signFor('coin. GAS'), ]). setMeta({ chainId: '1', gasLimit: 2500, gasPrice: 0. 000001, sender: from, }). setNetworkId('mainnet01'). createTransaction(); try { const signedTx = await signWithChainweaver(transaction); // Pick your preferred signing method const preflightResult = await client. preflight(signedTx); console. log('Preflight result: ', preflightResult); if (preflightResult. result. status === 'failure') { console. error('Preflight failed: ', preflightResult. result. error. message); return preflightResult; } const res = await client. submit(signedTx); console. log('Transaction submitted: ', res); return res; } catch (error) { console. error('Error transferring KDA: ', error); } }; transferKDA('your-from-account', 'your-to-account', 0. 1). catch(console. error); ``",
    "source": "guides/accounts/fund-accounts.md",
    "title": "Fund on-chain accounts"
  },
  {
    "content": "How to check account balances for existing account using an API call to the coin contract get-balance function, Kadena command-line interface, and Kadena client library functions. --- title: Check account balances description: \"How to check account balances for existing account using an API call to the coin contract get-balance function, Kadena command-line interface, and Kadena client library functions. \" id: howto-get-balances --- import Link from '@docusaurus/Link'; import CodeBlock from '@theme/CodeBlock'; Check account balances This guide provides instructions and examples for checking an account balance using an API call, Kadena CLI commands, and the Kadena client TypeScript library. These examples illustrate how you can construct calls to the blockchain to get an account balance—an important operation if you're building a wallet, exchange, game, or other application where you need to retrieve and display account information. If you're using Chainweaver or another wallet or frontend application, this information is typically available directly through the user interface, with the application performing an operation similar to these examples behind the scenes. Using a YAML request and curl One way yu can get an account balance is by calling the get-balance function that's defined in the coin contract deployed on the Kadena public main or test network. To make this call, you need to know the following information: - The account name for the account you want to look up. - The network identifier where you want to check the account balance. - The specific chain identifier for the balance you want to check. For this example, you can create the request using the YAML execution file format, convert the request to JSON, then submit the API request using a curl command. You could also submit the request using Postman or other tools than enable you to call API endpoints. To get an account balance: 1. Open a terminal on your local computer. 2. Check that you have curl installed by running the following command: ``bash which curl ` You should see the path to the file similar to the following: `bash /usr/bin/curl ` 3. Create a YAML execution request in a get-balance. yaml file with content similar to the following: `yaml code: (coin. get-balance \"k: 4fe7981d36997c2a327d0d3ce961d3ae0b2d38185ac5e5cd98ad90140bc284d0\") data: {} sigs: - public: \"4fe7981d36997c2a327d0d3ce961d3ae0b2d38185ac5e5cd98ad90140bc284d0\" caps: [] networkId: testnet04 publicMeta: chainId: \"1\" sender: \"k: 4fe7981d36997c2a327d0d3ce961d3ae0b2d38185ac5e5cd98ad90140bc284d0\" gasLimit: 100000, gasPrice: 0. 0000001, ttl: 7200, type: exec ` As you can see in this example: - The transaction request calls the coin. get-balance function. - The account name is k: 4fe7981d36997c2a327d0d3ce961d3ae0b2d38185ac5e5cd98ad90140bc284d0. - The network identifier is testnet04. - The chain identifier for the account balance is chain 1. The gasLimit, gasPrice, and ttl values represent reasonable settings. 4. Convert the YAML execution request to a JSON object with proper formatting using the pact --apireq command with a command similar to the following: `bash pact --apireq get-balance. yaml --local ` This command displays the resulting JSON as standard output. For example: `bash {\"hash\": \"8bZdo6EG-WVl5CqQLcsAkYOchfdujjdqsrsNYRQDXw\", \"sigs\": [], \"cmd\": \"{\\\"networkId\\\": \\\"testnet04\\\", \\\"payload\\\": {\\\"exec\\\": {\\\"data\\\": {}, \\\"code\\\": \\\"(coin. get-balance \\\\\\\"k: 4fe7981d36997c2a327d0d3ce961d3ae0b2d38185ac5e5cd98ad90140bc284d0\\\\\\\")\\\"}}, \\\"signers\\\": [], \\\"meta\\\": {\\\"creationTime\\\": 1726864470, \\\"ttl\\\": 7800, \\\"gasLimit\\\": 100000, \\\"chainId\\\": \\\"1\\\", \\\"gasPrice\\\": 1. 0e-7, \\\"sender\\\": \\\"k: 4fe7981d36997c2a327d0d3ce961d3ae0b2d38185ac5e5cd98ad90140bc284d0\\\"}, \\\"nonce\\\": \\\"2024-09-20 20: 34: 30. 276972 UTC\\\"}\"} ` Alternatively, you can save the result from the pact --apireq command in a file with a command similar to the following: `bash pact --apireq get-balance. yaml --local > get-balance. json ` Copy the output from the pact --apireq command to pass as the request body in the next step. 5. Connect to the Pact /local endpoint for the appropriate network with a command similar to the following: `bash curl -X POST \"https: //api. testnet. chainweb. com/chainweb/0. 0/testnet04/chain/1/pact/api/v1/local\" \\ -H \"Content-Type: application/json\" \\ -d '{\"hash\": \"8bZdo6EG-WVl5CqQLcsAkYOchfdujjdqsrsNYRQDXw\", \"sigs\": [], \"cmd\": \"{\\\"networkId\\\": \\\"testnet04\\\", \\\"payload\\\": {\\\"exec\\\": {\\\"data\\\": {}, \\\"code\\\": \\\"(coin. get-balance \\\\\\\"k: 4fe7981d36997c2a327d0d3ce961d3ae0b2d38185ac5e5cd98ad90140bc284d0\\\\\\\")\\\"}}, \\\"signers\\\": [], \\\"meta\\\": {\\\"creationTime\\\": 1726864470, \\\"ttl\\\": 7800, \\\"gasLimit\\\": 100000, \\\"chainId\\\": \\\"1\\\", \\\"gasPrice\\\": 1. 0e-7, \\\"sender\\\": \\\"k: 4fe7981d36997c2a327d0d3ce961d3ae0b2d38185ac5e5cd98ad90140bc284d0\\\"}, \\\"nonce\\\": \\\"2024-09-20 20: 34: 30. 276972 UTC\\\"}\"}' ` The command returns output similar to the following: `json { \"gas\": 20, \"result\": { \"status\": \"success\", \"data\": 20 }, \"reqKey\": \"8bZdo6EG-WVl5CqQLcsAkYOchfdujjdqsrsNYRQDXw\", \"logs\": \"wsATyGqckuIvlm89hhd2j4t6RMkCrcwJeoeCYr7Th8\", \"metaData\": { \"publicMeta\": { \"creationTime\": 1726864470, \"ttl\": 7800, \"gasLimit\": 100000, \"chainId\": \"1\", \"gasPrice\": 1. 0e-7, \"sender\": \"k: 4fe7981d36997c2a327d0d3ce961d3ae0b2d38185ac5e5cd98ad90140bc284d0\"}, \"blockTime\": 1726864883870724, \"prevBlockHash\": \"mBRDF6NQwFbvo4vHaF-5aS384lCYx1UB2Nj1pBfaeM\", \"blockHeight\": 4662494}, \"continuation\": null, \"txId\": null } ` In this example, the account k: 4fe7981d36997c2a327d0d3ce961d3ae0b2d38185ac5e5cd98ad90140bc284d0 has a balance of 20 coins on chain 1 of the Kadena testnet04 network. Using kadena-cli commands If you have installed the kadena-cli package in your development environment, you can use the kadena account details command to look up account balances on the development, test, or main network. To get an account balance using kadena-cli: 1. Open a terminal on your local computer. 2. Check that you have kadena installed by running the following command: `bash which kadena ` You should see the path to the file similar to the following: `bash /usr/local/bin/kadena ` If you want to check the account balance for an account you added using the kadena account add command, you can use the kadena account list to review all of the accounts available in your development environment. For this example, running kadena account list --account-alias=\"all\" returns the following results: `bash Account Alias: pistolas-local Account Name k: fe4b6da332193cce4d3bd1ebdc716a0e4c3954f265c5fddd6574518827f608b7 Fungible coin Predicate keys-all Public Keys fe4b6da332193cce4d3bd1ebdc716a0e4c3954f265c5fddd6574518827f608b7 filepath /Users/lisagunn/. kadena/accounts/pistolas-local. yaml Account Alias: pistolas-testnet Account Name k: bbccc99ec9eeed17d60159fbb88b09e30ec5e63226c34544e64e750ba424d35e Fungible coin Predicate keys-all Public Keys bbccc99ec9eeed17d60159fbb88b09e30ec5e63226c34544e64e750ba424d35e filepath /Users/lisagunn/. kadena/accounts/pistolas-testnet. yaml ` If you know the account name, network, and chain where you want to check the account balance, you can go directly to the next step. 3. Check the account balance with interactive prompting by running the following command: `bash kadena account details ` Select an account name: `bash? Select an account (alias - account name): (Use arrow keys) ❯ Enter an account name manually: pistolas-local - k: fe4b6d. . . . 27f608b7 pistolas-testnet - k: bbccc9. . . . a424d35e ` Select the network: `bash? Select a network: (Use arrow keys) ❯ devnet mainnet testnet ` Enter one or more chain identifiers: `bash? Enter a ChainId (0-19) (comma or hyphen separated e. g 0, 1, 2 or 1-5 or all): ` After you provide the information required, the command returns account details including the account balance for each chain identifier you specified. For example: `bash Details of account \"pistolas-testnet\" on network \"testnet04\" Name ChainID Public Keys Predicate Balance k: bbccc99ec9ee. . . . 4e750ba424d35e 1 bbccc99ec9eeed17d60159fbb88b09e30ec5e63226c34544e64e750ba424d35e keys-all 303. 97768665622 k: bbccc99ec9ee. . . . 4e750ba424d35e 3 bbccc99ec9eeed17d60159fbb88b09e30ec5e63226c34544e64e750ba424d35e keys-all 10 Success with Warnings: Account \"k: bbccc99ec9eeed17d60159fbb88b09e30ec5e63226c34544e64e750ba424d35e\" is not available on following chain(s): 2 on network \"testnet04\" ` The command output also includes the command executed. For example: ` Executed: kadena account details --account=\"pistolas-testnet\" --network=\"testnet\" --chain-ids=\"1-3\" ` If you want to check an account balance without interactive prompting, you can specify all of the required arguments in a single command. For example: `bash kadena account details --account=\"pistolas-local\" --network=\"devnet\" --chain-ids=\"3\" ` In this case, there are no warnings, so the command simply returns the account details: `bash Details of account \"pistolas-local\" on network \"development\" Name ChainID Public Keys Predicate Balance k: fe4b6da33219. . . . 74518827f608b7 3 fe4b6da332193cce4d3bd1ebdc716a0e4c3954f265c5fddd6574518827f608b7 keys-all 14 ` Using a transaction template You can also create a transaction template for checking account balances. Transaction templates are similar to YAML execution requests like the one in Using a YAML request and curl. However, transaction templates allow you to use variables for input values that can be set when adding and executing transactions using Kadena CLI commands. To get an account balance using kadena-cli and a transaction template: 1. Open a terminal on your local computer. 2. Check that you have kadena installed by running the following command: `bash which kadena ` You should see the path to the file similar to the following: `bash /usr/local/bin/kadena ` 3. Create a YAML API request file to use as a transaction template with the variables required to call the coin. get-balance function: `yaml code: |- (coin. get-balance \"{{{account}}}\") meta: chainId: '{{chain-id}}' sender: '{{{tx-sender}}}' gasLimit: 600 gasPrice: 0. 000001 ttl: 600 networkId: '{{network: networkId}}' signers: - public: \"{{signer-key}}\" caps: [] type: exec ` You can learn more about transaction templates, variables, and inputting values in Construct transactions. For more information about using YAML request files for transactions, see Formatting API requests in YAML. 4. Save the file with the. ktpl file extension in the. kadena/transaction-templates folder. For example, save the file as. kadena/transaction-templates/get-balance. ktpl in your working directory. 5. Add a transaction that uses the template by running the following command: `bash kadena tx add ` 6. Select the get-balance. ktpl template, then follow the prompts to enter the appropriate values for template variable. For this example, the prompts and values look like this: `bash? File path of data to use for template. json or. yaml (optional): ? Template value account: k: fe4b6da332193cce4d3bd1ebdc716a0e4c3954f265c5fddd6574518827f608b7? Template value chain-id: 3? Template value tx-sender: k: fe4b6da332193cce4d3bd1ebdc716a0e4c3954f265c5fddd6574518827f608b7? Select network id for template value networkId: devnet? Template value signer-key: fe4b6da332193cce4d3bd1ebdc716a0e4c3954f265c5fddd6574518827f608b7? Where do you want to save the output: pistolas-balance ` The values you enter for the command are saved in a JSON file. 1. Sign the transaction by running the following command and following the prompts displayed to select the transaction: `bash kadena tx sign ` You must select a wallet or key pair to sign the transaction and the transaction file that you want to sign. After you enter the information required, the command output confirms the signature with information similar to the following: `bash Command 1 (hash: ZBu4fPOtxhGCZUxT9clO8UqtjWXzrCNCCXNTGL6Kzw) will now be signed with the following signers: Public Key Capabilities fe4b6da332193cce4d3bd1ebdc716a0e4c3954f265c5fddd6574518827f608b7 Transaction executed code: \"(coin. get-balance \\\"k: fe4b6da332193cce4d3bd1ebdc716a0e4c3954f265c5fddd6574518827f608b7\\\")\" Transaction with hash: ZBu4fPOtxhGCZUxT9clO8UqtjWXzrCNCCXNTGL6Kzw was successfully signed. Signed transaction saved to /Users/lisagunn/. kadena/transaction-templates/transaction-ZBu4fPOtxh-signed. json Executed: kadena tx sign --tx-sign-with=\"wallet\" --tx-unsigned-transaction-files=\"pistolas-balance. json\" --wallet-name=\"pistolas-dev\" ` After signing the transaction, you can retrieve the account information without submitting the transaction or send the request to the blockchain for on-chain processing. 1. Get the account balance by running the following command: `bash --tx-signed-transaction-files transaction-ZBu4fPOtxh-signed. json ` In this example, the balance for account on the development network, chain 3—returned in the data field—is 14. `bash txSignedTransaction test result: -------------------------------------------------------------------------------- Transaction info: fileName: transaction-ZBu4fPOtxh-signed. json transactionHash: ZBu4fPOtxhGCZUxT9clO8UqtjWXzrCNCCXNTGL6Kzw Response: Response: gas: 21 result: status: success data: 14 reqKey: ZBu4fPOtxhGCZUxT9clO8UqtjWXzrCNCCXNTGL6Kzw logs: wsATyGqckuIvlm89hhd2j4t6RMkCrcwJeoeCYr7Th8 metaData: publicMeta: creationTime: 1728076660 ttl: 600 gasLimit: 600 chainId: 3 gasPrice: 0. 000001 sender: k: fe4b6da332193cce4d3bd1ebdc716a0e4c3954f265c5fddd6574518827f608b7 blockTime: 1728077254903367 prevBlockHash: MaSZcnXDBQGpnF4ZDCtuEtc1TOQRS27RWLqPf2uwmGw blockHeight: 938 continuation: null txId: null Details: chainId: 3 network: devnet networkId: development networkHost: http: //localhost: 8080 networkExplorerUrl: http: //localhost: 8080/explorer/development/tx/ Transaction Command: cmd: {\"payload\": {\"exec\": {\"code\": \"(coin. get-balance \\\"k: fe4b6da332193cce4d3bd1ebdc716a0e4c3954f265c5fddd6574518827f608b7\\\")\", \"data\": {}}}, \"nonce\": \"\", \"networkId\": \"development\", \"meta\": {\"sender\": \"k: fe4b6da332193cce4d3bd1ebdc716a0e4c3954f265c5fddd6574518827f608b7\", \"chainId\": \"3\", \"creationTime\": 1728076660, \"gasLimit\": 600, \"gasPrice\": 0. 000001, \"ttl\": 600}, \"signers\": [{\"pubKey\": \"fe4b6da332193cce4d3bd1ebdc716a0e4c3954f265c5fddd6574518827f608b7\", \"clist\": []}]} hash: ZBu4fPOtxhGCZUxT9clO8UqtjWXzrCNCC_XNTGL6Kzw sigs: [0]: sig: d13558e1d10ed5aa977232d5311eeafd04ec51d66e2b6515bda93000932f1f26b71ee8c5a4634996b2a434df45c64f7ba0808e42ec3f5df06d001304b7e7fc03 -------------------------------------------------------------------------------- Executed: kadena tx test --tx-signed-transaction-files=\"transaction-ZBu4fPOtxh-signed. json\" --tx-transaction-network=\"devnet\" ` Using the Kadena client library If you're familiar with JavaScript or TypeScript, you can use the @kadena/client library to write scripts for common tasks. The @kadena/client library implements a TypeScript-based API for interacting with smart contracts and Chainweb nodes. The library provides functions that simplify building transactions with Pact commands and connecting to blockchain nodes. You should note that creating the client connection is separate from using the Pact. builder function to construct transactions. To get an account balance using @kadena/client functions: 1. Open a terminal on your local computer. 2. Create a new file in your code editor and add code to call the getBalance function and create the client: `javascript import {Pact, createClient} from '@kadena/client' async function getBalance(account) { // Pact. builder. execution accepts a number of Pact. modules. <module>. <fun> calls const transaction = Pact. builder. execution(Pact. modules. coin'get-balance'). setMeta({ chainId: '1' }). createTransaction(); // client creation is separate from the transaction builder const staticClient = createClient('https: //api. chainweb. com/chainweb/0. 0/mainnet01/chain/1/pact'); const res = await staticClient. local(transaction, { preflight: false, signatureVerification: false, }); } getBalance(account). catch(console. error); ``",
    "source": "guides/accounts/get-balances.md",
    "title": "Check account balances"
  },
  {
    "content": "Install the Pact smart contract programming language and set up tooling for your development environment. Chainweaver integrates the management of wallets, accounts, and keys with signing and editing features that you can use as you develop smart contracts using the Pact programming language. With Chainweaver, you can build, test, and iterate on your smart contracts before deploying them to your local development network, the Kadena test network, or the Kadena main network. Chainweaver includes a built-in read-eval-print-loop (REPL) interactive interpreter that enables you to write and execute Pact code in the desktop or web-based application. You can also use Chainweaver to: - Explore smart contract modules and functions. - Define and manage authorization rules in keysets. - Deploy smart contracts on a network. - Update previously-deployed contracts. If you don't already have a Chainweaver account, you should create one using either the Chainweaver desktop application or the Chainweaver web application. After you download and install the desktop application or open Chainweaver in a browser, you can create a wallet and accounts to interact with Kadena networks. When you open and unlock Chainweaver, the navigation panel on the left is collapsed to only display icons by default. The navigation panel provides access to the tools for managing your accounts, keys, and development environment. Icon | Section | What you can do here! [](/. /img/accounts-icon. png) | Accounts | View and manage your accounts, add account names to your watch list, transfer funds between accounts and across chains, and view transaction status. ! [](/. /img/keys-icon. png) | Keys | Generate, view, and manage public keys associated with your secret key. ! [](/. /img/sig-icon. png) | Signature Builder | Construct the signatures needed to sign transactions. ! [](/. /img/contracts-icon. png) | Contracts | Access a code editor and development tools for writing, testing, and deploying Pact modules and smart contracts. ! [](/. /img/resources-icon. png) | Resources | Explore documentation and Chainweaver resources. ! [](/. /img/settings-icon. png) | Settings | Configure your network and account settings. ! [](/. /img/logout-icon. png) | Log out | Log out of the current session. For more information about using Chainweaver as your primary interface for development tasks, see Develop with Chainweaver. Connect to the development network By default, Chainweaver lets you connect to the Kadena test network and the Kadena main network. However, as you start writing Pact modules, you'll want to test and deploy them on your local development network. Before you can do that, you need to configure Chainweaver to connect to the local host and port number running the development network. To connect to the development network: 1. Click Settings in the Chainweaver navigation panel. 2. Click Network. 3. In Edit Networks, type a network name, then click Create. 4. Expand the new network, then add the localhost as a node for this network by typing 127. 0. 0. 1: 8080. If the local computer is still running the development network Docker container, you should see the dot next to the node turn green. 5. Click Ok to close the network settings. Navigate smart contracts After you connect Chainweaver to the development network, you can use Chainweaver to deploy and manage the smart contracts you develop. You can access the Chainweaver development environment by clicking Contracts in the navigation panel. After you click Contracts, Chainweaver displays common tasks and two working areas: - The left side displays a sample contract in a code editor that you can use to view and edit contract code. - The right side provides controls that enable you to navigate between contracts, view contract details, manage keys, and test operations for contracts you have deployed. The common tasks enable you to: - Browse to an open a file from the file system. - Load your contract into the Pact interactive REPL where you can run Pact commands. - Deploy the selected contract on the active blockchain network. You'll use Load into REPL and Deploy frequently as you start writing Pact modules and deploy modules on the local development network. Code editor Within the Contracts development environment, the code editor enables you to view and modify contract code using a familiar editing interface. It's similar to other code editors with support for copying and pasting text, syntax highlighting, and inline error reporting. You can hover the cursor over lines that indicate errors to view information about the problem to help you determine how to fix it. ! Inline error The Chainweaver code editor also supports formal verification. Formal verification is a process that enables you to automatically test the correctness of your code for potential errors and security vulnerabilities. With this process, you can mathematically prove that your contract has no security vulnerabilities, ensuring you can create secure code quickly and effectively. For more information about how formal verification helps you develop safer smart contracts, see Pact Formal Verification: Making Blockchain Smart Contracts Safer. Contract navigation and developer tools The right side of the Contracts development environment provides many useful features and tools for developing smart contracts. For example, there are features to help you set up your environment, run commands in the interactive REPL, read messages, and explore other modules that exist on the network. Env Select Env to view and fix errors or manage authorization data in keysets. If the error and warning detected can be fixed automatically, you'll see the Fix option. ! Environment errors In this example, the error is a missing keyset and you can click Fix to automatically create the keyset and add it to the Data section. ! New admin-keyset If you delete the keyset created for you, you can use the Data section to create a keyset by typing a keyset name, then clicking Create. By default, keysets require all of the keys associated with an account to sign transactions, so you'll see keys-all selected for the new keyset. You can also create keysets manually using the JSON format by clicking Raw, then defining the keyset name, keys, and pred values. You can see the JSON format for keysets you have created by clicking Result. ! Keyset in JSON format The pred field specifies a predicate function to use for the keyset. The predicate function returns a boolean value evaluating to true or false. In this case, the predicate option evaluated is keys-all and it returns true if all of the keys listed in the keyset—in this example, only one key—sign the transaction. REPL A great way to get started with Pact is by writing some simple code for yourself. The REPL enables you to run Pact commands directly in the browser. Select REPL to open the Pact interactive interpreter, then try running the following commands to start learning Pact syntax conventions. Numbers Pact uses prefix notation for math operators. With prefix notation, the operator precedes the values it’s operating on. For example, you can add two numbers with the following command: ``pact title=\" \" (+ 2 2) 4 Code example (): To subtract two numbers: pact title=\" \" pact>(- 4 9) -5 Code example (): To multiply two numbers: pact pact>(* 3 4) 12 Code example (): Strings You can concatenate strings using a plus (+) as a prefix. For example, you can concatenate the strings \"Hello\" and \"REPL\" with the following command: pact title=\" \" pact > (+ \"Hello\" \" REPL\") “Hello REPL” Code example (): Lists You can specify lists using square brackets ([ ]) with or without commas. For example, you can specify the elements in a list without using commas: pact pact> [1 2 3] [1 2 3] Code example (): To specify the elements in a list using commas: pact pact>[\"blue\", \"yellow\", \"green\"] [\"blue\" \"yellow\" \"green\"] Code example (): Objects You can create objects using curly braces ({ }) with key-value pairs separated by a colon (: ). For example: pact pact> { \"foo\": (+ 1 2), \"bar\": \"baz\" } { \"foo\": 3, \"bar\": \"baz\" } `` You can view more commands to try in Syntax and keywords and Pact functions. Run commands in the code editor You can also run commands in the code editor. To run commands in the code editor, delete existing code from the code editor type a command, then click Load into REPL. Messages Code editors often provide messages to help you identify errors and log outputs. These messages are useful for debugging programs and fixing potential issues with your contract. Select Messages to view messages from the code editor in Chainweaver. Module Explorer Select Module Explorer to open and view sample smart contracts, search for and view deployed contracts, and call functions from any contract that exists on the active network. ! Module explorer Under Examples, you can click Open next to an example contract name to load the contract into the code editor. You can modify the code in the editor and reload the original contract code at any time, if needed. Click View to explore the Pact modules in a contract. For example, if you select the Simple Payment contract, then click View for the payments modules, you'll see the functions and capabilities defined in the payments module. ! Simple payment functions and capabilities Under Deployed Contracts, you san search for any contract that has been deployed to the network using the Module Explorer by name, by chain, or by navigating the pages using the arrow buttons. After you select a deployed contract, you can click View to see details about what's defined in the contract, including implemented interfaces, functions, capabilities, and pact included in the contract. You can click Open to see the full contract code in the code editor. You can also call individual functions from within the Module Explorer. You'll learn more about navigating modules and calling functions in coding projects.",
    "source": "guides/chainweaver.md",
    "title": "Develop with Chainweaver"
  },
  {
    "content": "Quick reference for common tasks import Tabs from '@theme/Tabs'; import TabItem from '@theme/TabItem'; import CodeBlock from '@theme/CodeBlock'; Common task quick reference This guide provides a quick reference for the most common API calls: - Check account balances - Transfer coins - Deploy smart contracts Regardless of the method you choose, each task requires you to connect to an appropriate network endpoint with a payload in the expected format. The payload contains all of the information required to complete the task. The difference between using the API directly or the abstraction provided by the Kadena CLI or Kadena. js libraries is simply in how you deliver the request. Check account balances <Tabs> <TabItem value=\"api\" label=\"API\" default> Call the coin. get-balance function with the account name string as an argument using curl and a JSON object. For principal accounts, the account name starts with a prefix. For example, the k: prefix for single key accounts or the w: prefix for accounts with multiple keys. Code example (bash): curl -X POST \"https: //api. chainweb. com/chainweb/0. 0/testnet04/chain/1/pact/api/v1/local\" \\ -H \"Content-Type: application/json\" \\ -d '{ \"exec\": { \"data\": {}, \"code\": \"(coin. get-balance \\\"k: <account-public-key>\\\")\" }, \"meta\": { \"chainId\": \"1\", \"sender\": \"k: <account-public-key>\", \"gasLimit\": 100000, \"gasPrice\": 0. 0000001, \"ttl\": 7200 } }' `` </TabItem> <TabItem value=\"cli\" label=\"Kadena. . . [code continues] </TabItem> </Tabs> Transfer coins <Tabs> <TabItem value=\"api\" label=\"API\" default> Call the coin. transfer function with the sender, receiver, and amount as arguments using curl and a JSON object. Code example (bash): curl -X POST \"https: //api. chainweb. com/chainweb/0. 0/testnet04/chain/1/pact/api/v1/send\" \\ -H \"Content-Type: application/json\" \\ -d '{ \"cmds\": [{ \"hash\": \"<transaction-hash>\", \"sigs\": [\"<your-signature>\"], \"cmd\": \"{\\\"networkId\\\": \\\"testnet04\\\", \\\"payload\\\": {\\\"exec\\\": {\\\"data\\\": {\\\"amount\\\": 10. 0, \\\"receiver\\\": \\\"k: <receiver-public-key>\\\"}, \\ \"code\\\": \\\"(coin. transfer \\\\\\\"k: <sender-public-key>\\\", \\\"clist\\\": [{\\\"args\\\": [\\\"k: <sender-public-key>\\\", . . . [code continues] </TabItem> </Tabs> Deploy smart contracts <Tabs> <TabItem value=\"api\" label=\"API\" default> Connect to the Pact API send endpoint to submit a transaction that deploys a smart contract. Code example (bash): curl -X POST \"https: //api. chainweb. com/chainweb/0. 0/testnet04/chain/1/pact/api/v1/send\" \\ -H \"Content-Type: application/json\" \\ -d '{ \"cmds\": [{ \"hash\": \"<transaction-hash>\", \"sigs\": [\"<your-signature>\"], \"cmd\": \"{\\\"networkId\\\": \\\"testnet04\\\", \\\"payload\\\": {\\\"exec\\\": {\\\"data\\\": {}, \\\"code\\\": \\\"(namespace \\'free)\\n(define-keyset \\'free. vote-testing-keyset (read-keyset \\'vote))\\n(module vote-testing \\'free. vote-testing-keyset\\n (defschema vote\\n v. . . [code continues]javascript import { Pact, createClient, signWithChainweaver } from '@kadena/client'; async function deployContract(deployer, pubKey) { const pactClient = createClient('https: //api. chainweb. com/chainweb/0. 0/mainnet01/chain/0/pact'); const tx = Pact. builder. execution( (namespace 'free) (module simplemodule GOV (defcap GOV () true) (defconst TEXT: string \"Hello World\") (defun greet: string () TEXT) )). addSigner(pubKey, (signFor) => [signFor('coin. GAS')]). setMeta({ chainId: '1', gasLimit: 80300, gasPrice: 0. 000001, sender: deployer, }). setNetworkId('mainnet01'). createTransaction(); try { const signedTx = await signWithChainweaver(transaction); // Pick your preferred signing method const preflightResult = await client. preflight(signedTx); console. log('Preflight result: ', preflightResult); if (preflightResult. result. status === 'failure') { console. error('Preflight failed: ', preflightResult. result. error. message); return preflightResult; } const res = await client. submit(signedTx); console. log('Contract deployed: ', res); return res; } catch (error) { console. error('Error deploying contract: ', error); } }; deployContract('your-deployer-account', contractCode). catch(console. error); `` </TabItem> </Tabs>",
    "source": "guides/common-tasks-tabs.md",
    "title": "Common task quick reference"
  },
  {
    "content": "A guide to deploying smart contracts using an API call, the Kadena CLI, and Kadena.js This guide provides instructions and examples for deploying a smart contract by using an API call, the Kadena CLI, or the Kadena client TypeScript library. Using a YAML request and curl One way you can deploy a new smart contract is by constructing a YAML execution request, formatting the request as a JSON object, and sending the request to an API endpoint using the curl command. You could also submit the request using Postman or other tools that enable you to call API endpoints directly. However, formatting an API request manually is typically an error-prone process and inserting full contract code—even for a simple contract—into a YAML configuration file can often lead to unexpected results or errors. In most cases, constructing a transaction to deploy a smart contract is less error-prone if you use the Kadena CLI. The Kadena CLI uses the Kadena client library as a foundation for abstracting and simplifying interaction with the blockchain. If you want to deploy a contract by using the curl command directly, the following example illustrates the steps involved. To deploy a smart contract with a curl command: 1. Generate a public and secret key pair and save them to a file. Code example (bash): pact --genkey > pistolas. yaml `` For this example, the following keys are used: `yaml public: 3bdb1d3c48a1bb5f072b067e265ce5d9a5eabf5e290128be4d2623dd559ca698 secret: 682ce35a77eece5060537632423de96b965136bd7739c5064903612c0b300608 ` Use the public key to create and fund an account on at least one chain in the development, test, or main network, For example: - Use kadena account add to add an account for the public key manually in the development network. . . [code continues]typescript import type { ICommand } from '@kadena/client'; import { Pact, createClient } from '@kadena/client'; import { createRequestToSign } from '. /util/requestToSign'; const signTransaction = createRequestToSign(); async function deployContract( deployerAccount: string, pubKey: string, contractCode: string, ) { const pactClient = createClient(); const tx = Pact. builder. execution(contractCode). addSigner(pubKey, (signFor) => [signFor('coin. GAS')]). setMeta({ chainId: '1', gasLimit: 80300, gasPrice: 0. 0000001, senderAccount: deployerAccount, }). setNetworkId('testnet04'). createTransaction(); try { const signedTx = (await signTransaction(tx)) as ICommand; // Pick your preferred signing method const preflightResult = await pactClient. preflight(signedTx); console. log('Preflight result: ', preflightResult); if (preflightResult. result. status === 'failure') { console. error('Preflight failed: ', preflightResult. result. error); return preflightResult; } const res = await pactClient. submit(signedTx); console. log('Deploy request sent', res); const result = await pactClient. pollOne(res); if (result. result. status === 'failure') { console. error('Deploy failed: ', result. result. error); } return result; } catch (error) { console. error('Error deploying contract: ', error); } } const deployerKDAAccount = 'k: 94eede9754031395401332c2032694da9dd2f7972fb039070f698a3173745a8b'; const deployerPublicKey = '94eede9754031395401332c2032694da9dd2f7972fb039070f698a3173745a8b'; deployContract( deployerKDAAccount, deployerPublicKey, (namespace 'free) (module simplemodule GOV (defcap GOV () true) (defconst TEXT: string \"Hello World\") (defun greet: string () TEXT) ), ). then((result) => { console. log('Contract deployed: ', result); }). catch(console. error); Code example (): The following example illustrates using a requestToSign helper script. typescript import type { ICommand, IUnsignedCommand } from '@kadena/types'; const browserPrompt = async (command: string) => { await window. navigator. clipboard. writeText(command); return Promise. resolve( window. prompt( Command: \\n${command}\\nCommand copied to the clipboard\\nEnter Signature: \\n), )? ? '', ); }; const nodePrompt = async (command: string) => { const message = Command: \\n${command}\\nEnter Signature: \\n; const readline = await import('node: readline'); const rl = readline. createInterface({ input: process. stdin, output: process. stdout, }); return new Promise<string>((resolve) => { rl. question(message, (answer) => { resolve(answer); rl. close(); }); }); }; export function createRequestToSign( prompt: (message: string) => Promise<string> = typeof window! == 'undefined'? browserPrompt: nodePrompt, ) { return async (command: IUnsignedCommand): Promise<ICommand> => { const sig = await prompt(JSON. stringify(command, null, 2)); return {. . . command, sigs: [{ sig }], }; }; } ``",
    "source": "guides/contracts/deploy-a-contract.md",
    "title": "Deploy smart contracts"
  },
  {
    "content": "The `@kadena/kadena-cli` library provides a complete set of commands for creating applications and interacting with the Kadena network interactively or by using scripts from the command-line. The Kadena command-line interface (kadena-cli) provides direct access to the Kadena blockchain and to commands that help you create, test, deploy, and manage applications for the Kadena network. You can use the Kadena command-line interface to perform tasks interactively or in scripts and automated workflows that don't allow interactive input. The Kadena CLI has one primary entry point—the kadena parent command. By providing a single entry point for performing a wide range of tasks, the Kadena CLI integrates naturally into the typical development workflow. With commands designed specifically for building, testing, and managing Kadena-based applications, you can focus on building innovative applications using familiar tools. Before you begin Before you use the Kadena command-line interface, verify the following basic requirements: - You have node, version 18 or later, installed. Run node --version to verify the version you are running. - You have the pnpm package manager installed. Depending on your development environment, you can install pnpm using a standalone script or using a package manager. For example, you can run the command brew install pnpm or npm install --global pnpm to install pnpm on your local computer. For more information about installing pnpm on different operating systems, see Installation. Run pnpm --version to verify that you have pnpm installed and the version you are running. Install The Kadena CLI is packaged in a TypeScript library that you can install using a package manager such as npm or pnpm. To install globally using npm package manager, run the following command: Code example (bash): npm install -g @kadena/kadena-cli To install globally using pnpm package manager, run the following command: Code example (bash): pnpm install -g @kadena/kadena-cli To verify the package is installed and display usage information, type kadena and press Return: Code example (bash): kadena To see the version of the package you have installed, run the following command: Code example (bash): kadena version Get started The kadena-cli package is designed to streamline the development workflow with commands that provide direct access to everything you need to build on and interact with Kadena networks. Whether you're doing local development, deploying an application on the test network, or managing your accounts and keys on the Kadena main network, you can use the kadena-cli commands to complete tasks without leaving your development environment. The following diagram provides an overview of the kadena command-line interface: ! Kadena command-line interface at a glance Prepare a development workspace You can use the kadena entry point to run commands that help you set up a complete local development environment. You can use the command-line interface to generate random keys, create local wallets, add accounts, customize network connections, and construct and send transactions. After you prepare a development workspace, you can use kadena CLI commands in combination with other tools—like Pact and Kadena client—to create, test, deploy, and manage decentralized applications for the Kadena network. Start with interactive prompting The kadena-cli package is designed to simplify setting up a development environment. Its intuitive commands prompt you for all of the information required to complete tasks, like creating accounts or managing keys. Responding to prompts interactively is typically the best approach when getting started, eliminating the need to look up or remember the arguments required for the action you want to perform. To start using the CLI in interactive Mode, you simply type kadena followed by a subject that describes the type of information you want to work with and a verb to describe what you want to do. You don't need to specify any additional arguments or options. For example, if you want to add a new wallet but aren't sure of all the required flags and arguments, you can start by entering the following command: Code example (): kadena wallet add The CLI then displays interactive prompts, asking for the information required to successfully complete the task at hand—in this example, adding the wallet to your local development environment. As you gain experience, you can reduce interactive prompting by specifying some or all of the arguments as part of the command. If you run any command without specifying all of its required parameters, the CLI prompts you to provide the missing information. Configure initial settings After installing the kadena-cli package, the first step for working with the Kadena command-line interface is to use kadena config init to create a configuration folder to store information about your development environment and connecting to Kadena networks. Depending on where you want the configuration settings available for your projects to use, you can create the configuration folder in a working directory or in your home directory. By default, a Kadena configuration folder named. kadena is created in your current working directory. The settings in the folder are then available to projects within that directory. For example, if you run kadena config init with $HOME/projects/my-kadena-project as your current working folder, you can access the. kadena configuration settings from anywhere inside the my-kadena-project project folder. Creating the configuration folder in a working directory enables you to have different configuration settings for different projects. If you want to use the same configuration settings from any folder on your computer, you can create a global configuration folder in your home directory by running the kadena config init --global command. The --global command-line option adds the kadena configuration folder to the. config folder in your home directory so that the settings are available globally on your computer. Configuration settings that are defined in a local working directory take precedence over configuration settings defined in the home directory. If you add more than one configuration folder to your development environment, you can use kadena config show to see details about the development environment you have configured in your working or global directory. To configure initial settings: 1. Open a terminal shell on the computer where you've installed the kadena-cli package. 2. Enter kadena config init on the command line to create the configuration folder interactively: ``bash kadena config init ` This command creates the. kadena configuration folder location in your current working directory and adds default network settings to a networks subfolder, then prompts you to create a wallet. For example: `bash Created configuration directory: /Users/pistolas/MY-KADENA/. kadena Added default networks: - mainnet - testnet - devnet? Would you like to create a wallet? (Use arrow keys) ❯ Yes No ` If you already have keys and an account or an existing wallet that you want to use, you can select No to end the interactive session. However, wallets are an important part of interacting with any blockchain, so you can create one now as part of your initial configuration steps. 3. Select Yes and press Return to continue setting up your local development environment. 4. Enter a wallet name and press Return. For example: `bash? Enter your wallet name: pistolas ` 5. Enter and confirm a password for the wallet to generate a public and secret key pair. For example: `bash? Enter the new wallet password: *****? Re-enter the password: ** ` After entering the password, you are prompted to create an account using the wallet key generated for your first wallet. For example: `bash? Create an account using the first wallet key? (Use arrow keys) ❯ Yes No ` 6. Select Yes to continue setting up your local development environment with a local account. 7. Enter an alias for the local account and press Return. For example: `bash? Enter an alias for an account: pistolas-kda ` The command automatically creates a local Kadena principal account and displays information about your account and wallet. For example: `bash ==================================================== == 🚨 IMPORTANT: Mnemonic Phrase 🚨 == ==================================================== Mnemonic Phrase: upset crater alien galaxy humble appear prize all glove globe music number Please store the mnemonic phrase in a SAFE and SECURE place. This phrase is the KEY to recover your wallet. Losing it means losing access to your assets. ==================================================== First keypair generated publicKey: 61cf22aa8f209b1a5549242601b4a217f034e3d931b6522ccb7743bf6c355546 Wallet Storage Location. kadena/wallets/pistolas. yaml Account created accountName: k: 61cf22aa8f209b1a5549242601b4a217f034e3d931b6522ccb7743bf6c355546 Account Storage Location. kadena/accounts/pistolas-kda. yaml Executed: kadena config init --create-wallet=\"true\" --wallet-name=\"pistolas\" --create-account=\"true\" --account-alias=\"pistolas-kda\" ` Be sure to copy and store the mnemonic phrase in a safe place. This 12-word secret phrase is required if you ever need to recover your wallet. You now have a public key that you can use to sign transactions and authorize certain activity. In this example, the public key for the wallet is 61cf22aa8f209b1a5549242601b4a217f034e3d931b6522ccb7743bf6c355546. You also have the principal account associated with the key. In this example, the principal account name is k: 61cf22aa8f209b1a5549242601b4a217f034e3d931b6522ccb7743bf6c355546. For more information about accounts names, keys, and principal accounts, see Accounts, keys, and principals. View wallet and account information At this point, you have one public and secret key pair, a local wallet, and a local account. However, this information isn't associated with a specific network—devnet, testnet, or mainnet—or with any chain identifier (0-19). Before you add the account to a specific network and chain, you might want to verify the information you have defined so far to understand the current state of your development environment. View wallet information To view information about the wallet: 1. Open a terminal shell on the computer where you've installed the kadena-cli package. 2. Enter kadena wallet list on the command line to list wallet information interactively: `bash kadena wallet list ` This command prompts you to select a wallet. For example: `bash? Select a wallet: (Use arrow keys) ❯ All Wallets pistolas ` 1. Select All Wallets, then press Return. If you have only one wallet, you should see output similar to the following: `bash Wallet: pistolas Alias Index Public key N/A 0 61cf22aa8f209b1a5549242601b4a217f034e3d931b6522ccb7743bf6c355546 Executed: kadena wallet list --wallet-name=\"all\" ` View account information To view information about the account: 1. Open a terminal shell on the computer where you've installed the kadena-cli package. 2. Enter kadena account list on the command line to list account information interactively: `bash kadena account list ` This command prompts you to select an account. For example: `bash? Select an account (alias - account name): (Use arrow keys) ❯ All accounts pistolas-kda - k: 61cf22. . . . 6c355546 ` 1. Select All accounts, then press Return. If you have only one account, you should see output similar to the following: `bash Alias Name Public Key(s) Predicate Fungible pistolas-kda k: 61cf22aa8f20. . . . 7743bf6c355546 61cf22aa8f. . . . bf6c355546 keys-all coin Executed: kadena account list --account-alias=\"all\" ` Note that the account name k: 61cf22aa8f209b1a5549242601b4a217f034e3d931b6522ccb7743bf6c355546, shortened to k: 61cf22aa8f20. . . . 7743bf6c355546, uses the default keys-all predicate and the fungible for the account is coin. The keys-all predicate is a guard. Guards define the condition that must be satisfied for an operation to proceed. In this case, all public keys associated with the k: 61cf22aa8f209b1a5549242601b4a217f034e3d931b6522ccb7743bf6c355546 account must sign transactions. The first wallet and default account information provide you with the basics for signing transactions: a public key, an account name, and a predicate. However, there aren't many practical applications that involve signing transactions using a local account. Before you can use an account to send and receive funds and sign the most common types of transactions, it must exist on a network and have funds on one or more chains. Fund your first onchain account To create an account on the Kadena main network, you need to either have KDA already or know someone who can transfer funds to your account for you. However, for local development or development on the Kadena test network, you can fund your account using kadena account commands, a faucet application, or publicly available private keys. If you created a local wallet and an account using the wallet key, you can use that information to add your account to the development or test network on one or more chains. To fund an onchain account: 1. Open a terminal shell on the computer where you've installed the kadena-cli package. 2. Enter kadena account fund on the command line to fund an account interactively: `bash kadena account fund ` 1. Select the account alias you used for your first account. For example: `bash? Select an account (alias - account name): (Use arrow keys) ❯ pistolas-kda - k: 61cf22. . . . 6c355546 ` 1. Enter an amount, then press Return. 2. For example: `bash? Enter an amount: 2 ` You can request up to 20 coins per network. If you select more than one chain in the request, the coins are distributed equally over the chain identifiers you specify. For example, if you request 20 coins for the development network and chains 0-3, each chain receives five coins. 1. Select a network, then press Return. For example, enter devnet to make this account available on the local development network: `bash? Select a network: (Use arrow keys) ❯ devnet testnet ` 2. Select one or more chain identifiers, then press Return. For example, enter all: `bash? Enter a ChainId (0-19) (comma or hyphen separated e. g 0, 1, 2 or 1-5 or all): all ` If prompted to deploy the faucet module on the network, select Yes. For example: `bash? Do you wish to deploy faucet module? (Use arrow keys) ❯ Yes No ` If you selected all chains and are deploying the faucet module, you should see output similar to the following: `bash Deployed faucet module on chain \"18, 0, 7, 12, 4, 3, 1, 6, 11, 10, 13, 9, 14, 5, 16, 15, 2, 8, 19, 17\" in \"devnet\" network. Success with Warnings: Account \"k: 61cf22aa8f209b1a5549242601b4a217f034e3d931b6522ccb7743bf6c355546\" does not exist on Chain ID(s) 3, 8, 6, 11, 1, 16, 5, 10, 2, 4, 9, 13, 0, 7, 18, 19, 15, 12, 14, 17. So the account will be created on these Chain ID(s). Transaction explorer URL for Chain ID \"0\": http: //localhost: 8080/explorer/development/tx/7vkKlYWDDyM8Ceau1gEG8G6UfwZsahYgsafEd5ak74. . . Chain ID \"19\": http: //localhost: 8080/explorer/development/tx/JbQ4KlPGxTEfeirvDd7HOj4uwFG8HVipmmNfP4YnmLM ✔ Funding account successful. Account \"k: 61cf22aa8f209b1a5549242601b4a217f034e3d931b6522ccb7743bf6c355546\" funded with 2 coin(s) on Chain ID(s) \"0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19\" in development network. Use \"kadena account details\" command to check the balance. Executed: kadena account fund --account=\"pistolas-kda\" --amount=\"2\" --network=\"devnet\" --chain-ids=\"all\" --deployFaucet ` 1. Verify account information for the account for a subset of by chains. For example, to see account details for chains 1, 2, and 3 formatted as JSON output, you can specify command-line options similar to the following: `bash kadena account details --account=\"pistolas-kda\" --network=\"devnet\" --chain-ids=\"1-3\" --json ` This command displays output similar to the following: `bash Details of account \"pistolas-kda\" on network \"development\" [ { \"1\": { \"guard\": { \"pred\": \"keys-all\", \"keys\": [ \"61cf22aa8f209b1a5549242601b4a217f034e3d931b6522ccb7743bf6c355546\" ] }, \"balance\": 2, \"account\": \"k: 61cf22aa8f209b1a5549242601b4a217f034e3d931b6522ccb7743bf6c355546\" } }, { \"2\": { \"guard\": { \"pred\": \"keys-all\", \"keys\": [ \"61cf22aa8f209b1a5549242601b4a217f034e3d931b6522ccb7743bf6c355546\" ] }, \"balance\": 2, \"account\": \"k: 61cf22aa8f209b1a5549242601b4a217f034e3d931b6522ccb7743bf6c355546\" } }, { \"3\": { \"guard\": { \"pred\": \"keys-all\", \"keys\": [ \"61cf22aa8f209b1a5549242601b4a217f034e3d931b6522ccb7743bf6c355546\" ] }, \"balance\": 2, \"account\": \"k: 61cf22aa8f209b1a5549242601b4a217f034e3d931b6522ccb7743bf6c355546\" } }, ] ` You now have one account on the development network with the same account name and public key on twenty development chains. The account on each chain has a balance of two KDA coins. To make this development environment more interesting—and learn about additional CLI commands—you can create additional accounts on the development network or the test network. Add another account There are several ways you can create additional accounts for testing in your local development environment. For example, you can: - Add another wallet with a completely new public and secret key pair (kadena wallet add). - Generate new random keys for a completely independent account (kadena key generate). - Import keys from a wallet you've previously created for a new account (kadena wallet import). - Add new keys from your first wallet to create a new account (kadena account add). The following example illustrates how to use kadena account add to create a new local account. To add a new local account: 1. Open a terminal shell on the computer where you've installed the kadena-cli package. 2. Enter kadena account add on the command line to fund an account interactively: `bash kadena account add ` You are prompted to select the method for providing the public keys for the new account. Because you already have a wallet, you can add a new account based on the public key and secret key pair generated for that wallet. If you have other keys you want to use, you can also add accounts by manually providing them. However, to keep things simple, use your first wallet. 3. Use the arrow keys to select Wallet, then press Return. For example: `bash? How would you like to add the account locally? Manually - Provide public keys to add to account manually ❯ Wallet - Provide public keys to add to account by selecting from a wallet ` 4. Select the wallet alias you set for the first wallet, then press Return. For example: `bash? Select a wallet: (Use arrow keys) ❯ Wallet: pistolas ` 5. Enter a new alias for this account, then press Return. Because you're adding a new account for this wallet, you must give it a new alias. For example: `bash? Enter an alias for an account: pistolas-local ` 6. Enter the name of a fungible for the account, then press Return. You can specify coin or nft as the fungible for an account. For most accounts, the default—coin—is appropriate. You can press Return to accept the default. `bash? Enter the name of a fungible: coin ` 7. Select the public keys that should be used for the account. You can select Generate new public key to generate a new random public key from the original wallet key pair. This key can be recovered using the same 12-word secret phrase you saved for your first wallet. For example: `bash? Select public keys to add to account(index - alias - publickey): ◯ 0 61cf22aa8f. . . . bf6c355546 ❯◉ Generate new public key ` 8. Enter the wallet password, then press Return. 9. Select a keyset predicate for the account, then press Return. If this account is only going to have one owner and one public key, select the default keys-all predicate. If an account has more than one owner and public key, select an appropriate predicate. After you select the predicate and press Return, the account information is displayed in a confirmation message similar to the following: `bash The account configuration \"pistolas-local\" has been saved in. kadena/accounts/pistolas-local. yaml Executed: kadena account add --from=\"wallet\" --wallet-name=\"pistolas\" --account-alias=\"pistolas-local\" --fungible=\"coin\" --public-keys=\"ad833b6bbfc72fb7d18b88cd5b4349f82b2f015be8e4b5e7ad28f3249fd5e105\" --predicate=\"keys-all\" ` You now have one onchain account and one local account. View updated account information After you've added a second account, you might want to check your updated information with a simple command-line option instead of interactive prompting. To verify your updated account information: 1. Open a terminal shell in your working or home directory. 1. Verify the information for all accounts by running the following command: `bash kadena account list --account-alias=\"all\" ` The command now displays information for two account similar to the following: `bash Alias Name Public Key(s) Predicate Fungible pistolas-kda k: 61cf22aa8f20. . . . 7743bf6c355546 61cf22aa8f. . . . bf6c355546 keys-all coin pistolas-local k: ad833b6bbfc7. . . . 28f3249fd5e105 ad833b6bbf. . . . 249fd5e105 keys-all coin ` Format command output In some cases, you might want to format the output from a command, so it can be used as input to another command or easier to parse. You can use the --json or --yaml flag to convert the output from virtually any CLI command to JSON or YAML format. To format the output using JSON: 1. Open a terminal shell in your working or home directory. 2. Add the --json flag to the command line. For example: `bash kadena account list --account-alias=\"all\" --json ` With the --json flag, the command displays account information in JSON format similar to the following: `bash [ { \"name\": \"k: 61cf22aa8f209b1a5549242601b4a217f034e3d931b6522ccb7743bf6c355546\", \"fungible\": \"coin\", \"publicKeys\": [ \"61cf22aa8f209b1a5549242601b4a217f034e3d931b6522ccb7743bf6c355546\" ], \"predicate\": \"keys-all\", \"alias\": \"pistolas-kda. yaml\" }, { \"name\": \"k: ad833b6bbfc72fb7d18b88cd5b4349f82b2f015be8e4b5e7ad28f3249fd5e105\", \"fungible\": \"coin\", \"publicKeys\": [ \"ad833b6bbfc72fb7d18b88cd5b4349f82b2f015be8e4b5e7ad28f3249fd5e105\" ], \"predicate\": \"keys-all\", \"alias\": \"pistolas-local. yaml\" } ] ` Add a simple transaction You must have an onchain account to sign and submit transactions that transfer funds. However, you can use local accounts for transactions that read information from the blockchain or that execute commands with local calls. The following example illustrates how to create and execute a simple transaction using a transaction template and a local account. Create a transaction template To create a transaction template: 1. Open a terminal shell in your working or home directory. . 2. Create a YAML API request file to execute a simple command similar to the following: `yaml code: ( 5 5) meta: chainId: '{{chain-id}}' sender: '{{{account: from}}}' gasLimit: 600 gasPrice: 0. 000001 ttl: 600 networkId: '{{network: networkId}}' ` This transaction uses template variables to construct a transaction. You can learn more about transaction templates and variables in Construct a transaction. For more information about using YAML request files for transactions, see Formatting API requests in YAML. 3. Save the file as a transaction template by giving it a name with the. ktpl file extension and moving the file to the. kadena/transaction-templates folder. For example, save the file as. kadena/transaction-templates/simple-code. ktpl in your working directory. Create the transaction To create a transaction from the template: 1. Create a transaction from the template by running the following command: `bash kadena tx add ` 1. Select the transaction template you created, then press Return. For example: `bash? Which template do you want to use: Select file path safe-transfer. ktpl ❯ simple-code. ktpl transfer. ktpl ` 6. Press Return to skip using a data file. 7. Specify any chain identifier, then press Return. 8. Select your local account alias as the transaction sender, then press Return. For example: `bash? Select account alias for template value account: from: Enter account manually pistolas-kda k: 61cf22. . . . 6c355546 coin 61cf2. . . . 355546 keys-all ❯ pistolas-local k: ad833b. . . . 9fd5e105 coin ad833. . . . d5e105 keys-all ` 9. Select the network for the transaction, then press Return. `bash? Select network id for template value networkId: (Use arrow keys) ❯ devnet mainnet testnet ` 10. Type a name for the transaction request JSON file, then press Return. In this example, the transaction request is named my-code. After you press Return the command displays the JSON object, the location of the file, and the command executed to create the transaction. For example: `bash { \"cmd\": \"{\\\"payload\\\": {\\\"exec\\\": {\\\"code\\\": \\\"( 5 5)\\\", \\\"data\\\": {}}}, \\\"nonce\\\": \\\"\\\", \\\"networkId\\\": \\\"development\\\", \\\"meta\\\": {\\\"sender\\\": \\\"k: ad833b6bbfc72fb7d18b88cd5b4349f82b2f015be8e4b5e7ad28f3249fd5e105\\\", \\\"chainId\\\": \\\"3\\\", \\\"creationTime\\\": 1715888245, \\\"gasLimit\\\": 600, \\\"gasPrice\\\": 0. 000001, \\\"ttl\\\": 600}, \\\"signers\\\": []}\", \"hash\": \"hyu6NGeQybOGOdJtnuZZ5SJoxurzTyTE2q5yd9OX-ic\", \"sigs\": [] } transaction saved to: . /my-code. json Executed: kadena tx add --template=\"simple-code. ktpl\" --template-data=\"\" --chain-id=\"3\" --account: from=\"k: ad833b6bbfc72fb7d18b88cd5b4349f82b2f015be8e4b5e7ad28f3249fd5e105\" --network: networkId=\"development\" --out-file=\"my-code. json\" ` Test the transaction To test the transaction: 1. Submit the transaction on the local endpoint by running the following command: `bash kadena tx test ` 2. Select the transaction you created from the template, then press Return. For example: `bash? Select a transaction file: ❯◉ Transaction: my-code. json ` After you press Return, you should see output similar to the following: `bash -------------------------------------------------------------------------------- txSignedTransaction test result: -------------------------------------------------------------------------------- Transaction info: fileName: my-code. json transactionHash: hyu6NGeQybOGOdJtnuZZ5SJoxurzTyTE2q5yd9OX-ic Response: Response: gas: 6 result: status: success data: 25 reqKey: hyu6NGeQybOGOdJtnuZZ5SJoxurzTyTE2q5yd9OX-ic logs: wsATyGqckuIvlm89hhd2j4t6RMkCrcwJeoeCYr7Th8 metaData: publicMeta: creationTime: 1715888245 ttl: 600 gasLimit: 600 chainId: 3 gasPrice: 0. 000001 sender: k: ad833b6bbfc72fb7d18b88cd5b4349f82b2f015be8e4b5e7ad28f3249fd5e105 blockTime: 1715888557715218 prevBlockHash: GfT16uJG4TtVG1VKzIsvHrgbGW493mRMucymBeTu8 blockHeight: 4029 continuation: null txId: null Details: chainId: 3 network: devnet networkId: development networkHost: http: //localhost: 8080 networkExplorerUrl: http: //localhost: 8080/explorer/development/tx/ Transaction Command: cmd: {\"payload\": {\"exec\": {\"code\": \"( 5 5)\", \"data\": {}}}, \"nonce\": \"\", \"networkId\": \"development\", \"meta\": {\"sender\": \"k: ad833b6bbfc72fb7d18b88cd5b4349f82b2f015be8e4b5e7ad28f3249fd5e105\", \"chainId\": \"3\", \"creationTime\": 1715888245, \"gasLimit\": 600, \"gasPrice\": 0. 000001, \"ttl\": 600}, \"signers\": []} hash: hyu6NGeQybOGOdJtnuZZ5SJoxurzTyTE2q5yd9OX-ic sigs: -------------------------------------------------------------------------------- Executed: kadena tx test --tx-signed-transaction-files=\"my-code. json\" --tx-transaction-network=\"devnet\" ` Set a default network Many commands require you to specify the network you want to work with. You can streamline command execution by setting a default network. For example, if you are just getting started, you might want to set the default network to devnet to save time as you iterate on your application. Later, you might want to unset the default, so you can specify the network to use on a command-by-command basis. As your application matures, you might want change the default network from devnet to testnet so you can deploy updates for broader testing. To set the default network: 1. Open a terminal shell on the computer where you've installed the kadena-cli package. 2. Enter kadena network set-default on the command line to set the default network interactively: `bash kadena network set-default ` Because you're running the command interactively, you are prompted to select a network. For example: `bash? Select a network (Use arrow keys) ❯ devnet mainnet testnet ` 3. Use the up and down arrow keys to select the network you want to use as your default network, then press Return. For example, select devnet, then press Return. 4. Select Yes to confirm your default network, then press Return. The command displays confirmation of your default network. For example: `bash The network configuration \"devnet\" has been set as default. Executed: kadena network set-default --network=\"devnet\" --confirm ` After settings default network, you won't be prompting to select a network when running other commands. If you want to remove the default network from your configuration, run the following command: `bash kadena network set-default --network none --confirm ` The command displays confirmation of your change. For example: `bash The default network configuration has been removed. ` Run commands in automated scripts For most commands, responding to interactive prompts and confirmation messages helps to ensure that you provide all of the information necessary to successfully execute each command. However, if you want to disable all interactive prompts and confirmation messages, you can use the --quiet flag. The --quiet flag enables you to run commands in environments where interactive input is impractical, such as automated test suites and continuous integration (CI) pipelines. If you include the --quiet flag in a command, the command suppresses all interactive prompts and skips all confirmation messages, so that each command can run uninterrupted without human intervention. Running commands using the --quiet flag ensures that automated processes can run smoothly and efficiently, without manual input. If you use the --quiet flag for a command, you must include all required arguments in the command line. Create a project You can use the kadena dappcommand to create a new project directory for the decentralized application you want to build. This command allows you to create an empty project directory or to create a new project from one of the frontend framework templates that are currently supported. You can create the new project using templates for the following frontend frameworks: - Angular - Nextjs - Vuejs To create a new project from a template: 1. Open a terminal shell on the computer where you've installed the kadena-cli package. 2. Enter kadena dapp create <app-name> on the command line to create a new project directory with the name you specify. For example, to create a project names my-to-do: `shell kadena dapp add my-to-do ` Because you're running the command interactively, you are prompted to select a template. For example: `shell? What template do you want to use? (Use arrow keys) ❯ Angular Next JS Vue JS ` 3. Use the up and down arrow keys to select the template to use for your project, then press Return. If you are missing required dependencies for the template you select, you are prompted to install them. 4. Confirm that you want to install missing dependencies. 5. Change to your project directory by running a command similar to the following: `bash cd my-to-do ` If you explore the project directory, you'll see it contains the appropriate template files and folders for the framework you selected plus a pact folder with some starter code for a Pact module (message-store. pact) and for testing the Pact module in the Pact REPL (message-store. repl`). Next steps Learn more about the Kadena command-line interface and the actions you can perform using CLI commands in the Command-line reference section. To get started with building a smart contract backend for your application, see the sample modules in Coding projects. For information about using the Kadena client libraries and packages, see Kadena client.",
    "source": "guides/dev-with-cli.md",
    "title": "Develop with kadena-cli"
  },
  {
    "content": "Become a Chainweb node operator to support the Kadena network infrastructure. Computers that run the Chainweb consensus protocol—by installing and managing the chainweb-node software—provide the resources that power the Kadena public blockchain network by participating in consensus and validating transactions to produce blocks. By installing and running chainweb-node and connecting to the Kadena test or production network, you can extend the peer-to-peer communication infrastructure and have direct access to the blockchain state. You can help to improve the security and scalability of the network just by participating. You can also earn rewards if you choose to add resources to calculate proof-of-work solutions to validate transactions as a miner. Minimum system requirements Before installing Chainweb, you should verify that your computer meets the following minimum recommended hardware requirements for running a node: - CPU: Minimum of two (2) CPU cores. - RAM: Minimum of four (4) GB of RAM. - Storage: Minimum 250 GB using a solid state drive (SSD) or fast hard disk drive (HDD). - Network: Publicly-accessible IP address. - Operating system: Linux AMD64 architecture. If you also plan to use the node for mining, to submit transactions, or to query blockchain data, you should verify that your computer meets the following minimum recommended hardware requirements: - Four (4) CPU cores. - Eight (8) GB of RAM. Operating system architecture Most chainweb-node software runs on Linux or macOS with AMD64 architectures. If you want to run a Chainweb node on Linux or macOS with ARM64 architecture, you'll need to build the binaries yourself from the source code. You might experience some unexpected behavior when running a node on ARM64 architecture. Note that you should not configure mining for nodes on ARM64 architecture. Running a mining node on ARM64 architecture could cause your node to fork from the network. If you want to run a Chainweb node on Microsoft Windows, you should note that this isn't a supported configuration and requires you to install the latest Windows Services for Linux (WSL) software. If you choose to proceed after installing WSL, you can install the chainweb-node software in the WSL virtual environment rather than using the native Windows operating system. Incoming and outgoing network rules In addition to a publicly-accessible IP address, nodes must be able to communicate with peers and accept incoming messages from other computers in the network. If your computer is behind a firewall or is a virtual guest connecting to the internet through a host computer, you should review your network configuration and open required ports to allow inbound and outbound traffic. For example, you might need to configure port forwarding for port 1789 on your router or host computer to allow inbound connections from remote nodes. Installation options There are several options for setting up a Chainweb node in a physical or virtual environment. For example, you can run a Chainweb node image in a Docker container or build the binaries directly from the source code. You can install release binaries directly on a physical Linux server or run them using the infrastructure from a cloud services provider. For more information about your installation options, see the following topics: - Install release binaries - Run in a Docker container - Build from source code Install release binaries You can download compressed archive files with chainweb-node release binaries for Ubuntu Linux directly from the Releases page in the chainweb-node repository. If you have Ubuntu 20. 04 or Ubuntu 22. 04 on a physical or virtual machine, downloading the binary is the most straightforward installation path. To install from a release archive: 1. Open a terminal shell on the physical or virtual host with the Ubuntu Linux operating system. 2. Update the system with the latest software by running the following command: Code example (bash): sudo apt update && sudo apt upgrade `` 3. Install the required packages by running the following command: `bash sudo apt-get install ca-certificates libgmp10 libssl3 libsnappy1v5 zlib1g liblz4-1 libbz2-1. 0 libgflags2. 2 zstd ` If your computer uses the Ubuntu 20. 04 operating system, install the libssl1. 1 package instead of the libssl3 package. 4. Download the archive file from the Releases page. Note tha. . . [code continues]bash. /chainweb-node --config-file modified-config. yaml Code example (): The node immediately begins trying to synchronize state with other nodes in the network. If the network is correctly configured to allow communication, you should start seeing the block height for your node catching up with its peers. If you see errors or warning messages, you should review the Troubleshooting section for potential causes and solutions. Start the node in a container To start the node in a Docker container, you can run a command similar to the fol. . . [code continues]bash docker run --publish 1789: 1789 --publish 1848: 1848 --entrypoint=/chainweb/chainweb-node ghcr. io/kadena-io/chainweb-node/ubuntu: latest Code example (): After starting the node in a Docker container, you can view the contents of the container and interact with it using basic shell commands. For example, you can get the container identifier by running docker ps, then open a shell in the container by running a command similar to the following: bash docker exec --interactive --tty <container-id> /bin/bash Code example (): However, the container doesn't include a text editor for modifying the configuration file. If you want to run the node with modified configuration settings in a Docker container, you can add the appropriate command-line options when starting the node. For example: bash docker run --publish 1789: 1789 --publish 1848: 1848 --entrypoint=/chainweb/chainweb-node ghcr. io/kadena-io/chainweb-node/ubuntu: latest --enable-backup-api --backup-directory /tmp/my-backups `` For more information about using command-line options to control node operations, see the chainweb-node command-line reference. After you start the node in the container, it immediately begins trying to synchronize state with other nodes in the network. If the network is correctly configured to allow communication, you should start seeing the block height for your node catching up with its peers. If you see errors or warning messages, you should review the Troubleshooting section for potential causes and solutions or post a question on the Kadena Discord server #infrastructure channel.",
    "source": "guides/nodes/chainweb-get-started.md",
    "title": "Get started running a node"
  },
  {
    "content": "Deploy a private Chainweb EVM node to set up a local development network for testing. Get started with Kadena Chainweb EVM The Kadena network relies on nodes that run the Chainweb consensus protocol. When Ethereum transitioned from a Proof-of-Work consensus model to a Proof-of-Stake consensus model, it effectively split the blockchain into separate consensus and execution layers. This change to the architecture enabled the Ethereum Virtual Machine (EVM) to provide an execution environment that is agnostic about the underlying consensus. Because the execution layer operates independently, Chainweb nodes can provide the same EVM execution environment running in parallel with Pact while maintaining the Chainweb Proof-of-Work consensus, security, and decentralization over a multi-chain network. How it works The Chainweb consensus protocol enables multiple independent chains to share a common view of state beyond a certain block depth. This common view of state enables any chain in the network to verify whether historical events beyond the required block depth occurred on any other chain. For example, if a transaction occurs on chain 3, chain 3 can produce a simple payment verification (SPV) proof that chain 6 can verify by checking the shared history. The only requirement for verifying the transaction is that the proof must be conveyed from the original chain, in this example, chain 3—to the target chain, in this example, chain 6. With this approach, security relies strictly on the shared consensus across the chains in the network. There are no relayers, oracles, validators, archives, or third-party coordinators. The chains in the Kadena Chainweb EVM network run in parallel, but independently, allowing for concurrent transaction processing without the risk of collisions or delays. Because Chainweb provides a single common view of state, global security, and concurrent payload processing, Kadena Chainweb EVM enables cross-chain transactions to be executed more efficiently and at a lower cost than traditional bridging techniques. At a high level, Kadena Chainweb EVM supports cross-chain activity in three main steps: - An event occurs on a source chain. For a cross-chain transfer, a user initiates a transaction to transfer tokens from a source chain using a smart contract. The smart contract emits a well-defined cross-chain event. - An off-chain endpoint generates proof of a specific event. For a cross-chain transfer, a user queries an endpoint that generates a simple payment verification proof or another type of proof that can be validated. The proof must encode all of the information required to uniquely identify the event on the source chain and the contract on the target chain. - The event is observed on the target chain. For a cross-chain transfer, a user relays the proof to the target chain, where it is verified against the history shared by the source and target chains. By checking the shared history, the contract on the target chain validates that the transfer event claimed by the user occurred on the source chain. The smart contract on the target chain completes the transaction, for example, by minting the number of tokens transferred from the source chain. Chainweb EVM development environment The kadena-evm-sandbox repository provides tools and configuration files for developers interested in setting up a private local development environment for testing the Ethereum Virtual Machine (EVM) execution environment running on Chainweb nodes that provide the infrastructure for the Kadena blockchain network. The repository includes a default configuration for a docker compose image that is optimized for basic frontend development with an EVM-compatible node as the backend. The default configuration includes chains 0 through 19 for Pact smart contracts and chains 20 though 24 for Solidity contracts. What's included in the repository The kadena-evm-sandbox repository provides everything you need to set up a local Kadena development network that runs a single Chainweb node with core backend services and a mining client. The default configuration for the development network provides five chains that use EVM as the payload provider for processing transactions. The repository includes the following directories and components: | Name | What it provides | ---- | ---------------- | allocations | Files to set up an ethers project that describes a set of BIP-44 wallets and allocations to be created in the genesis block for the development network. | apps | Files to set up the contract, server, and frontend application that demonstrates cross-chain transactions. | blockscout | Files to set up an optional block explorer for the EVM chains in the development network. Blockscout instances provide an explorer interface and API similar to Etherscan. | devnet | A Docker compose project and files to set up the Chainweb node services for the development network. | docker&#8209; bake. hcl | A script to build multi-platform images for the development network Docker compose project. | docs | Technical documentation about the functions and events proposed for the Kadena Chainweb EVM cross-chain bridging protocol in draft form. | network | An optional command-line program for starting, stopping, and monitoring the Kadena Chainweb EVM development network. | solidity | A Hardhat project that demonstrates the implementation of a simple ERC-20 token with support for burn and mint style transfers between the two EVM chains in the network. Prerequisites and system requirements Before you set up the Kadena Chainweb EVM development environment, verify that your local computer has the required tools installed and meets the following basic requirements: - You must have Docker and Docker Compose or an Open Container Initiative (OCI) compliant alternative. - You must have at least 4 CPU cores and 8 GB of memory available for Docker. You can configure CPU and memory for Docker using command-line options or Resource settings. - You must have a network connection to download the container images for the development network. - You must have a POSIX-compliant terminal shell for running command-line programs and scripts. - You should have bash and jq programs installed. - You must have JavaScript tooling installed, including Node. js version v22, the npm or yarn package manager, and npx to deploy Solidity contracts with Hardhat. - You must have at least 6 CPU cores and 12 GB of memory available for Docker to run the Blockscout block explorer. Quick start To download and install the Chainweb EVM development network: 1. Open a terminal shell on your computer. 1. Clone the kadena-evm-sandbox repository and change to the kadena-evm-sandbox directory by running the following command: Code example (sh): git clone https: //github. com/kadena-io/kadena-evm-sandbox && cd kadena-evm-sandbox `` The kadena-evm-sandbox directory includes the network command-line program that you can use to perform common tasks to manage and monitor the development network. The network program supports commands that are similar to Docker commands. You can explore all of the commands available by running the following command: `sh. /network help ` 2. Pull the latest container images usin. . . [code continues]sh. /network devnet restart Code example (): ### Stopping the development network When you're finished testing, you can shut down the development network, remove all containers, and reset the database to a clean state. To shut down the network and remove containers: sh. /network devnet stop Code example (): In some cases, you might find that stopping or restarting the network fails to return the container to a clean state. If this problem occurs, run the following command to forcibly remove orphan processes: bash docker compose down --volumes --remove-orphans Code example (): After removing all containers and processes, you should be able to restart the network in a clean state. Modifying the network configuration The devnet folder in the kadena-evm-sandbox repository includes a Python script, compose. py, that generates the docker-compose. yaml file for the Chainweb EVM Docker Compose project. The compose. py script automates the creation of the docker-compose. yaml file with different configuration settings for the following predefined project use c. . . [code continues]bash python3. 13 compose. py --project kadena-dev > docker-compose. yaml && docker compose up -d Code example (): To generate a docker-compose. yaml that's optimized for application development, you can run a command similar to the following: bash python3. 13 compose. py --project app-dev --exposed-chains \"3, 20\" > docker-compose. yaml && docker compose up -d Code example (): This example only exposes the Chainweb service API on one Pact chain (3) and one EVM chain (20). You can run compose. py script to generate the docker-compose. yaml file for any of the predefined project configurations. Alternatively, you can modify the compose. py script or write your own script to customize the development environment settings you want to use. Test the sample Solidity project The solidity directory provides an example of a simple Hardhat project with a Hardhat confi. . . [code continues]sh. /network solidity setup Code example (): If the npm package manager reports any issues, address them before continuing to the next step. For example, you might be prompted to run npm audit fix to address issues. Running tests You can develop, test, and deploy Solidity contracts using standard Hardhat commands. For example, you can run the unit tests for the SimpleToken contract against the internal Hardhat v2 network: sh npx hardhat test Code example (): The solidity project also provides sample npm scripts to perform common tasks. To execute unit tests for the SimpleToken contract using a sample npm script, run: sh npm run test Code example (): The SimpleToken tests deploy the sample ERC-20 token contract and check that token transfer operations succeed or revert as expected when tokens are transferred between addresses on two Chainweb EVM chains. For example, you should see output similar to the following excerpt as tests are executed and new blocks are added to the chain: sh Chainweb: hardhat Chains: 5 [hardhat -] creating chains [hardhat -] integrating chains into Chainweb [hardhat -] Starting chain networks Creating provider Creating provider. . . Transferring 500000000000000000000 tokens from 20: 0x5FbDB2315678afecb367f032d93F642f64180aa3: 0x70997970C51812dc3A010C7d01b50e0d17dc79C8 to 21: 0x5FbDB2315678afecb367f032d93F642f64180aa3: 0x70997970C51812dc3A010C7d01b50e0d17dc79C8 Initiating cross-chain transfer from chainwebhardhat20 to chainwebhardhat21 Switched to 20 [hardhat 20] mining requested [hardhat 20] current height is 16 [hardhat 21] current height is 15. . . transfer-crosschain status: 1, at block number 17 with hash 0x2ac3ff7aa6dae262355da187088b9f79b70ac62309b1870a65765fea38a959e7 found log at tx 0 and event 1 waiting for SPV proof to become available on chain 21; current height 16; required height 18 [hardhat 21] mining requested [hardhat 21] current height is 16 [hardhat 22] current height is 15. . . waiting for SPV proof to become available on chain 21; current height 17; required height 18 [hardhat 21] mining requested [hardhat 21] current height is 17 [hardhat 22] current height is 16. . . Hex proof: 0x8b950f0e. . . 01b1ae4d6e Switched to 21 Redeeming tokens on chain chainweb_hardhat21 [hardhat 21] mining requested [hardhat 21] current height is 18 [hardhat 20] current height is 17. . . result at block height 19 received with status undefined ✔ Should transfer tokens to same address from one chain to another (239ms). . . 38 passing (2m) 1 pending [hardhat -] Stopping chain networks [hardhat 20] Automine disabled [hardhat 21] Automine disabled Code example (): ### Deploying To deploy the SimpleToken contract against the local sandbox development network using the npm script, run: sh npm run deploy sandbox Code example (): To deploy deterministically with the same address on all chains using Create2, run: sh npm run deploy-create2 sandbox Code example (): To deploy the SimpleToken contract to the internal Hardhat network, run: sh npm run deploy: hardhat Code example (): To deploy deterministically with the same address on all chains using Create2, run: sh npm run deploy-create2: hardhat Code example (): ### Starting a local node To start a separate Hardhat node, run: sh npx hardhat node Code example (): After starting the node, open another terminal, then run: sh npm run deploy localhost Code example (): To deploy deterministically with the same address on all chains using Create2, run: sh npm run deploy-create2 localhost Code example (): ## Integrating with other Hardhat projects If you want to experiment with using the Chainweb EVM development environment with other Hardhat projects, you must configure the Hardhat project to connect to the Chainweb EVM development environment much like you would configure a project to connect to an external network. You must also configure the Hardhat project to include account information—addresses and balances—for all available accounts. You can use the solidity project as a template for. . . [code continues]json \"scripts\": { \"build\": \"npx hardhat compile\", \"test\": \"npx hardhat test\", \"deploy: hardhat\": \"hardhat compile && npx hardhat run scripts/deploy. js\", \"deploy-create2: hardhat\": \"hardhat compile && npx hardhat run scripts/deploy-using-create2. js\", \"deploy\": \"hardhat compile && npx hardhat run scripts/deploy. js --chainweb\", \"deploy-create2\": \"hardhat compile && npx hardhat run scripts/deploy-using-create2. js --chainweb\" }, Code example (): With these scripts, you can compile, test, and deploy the SimpleToken using npm run commands. For example, you can deploy a project with the same address on all chains by running the following command: sh npm run deploy-create2 sandbox Code example (): ### Modifying the Hardhat project To integrate with the Chainweb EVM development network: 1. Copy the solidity/devnet-accounts. json file into the root directory of your Hardhat project. 2. Install the @kadena/hardhat-chainweb and @kadena/hardhat-kadena-create2 plugins in the root directory of your project: `sh npm install @kadena/hardhat-chainweb @kadena/hardhat-kadena-create2 ` 3. Open the hardhat. config. js or hardhat. config. ts file for your Hardhat project in your. . . [code continues]sh npx hardhat compile Code example (): You should see that your project compiles successfully: sh Compiled 1 Solidity file successfully (evm target: prague). Code example (): Alternatively, you can use the npm convenience scripts. For example, to deploy a Hardhat project on the Chainweb EVM you have configured for development: sh npm run deploy: hardhat Code example (): ### Specifying the Chainweb EVM development environment One of the primary advantages of using the @kadena/hardhat-chainweb plugin is that it is specifically designed to enable you to interact with multiple Chainweb chains. By default, you can configure multiple networks for Hardhat, but not multiple chains in the same network. With the @kadena/hardhat-chainweb plugin, you can configure the Chainweb EVM development environment to run as a typical Hardhat network. You can maintain Hardhat as. . . [code continues]sh npx hardhat run scripts/deploy. js --chainweb sandbox Code example (): In this command, the --chainweb command-line option behaves like the Hardhat --network option to specify the environment you want to deploy into. If you want to deploy into the Chainweb EVM sandbox environment by default, you can add a defaultChainweb key to your Hardhat configuration file. To run scripts against the Chainweb EVM development sandbox environment: 1. Open the hardhat. config. js or hardhat. config. ts file for your Hardhat project in your code editor. 2. Add default. . . [code continues]javascript const tx = await token0. transferCrossChain(receiver. address, amount, token1Info. chain); Code example (): This address is the msg. sender for the transaction and is displayed as the deploying signer when you execute the SimpleToken tests. The address is retrieved by calling the getSigners function in the solidity/test/utils/utils. js file. Typically, if you wanted to call a smart contract function using a different signer—for example, alice—you could call the function like this: javascript const tx = await token0. connect(alice). transferCrossChain(receiver. address, amount, token1Info. chain); Code example (): In ethers tests, this call creates a new contract instance using the new signer alice in the background. It's important to note, however, that the signer address always has a network context associated with it. For contracts deployed on Chainweb EVM, the network context is slightly more complex because you must know the Chainweb chain identifier where the contract is deployed to get the correct signing address. For example, if you want to call a contract with a specific signer, you m. . . [code continues]sh. /network devnet allocations `` The allocations in the genesis block use the following path values: - m/44'/1'/0'/0/0 (address: 0x8849BAbdDcfC1327Ad199877861B577cEBd8A7b6) - m/44'/1'/0'/0/1 (address: 0xFB8Fb7f9bdc8951040a6D195764905138F7462Ed) - m/44'/1'/0'/0/2 (address: 0x28f2d8ef4e0fe6B2E945cF5C33a0118a30a62354) - m/44'/1'/0'/0/3 (address: 0xa24a79678c9fffEF3E9A1f3cb7e51f88F173B3D5) - m/44'/1'/0'/0/4 (address: 0x47fAE86F6416e6115a80635238AFd2F18D69926B) - m/44'/1'/0'/0/5 (address: 0x87466A8266b9DFB3Dc9180a9c43946c4AB2c2cb2) - m/44'/1'/0'/0/6 (address: 0xA310Df9740eb6CC2F5E41C59C87e339142834eA4) - m/44'/1'/0'/0/7 (address: 0xD4EECE51cf451b60F59b271c5a748A8a9F16bC01) - m/44'/1'/0'/0/8 (address: 0xE08643a1C4786b573d739625FD268732dBB3d033) - m/44'/1'/0'/0/9 (address: 0x33018A42499f10B54d9dBCeBB71831C805D64cE3) - m/44'/1'/0'/0/10 (address: 0xa3659D39C901d5985450eE18a63B5b0811fDa521) - m/44'/1'/0'/0/11 (address: 0x7e99c2f1731D3750b74A2a0623C1F1DcB8cCa45e) - m/44'/1'/0'/0/12 (address: 0xFd70Bef78778Ce8554e79D97521b69183960C574) - m/44'/1'/0'/0/13 (address: 0xEE2722c39db6014Eacc5FBe43601136825b00977) - m/44'/1'/0'/0/14 (address: 0xeDD5a9185F9F1C04a011117ad61564415057bf8F) - m/44'/1'/0'/0/15 (address: 0x99b832eb3F76ac3277b00beADC1e487C594ffb4c) - m/44'/1'/0'/0/16 (address: 0xda1380825f827C6Ea92DFB547EF0a341Cbe21d77) - m/44'/1'/0'/0/17 (address: 0xc201d4A5E6De676938533A0997802634E859e78b) - m/44'/1'/0'/0/18 (address: 0x03e95Af0fC4971EdCa12E6d2d1540c28314d15d5) - m/44'/1'/0'/0/19 (address: 0x3492DA004098d728201fD82657f1207a6E5426bd) The mining accounts are: - m/44'/1'/1'/0/0 (address: 0xd42d71cdc2A0a78fE7fBE7236c19925f62C442bA) - m/44'/1'/1'/0/1` (address: 0x38a6BD13CC381c68751BE2cef97BD79EBcb2Bb31)",
    "source": "guides/nodes/evm-get-started.md",
    "title": "Get started with Chainweb EVM"
  },
  {
    "content": "Deploy your Solidity and EVM-compatible smart contract the Kadena Chainweb EVM test network. Kadena Chainweb EVM deployment If you are a smart contract developer who is used to building decentralized applications for Ethereum and EVM-compatible chains, deploying on the Kadena Chainweb EVM Testnet is largely the same as deploying on any other EVM-based chain. At a high level, there are three basic steps: - Get an EVM-compatible wallet for your development account and fund it with test KDA from the Chainweb EVM Testnet faucet application. - Configure your development environment and wallet to use Chainweb EVM Testnet. - Deploy your application the way you would on any other chain. This guide provides detailed instructions for each step. Because Hardhat is one of the most common development environment for Ethereum, this guide focuses on configuring and deploying Solidity smart contracts on Chainweb EVM Testnet using the Hardhat development environment and the @kadena/hardhat-chainweb plugin. Additional guides that focus on other development tools—such as Foundry and Remix—might be available separately, if there's sufficient interest from the broader community. Get a wallet and tokens Before you can deploy any smart contracts, you must have a wallet that supports EVM-compatible chains. You can add Kadena Chainweb EVM to any EVM-compatible wallet that supports adding custom networks. For example, you can add custom networks in MetaMask, Ledger, Trust Wallet, or Coinbase Wallet. Note that wallets currently used for traditional Kadena development—such as Chainweaver, eckoWALLET, Enkrypt, Koala Wallet, or LinxWallet—only support Pact smart contracts at this time. Chainweb EVM Testnet supports Pact smart contracts on chains 0 through 19 and EVM-compatible smart contracts on chains 20 through 24. You must have an EVM-compatible wallet to interact with chains 20 through 24. Add the Kadena network Most EVM-compatible wallets provide an option to Add a custom network or a Connect to a custom network where you can specify details about the network you want to add or connect to. However, navigating to the network settings will vary depending on the specific wallet and version you use. To add network settings to a MetaMask wallet: 1. Open the MetaMask extension in your browser. 2. Expand Ethereum Mainnet to display the list of networks: ! Click Ethereum Mainnet to display the list of networks 3. Click Add a custom network at the bottom of the Enabled networks list. 4. Add the following network settings to add Kadena Chainweb EVM Testnet chain 20 to your wallet: - Network Name: Kadena Chainweb EVM Testnet 20 - RPC: https: //evm-testnet. chainweb. com/chainweb/0. 0/evm-testnet/chain/20/evm/rpc - Chain ID: 5920 - Currency Symbol: KDA - Block Explorer URL: http: //chain-20. evm-testnet-blockscout. chainweb. com Alternatively, you can connect to an existing MetaMask wallet from Blockscout by clicking Add testnet@chain20. ! Add to MetaMask from Blockscout Note that navigating to network settings will depend on the EVM-compatible wallet you choose. For example, if you choose Coinbase Wallet, you must click Settings, then Networks before you have the option to Add or import a custom network. If you have trouble finding the option to connect to a custom network, consult the documentation for your specific wallet. Fund the wallet account After you connect your wallet account to Kadena Chainweb EVM Testnet chain 20, you need to fund the account with testnet KDA tokens to deploy contracts and pay transaction fees. Testnet KDA tokens have no monetary value but they are required to execute transactions on the network. In most cases, you can access the official Kadena EVM Faucet to fund your wallet account with enough KDA to deploy and interact with contracts on Chainweb EVM Testnet. <! --You have two options for funding wallet accounts that interact with Chainweb EVM Testnet: - Official Kadena EVM Faucet: Kadena provides a public faucet interface for testnet KDA. - Alternate faucet: You can opt to use third-party faucet services—such as Tatum—to obtain KDA tokens for Kadena Chainweb EVM Testnet. The Tatum faucet can transfer up to 100 KDA tokens to your wallet address. However, you might be required to sign up for services to access the Tatum Dashboard. --> The funds provided by the official Kadena EVM Faucet should be sufficient for most testing scenarios. However, if the official faucet limits your ability to test because you are low on funds, contact the Kadena team to find out if there are other funding services or resources available. To fund your wallet account using the official Chainweb EVM faucet: 1. Open Developer Tools EVM faucet in a browser. 2. Select Testnet from the network menu, if it isn't already selected. ! Kadena EVM Faucet 3. Enter your Ethereum account name or account address (0x. . . ). 4. Click Fund 0. 5 Coins. The faucet contract will transfer 0. 5 KDA to the account you specify. Important The Ethereum wallet account you use to connect to Chainweb EVM Testnet is on chain 20 in the Chainweb EVM Testnet network. The Ethereum chain identifier for this Chainweb EVM chain is 5920. You should only deploy smart contracts on this chain during the initial phase of testing using Chainweb EVM Testnet. Most applications only need to be deployed on a single chain for testing purposes. However, if you need access to other chains, you must provide different network details to connect to those chains. For more information about working with other chains, see Multi-chain support. Configure the development environment After you have a Chainweb EVM testnet account with funds, the next step is to configure your development environment to use the Kadena Chainweb EVM Testnet network. These steps assume you are on using Hardhat, which is a popular Ethereum development framework, and the Kadena Hardhat plugin @kadena/hardhat-chainweb for multi-chain support. Before you begin Verify that your development environment meets the following basic requirements: - You have the Node. js runtime environment, npm or yarn package manager, and npx installed. - You have Git installed for managing your project. - You have the private key for the wallet account holding the testnet KDA funds. - You have cloned the kadena-evm-sandbox so you have access to the files in the sample solidity Hardhat project. You can model testing and deployment for your own Hardhat projects based on the configuration of the solidity project. Configure Hardhat settings For completeness, these steps assume you're creating a new Hardhat project. If you already have a Hardhat project, you can skip the first two steps. To configure the development environment using Hardhat: 1. Create a new project directory by running a command similar to the following: ``bash mkdir kadena-hardhat-project && cd kadena-hardhat-project ` 2. Initialize the Hardhat project in the directory by running the following commands: `bash npm init -y npm install --save-dev hardhat npx hardhat init ` Follow the prompts displayed to generate a default hardhat. config. js or hardhat. config. ts file and a sample project structure. 3. Install the @kadena/hardhat-chainweb plugin in the root directory of your project using npm, pnpm, or yarn. For example: `sh npm install @kadena/hardhat-chainweb ` 4. Install dependencies for the project. `sh npm install ` 1. Create a local environment (. env) file for the private key that will deploy your contract. You can copy the. env. example from the solidity project to create the. env file and replace the placeholder key with your private key. `sh cp ~/kadena-evm-sandbox/solidity/. env. example. env ` After you create the. env file in your Hardhat project, open the. env file and replace the placeholder key with your private key. `sh # PK of the deployer account DEPLOYERPRIVATEKEY=0x0000000000000000000000000000000000000000000000000000000000000000 ` 2. Open the hardhat. config. js or hardhat. config. ts file in your code editor and import the @kadena/hardhat-chainweb plugin. For example: `javascript import \"@nomicfoundation/hardhat-toolbox\"; import \"@kadena/hardhat-chainweb\"; import \"hardhat-deploy\"; import \"hardhat-deploy-ethers\"; import \"dotenv/config\"; import { HardhatUserConfig } from \"hardhat/config\"; 3. Add Chainweb EVM network settings provided by the @kadena/hardhat-chainweb plugin. For example, the following settings configure the testnet network settings to only deploy to chain 20, where you have an account with testnet KDA, and use the deployer private key from the. env file: `javascript defaultChainweb: \"testnet\", chainweb: { hardhat: { chains: 2 }, testnet: { type: 'external', chains: 1, accounts: [process. env. DEPLOYERPRIVATEKEY], chainIdOffset: 5920, chainwebChainIdOffset: 20, externalHostUrl: \"https: //evm-testnet. chainweb. com/chainweb/0. 0/evm-testnet\", etherscan: { apiKey: 'abc', // Any non-empty string works for Blockscout apiURLTemplate: \"http: //chain-{cid}. evm-testnet-blockscout. chainweb. com/api/\", browserURLTemplate: \"http: //chain-{cid}. evm-testnet-blockscout. chainweb. com\" }, }, }, ` If you're deploying the SimpleToken contract using the sample deploy script, you can use npm to deploy with the following command: `sh npm run deploy testnet ` This script provides output similar to the following excerpt: `sh > deploy > hardhat compile && npx hardhat run scripts/deploy. js --chainweb testnet DEPLOYERPRIVATEKEY in hardhat config: 0xabec8b26. . . 17f75241. . . Chainweb: testnet Chains: 1 Switched to chainwebtestnet20 Deploying with signer: 0x93A2d568. . . 4e5d4E1d on network 20 Contracts deployed 0x9D024a48A4011e632b1492f014Eb459c894041Ac on 20 Switched to chainwebtestnet20 Waiting 10 seconds before verification. . . Attempting to verify contract 0x9D024a48A4011e632b1492f014Eb459c894041Ac on chain 20. . . The contract 0x9D024a48A4011e632b1492f014Eb459c894041Ac has already been verified on the block explorer. If you're trying to verify a partially verified contract, please use the --force flag. http: //chain-20. evm-testnet-blockscout. chainweb. com/address/0x9D024a48A4011e632b1492f014Eb459c894041Ac#code ✅ Contract successfully verified on chain 20 SimpleToken deployment process completed ` For a complete example of the Hardhat configuration file, see the solidity project or scaffold-kadena. The scaffold-kadena repository also provides sample scripts for performing many common tasks that simplify project deployment and interacting with a contract after its deployed. For more information about the configuration settings and options provided by the Hardhat Chainweb plugin, see hardhat-kadena-plugin or @kadena/hardhat-chainweb. Deployer account When you connect to Chainweb EVM Testnet to deploy, use the private key for the account you funded with testnet KDA. Consider using environment variables for private keys—for example, use the dotenv package and process. env. PRIVATE_KEY as illustrated in the sample Hardhat configuration—to avoid hardcoding secret keys in your configuration file. If you prefer not to expose your private keys at all, you can configure Hardhat to use a wallet provider and enter your keys manually when you deploy. However, using Hardhat scripts is more automation-friendly. Deploy a smart contract using Hardhat After you configure your development environment to connect to Chainweb EVM Testnet, you are ready to deploy smart contracts on the network. To deploy using Hardhat: 1. Run the deployment script you've created for the smart contract and specify the --chainweb command-line option with the name you are using for the Chainweb configuration settings in the Hardhat configuration file. For example, if you are using the evm-testnet configuration settings in the Hardhat configuration file: `bash npx hardhat run scripts/deploy. js --chainweb evm-testnet ` For examples of Hardhat deployment scripts, see the following project files: - solidity/scripts/deploy. js - solidity/scripts/deploy-using-create2. js - scaffold-kadena. 1. Wait for confirmation that the transaction has been mined into a block. As a proof-of-work network, it takes 30 seconds on average to produce a block. You should allow time for the transaction to be mined into a block and for the block to be confirmed by consensus and added to the chain. If Hardhat doesn't report errors during deployment, it's likely that the contract will be successfully deployed. You can double-check by querying the contract or looking up the transaction in a block explorer. Congratulations! You have successfully deployed a Solidity smart contract on Kadena Chainweb EVM Testnet chain 20! Troubleshooting If the deployment script times out or cannot connect to the network, check that the RPC URL is correct and verify internet connectivity. If you see an insufficient funds error, make sure the account you are using has enough testnet KDA tokens on the chain where you are deploying the contract. For example, verify that you've configured the network settings for chain 20, funded the account on chain 20, and are attempting to deploy your contact on chain 20. The transaction fee for deploying a simple contract typically costs less than 0. 001 KDA, so you should have enough funds from the official faucet to deploy multiple contracts. If you see a nonce or chainId error, check that the chain identifier you set in the Hardhat configuration file matches the network you are deploying to. If you specify more than one chain in a Chainweb EVM configuration, Hardhat will attempt to deploy your contract on all of the chains. If you haven't added network settings for the additional chains, you'll see deployment fail with provider and insufficient funds errors. For more information about deploying to more than one chain, see Multi-chain support. Contract verification You can use Blockscout or the @kadena/hardhat-chainweb plugin to verify contracts on the Kadena Chainweb EVM Testnet. You can find examples of how to perform contract verification in the deploy and deploy-create2 scripts for the sample solidity project. Note that you must configure the etherscan settings in the Hardhat configuration file for contract verification to work. Multi-chain support During the initial rollout of Chainweb EVM on the EVM Testnet, there will be twenty Pact chains—chains 0 through 19—and five EVM chains—chains 20 through 24. However, Kadena recommends that you only deploy contracts and test transaction execution on a single chain to ensure operations work as expected without any significant changes to your contracts or development environment. Limiting deployments to a single chain is intended to be a temporary constraint so that network stability and data persistence can be evaluated and, potentially, improved before rolling out the additional complexities involved in multi-chain contract deployments. The instructions for adding a custom network to your wallet provided the network information to use for Chainweb EVM chain 20. If you want to use any of the other chains, you must add the appropriate network information for that chain to the wallet. Chainweb EVM Testnet chain 20 (Production testing) Use the following information when adding this chain as a custom network: - Chain ID: 5920 - RPC: https: //evm-testnet. chainweb. com/chainweb/0. 0/evm-testnet/chain/20/evm/rpc - Block Explorer: http: //chain-20. evm-testnet-blockscout. chainweb. com/ Chainweb EVM Testnet chain 21 Use the following information when adding this chain as a custom network: - Chain ID: 5921 - RPC: https: //evm-testnet. chainweb. com/chainweb/0. 0/evm-testnet/chain/21/evm/rpc - Block Explorer: http: //chain-21. evm-testnet-blockscout. chainweb. com/ Chainweb EVM Testnet chain 22 Use the following information when adding this chain as a custom network: - Chain ID: 5922 - RPC: https: //evm-testnet. chainweb. com/chainweb/0. 0/evm-testnet/chain/22/evm/rpc - Block Explorer: http: //chain-22. evm-testnet-blockscout. chainweb. com/ Chainweb EVM Testnet chain 23 Use the following information when adding this chain as a custom network: - Chain ID: 5923 - RPC: https: //evm-testnet. chainweb. com/chainweb/0. 0/evm-testnet/chain/23/evm/rpc - Block Explorer: http: //chain-23. evm-testnet-blockscout. chainweb. com/ Chainweb EVM Testnet chain 24 Use the following information when adding this chain as a custom network: - Chain ID: 5924 - RPC: https: //evm-testnet. chainweb. com/chainweb/0. 0/evm-testnet/chain/24/evm/rpc - Block Explorer: http: //chain-24. evm-testnet-blockscout. chainweb. com/ Known issues If you attempt to add the network settings for Chainweb EVM to MetaMask from Blockscout, the Block Explorer URL isn't automatically populated. You should add the URL to the network settings manually in MetaMask to ensure that the links to the transactions that are displayed in Blockscout work as expected. The @kadena/hardhat-chainweb` plugin is compatible with Hardhat versions v2. 22. 18 through 2. 24. 3. The plugin isn't compatible with the most recently released of Hardhat, version 2. 25. 0.",
    "source": "guides/nodes/evm-testnet.md",
    "title": "Testnet deployment guide"
  },
  {
    "content": "Manage node databases Because a blockchain continuously adds new transactions in new blocks that change the state of the database, it's important to monitor and manage the databases that store chain data and transactional history. For example, as a node operator, you should plan for routine maintenance such as backing up or purging old data. The specific details of your maintenance plan—such as how often you back up or compact node databases—will depend on your specific use-case for the node. For example, if you are running a node as an indexer and want access to full node history, you'll need to consider adding storage or compacting databases more often to reduce disk space requirements. Back up databases Chainweb nodes have two separate databases. One database—the RocksDB database—stores information about blocks and chains. A second database—the Pact Sqlite database—stores information about smart contracts and state. You can configure a Chainweb node to enable database backup operations by starting the node with the --enable-backup-api and --backup-directory command-line options. For example: Code example (bash): . /chainweb-node --enable-backup-api --backup-directory=/usr/share/cw-db-backups Alternatively, you can configure a node to enable database backup operations by specifying the following configuration settings in a node configuration file: Code example (yaml): backup: api: enabled: true directory: /usr/share/cw-db-backups If you enable database backups in a configuration file, you can then restart the node with the modified configuration file. For example: Code example (bash): . /chainweb-node --config-file modified-config After you enable the backup API for a node, you can use the /make-backup endpoint to a start backup job and the /check-status endpoint to check the status of a previously started backup job. You should note that when you call the /make-backup endpoint, the backup job always backs up the RocksDB database. Backing up the Pact Sqlite database is optional. Backing up both databases takes significantly more time than only backing up the RockDB database. In addition, Pact database backups always require as much space as the active Pact database. For more information about starting backup jobs using the /make-backup endpoint, see Start a database backup job. For more information about checking the status of a database backup, see Check the status of a database backup. Compact node databases Because a healthy blockchain continuously adds new transactions in new blocks that change the state of the database, managing the storage requirements on individual nodes can be challenging. To address this storage issue, Chainweb provides the compact command-line program. The compact program enables you to delete historical unused state from the chainweb-node RocksDB database and the Pact SQLite database. Removing old state that isn't required to validate transactions or reach consensus enables your node to use far less disk space overall while maintaining the semantic integrity of node operations. Note that, if possible, you should run the compact program on a computer or instance with higher input/output operations per second (IOPs). For nodes that run as virtual machines or instances on a cloud platform, you can typically configure this setting to optimize performance. After you compact the state and restart the node to use the compacted database, you can delete the old database to further reduce your storage overhead or save the old database in another location as a backup. To reduce storage for Chainweb node databases: 1. Open a terminal shell on a computer with access to the chainweb-node you manage. For example, if you run the node in a Docker container, open a terminal in the container. If you installed chainweb-node from a release binary or built it from source, open a terminal or secure shell on the computer where the binary is installed. 2. Verify that you have access to the compact command-line program by running the following command: ``bash compact --help ` If you have access to the compact program, you should see usage information similar to the following: `bash Usage: compact [--chainweb-version ARG] --from ARG --to ARG [--parallel] --log-dir ARG Pact DB Compaction Tool - create a compacted copy of the source database directory Pact DB into the target directory. Available options: --from ARG Directory containing SQLite Pact state and RocksDB block data to compact, expected to be in $DIR/0/{sqlite, rocksDb}. --to ARG Directory where to place the compacted Pact state and block data. It will place them in $DIR/0/{sqlite, rocksDb}, respectively. --parallel Turn on multi-threaded compaction. The threads are per-chain. --log-dir ARG Directory where compaction logs will be placed. -h, --help Show this help text ` 3. Compact your rocksdb and sqlite databases by running the compact command with the following arguments: - --from to specify the path to the database directory you want to compact. You should specify the database root directory that contains the 0/sqlite and 0/rocksdb subdirectories. For example, the data/state/chainweb/db directory is the root directory for the data/state/chainweb/db/0/sqlite directory and the data/state/chainweb/db/0/rocksdb directory. - --to to specify the path to the compacted database. The compact program writes the compacted databases to the $DIR/0/sqlite and $DIR/0/rocksdb subdirectories within the directory you specify. - --log-dir to specify the directory where you want the compact program to put the log files it creates, one for each chain. If the directory doesn’t exist, the compact program creates it. These logs can be useful for debugging if something goes wrong. - --chainweb-version to specify the network identifier for the node. This argument is optional if you're compacting a database for the mainnet01 network. If you're compacting a database for another network—for example, the Kadena test network—you must specify the network identifier. Valid values are \"development\", \"testnet04\", and \"mainnet01\". For example, if you are using the default location for the database directory and a node connected to the Kadena test network, run a command similar to the following: `bash compact --from ~/. local/share/chainweb-node/testnet04 --to ~/. local/share/chainweb-node/compact-db --log-dir /tmp/compaction-log-files --chainweb-version testnet04 ` Note that the location of the Chainweb root database directory—~/. local/share/chainweb-node/testnet04 in this example—depends on the configuration of the node. If you haven't specified a location in the configuration file, the default location is ~/. local/share/chainweb-node/{chainweb-network-id}, for example ~/. local/share/chainweb-node/testnet04 for a node in the Kadena test network. If your node isn't synchronized with the current block height of the network or doesn't have enough history to ensure proper validation, you might see the compact operation fail with any error similar to the following: `bash 2024-08-09T20: 03: 38. 215Z [Error] [] locateLatestSafeTarget: Not enough history to safely compact. Aborting. ` If you have enough history for compaction to succeed, you should see a message in the terminal similar to the following: `text 2024-08-13T18: 11: 30. 991Z [Debug] [] Latest Common BlockHeight: 4115162 2024-08-13T18: 11: 30. 991Z [Debug] [] Earliest Common BlockHeight: 332604 2024-08-13T18: 11: 31. 438Z [Debug] [] Compaction target blockheight is: 4114162 2024-08-13T18: 11: 31. 438Z [Debug] [] targetBlockHeight: 4114162 ` All other messages are recorded in the log files in the directory you specified for the --log-dir command-line argument. 4. Stop your node. 5. Restart your node with the new compacted database directory. You can specify the new compacted database directory as a command-line option or edit the node configuration file you use to set the new compacted database directory. For example, you can restart the node with a command similar to the following: `bash chainweb-node --database-directory=~/. local/share/chainweb-node/compact-db ` If you're editing the configuration file, update the YAML or JSON file to set the databaseDirectory field to the location of the compacted database. For example: `yaml chainweb: allowReadsInLocal: false backup: api: configuration: {} enabled: false directory: null databaseDirectory: ~/. local/share/chainweb-node/compact-db `` After you restart the node, it should run normally with the reduced database size as though nothing has changed. You can delete the old database files or keep them locally or in another location as a backup. If you encounter errors or warnings, open a new issue for chainweb-node or contact Kadena developers in the infrastructure channel on the Kadena Discord server.",
    "source": "guides/nodes/manage-databases.md",
    "title": "Manage node databases"
  },
  {
    "content": "A guide to crafting blockchain calls using Traditional API, Kadena CLI, and Kadena.js You can check the status of transactions using the transaction request key and the /poll or /listen endpoints. To check the status of single transaction and wait for a result, use the /listen endpoint. To check the status for a list of transaction request keys, use the /poll endpoint. Using kadena-cli commands If you have installed the kadena-cli package in your development environment, you can use the kadena tx status command to check the status of a transaction on the development, test, or main network. To check transaction status using kadena-cli: 1. Open a terminal on your local computer. 2. Check that you have kadena installed by running the following command: Code example (bash): which kadena `` You should see the path to the file similar to the following: `bash /usr/local/bin/kadena ` 3. Check the transaction status with interactive prompting by running the following command: `bash kadena tx status ` Enter the request key. Select the network. Enter the chain identifier. The command returns status information for the request key similar to the following: `bash Transaction Status: success. . . [code continues]typescript const NETWORKID = 'testnet04'; const CHAINID = '1'; const APIHOST = https: //api. testnet. chainweb. com/chainweb/0. 0/${NETWORKID}/chain/${CHAINID}/pact; if (process. argv. length! == 3) { console. info(HELP); process. exit(1); } getTxStatus(process. argv[2]); async function getTxStatus(requestKey) { const txResult = await Pact. fetch. listen({ listen: requestKey }, APIHOST); console. log(txResult); } ``",
    "source": "guides/transactions/check-tx-status.md",
    "title": "Check transaction status"
  },
  {
    "content": "How to construct transactions using transaction templates and the Kadena CLI. There are several ways you can construct transaction requests that you want to submit to the Kadena blockchain. For example, you can construct transaction by: - Manually craft API requests. - Running Kadena CLI commands. - Calling functions in the Kadena client library. - Interacting with frontend tools like Chainweaver. The Kadena CLI provides one of the most versatile ways to construct transactions by enabling you to create and use transaction templates. With transaction templates, you can create transactions for common operations and customize the values used each time the transaction is submitted. By providing values for template variables at runtime, you can generate transactions for multiple chains, accounts, or assets that are ready to sign and submit with minimal configuration requirements. You can provide template values interactively, specify them as command-line options, or pass them as input from a data file. Default templates The Kadena CLI provides three default templates. The default templates—defined in the transfer-create. ktpl, transfer. ktpl, and safe-transfer. ktpl files—are stored in the. kadena/transaction-templates directory after you configure your local development environment using the kadena config init command. These templates cover the most common transaction types, allowing for straightforward transfers of tokens between accounts. Command options The basic syntax for creating a transaction from a template is: Code example (bash): kadena tx add [options] If you run the command without any options, you are prompted to select a template and enter the information required to create the transaction interactively. If you want to create a transaction without interactive prompted, you can specify command-line options similar to the following: Code example (bash): kadena tx add --template=\"transfer. kptl\" --template-data=\"data. yaml\" --network-id=\"testnet04\" --out-file=\"transaction. json\" In this example: - The --template=\"transfer. kptl\" argument is required to identify the template you want to use to construct the transaction. - The --template-date=\"data. yaml\" argument specifies the file that contains the values to use for the template variables. - The --network-id=\"testnet04\" argument specifies the network the transaction is intended for. - The --out-file=\"transaction. json\" argument specifies the file name for the generated transaction that is saved in the current working directory. For information about the command-line options you can use with the kadena tx add command, type: Code example (bash): kadena tx add --help For additional information about using the kadena tx add command, see kadena tx add. Template formats, prefixes, and variables Transaction templates use the YAML API request format for execution (exec) and continuation (cont) transaction requests. However, templates support the use of variables for input values that can be entered interactively or from a data file. The following example illustrates the use of prefixes to identify the data types and values expected for fields in a coin. transfer transaciton using the transfer. kptl template: Code example (yaml): code: |- (coin. transfer \"{{{account: from}}}\" \"{{{account: to}}}\" {{decimal: amount}}) data: meta: chainId: '{{chain-id}}' sender: '{{{account: from}}}' gasLimit: 2300 gasPrice: 0. 000001 ttl: 600 signers: - public: '{{key: from}}' caps: - name: 'coin. TRANSFER' args: ['{{{account: from}}}', '{{{account: to}}}', {{decimal: amount}}] - name: 'coin. GAS' args: [] networkId: '{{network: networkId}}' type: exec The template uses the following prefixes to identify the expected data type and format for each field: - The account: prefix is used for variables that should specify a valid Kadena account name. - The key: prefix is used for variables that should specify a public key. - The network: prefix is used for variables that should specify the appropriate network identifier for the transaction. - The decimal: prefix is used for variables that should specify a numerical values with a decimal point. If you create transactions interactively, the prefixes are displayed to ensure you are prompted for the appropriate information for the transaction you are constructing. If you provide variable input on the command-line or in a file, the prefixes are ignored and you must provide the appropriate data types and formats to create valid transactions. If you aren't sure of the variables that a template requires, you can list the variables defined for a template by using the --holes command-line option. For example, you can list the template variables for the transfer. ktpl template like this: Code example (bash): kadena tx add --template=\"transfer. ktpl\" --holes This command returns the list of variables like this: Code example (bash): Template variables used in this template: account: from: '' account: to: '' decimal: amount: '' chain-id: '' key: from: '' network: networkId: '' You can create a file with input values for the template variables in YAML format similar to the following: Code example (yaml): account: from: 'k: 99d30af3fa91d78cc06cf53a0d4eb2d7fa2a5a72944cc5451311b455a67a3c1c' account: to: 'k: 58705e8699678bd15bbda2cf40fa236694895db614aafc82cf1c06c014ca963c' decimal: amount: '1. 0' chain-id: '3' key: from: '99d30af3fa91d78cc06cf53a0d4eb2d7fa2a5a72944cc5451311b455a67a3c1c' network: networkId: 'development' You can then construct a transaction that uses these input values with a command similar to the following: Code example (bash): kadena tx add --template=\"transfer. ktpl\" --template-data=\"input-values. yaml\" --out-file=\"transfer-tx-01. json\" This command creates an unsigned transaction in your working directory. After you construct the transfer transaction, you can sign it with the following command: Code example (bash): kadena tx sign After you sign the transfer transaction, you can send the signed transaction to the blockchain with the following command: Code example (bash): kadena tx sign",
    "source": "guides/transactions/construct-tx.md",
    "title": "Construct transactions"
  },
  {
    "content": "How to define a principal namespace using a transaction template and the Kadena CLI. As discussed in Basic concepts, Kadena namespaces provide a static prefix and a secure boundary for all of the contracts, modules, functions, and keyset definitions that you control. When you are building, testing, and deploying smart contracts on your local development network, you can work directly in the root namespace without defining this boundary. For local development, your work is isolated from others because your blockchain—and any smart contracts you deploy—run exclusively on your local computer. However, if you want to deploy a smart contract on a public blockchain network, like the Kadena test network or main production network, the contract must have a unique name that distinguishes your Pact module from all the others. If you try to deploy a Pact module with a name that's already being used on the network where you are trying to deploy, the deployment will fail with an error and you'll pay a transaction fee for the failed attempt. To prevent name collisions on the same network, Kadena allows you to define your own unique namespace on the blockchain. The namespace segregates your work—your smart contracts, keyset definitions, and Pact modules—from applications and modules created and deployed by others. Within your namespace, you can control who has access to which features and who can update the namespace with changes. As long as the namespace has a unique name, everything you define inside of that namespace is automatically unique, too. To ensure every namespace has a unique name, Kadena provides a built-in ns module on the main, test, and development networks. You can use the ns module to create a uniquely-named and cryptographically-secure principal namespace on any Kadena network. The ns module includes a create-principal-namespace function specifically for this purpose. The create-principal-namespace function enables you to create a namespace using the prefix n_ followed by the hash of a keyset. This naming convention ensures that your principal namespace won't conflict with any other namespaces defined in the same network. The following example demonstrates how to define a principal namespace in your development environment by using the Kadena CLI and a transaction template. Create a transaction request To define a principal namespace: 1. Open the code editor on your computer and create a new transaction template (. ktpl) file in the ~/. kadena/transaction-templates folder. For example, create a namespace. ktpl file in the ~/. kadena/transaction-templates folder. 1. Create a transaction request using the YAML API request format with content similar to the following: ``yaml code: |- (define-namespace (ns. create-principal-namespace (read-keyset \"dev-account\")) (read-keyset \"dev-account\") (read-keyset \"dev-account\")) data: dev-account: keys: [fe4b6da332193cce4d3bd1ebdc716a0e4c3954f265c5fddd6574518827f608b7] pred: \"keys-all\" meta: chainId: \"3\" sender: \"k: fe4b6da332193cce4d3bd1ebdc716a0e4c3954f265c5fddd6574518827f608b7\" gasLimit: 80300 gasPrice: 0. 000001 ttl: 600 signers: - public: \"fe4b6da332193cce4d3bd1ebdc716a0e4c3954f265c5fddd6574518827f608b7\" caps: - name: \"coin. GAS\" args: [] networkId: \"development\" ` 1. Create a transaction that uses the template to define a namespace with a command similar to the following: `bash kadena tx add --template=\"namespace. ktpl\" --out-file=\"namespace-sidebet\" ` 1. Sign the transaction with a command similar to the following: `bash kadena tx sign --tx-sign-with=\"wallet\" --tx-unsigned-transaction-files=\"namespace-sidebet. json\" --wallet-name=\"pistolas-wallet\" ` 1. Send the transaction to the blockchain with a command similar to the following: `bash kadena tx send --tx-signed-transaction-files=\"transaction-39LtH3PjVf-signed. json\" --tx-transaction-network=\"devnet\" `` 1. Verify the transaction results in the block explorer: ! Namespace definitiopn",
    "source": "guides/transactions/define-namespace.md",
    "title": "Define principal namespaces"
  },
  {
    "content": "Guarantee safe transfer operations. Transferring funds from one account to another involves a certain amount of risk because if you make a mistake in typing or copying a public key, you could lose access to the funds after they are transferred. Pact allows you to construct safe transfer transactions that guarantee: - Someone possesses the correct private key. - The private key will be able to access the funds being transferred. To provide this guarantee, you can construct a single transaction that executes two separate transfer operations. For example, if Alice wants to transfer coins to Bob, she can construct the transaction with one transfer operation for the desired coins plus a small additional amount to use as a test transfer. She then adds a second transfer operation to return the additional coin amount that is used to verify the account owner. This type of transaction must be signed by both the Alice and Bob accounts and each signature must have the appropriate coin. TRANSFER capability. It's especially important to construct this type of transaction if you are using the transfer-create function because that is when you are defining the new account's keyset. Using a YAML request file and curl Wallets with frontend interfaces can make transfers, including safe transfers, transparent for end-users. However, it's often useful to step through the process from the command-line to better understand the mechanics of how a safe transfer works. In this example: - Two key pairs are generated and saved to separate files for the transaction signers using pact --genkey > alice-keys. yaml and pact --genkey > bob-keys. yaml. - The public key for the Alice (pact-random-key) account is 3c4fc4bcd59850704ba04704730140839ac0f0b65c1ba8fe2f3f6640475f8d67. - The public key for the Bob account is 3fef2d008c1ba8c319dce5b5ce5d89ba4074fb3a3b333746420619135e305678. - The keyset defined in the request is used to create the Bob account, so that public key is required. To create the transaction for a safe transfer: 1. Create a YAML execution request that looks similar to the following example: ``pact code: |- (coin. transfer-create \"pact-random-key\" \"bob\" (read-keyset \"ks\") 2. 001) (coin. transfer \"bob\" \"pact-random-key\" 0. 001) data: ks: keys: [\"3fef2d008c1ba8c319dce5b5ce5d89ba4074fb3a3b333746420619135e305678\"] pred: \"keys-all\" publicMeta: chainId: \"5\" sender: \"pact-random-key\" gasLimit: 1200 gasPrice: 0. 0000001 ttl: 7200 networkId: \"development\" signers: - public: \"3c4fc4bcd59850704ba04704730140839ac0f0b65c1ba8fe2f3f6640475f8d67\" caps: - name: \"coin. TRANSFER\" args: [\"pact-random-key\", \"bob\", 2. 001] - name: \"coin. GAS\" args: [] - public: \"3fef2d008c1ba8c319dce5b5ce5d89ba4074fb3a3b333746420619135e305678\" caps: - name: \"coin. TRANSFER\" args: [\"bob\", \"pact-random-key\", 0. 001] type: exec ` Notice that this YAML file uses the signers attribute and not the keyPairs attribute. 2. Prepare the transaction for signing by using the --unsigned command-line option: `bash pact --unsigned test-transfer. yaml > test-transfer-unsigned. yaml ` 3. Add the signature for the Alice account from the alice-keys. yaml file: `bash cat test-transfer-unsigned. yaml | pact add-sig alice-keys. yaml > signed-alice. yaml ` 4. Add the signature for the Bob account from the bob-keys. yaml file: `bash cat test-transfer-unsigned. yaml | pact add-sig bob-keys. yaml > signed-bob. yaml ` 5. Combine the signatures from both accounts to create the final transaction file: `bash pact combine-sigs signed-alice. yaml signed-bob. yaml > tx-transfer. json ` 6. Send the final transaction to the blockchain: `bash curl -X POST -H \"Content-Type: application/json\" -d \"@tx-transfer. json\" http: //localhost: 8080/chainweb/0. 0/development/chain/5/pact/api/v1/send ` Using kadena-cli commands If you have installed the kadena-cli package in your development environment, you can use the kadena tx add and the safe-transfer. ktpl` template to construct safe transfer transactions for the development, test, or main network. With interactive prompting, the template guides you to provide the information required, so it is less error-prone than manually crafting and signing a transaction request.",
    "source": "guides/transactions/safe-transfers.md",
    "title": "Transfer funds safely"
  },
  {
    "content": "A guide to crafting blockchain calls using Traditional API, Kadena CLI, and Kadena.js --- title: Sign and submit transactions description: \"A guide to crafting blockchain calls using Traditional API, Kadena CLI, and Kadena. js\" id: howto-sign-submit-tx --- import Tabs from '@theme/Tabs'; import TabItem from '@theme/TabItem'; import CodeBlock from '@theme/CodeBlock'; Sign and submit transactions There are several ways you can sign and submit transactions. This guide provides instructions and examples for signing and submitting transactions using different tools and in different scenarios. For example, this guide describes how to use the Pact command-line interpreter HTTP server and REST API to sign and submit transactions locally using Pact commands and how to format transactions requests so that they can be executed using curl commands or Postman API calls. Use the Pact built-in server To use the built-in Pact server: 1. Open a terminal shell on your local computer. 2. Create a configuration file using YAML format with the following properties: Code example (bash): port - HTTP server port number. persistDir - Directory for persisting database files. If you omit this setting, the server runs in-memory only. logDir - Directory for HTTP logs. pragmas - SQLite pragma statement to use with persistent database files. entity - Entity name for simulating privacy. The default is \"entity\". gasLimit - Gas limit for each transaction. The default is zero (0). gasRate - Gas price per action. The default is zero (0). flags. . . [code continues]yaml code: |- (coin. transfer-create \"alice\" \"bob\" (read-keyset \"ks\") 100. 1) (coin. transfer \"bob\" \"alice\" 0. 1) data: ks: keys: [368820f80c324bbc7c2b0610688a7da43e39f91d118732671cd9c7500ff43cca] pred: \"keys-all\" publicMeta: chainId: \"0\" sender: alice gasLimit: 1200 gasPrice: 0. 0000000001 ttl: 7200 networkId: \"mainnet01\" sigs: - public: 6be2f485a7af75fedb4b7f153a903f7e6000ca4aa501179c91a2450b777bd2a7 caps: - name: \"coin. TRANSFER\" args: [\"alice\", \"bob\", 100. 1] - name: \"coin. GAS\" args: [] - public: 368820f80c324bbc7c2b0610688a7da43e39f91d118732671cd9c7500ff43cca caps: - name: \"coin. TRANSFER\" args: [\"bob\", \"alice\", 0. 1] type: exec Code example (): When this YAML request is converted to an unsigned transaction, the result looks similar to the following: json hash: KY6RFunty4WazQiCsKsYD-ovu-XQByfY6scTxi9gQQ sigs: 368820f80c324bbc7c2b0610688a7da43e39f91d118732671cd9c7500ff43cca: null 6be2f485a7af75fedb4b7f153a903f7e6000ca4aa501179c91a2450b777bd2a7: null cmd: '{\"networkId\": \"mainnet01\", \"payload\": {\"exec\": {\"data\": {\"ks\": {\"pred\": \"keys-all\", \"keys\": [\"368820f80c324bbc7c2b0610688a7da43e39f91d118732671cd9c7500ff43cca\"]}}, \"code\": \"(coin. transfer-create \\\"alice\\\" \\\"bob\\\" (read-keyset \\\"ks\\\") 100. 1)\\n(coin. transfer \\\"bob\\\" \\\"alice\\\" 0. 1)\"}}, \"signers\": [{\"pubKey\": \"6be2f485a7af75fedb4b7f153a903f7e6000ca4aa501179c91a2450b777bd2a7\", \"clist\": [{\"args\": [\"alice\", \"bob\", 100. 1], \"name\": \"coin. TRANSFER\"}, {\"args\": [], \"name\": \"coin. GAS\"}]}, {\"pubKey\": \"368820f80c324bbc7c2b0610688a7da43e39f91d118732671cd9c7500ff43cca\", \"clist\": [{\"args\": [\"bob\", \"alice\", 0. 1], \"name\": \"coin. TRANSFER\"}]}], \"meta\": {\"creationTime\": 1580316382, \"ttl\": 7200, \"gasLimit\": 1200, \"chainId\": \"0\", \"gasPrice\": 1. 0e-5, \"sender\": \"alice\"}, \"nonce\": \"2020-01-29 16: 46: 22. 916695 UTC\"}' Code example (): To get a condensed version for signing on a cold wallet, you can remove the cmd field manually or using a script similar to the following: bash cat tx-unsigned. yaml | grep -v \"^cmd: \" Code example (): The result would look like this: hash: KY6RFunty4WazQiCsKsYD-ovu-XQByfY6scTxi9gQQ sigs: 368820f80c324bbc7c2b0610688a7da43e39f91d118732671cd9c7500ff43cca: null 6be2f485a7af75fedb4b7f153a903f7e6000ca4aa501179c91a2450b777bd2a7: null ``` Keep in mind that when you sign using the condensed version, you won't be able to submit the output directly to the blockchain. You'll have to restore the full command to submit the transaction to the blockchain.",
    "source": "guides/transactions/sign-submit-transactions.md",
    "title": "Sign and submit transactions"
  },
  {
    "content": "Tips for troubleshooting common issues when connecting to Chainweb nodes or calling Kadena API endpoints. If you encounter errors, warnings, or Bad Request failures when you attempt to connect to a Chainweb nodes or call Kadena API endpoints, you should check for the following common issues and potential solutions. Common API issues It can be challenging to call REST API endpoints manually from the command-line because of all of the information you must include in the URL to reach a node that can respond to your request. The following are the most common causes of potential issues when you have problems calling Kadena API endpoints. Network and chain identifiers You should verify that you are using the correct network identifier and chain in the call. Most API endpoints require you to specify the network identifier, such as testnet04 or mainnet01, and a specific chain identifier in the request. If you specify testnet or mainnet or the wrong chain identifier, you'll receive a Bad Request or empty response instead of the information you expect. If you're submitting or checking the status of a transaction, be sure you've specified the correct chain identifier, and, if applicable, that there are sufficient funds to pay transaction fees on the network and chain you specify. Transaction formatting If you are using YAML files to format your transaction requests and encounter errors, check the YAML file for formatting or field name errors. There are slight differences in the fields expected and how they are defined in the YAML file depending on whether you are sending a signed transaction request with a public and secret key, an unsigned transaction request with a public key, or using a transaction template and the Kadena CLI to submit the transaction. For more information about transaction formatting, see the following topics: - Transaction format and flow - Construct transactions - Sign and submit transactions Gas management Although default values for the gas limit and gas price might be appropriate for most situations, you should always check the settings and adjust them when necessary. For example, if you're deploying a complex contract, you might need to set a higher gas limit or gas price to ensure your transaction is processed. Nonce handling The nonce setting is optional in YAML request files and defaults to the transaction creation time, if not set. However, it's a best practice to include a unique nonce to prevent duplicate transactions. Error handling If you don't get the results you expect from an API request, you should always check the response for any additional information about the errors encountered. Security If an API request fails, you should check the keys you used to sign the transaction request and verify you are using the correct keys and accounts for the network and chain you connect to. Most Chainweb service API requests don't require a secure (HTTPS) connection. However, private keys are used to sign requests, so in most cases you should use a secure connection when calling API endpoints. For more information about calling specific endpoints and their parameters, see the API documentation. Common Pact contract issues In most cases, Pact error messages provide the information you need to resolve coding issues such as invalid syntax or formatting errors. However, there a few common errors that can be more difficult to diagnose and resolve. The following are the most common errors that you might encounter when executing functions defined in Pact contracts. Contract-specific errors If you see an error message that isn't a Pact interpreter error, you should copy the message and search in the smart contract you are executing for a matching message. It's likely that the function definition includes an enforce statement that contains the message and the error indicates that you haven't met all of the conditions that the enforce statement defines. Not enough input parsing error One of the most common Pact parsing errors you might see is a signing error that's similar to the following: Code example (pact): Error in $. signers[0]. clist[0]. name: \". \": not enough input This error typically indicates that you've forgotten to add the namespace of a capability that you tried to sign for. Even contracts that are deployed in the root namespace must include at least the module name before the capability name. For example, the capabilities defined in the coin contract require you to specify the coin module name before the capability name, such that to acquire the TRANSFER capability, you must sign for the coin. TRANSFER capability. For most contracts, you must sign for capabilities using a registered namespace, like free or user or a principal namespace like neef68e581f767dd66c4d4c39ed922be944ede505, and the module name before the capability name. For example, if you define the VOTERREG capability in a vote-mgr module and deploy the module in the free namespace, you would sign for the free. vote-mrg. VOTER_REG capability. Error: Keyset failure. . . If you see a keyset failure, you should check for the following issues: - Check whether you have signed the transaction using the required keyset. - Check that you've met the conditions that are specified inb the keyset predicate. For example, if a keyset requires more that one key to sign the message, be sure you have signed with the required number of keys. - Check that you have signed for all required capabilities. For example, if you have signed to a acquire a capability, check whether the function requires you to sign for additional capabilities by reviewing the with-capability statements to be sure that all capabilities are in scope. Capability not in scope If you attempt to access an account or row that is guarded by a capability defined outside of the scope of a function, executing the function might fail because the capability is not in scope. In this case, you might need to execute a different function that brings the capability into scope for the function you intended to execute. Common Chainweb node issues The most common issues you might encounter if you're a node operator or attempting to connect to a remote node are problems with peer synchronization, network interruptions, or node unavailability. The following are the most common causes of potential issues when you have problems connecting to Chainweb nodes. Out of date binaries Peer synchronization failures are often caused by nodes with out of date binaries or dependencies. For example, if a node attempts to synchronize with an outdate version of the librocksdb library, peer synchronization will fail. To address this issue, you should make that any node you control is up to date with the most recent official release of the chainweb-node binary. Timeout exceptions If a synchronizing node fails to provide timely feedback to the network, other nodes will receive a timeout exception warning. Generally, the warning can be ignored and nodes can synch to alternative nodes. These exceptions can be fixed by issuing a ConnectionTimeout statement. Something went wrong exceptions A \"Something went wrong\" error signals an internal server error due to misconfiguration. If you see this error, you should regenerate your current configuration file and post a message on the Kadena Discord server #infrastructure channel to make sure your node is configured correctly. To regenerate the configuration: Code example (bash): . /chainweb-node --print-config > config. yaml Network communication issues Every Chainweb node maintains a list of peers. You can connect to the /cut/peer endpoint on any node to discover its list of peers. For example, to see a list of peers for a bootstrap node, you can run a command similar to the following: Code example (bash): curl -sk \"https: //us-e2. chainweb. com/chainweb/0. 0/mainnet01/cut/peer\" | python -m json. tool | grep hostname The command returns information about peer nodes similar to the following: Code example (bash): \"hostname\": \"46. 38. 245. 213\", \"hostname\": \"fr1. chainweb. com\", \"hostname\": \"95. 214. 55. 90\", \"hostname\": \"api. kda. kaddex. xyz\", \"hostname\": \"us-w3. chainweb. com\", \"hostname\": \"195. 201. 194. 100\", \"hostname\": \"89. 58. 13. 15\", \"hostname\": \"37. 221. 196. 102\", \"hostname\": \"3. 75. 157. 154\", \"hostname\": \"node. kadena. fun\", \"hostname\": \"cw. hyperioncn. net\", \"hostname\": \"195. 201. 194. 100\", \"hostname\": \"fr2. chainweb. com\", \"hostname\": \"212. 25. 52. 40\", Network configuration issues If you do not have incoming and outgoing ports configured correctly on your router, network traffic might be blocked, preventing access to the node, or the node might be offline. To see is a node is accessible, you can try pinging the node with a command similar to the following: Code example (bash): ping -c 3 <node ip> You can also try sending a request to the /health-check endpoint for a node: Code example (bash): curl -k https: //<node-ip>: 443/health-check A healthy node should return the following: Code example (bash): Health check OK. If a node is down, try connecting to a different node.",
    "source": "guides/troubleshooting-tips.md",
    "title": "Troubleshooting tips"
  },
  {
    "content": "compose-capability Use compose-capability to compose and grant capabilities in a nested structure to control the scope of how the capabilities are applied. By convention, capabilities are defined using all uppercase letters. With this function, you can define the specified CAPABILITY within the context of an outer defcap declaration. The function is only valid within the distinct defcap body of its outer capability, such that the CAPABILITY you specify for the compose-capability function is included when you call the with-capability function for its outer capability. For example, if you call (with-capability (OUTER-CAP) OUTER-BODY) and the OUTER-CAP declaration includes the (compose-capability (INNER-CAP)) function, the INNER-CAP capability is granted in the scope of the OUTER-BODY logic. Basic syntax To compose and grant a specified CAPABILITY within an outer capability body, use the following syntax: Code example (pact): (compose-capability CAPABILITY) Arguments Use the following argument to specify the CAPABILITY for the compose-capability Pact function. Argument | Type | Description CAPABILITY | capability | Specifies the capability to include in the scope of an outer capability. Return value The compose-capability function returns a boolean value to indicate success or failure in requesting the grant of the specified CAPABILITY. Examples The following example demonstrates how to use the compose-capability function within the body of the TRANSFER capability and include the DEBIT and CREDIT capabilities when the with-capability function is called: Code example (pact): (defcap TRANSFER: bool ( id: string sender: string receiver: string amount: decimal ) @managed amount TRANSFER-mgr (enforce-unit id amount) (enforce (> amount 0. 0) \"Amount must be positive\") (compose-capability (DEBIT id sender)) (compose-capability (CREDIT id receiver)) ). . . (with-capability (TRANSFER id sender receiver amount). . . )",
    "source": "pact-5/capabilities/compose-capability.md",
    "title": "compose-capability"
  },
  {
    "content": "emit-event Use emit-event to emit a specified CAPABILITY as an event without evaluating the body of the capability. This function fails if the specified CAPABILITY doesn't include the @managed or @event keyword in its declaration. By convention, capabilities are defined using all uppercase letters. Basic syntax To emit a CAPABILITY as an event without evaluating its body, use the following syntax: Code example (pact): (emit-event CAPABILITY) Arguments Use the following argument to specify the CAPABILITY for the emit-event Pact function. Argument | Type | Description CAPABILITY | capability | Specifies the capability to emit as an event. Return value The emit-event function returns a boolean value indicating success or failure of emitting the event. Examples The following example demonstrates how to use the emit-event function to emit an event for the TRANSFER capability with the parameters \"Bob\", \"Alice\", and 12. 0: Code example (pact): pact> (emit-event (TRANSFER \"Bob\" \"Alice\" 12. 0)) true The function returns a boolean value indicating the success or failure of emitting the event.",
    "source": "pact-5/capabilities/emit-event.md",
    "title": "emit-event"
  },
  {
    "content": "install-capability Use install-capability to specify and provision a managed capability. Managed capabilities are defined in defcap declarations that include the @managed keyword. The @managed keyword designates a single parameter to be managed by a specified management function. After a capability is installed, it must still be brought into scope using the with-capability function. When the capability is brought into scope, its management function is invoked to validate the request. The management function takes the type of the managed parameter, executes the logic required to validate the requested capability or perform the managed operation, and returns the new managed value that results from the request. The type signature for the management function is managed: <type> requested: <type> -> <type>, where <type> indicates the type of the managed parameter. For example, assume you define a managed capability as: Code example (pact): (defcap FOO (bar: string baz: integer) @managed baz FOO-mgr. . . ) The management function for this capability would be: Code example (pact): (defun FOO-mgr: integer (managed: integer requested: integer). . . ) Any capability that has static unmanaged parameters will invoke the management function with the current managed value and that of the requested capability. The function should perform whatever logic, presumably linear, to validate the request, and return the new managed value representing the balance of the request. Note that signatures scoped to a managed capability cause the capability to be automatically provisioned in a manner similar to how capabilities are installed with this function. By convention, capabilities are defined using all uppercase letters. Basic syntax To specify and provision a managed capability, use the following syntax: Code example (pact): (install-capability CAPABILITY) Arguments Use the following argument to specify the capability you want to install using the install-capability Pact function. Argument | Type | Description CAPABILITY | any | Specifies the capability to be installed. Return value The install-capability function returns a boolean value indicating the success or failure of the installation, along with a string message providing additional information. Examples The following example demonstrates how to use the install-capability to install a capability named coin. TRANSFER with specified parameters: Code example (pact): (install-capability (coin. TRANSFER ESCROW_ID merchant merchant-payout)) The following example illustrates the definition for a capability with a management function and a managed parameter. Code example (pact): (defcap TRANSFER: bool ( id: string sender: string receiver: string amount: decimal ) @managed amount TRANSFER-mgr (enforce-unit id amount) (enforce (> amount 0. 0) \"Amount must be positive\") (compose-capability (DEBIT id sender)) (compose-capability (CREDIT id receiver)) ) (defun TRANSFER-mgr: decimal ( managed: decimal requested: decimal ) (let ((newbal (- managed requested))) (enforce (>= newbal 0. 0) (format \"TRANSFER e. . . [code continues] The following example demonstrates the use of install-capability in the Pact REPL to install a capability named PAY with specified parameters: Code example (pact): pact> (install-capability (PAY \"alice\" \"bob\" 10. 0)) If the PAY capability is installed successfully, the function returns a boolean value indicating success. If the capability isn't installed, the function returns an error message indicating the reason for failure.",
    "source": "pact-5/capabilities/install-capability.md",
    "title": "install-capability"
  },
  {
    "content": "require-capability Use require-capability to require a specific CAPABILITY to be granted before allowing the current body of code to be executed. If the required capability isn't found in the environment, the code fails to execute. By convention, capabilities are defined using all uppercase letters. Basic syntax To test whether a specific CAPABILITY has been granted before executing a portion of code in a contract, use the following syntax: Code example (pact): (require-capability CAPABILITY) Arguments Use the following argument to specify the CAPABILITY to be tested for using the require-capability Pact function. Argument | Type | Description CAPABILITY | Specifies the capability that must be granted before executing a certain portion of code. Return value The require-capability function returns a boolean value indicating whether the specified CAPABILITY exists in the environment. Examples The following example demonstrates how to use the require-capability function to check whether the capability to transfer funds from one source to another has been granted: Code example (pact): (require-capability (TRANSFER src dest)) If the capability isn't found, the function fails. The following example uses the require-capability function to create a guard that ensure both the GAS and ALLOWGAS capabilities have been granted: Code example (pact): (defun gas-payer-guard () (require-capability (GAS)) (require-capability (ALLOWGAS)) )",
    "source": "pact-5/capabilities/require-capability.md",
    "title": "require-capability"
  },
  {
    "content": "with-capability Use with-capability to apply the access to a specific capability to execute a body of code. This function ensures that an elevated privilege—defined as a capability using a defcap code block—is present during the execution of the provided body of code. You can only call the with-capability function in the same module that contains the corresponding defcap declaration. If the token that grants permission to use the specified capability isn't found, the with-capability evaluates the capability definition to install or grant the permission token. The permission token is automatically revoked after executing the code body. Nested with-capability calls for the same permission token detect the presence of the token and execute the body without reapplying the capability. By convention, capabilities are defined using all uppercase letters. Basic syntax To request the grant of an acquired CAPABILITY, use the following syntax: Code example (pact): (with-capability CAPABILITY body) Arguments Use the following arguments to specify the name of the capability and the body of expressions to be executed using the with-capability Pact function. Argument | Type | Description CAPABILITY | capability | Specifies the name of the capability to grant access to. body | any | Specifies the body of expressions to be executed using the granted capability. Return value The with-capability function returns the result of executing the provided body of code using the granted capability. Examples The following example demonstrates how to use the with-capability function to request access to the UPDATE-USERS capability to execute the code that updates user information: Code example (pact): (with-capability (UPDATE-USERS id) (update users id { salary: new-salary })) In this example, the with-capability function ensures that a sensitive operation can only be executed with an elevated permission granted using the UPDATE-USERS capability.",
    "source": "pact-5/capabilities/with-capability.md",
    "title": "with-capability"
  },
  {
    "content": "hyperlane-decode-token-message Use hyperlane-decode-token-message to decode a base-64-unpadded encoded Hyperlane Token Message into an object containing recipient, amount, and chainId information. Basic syntax To decode a Hyperlane Token Message using hyperlane-decode-token-message, use the following syntax: Code example (pact): (hyperlane-decode-token-message x) Arguments Name | Type | Description x | string | A base-64-unpadded encoded Hyperlane Token Message Return value The hyperlane-decode-token-message function returns an object with the following fields: Field | Type | Description recipient | GUARD | The recipient of the token message amount | DECIMAL | The amount of tokens chainId | STRING | The chain identifier Examples Here's an example of using hyperlane-decode-token-message to decode a Hyperlane Token Message: Code example (pact): pact> (hyperlane-decode-token-message \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHsABHsicHJlZCI6ICJrZXlzLWFsbCIsICJrZXlzIjpbImRhMWEzMzliZDgyZDJjMmU5MTgwNjI2YTAwZGMwNDMyNzVkZWIzYWJhYmIyN2I1NzM4YWJmNmI5ZGNlZThkYjYiXX0\") {\"amount\": 0. 000000000000000123, \"chainId\": \"4\", \"recipient\": KeySet {keys: [da1a339bd82d2c2e9180626a00dc043275deb3ababb27b5738abf6b9dcee8db6], pred: keys-all}} In this example, the function decodes the provided base-64-unpadded string and returns an object containing the decoded information: - The amount is 0. 000000000000000123 - The chainId is \"4\" - The recipient is a KeySet with one key and a keys-all predicate",
    "source": "pact-5/commitments/hyperlane-decode-token-message.md",
    "title": "hyperlane-decode-token-message"
  },
  {
    "content": "hyperlane-encode-token-message Use hyperlane-encode-token-message to encode an object into a Hyperlane Token message as an unpadded base64url string. Basic syntax To encode an object into a Hyperlane Token message using hyperlane-encode-token-message, use the following syntax: Code example (pact): (hyperlane-encode-token-message x) Arguments Name | Type | Description x | object | An object containing recipient, amount, and chainId The object should have the following structure: - recipient: string (base64 encoded representation of a guard) - amount: decimal - chainId: string Return value The hyperlane-encode-token-message function returns a string representing the encoded Hyperlane Token message in unpadded base64url format. Examples Here's an example of using hyperlane-encode-token-message to encode an object into a Hyperlane Token message: Code example (pact): pact> (hyperlane-encode-token-message {\"recipient\": \"eyJwcmVkIjogImtleXMtYWxsIiwgImtleXMiOlsiZGExYTMzOWJkODJkMmMyZTkxODA2MjZhMDBkYzA0MzI3NWRlYjNhYmFiYjI3YjU3MzhhYmY2YjlkY2VlOGRiNiJdfQ\", \"amount\": 123000000000000000. 0, \"chainId\": \"4\"}) \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbT72StfgAAABHsicHJlZCI6ICJrZXlzLWFsbCIsICJrZXlzIjpbImRhMWEzMzliZDgyZDJjMmU5MTgwNjI2YTAwZGMwNDMyNzVkZWIzYWJhYmIyN2I1NzM4YWJmNmI5ZGNlZThkYjYiXX0\" In this example, the function encodes the provided object into a Hyperlane Token message. The object contains: - A recipient represented as a base64 encoded string (which itself represents a guard) - An amount of 123000000000000000. 0 - A chainId of \"4\" The function returns the encoded message as an unpadded base64url string.",
    "source": "pact-5/commitments/hyperlane-encode-token-message.md",
    "title": "hyperlane-encode-token-message"
  },
  {
    "content": "hyperlane-message-id Use hyperlane-message-id to get the Message Id of a Hyperlane Message object. Basic syntax To get the Message Id of a Hyperlane Message object using hyperlane-message-id, use the following syntax: Code example (pact): (hyperlane-message-id x) Arguments Name | Type | Description x | object: * | A Hyperlane Message object The Hyperlane Message object should have the following structure: - destinationDomain: integer - nonce: integer - originDomain: integer - recipient: integer - sender: string - messageBody: string - version: integer Return value The hyperlane-message-id function returns a string representing the Message Id of the given Hyperlane Message object. Examples Here's an example of using hyperlane-message-id to get the Message Id of a Hyperlane Message object: Code example (pact): pact> (hyperlane-message-id {\"destinationDomain\": 1, \"nonce\": 325, \"originDomain\": 626, \"recipient\": \"AAAAAAAAAADpgrOqkM0BOY-FQnNzkDXuYlsVcf50GRU\", \"sender\": \"AAAAAAAAAAAAAAAAf6k4W-ECrD6sKXSD3WIz1is-FJY\", \"messageBody\": \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHsABHsicHJlZCI6ICJrZXlzLWFsbCIsICJrZXlzIjpbImRhMWEzMzliZDgyZDJjMmU5MTgwNjI2YTAwZGMwNDMyNzVkZWIzYWJhYmIyN2I1NzM4YWJmNmI5ZGNlZThkYjYiXX0\", \"version\": 1}) \"9lxextceVw0b18kUdfwSze-3Iw7OE-Z5Kq9I8HTDKGE\" In this example, the function takes a Hyperlane Message object with the following properties: - destinationDomain: 1 - nonce: 325 - originDomain: 626 - recipient: \"AAAAAAAAAADpgrOqkM0BOY-FQnNzkDXuYlsVcf50GRU\" - sender: \"AAAAAAAAAAAAAAAAf6k4W-ECrD6sKXSD3WIz1is-FJY\" - messageBody: \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHsABHsicHJlZCI6ICJrZXlzLWFsbCIsICJrZXlzIjpbImRhMWEzMzliZDgyZDJjMmU5MTgwNjI2YTAwZGMwNDMyNzVkZWIzYWJhYmIyN2I1NzM4YWJmNmI5ZGNlZThkYjYiXX0\" - version: 1 The function returns the Message Id \"9lxextceVw0b18kUdfwSze-3Iw7OE-Z5Kq9I8HTDKGE\" for this Hyperlane Message object.",
    "source": "pact-5/commitments/hyperlane-message-id.md",
    "title": "hyperlane-message-id"
  },
  {
    "content": "create-table Use create-table to create a table identified by the specified table name. Basic syntax To create a table identified by the specified table name, use the following syntax: Code example (pact): (create-table table) Prerequisites Before using this function in a Pact module, you must define the table fields using the defschema declaration and the table identifier using the deftable declaration. Creating the table is a separate step that is outside of the Pact module where the schema and identifier are defined. Arguments Use the following argument to specify the table name you want to create using the create-table Pact function. Argument | Type | Description table | table: <{row}> | Specifies the table to create. Return value The create-table function returns a string representing the identifier of the created table. Example The following example demonstrates how to use the create-table function to create a table identified by accounts that can be used for storing account information: Code example (pact): (create-table accounts) The following example illustrates using the create-table function after defining the table schema and table identifier: Code example (pact): (defschema wallet-schema name: string ) (deftable wallet-table: {wallet-schema}). . . (create-table wallet-table)",
    "source": "pact-5/database/create-table.md",
    "title": "create-table"
  },
  {
    "content": "describe-keyset Use describe-keyset to retrieve metadata for a specified keyset. Note: You can only use this function at the top level of your code. The function fails if used within module code. Basic syntax To get metadata for the specified keyset name, use the following syntax: Code example (pact): (describe-keyset keyset) Arguments Use the following argument to specify the keyset for which to retrieve metadata using the describe-keyset Pact function. Argument | Type | Description keyset | string | Specifies the name of the keyset that you want to retrieve metadata for. Return value The describe-keyset function returns a guard. The returned object includes the following properties: - pred: The predicate function associated with the keyset. - keys: An array of public keys associated with the keyset. Examples The following example retrieves metadata for a keyset named 'admin-keyset' in the Pact REPL: Code example (lisp): pact> (describe-keyset 'admin-keyset) { \"pred\": \"keys-all\", \"keys\": [ \"ba54b224d1924dd98403f5c751abdd10de6cd81b0121800bf7bdbdcfaec7388d\", \"8cc94f8a4b43f4d9e3f8c5dca3966ea000f13ecbd79abc01bc7c00faacd06a5e\" ] }",
    "source": "pact-5/database/describe-keyset.md",
    "title": "describe-keyset"
  },
  {
    "content": "describe-module Use describe-module to get metadata for a specified module. This function returns an object with fields including name, hash, blessed, code, and keyset. Note: This function is only allowed in /local in chainweb. Basic syntax To get metadata for a module, use the following syntax: Code example (pact): (describe-module module) Arguments Use the following argument to specify the module for the describe-module Pact function. Argument | Type | Description module | string | Specifies the name of the module to describe. Return value The describe-module function returns an object with metadata for the specified module. Examples The following example demonstrates how to use describe-module function to describe a loaded module: Code example (pact): pact> (module election-gas-station GOVERNANCE (defcap GOVERNANCE () true)) \"Loaded module election-gas-station, hash S6Dtzd7TzbRkYV65G5JRhjtF9Ztvaw7LuUEHEeRivQ\" pact> (describe-module \"election-gas-station\") { \"blessed\": [], \"code\": \"(module election-gas-station GOVERNANCE (defcap GOVERNANCE () true))\", \"hash\": \"S6Dtzd7TzbRkYV65G5JRhjtF9Ztvaw7LuUEHEeRivQ\", \"interfaces\": [], \"keyset\": \"Governance {gGovernance = Right (Def {dDefName = DefName {unDefName = \"GOVERNANCE\"}, dModule =. . . [code continues] In this example, (describe-module 'm) is used to get metadata for the module named 'm'. The function returns an object providing detailed information about the module.",
    "source": "pact-5/database/describe-module.md",
    "title": "describe-module"
  },
  {
    "content": "describe-table Use describe-table to get metadata for a specified table. This function returns an object with fields including module, name, and type. Basic syntax To get metadata for a specified table, use the following syntax: Code example (pact): (describe-table table) Arguments Use the following argument to specify the table for the describe-table Pact function. Argument | Type | Description table | table: <{row}> | Specifies the table to describe. Return value The describe-table function returns an object with metadata for the specified table. Examples The following example demonstrates use to use the describe-table function in the Pact REPL by loading a module that has a table definition: Code example (pact): pact> (module ledger GOVERNANCE (defcap GOVERNANCE () true) (defschema token-schema id: string uri: string precision: integer supply: decimal) (deftable tokens: {token-schema})) The Pact REPL loads the module and displays the has with output similar to the following: Code example (text): Loaded module m, hash UAnq05ArrOYCFbeJDjCLpWecBq5bS5I0WA6Mj0O041o Code example (pact): pact> (describe-table tokens) {\"module\": \"ledger\", \"name\": \"tokens\", \"type\": \"(defschema token-schema [id: string, uri: string, precision: integer, supply: decimal])\"}",
    "source": "pact-5/database/describe-table.md",
    "title": "describe-table"
  },
  {
    "content": "fold-db Use fold-db to select rows from a specified table using a predicate query with both a key and a value, and then accumulate the results of the query using a consumer function. The output is sorted by the ordering of keys. Basic syntax To select rows from a table, apply a predicate, and accumulate the results using a consumer function, use the following syntax: Code example (pact): (fold-db table query consumer) Arguments Use the following arguments to specify the table, predicate, and consumer function for the fold-db Pact function: Argument | Type | Description table | table: <{row}> | Specifies the table from which to select rows. query | a: string b: object: <{row}> | Specifies the predicate function to apply to each row and return a boolean value. consumer | function with key: string and value: object: <{row}> | Specifies the consumer function used to accumulate results from each row and return the final result from all accumulated results. Return value The fold-db function returns a list of accumulated results based on the predicate query and the consumer function. Examples The following example demonstrates how to use the fold-db function: Code example (pact): (let ((query (lambda (k obj) true)); ; Select all rows (func (lambda (x) [(at 'firstName x), (at 'b x)])); ; Example consumer function ) (fold-db people query func) ) In this example: - (qry (lambda (k obj) true)) is a predicate that selects all rows. - (f (lambda (x) [(at 'firstName x), (at 'b x)])) is a consumer function that selects the \"firstName\" and \"b\" fields from each row. The fold-db function is then used to select rows from the people table using the predicate qry and accumulate the results using the consumer function f. The result is a list of accumulated results based on the selected rows and the specified consumer function. The fold-db function is useful for iterating over rows in a table and performing operations in Pact contracts.",
    "source": "pact-5/database/fold-db.md",
    "title": "fold-db"
  },
  {
    "content": "insert Use insert to write an entry in a specified table for a given key of object data. This operation fails if data already exists for the specified key. Basic syntax To insert data into a table for a specified key, use the following syntax: Code example (pact): (insert table key object) Arguments Use the following arguments to specify the table, key, and object data you want to insert using the insert Pact function. Argument | Type | Description table | table: <{row}> | Specifies the table where the entry will be written. key | string | Specifies the key for which the data will be inserted. object | object | Specifies the object data to be inserted for the specified key. Return value The insert function returns a string indicating the success or an exception on failure of the operation. Examples The following example demonstrates how to use the insert function to insert information into the accounts table for the account specified using the id for the account: Code example (pact): (insert accounts id { \"balance\": 0. 0, \"note\": \"Created account. \" }) The following example illustrates a more complete flow from defining the table schema to inserting values into the table: Code example (pact): (defschema coin-schema balance: decimal guard: guard) (deftable coin-table: {coin-schema}) (defun create-account: string (account: string guard: guard) (insert coin-table account { \"balance\": 0. 0, \"guard\": guard }) )",
    "source": "pact-5/database/insert.md",
    "title": "insert"
  },
  {
    "content": "keys Use keys to retrieve all the keys in a specified table. Basic syntax To retrieve all of the keys for a specified table, use the following syntax: Code example (pact): (keys table) Arguments Use the following argument to specify the table from which to retrieve keys using the keys Pact function. Argument | Type | Description table | table: <{row}> | Specifies the table from which to retrieve keys. In the table schema, a row represents the structure of each row in the table. Return value The keys function returns an array of strings, where each string represents a key in the specified table. Examples The following example demonstrates defining a table schema for an accounts table that stores information about bank accounts, including the balance and owner of each account: Code example (pact): (defschema account balance: decimal owner: string) (deftable accounts: {account}) You can then retrieve all of the the keys from the accounts table using the keys function: Code example (pact): pact> (keys accounts) []",
    "source": "pact-5/database/keys.md",
    "title": "keys"
  },
  {
    "content": "list-modules Use list-modules to get all of the modules deployed on a particular chain. Note: This function is only allowed in /local in chainweb. Basic syntax To list all modules in /local, use Code example (pact): (list-modules) Arguments None Return value The list-modules function returns a list of all module names (including their namespace) stored on-chain Examples The following example deploys a simple module in the repl, then calls list-modules. Code example (): pact>(module my-module gov (defcap gov () true) (defun say-hello () (do \"hello world! \"))) Loaded module my-module, hash Z5GCj0v6YdJTPbcc37eUYYeRiPuJGie1XFRXG16il68 pact>(list-modules) [\"my-module\"]",
    "source": "pact-5/database/list-modules.md",
    "title": "list-modules"
  },
  {
    "content": "read Use read to retrieve a row from a specified table by its key. You can optionally specify a subset of columns to return. Basic syntax To read an entire row from a table, use the following syntax: Code example (pact): (read table key) To read specific columns from a row in a table, use the following syntax: Code example (pact): (read table key columns) Arguments Use the following arguments to specify the table, key, and optional columns when using the read Pact function. Argument | Type | Description table | table: <{row}> | Specifies the table from which to read the row. In the table schema, a row represents the structure of each row in the table. key | string | Specifies the key of the row to read from the table. columns | [string] | Specifies one or more column names to return from the row. If not provided, the entire row is returned (optional). Return value The read function returns an object representing the requested row or columns from the specified table. - If you don't specify one or more columns as parameters, the function returns an object with the structure of the entire row. - If you specify one or more columns as parameters, the function returns an object containing only the specified columns from the row. Examples he following example demonstrates defining a table schema for an accounts table that stores information about bank accounts, including the balance, currency, and owner of each account: Code example (pact): (defschema account balance: decimal currency: string owner: string) (deftable accounts: {account}) You can then use the read function to read a row from the accounts table by its key id and retrieve only the balance and currency columns: Code example (pact): (read accounts id ['balance 'currency])",
    "source": "pact-5/database/read.md",
    "title": "read"
  },
  {
    "content": "select Use select to retrieve full rows or specified columns from a table by applying a where clause to each row to determine whether to include the row or column in the selection. Basic syntax To select full rows from a table based on a where clause, use the following syntax: Code example (pact): (select table where) To select specific columns from a table based on a where clause, use the following syntax: Code example (pact): (select table columns where) Arguments Use the following arguments to specify the table, columns, and where clause for selecting rows using the select Pact function. Argument | Type | Description table | table: <{row}> | Specifies the table from which to select rows matching the where clause. columns | [string] | Specifies the list of columns to select from the table matching the where clause (optional). where | row: object: <{row}> | Specifies the where clause to apply to each row to determine inclusion. Return value The select function returns a list of objects representing the selected rows from the table that satisfy the where condition. Examples The following example demonstrates how to use the select function to select the columns 'firstName and 'lastName from the people table where the name is equal to \"Fatima\": Code example (pact): (select people ['firstName 'lastName] (where 'name (= \"Fatima\"))) The following example demonstrates how to select all columns from the people table where the age is less than 30: Code example (pact): (select people (where 'age (> 30)))",
    "source": "pact-5/database/select.md",
    "title": "select"
  },
  {
    "content": "update Use update to write an entry in the specified table for a given key with the data provided in the object column. It fails if data does not exist for the specified key. Basic syntax To update an entry in the specified table for a specific key with the provided object column data, use the following syntax: Code example (pact): (update table key object) Arguments Use the following arguments to specify the table, key, and object data for updating a table using the update Pact function. Argument | Type | Description table | table: <{row}> | Specifies the table in which to update the entry. key | string | Specifies the key for the entry to be updated. object | object | Specifies the object column data to be written for the key. Return value The update function returns a string indicating the success of the update operation. Examples The following example demonstrates how to use the update function to update an entry in the accounts table for the specified key with the provided object column data: Code example (pact): (update accounts id { \"balance\": (+ bal amount), \"change\": amount, \"note\": \"credit\" }) This example illustrates how to use the update function to modify an entry in a table with new data in Pact, ensuring that the operation fails if data does not exist for the specified key.",
    "source": "pact-5/database/update.md",
    "title": "update"
  },
  {
    "content": "with-default-read Use with-default-read to read a row from a specified table for a given key and bind columns according to provided bindings. If the row is not found, the function reads columns from a default object with matching key names. Basic syntax To read a row from a table with default values and bind columns according to the provided binding, use the following syntax: Code example (pact): (with-default-read table key default bindings) Arguments Use the following arguments to specify the table, key, defaults, bindings, and body for execution using the with-default-read Pact special form. Argument | Type | Description table | table: <{row}> | Specifies the table from which to read the row. key | string | Specifies the key for which to read the row. default | object | Specifies a default object containing values for missing columns. bindings | binding: <{row}> | Specifies the bindings for columns to be bound. body | any | Specifies the subsequent body statements to be executed. Return value The with-default-read is a special form that returns the result of executing the provided body statements. Examples The following example demonstrates how to use the with-default-read function to read a row from the accounts table for the specified key, using default values if the row is not found, and binds the balance and currency columns for further processing: Code example (pact): (with-default-read accounts id { \"balance\": 0, \"currency\": \"USD\" } { \"balance\": = bal, \"currency\": = currency } (format \"Balance for {} is {} {}\" [id bal currency])) This example illustrates reading the accounts table with the row key of id and setting default values of 0 and USD for the balance and currency columns if the row isn't found to format a default message using the format function.",
    "source": "pact-5/database/with-default-read.md",
    "title": "with-default-read"
  },
  {
    "content": "with-read Use with-read to read a row from a specified table for a given key and bind columns according to provided bindings over subsequent body statements. Basic syntax To read a row from a table and bind columns according to provided bindings, use the following syntax: Code example (pact): (with-read table key bindings) Arguments Use the following arguments to specify the table, key, bindings, and body for execution using the with-read Pact special form. Argument | Type | Description table | table: <{row}> | Specifies the table from which to read the row. key | string | Specifies the key for which to read the row. bindings | binding: <{row}> | Specifies the bindings for columns to be bound. body | any | Specifies the subsequent body statements to be executed. Return value The with-read is a special form returns the result of executing the provided body statements. Examples The following example demonstrates how to use the with-read function to read a row from the accounts table for the specified key and bind the balance and currency columns for further processing: Code example (pact): (with-read accounts id { \"balance\": = bal, \"currency\": = ccy } (format \"Balance for {} is {} {}\" [id bal ccy]))",
    "source": "pact-5/database/with-read.md",
    "title": "with-read"
  },
  {
    "content": "write Use write to write the specified {column: value} object in the specified table for a given key row. The write function is similar to the insert and update functions, except that: - The insert function fails if data already exists for the specified key row. - The update function fails if data does not exist for the specified key row. In both of these cases, the write function can succeed and update the table without failing. Basic syntax To write an entry in a specified table for a specific key with the provided object, use the following syntax: Code example (pact): (write table key object) Arguments Use the following arguments to specify the table, key, and object data for writing using the write Pact function. Argument | Type | Description table | table: <{row}> | Specifies the table in which to write the entry. key | string | Specifies the key for the entry to be written. object | object | Specifies the object column data to be written for the key. Return value The write function returns a string indicating the success of the write operation. Examples The following example demonstrates how to use the write function to write an entry in the accounts table for the specified key with the provided object column data: Code example (pact): (write accounts id { \"balance\": 100. 0 }) This example illustrates inserting data into the balance column in the accounts table using the id as the row key.",
    "source": "pact-5/database/write.md",
    "title": "write"
  },
  {
    "content": "acquire-module-admin Use acquire-module-admin to grant module admin privileges for a particular module m. You must already own admin for this particular module; that is, you must either be the owner of the keyset that grants the governance, or be able to pass the governance capability acquisition. Basic syntax Assume you have some module Code example (pact): (module my-module gov (defcap gov () (do-stuff-for-governance) ) ) To grant module admin, use Code example (pact): (acquire-module-admin some-module) It will attempt to acquire the governance cap and if successful, it will grant module admin for the rest of the transaction. Arguments | Argument | Type | Description | -------- | ---- | ----------- | ref | modref | Specifies the module to acquire administrative capabilities for. Return value Module admin acquisition will either fail, or return \"Module admin for module <my-module> acquired\" Examples See: Basic Syntax.",
    "source": "pact-5/general/acquire-module-admin.md",
    "title": "acquire-module-admin"
  },
  {
    "content": "at Use at to retrieve the value at the location specified by an index number or by a key string in a collection. If you specify an index number, the collection must be a list of values. If you specify a key string, the collection must be an object. Basic syntax Because at is an overloaded function, there are two ways to use it. To get a value using the specified index location from a list of values, use the following syntax: Code example (pact): (at index [list]) To get a value using the specified key string from an object, use the following syntax: Code example (pact): (at key {object}) Arguments Use one of the following argument to define the value you want to retrieve using the at Pact function. | Argument | Type | Description | -------- | ---- | ----------- | index | integer | Specifies the information you want to retrieve. If you specify an index number, the function returns the value from that location in a list of values. | list | [integer or decimal] | Specifies the list of values to retrieve the value from using the specified index location. | key | string | Specifies the information you want to retrieve. If you specify a key string, the function returns the value corresponding to that key from an object. | object | object | Specifies the set of key and value pairs to retrieve the value from using the specified key. Return value The at function returns the value found at the specified index or using the specified key. The return value can be any data type. Examples The following example returns the value found at the index location—starting with 0—from a list of values. For example, the value at index location 3 is 14: Code example (pact): (at 3 [20 18 16 14 12 10]) 14 You can use the at function to return any type of data from a list. For example: Code example (pact): (at 1 [\"blue\", \"green\", \"red\", \"yellow\"]) \"green\" The following example returns the value found at the specified key from an object: Code example (pact): (at \"last-name\" { \"first-name\": \"maya\", \"last-name\": \"tea\"}) \"tea\" You can use the at function to return any type of data using the specified key from an object. For example: Code example (pact): (at \"chainId\" { \"networkId\": \"development\", \"chainId\": 1, \"auth\": 0}) 1",
    "source": "pact-5/general/at.md",
    "title": "at"
  },
  {
    "content": "base64-decode Use base64-decode to convert a previously-encoded string from unpadded base64 encoding to a string. Basic syntax To decode a string from unpadded base64 encoding, use the following syntax: Code example (pact): (base64-decode string) Arguments Use the following argument to specify the string to decode using the base64-decode Pact function. Argument | Type | Description string | string | Specifies the base64-encoded string to decode. Return value The base64-decode function returns the decoded string. Examples The following example decodes a base64-encoded \"aGVsbG8gd29ybGQh\" string to the decoded \"hello world! \" string in the Pact REPL: Code example (pact): pact> (base64-decode \"aGVsbG8gd29ybGQh\") \"hello world! \"",
    "source": "pact-5/general/base64-decode.md",
    "title": "base64-decode"
  },
  {
    "content": "base64-encode Use base64-encode to convert the specified string to an unpadded base64-encoded string. Basic syntax To encode a string as unpadded base64, use the following syntax: Code example (pact): (base64-encode string) Arguments Use the following argument to specify the string to encode using the base64-encode Pact function. Argument | Type | Description string | string | Specifies the string to encode as unpadded base64. Return value The base64-encode function returns the unpadded base64 encoded string. Examples The following example converts the \"hello world! \" into the unpadded base64-encoded string \"aGVsbG8gd29ybGQh\" in the Pact REPL: Code example (pact): pact> (base64-encode \"hello world! \") \"aGVsbG8gd29ybGQh\"",
    "source": "pact-5/general/base64-encode.md",
    "title": "base64-encode"
  },
  {
    "content": "bind Use bind to evaluate a src object, then apply the specified bindings to bind field variables to values over subsequent body statements. Basic syntax To evaluate src to an object and bind it with bindings over subsequent body statements, use the following syntax: Code example (pact): (bind src bindings) Arguments Use the following arguments to specify the src object and bindings for the bind special form. Argument | Type | Description src | object: {row} | Specifies the source object to evaluate. bindings | binding: {row} | Specifies the bindings to apply to the src object. Return value The bind returns the result of evaluating the src object with the specifies bindings. The data type depends on the data type of the field you specify for the bindings argument. Examples The following example demonstrates the bind special form in the Pact REPL: Code example (pact): pact> (bind { \"a\": 1, \"b\": 2 } { \"a\": = a-value } a-value) 1 In this example, bind evaluates the object { \"a\": 1, \"b\": 2 } and binds the value of \"a\" to a-value. It then returns the value 1, which is the value bound to a-value.",
    "source": "pact-5/general/bind.md",
    "title": "bind"
  },
  {
    "content": "chain-data Use chain-data to retrieve the blockchain-specific public metadata for a transaction. This function returns an object with the following fields: - chain-id: The chain identifier (0-19) for the blockchain where the transaction was executed. - block-height: The height of the block that includes the transaction. - block-time: The timestamp of the block that includes the transaction. - prev-block-hash: The hash of the previous block. - sender: The sender of the transaction. - gas-limit: The gas limit for the transaction. - gas-price: The gas price for the transaction. - gas-fee: The gas fee for the transaction. Basic syntax To retrieve the public metadata for a transaction using chain-data, use the following syntax: Code example (pact): (chain-data) Arguments You can use the chain-data function without arguments in code that identifies the transaction that you want to return metadata for. Return value The chain-data function returns the public metadata for a transaction as an object with the following fields | Field | Type | Description | ----- | ---- | ----------- | chain-id | string | The chain identifier (0-19) for the blockchain where the transaction was executed. | block-height | integer | The height of the block that includes the transaction. | block-time | time | The timestamp of the block that includes the transaction. | prev-block-hash | string | The hash of the previous block. | sender | string | The sender of the transaction. | gas-limit | integer | The gas limit for the transaction. | gas-price | decimal | The gas price for the transaction. | gas-fee | decimal | The gas fee for the transaction. Examples If you call the chain-data function in the Pact REPL without providing a transaction context in the surrounding code, the function returns the object with placeholder fields. For example: Code example (pact): {\"block-height\": 0, \"block-time\": \"1970-01-01T00: 00: 00Z\", \"chain-id\": \"\", \"gas-limit\": 0, \"gas-price\": 0. 0, \"prev-block-hash\": \"\", \"sender\": \"\"} If you provide context for the call, the function returns an object with fields similar to the following: Code example (pact): pact> (chain-data) { \"chain-id\": \"3\", \"block-height\": 4357306, \"block-time\": \"2024-06-06 20: 12: 56 UTC\", \"prev-block-hash\": \"33caae279bd584b655283b7d692d7e7b408d6549869c5eb6dcf2dc60021c3916\", \"sender\": \"k: 1d5a5e10eb15355422ad66b6c12167bdbb23b1e1ef674ea032175d220b242ed4, \"gas-limit\": 2320, \"gas-price\": 1. 9981e-7, \"gas-fee\": 726 } In most cases, you use chain-data in Pact modules or in combination with frontend libraries to return information in the context of a specific transaction. The following example illustrates using chain-data in a Pact module to get the block time from a transaction: Code example (pact): (let ((curr-time: time (at 'block-time (chain-data))))",
    "source": "pact-5/general/chain-data.md",
    "title": "chain-data"
  },
  {
    "content": "CHARSETASCII CHARSETASCII is a constant used to indicate the standard ASCII character set. Constant value (CHARSETASCII: integer = 0) Description The CHARSETASCII constant represents the ASCII (American Standard Code for Information Interchange) character set, which is a widely used character encoding that includes 128 characters. It consists of control characters, digits, lowercase and uppercase English letters, and various symbols. When working with functions or modules that require specifying a character set, you can use CHARSET_ASCII to indicate that the ASCII character set should be used.",
    "source": "pact-5/general/charset-ascii.md",
    "title": "CHARSET_ASCII"
  },
  {
    "content": "CHARSETLATIN1 CHARSETLATIN1 is a constant used to indicate the standard Latin-1 (ISO-8859-1) character set. Constant value (CHARSETLATIN1: integer = 1) Description The CHARSETLATIN1 constant represents the Latin-1 (ISO-8859-1) character set, which is a widely used single-byte character encoding. It includes characters from various Western European languages. When working with functions or modules that require specifying a character set, you can use CHARSET_LATIN1 to indicate that the Latin-1 character set should be used.",
    "source": "pact-5/general/charset-latin1.md",
    "title": "CHARSET_LATIN1"
  },
  {
    "content": "compose Use compose to compose functions where oper1 performs an operation using the specified value and oper2 takes the results from oper1 as input to produce the result for the composed function. You can use any data type for the value argument as long as the first oper1 functions can take that same data type. By convention, the data type <a> is used to represent a type-bound parameter like the value argument in this function. Basic syntax To compose a function using oper1 and oper2 with the specified value, use the following syntax: Code example (pact): (compose oper1 oper2 value) Arguments Use the following arguments to specify the functions oper1 and oper2 for composing with value using the compose Pact function. Argument | Type | Description oper1 | function: <a> -> <b> | Specifies the first function to operate on the specified value and return a result to provide input to the second function. oper2 | function: <b> -> <c> | Specifies the second function to operate on the results of the oper1 function. value | <a> | Specifies the value on which oper1 operates. Return value The compose function returns the result of applying oper2 to the result returned by oper1 for the specified value. Examples In the following example, compose uses the contains function to evaluate the specified list for a string, then uses the if function to operate on the results of the contains function to display the final result: Code example (pact): pact> (compose (contains \"summer\") (if true \"Success! \") [\"spring\" \"summer\" \"fall\" \"winter\"]) \"Success! \"",
    "source": "pact-5/general/compose.md",
    "title": "compose"
  },
  {
    "content": "concat Use concat to take a list of strings str-list and concatenate each of the strings in the list, returning the resulting string. Basic syntax To concatenate each string in a list, use the following syntax: Code example (pact): (concat [str-list]) Arguments Use the following argument to specify the list of strings str-list for the concat Pact function. Argument | Type | Description str-list | [string] | Specifies the list of strings to concatenate. Return value The concat function returns the resulting string after concatenating all the strings in the str-list. Examples The following example demonstrates the concat function in the Pact REPL: Code example (pact): pact>(concat [\"k\" \"d\" \"a\"]) \"kda\" In this example, concat takes the list [\"k\" \"d\" \"a\"] and concatenates each string in the list, resulting in the string \"kda\". The following example shows how to concatenate a list of strings after mapping each element with a function: Code example (pact): pact>(concat (map (+ \" \") (str-to-list \"abcde\"))) \"a b c d e\" In this example, (str-to-list \"abcde\") converts the string \"abcde\" into a list of characters [\"a\" \"b\" \"c\" \"d\" \"e\"]. Then, (map (+ \" \"). . . ) maps the function (+ \" \") to each character, adding a space after each character. Finally, concat concatenates all the strings in the resulting list, producing the string \"a b c d e\".",
    "source": "pact-5/general/concat.md",
    "title": "concat"
  },
  {
    "content": "cond Use cond to evaluate multiple branching conditional expressions. This function allows you to evaluate a series of if expression in a more concise manner. Basic syntax Use the following syntax: Code example (pact): (defun award: string (score: integer) (cond ((< score 10) \"Bronze\") ((< score 20) \"Silver\") ((< score 30) \"Gold\") \"Platinum\")) Examples Code example (pact): (module m g (defcap g () true) (defun award: string (score: integer) (cond ((< score 10) \"Bronze\") ((< score 20) \"Silver\") ((< score 30) \"Gold\") \"Platinum\"))) (award 100)",
    "source": "pact-5/general/cond.md",
    "title": "cond"
  },
  {
    "content": "constantly Use constantly to lazily ignore the specified ignore arguments and return the specified vale. Basic syntax To lazily ignore arguments and return a value, use the following syntax: Code example (pact): (constantly value ignore1 ignore2. . . ) Arguments Use the following arguments to specify the value to return and the ignore arguments for the constantly Pact function. Argument | Type | Description value | any | Specifies the value to return. ignore1, ignore2, . . . | any | Specifies the arguments to ignore. You can have multiple ignore arguments (optional). Return value The constantly function returns the specified value, ignoring any additional arguments. Examples The following example demonstrates the constantly function in the Pact REPL: Code example (pact): pact> (filter (constantly true) [1 2 3]) [1 2 3] In this example, constantly true is used as the predicate function for the filter function. The constantly function always returns true and ignores the elements of the [1 2 3] list argument, so the filter function always returns the entire list. The following example illustrate specifying multiple arguments and argument using different data types: Code example (pact): pact> (constantly \"hello\" {\"name\": \"Kris\", \"age\": 45}) \"hello\" pact> (constantly \"world\" 6 \"ignore\" \"these\" \"arguments\" [2. 1 3. 0]) \"world\" pact> (constantly 42 \"ignore\" 123 \"arguments\") 42",
    "source": "pact-5/general/constantly.md",
    "title": "constantly"
  },
  {
    "content": "contains Use contains to test whether a list contains a value, an object has a key entry, or a string contains a substring value. Basic syntax Because contains is an overloaded function, there are a few different ways to use it. To test whether a list contains a value, use the following syntax: Code example (pact): (contains value [list]) To test whether an object has a key entry, use the following syntax: Code example (pact): (contains key {object}) To test whether a string contains a substring value, use the following syntax: Code example (pact): (contains value string) Arguments Use the following arguments to specify the value, list, key, object, string for the contains Pact function. Argument | Type | Description value | any | Specifies the value to search for in a list or string. list | [any] | Specifies the list to search for the specified value. key | any | Specifies the key to check for in an object. object | object | Specifies the object to check for the specified key. string | string | Specifies the string to search for the specified value. Return value The contains function returns a boolean value indicating whether the specified value or the specified key was found. Examples The following examples demonstrate the contains function in the Pact REPL. To check whether a list contains a specified value: Code example (pact): pact> (contains 2 [1 2 3]) true In this example, the contains functions checks whether the value 2 is included in the [1 2 3] list. Because the list contains the specified value, the contains function returns true. To check whether a specified object has 'name as a key field: Code example (pact): pact> (contains 'name { 'name: \"Ted\", 'age: 72 }) true To check whether the string \"foobar\" contains the substring \"foo\", Code example (pact): pact> (contains \"foo\" \"foobar\") true In this example, contains \"foo\" \"foobar\" checks which it does, so it returns true.",
    "source": "pact-5/general/contains.md",
    "title": "contains"
  },
  {
    "content": "continue Use continue to continue a previously-started multi-step transaction. Transactions that have multiple steps executed in a sequence are called pacts and are defined using the defpact keyword. Steps can be nested in defpact structures and the continue function enables you to continue execution with a specified value. Basic syntax To continue a previously-started defpact transaction, use the following syntax: Code example (pact): (continue value) Arguments Use the following argument to specify the value to continue the nested defpact. Argument | Type | Description value | any | Specifies the value to continue the nested defpact. Return value The continue function continues the execution of the nested defpact with the specified value. Examples The following example demonstrates the use of continue within the context of a defpact to resume its execution with a specified value. Code example (pact): (defpact transfer-crosschain: string ( sender: string receiver: string receiver-guard: guard target-chain: string amount: decimal ) (step (with-capability (TRANSFER_XCHAIN sender receiver amount target-chain) (install-capability (coin. TRANSFER sender receiver amount)) (coin. transfer-crosschain sender receiver receiver-guard target-chain amount) ) ) (step (continue (coin. transfer-crosschain sender receiver receiver-guard tar. . . [code continues]",
    "source": "pact-5/general/continue.md",
    "title": "continue"
  },
  {
    "content": "define-namespace Use define-namespace to create a new namespace or update the guards of an existing namespace. The ownership and use of the namespace are controlled by the specified guards. Note: This function can only be used at the top level of your code. It will fail if used within module code. Basic syntax To define the namespace namespace, use the following syntax: Code example (pact): (define-namespace namespace user-guard admin-guard) Arguments Use the following arguments to specify the namespace and guards when using the define-namespace Pact function. Argument | Type | Description namespace | string | Specifies the name of the namespace to create or update. user-guard | guard | Specifies the guard that controls who can use the namespace. admin-guard | guard | Specifies the guard that controls the ownership and administrative tasks in the namespace. Return value The define-namespace function returns the name of the created or updated namespace as a string. Example The following example creates a new namespace called 'my-namespace' with user and admin guards defined by the 'user-ks' and 'admin-ks' keysets, respectively: Code example (pact): (define-namespace 'my-namespace (read-keyset 'user-ks) (read-keyset 'admin-ks))",
    "source": "pact-5/general/define-namespace.md",
    "title": "define-namespace"
  },
  {
    "content": "describe-namespace Use describe-namespace to describe the specified namespace, returning a row object containing the keyset guards for the administrative owner of the namespace and the user allowed to access the namespace for the specified namespace. Basic syntax To describe the namespace namespace, use the following syntax: Code example (pact): (describe-namespace namespace) Prerequisites You must define a namespace with the define-namespace function before you can use the describe-namespace function. For information about defining a namespace, see define-namespace. Arguments Use the following argument to specify the namespace for the describe-namespace Pact function. Argument | Type | Description namespace | string | Specifies the name of the namespace to describe. Return value The describe-namespace function returns an object with detailed information about the specified namespace. Examples The following example demonstrates the describe-namespace function: Code example (pact): pact> (env-data { \"keyset\": [\"fake-key\"]}) \"Setting transaction data\" pact> (define-namespace 'my-namespace (read-keyset 'keyset) (read-keyset 'keyset)) \"Namespace defined: my-namespace\" pact> (describe-namespace 'my-namespace) \"admin-guard\": KeySet {keys: [fake-key], pred: keys-all}, \"namespace-name\": \"my-namespace\", \"user-guard\": KeySet {keys: [ fake-key ], pred: keys-all}} In this example, (describe-namespace 'my-namespace) is used to describe the namespace named \"my-namespace\". The function returns a row object containing the keyset guards for the administrative owner of the namespace and the user allowed to access the namespace for the specified namespace.",
    "source": "pact-5/general/describe-namespace.md",
    "title": "describe-namespace"
  },
  {
    "content": "distinct Use distinct to return a list with duplicates removed from a homogeneous list of values. The original order of the values is preserved. Basic syntax To return a list with duplicates removed from a list of values, use the following syntax: Code example (pact): (distinct [values]) Arguments Use the following argument to specify the list of VALUES for the distinct Pact function. Argument | Type | Description values | [any] | Specifies the list of values that includes duplicates. Return value The distinct function returns a list with duplicates removed from the specified list of values. Examples The following example demonstrates how to use the distinct function to remove duplicates from a list of numeric values: Code example (pact): pact>(distinct [3 3 1 1 2 2]) [3, 1, 2] The function returns [3 1 2], preserving the original order of the values.",
    "source": "pact-5/general/distinct.md",
    "title": "distinct"
  },
  {
    "content": "do Use do to evaluate a sequence of expressions in order and only return the result from the last expression. Basic syntax To evaluate a series of expressions, use the following syntax: Code example (pact): (do (my-expression1) (my-expression2) (my-return-expression)) Examples The following example demonstrates using the do built-in function to evaluate three expressions using the Pact command-line interpreter interactively: Code example (pact): pact> (do (base64-encode \"hello world! \") (+ 1 2) (+ 121 299)) 420 Notice that this example returns the value from the last expression evaluated, in this case, the result of the (+ 121 299) expression. You should also note that the do built-in function evaluates every expression in order. If any expression in the sequence results in an error, the remaining expressions are never evaluated. For example, if the first expression results in a error, only the error is returned: Code example (pact): pact> (do (enforce false \"boom\") (+ 1 2)) (interactive): 1: 4: boom 1 | (do (enforce false \"boom\") (+ 1 2)) | ^^^^^^^^^^^^^^^^^^^^^^",
    "source": "pact-5/general/do.md",
    "title": "do"
  },
  {
    "content": "drop Use drop to remove a specified number of values from a list, string, or object. Basic syntax Because drop is an overloaded function, there are two ways to use it. To remove the specified count number of values from a list or string, use the following syntax: Code example (pact): (drop count [list]) To remove the specified keys and corresponding values from an object or string, use the following syntax: Code example (pact): (drop keys {object}) Arguments Use the following arguments to specify the count and list or keys and object for the drop Pact function: Argument | Type | Description count | integer | Specifies the number of values to drop from the list or a string. list | [any] or string | Specifies the list (or string) from which to drop values. keys | [string] | Specifies the keys to drop from the object. object | object | Specifies the object from which to drop entries with specified keys. Return value The drop function returns the modified list, string, or object after removing the specified number of values or specified keys. Examples The following example demonstrates how to use the drop function to drop the first two characters from the specified string: Code example (pact): pact> (drop 2 \"vwxyz\") \"xyz\" The following example illustrates how to drop the last two values from the specified list: Code example (pact): pact> (drop -2 [1 2 3 4 5]) [1, 2, 3] The following example drops the key 'name and its corresponding value from the specified object: Code example (pact): pact> (drop ['name] { 'name: \"Vlad\", 'active: false }) {'active: false}",
    "source": "pact-5/general/drop.md",
    "title": "drop"
  },
  {
    "content": "enforce-guard Use enforce-guard to execute a specified guard or a defined keyset named keysetname to enforce the predicate logic. Basic syntax To use a guard to enforce specific conditions defined in predicate logic, use the following syntax: Code example (pact): (enforce-guard guard) To use a defined keyset as a guard to enforce specific conditions defined in predicate logic, use the following syntax: Code example (pact): (enforce-guard keysetname) Arguments Use the following arguments to specify the guard or keysetname for the enforce-guard Pact function: Argument | Type | Description guard | guard | Specifies the name of the guard to execute. keysetname | string | Specifies the name of the defined keyset to enforce. Return value The enforce-guard function returns a boolean value indicating whether the conditions specified in the predicate logic that the guard or keyset is there to enforce were met. Examples The following example demonstrates using the keyset guard named admin-keyset to enforce specific signing requirements defined in the keyset predicate function, for example with the keys-all or keys-2predicate: Code example (pact): (enforce-guard 'admin-keyset) In most cases, you use enforce-guard in the context of contract logic to ensure a specific condition is true before allowing a specific operation to be executed. For example, you might have logic to validate a sender account before allowing a transfer operation. You can then call the enforce-guard to ensure the sender meets the specified conditions—returning true as a result—before executing further logic: Code example (pact): (enforce-guard sender-guard)",
    "source": "pact-5/general/enforce-guard.md",
    "title": "enforce-guard"
  },
  {
    "content": "enforce-one Use enforce-one to run a series of tests in order (in a pure context, plus keyset enforces). If all tests fail, the transaction fails. This function short-circuits on the first successful test. Basic syntax To run a series of tests in order and short-circuit on the first successful test, use the following syntax: Code example (pact): (enforce-one msg tests) Arguments Use the following arguments to specify the error message and tests for the enforce-one Pact function: Argument | Type | Description msg | string | Specifies the error message if all tests fail. tests | bool | Specifies the list of tests to run in order. Return value The enforce-one function returns true if at least one test succeeds. If all tests fail, the function fails the transaction with the specified error message. Examples The following example demonstrates the enforce-one function: Code example (pact): pact> (enforce-one \"Should succeed on second test\" [(enforce false \"Skip me\") (enforce (= (+ 2 2) 4) \"Chaos reigns\")]) true In this example, (enforce-one \"Should succeed on second test\" [(enforce false \"Skip me\") (enforce (= (+ 2 2) 4) \"Chaos reigns\")]) is used to run two tests in order. The first test is enforce false \"Skip me\", which fails intentionally. The second test is (enforce (= (+ 2 2) 4) \"Chaos reigns\"), which succeeds because 4 = 4 is true. Because the second test succeeds, the enforce-one function returns true. If all tests had failed, the transaction would have failed with the specified error message \"Should succeed on second test\".",
    "source": "pact-5/general/enforce-one.md",
    "title": "enforce-one"
  },
  {
    "content": "enforce-pact-version Use enforce-pact-version to enforce the runtime Pact version to be within a specified range, where the version is greater than or equal to the min-version argument and less than or equal to the max-version argument. The max-version argument is optional. Version values are matched numerically from the left, meaning versions like '2', '2. 2', and '2. 2. 3' would all allow '2. 2. 3'. Basic syntax To enforce the runtime Pact version within a specified range, use the following syntax: Code example (pact): (enforce-pact-version min-version max-version) Arguments Use the following arguments to specify the minimum and maximum Pact versions for the enforce-pact-version Pact function: Argument | Type | Description min-version | string | Specifies the minimum Pact version to enforce. max-version | string | Specifies the maximum Pact version to enforce (optional). Return value The enforce-pact-version function returns a boolean value indicating whether the runtime Pact version is within the specified range. Examples The following example demonstrates how to use the enforce-pact-version function to ensure that the runtime Pact version is at least \"4. 10\": Code example (pact): pact>(enforce-pact-version \"4. 10\") true If the current Pact version is \"4. 10\" or higher, the function returns true. If the Pact version is lower than \"4. 10\" or you specify an invalid version, the function fails. Code example (pact): <interactive>: 0: 0: Error: Invalid pact version 4. 10, minimum allowed: 4. 4 You can also specify a maximum Pact version: Code example (pact): pact>(enforce-pact-version \"4. 0\" \"4. 10\") true",
    "source": "pact-5/general/enforce-pact-version.md",
    "title": "enforce-pact-version"
  },
  {
    "content": "enforce-verifier Use enforce-verifier to enforce that a verifier plugin with the specified verifier-name is in scope. Basic syntax To enforce that a verifier is in scope, use the following syntax: Code example (pact): (enforce-verifier verifier-name) Arguments Use the following argument to specify the verifier-name for the enforce-verifier Pact function: Argument | Type | Description verifier-name | string | Specifies the name of the verifier to enforce. Return value The enforce-verifier function returns a boolean value indicating whether the specified verifier is in scope. Examples The following example demonstrates the enforce-verifier function: Code example (pact): pact> (enforce-verifier 'COOLZK) <interactive>: 0: 0: Error: Verifier failure COOLZK: not in transaction In this example, (enforce-verifier 'COOLZK) is used to enforce that the verifier named 'COOLZK' is in scope. If the verifier 'COOLZK' is in scope, the function returns true. If the verifier is not in scope, the function fails. The enforce-verifier function provides a way to ensure that a specific verifier is available for use within a Pact contract.",
    "source": "pact-5/general/enforce-verifier.md",
    "title": "enforce-verifier"
  },
  {
    "content": "enforce Use enforce to test whether a pure expression evaluates to true or false. If the specified expression evaluates to true, the function returns true. If the specified expression evaluates to false, the function fails the transaction and displays the specified error message. Basic syntax To fail a transaction with a specified error message if an expression evaluates to false, use the following syntax: Code example (pact): (enforce expression message) Arguments Use the following arguments to specify the test expression and error message for the enforce Pact function: Argument | Type | Description expression | bool | Specifies the expression to evaluate. message | string | Specifies the error message to display if the expression evaluates as false. Return value The enforce function returns true if the specified expression is true. If the expression is false, the function fails the transaction with the specified error message. Examples The following example demonstrates how to use the enforce function to evaluate the expression (+ 2 2) = 4: Code example (pact): pact> (enforce (= (+ 2 2) 4) \"All is well\") true Because the specified expression (2 + 2 = 4) is true, the function returns true and the transaction continues. The following example demonstrates how to use the enforce function to evaluate the expression (2 + 2)! = 4: Code example (pact): pact> (enforce (! = (+ 2 2) 4) \"The expression is false\") The expression is false at <interactive>: 0: 0: (enforce (native! = True if X does not equal Y. Type: x. . . \"The expression is false\") Because the expression is false, the transaction fails with the error message specified.",
    "source": "pact-5/general/enforce.md",
    "title": "enforce"
  },
  {
    "content": "enumerate Use enumerate to return a sequence of numbers from the specified first number to the specified last number, inclusively, as a list. By default, the sequence increments by one from the first number to the last number. Optionally, you can specify an increment other than one to use between numbers in the sequence. If you specify a first number that’s greater than the last number, the sequence decrements by one from the first number to the last number. Basic syntax To increment or decrement the sequence by one, use the following syntax: Code example (pact): (enumerate first last) To specify a value to increment or decrement the sequence by, use the following syntax: Code example (pact): (enumerate first last inc) Arguments Use the following arguments to define the beginning and end of the sequence you want to list using the enumerate Pact function. Argument | Type | Description first | integer | Specifies the first number in the sequence. last | integer | Specifies the last number in the sequence. Options Use the following option to define the increment to use between the beginning and end of the sequence in the enumerate Pact function. Option | Type | Description inc | integer | Specifies the increment to use between numbers in the sequence. The value can be a positive or negative integer. Return value The enumerate function returns the resulting sequence of numbers as a list. Examples The following example enumerates a sequence of numbers using the default increment of one in the Pact REPL: Code example (pact): pact>(enumerate 0 10) [0 1 2 3 4 5 6 7 8 9 10] The following example enumerates a sequence of numbers using an increment of two between numbers in the sequence: Code example (pact): pact>(enumerate 0 10 2) [0 2 4 6 8 10] The following example illustrates decrementing a sequence of numbers using an inc value of -2 between numbers in the sequence: Code example (pact): (enumerate 20 10 -2) [20 18 16 14 12 10]",
    "source": "pact-5/general/enumerate.md",
    "title": "enumerate"
  },
  {
    "content": "filter Use filter to filter a list of elements by applying the specified apply function to each element in the list. For each element in the list, the apply function should return true or flase to identify the elements that should be included in the filtered list. Each element that returns a result of true from the apply function is included in the resulting list with its original value. With the filter function, you can include elements in a list based on a specific condition. Basic syntax To filter a list by applying a function to each element, use the following syntax: Code example (pact): (filter apply [elements]) Arguments Use the following arguments to specify the function and list for the filter Pact function: Argument | Type | Description apply | function | Specifies the function to apply to each element of the list. The return value for the function must be a Boolean (true or false) to identify elements to be included in the resulting list. elements | [any] | Specifies the list of elements to filter. The elements in the list can be any data type. Return value The filter function returns a new list containing elements from the original list for which the apply function returns true. Examples The following example demonstrates how to use filter with a function that evaluates the length of strings to only include the strings with more than two characters: Code example (pact): (filter (lambda (str) (< 2 (length str))) [\"my\" \"dog\" \"has\" \"fleas\"]) [\"dog\" \"has\" \"fleas\"] In this example, (lambda (str) (< 2 (length str))) is used as the function that is applied to each element. This function checks the length of each element in the list. The filter function then filters the list [\"my\" \"dog\" \"has\" \"fleas\"] based on this condition. The resulting list only contains the elements that returned true when the function was applied. In this case, the resulting list is [\"dog\" \"has\" \"fleas\"]. In the following example, (compose (length) (= 3)) is the function applied to each element: Code example (pact): pact> (filter (compose (length) (= 3)) [\"my\" \"red\" \"dog\" \"has\" \"fleas\"]) [\"red\" \"dog\" \"has\"] Like the previous example, the (compose (length) (= 3)) function checks the length of each element in the list. The filter function then filters the list based on this condition and the resulting list only contains the elements that returned true when the function was applied. In this case, the resulting list is [\"red\" \"dog\" \"has\"].",
    "source": "pact-5/general/filter.md",
    "title": "filter"
  },
  {
    "content": "fold Use fold to iteratively reduce a list by applying the app function to the last result for each element in the list, starting with the specified init initial value. You can use any data type for the value argument as long as the first oper1 functions can take that same data type. By convention, data type notation like <a> and <b> are used to represent type-bound parameters like the init and list arguments in this function. Basic syntax To iteratively reduce a list by applying a function to each element, starting with an initial value, use the following syntax: Code example (pact): (fold app init [list]) Arguments Use the following arguments to specify the function, initial value, and list for the fold Pact function: Argument | Type | Description app | function x: <a> y: <b> -> <a> | Specifies the function to apply to each element and the last result. init | <a> | Specifies the initial value for the reduction. list | [<b>] | Specifies the list to iterate over. Return value The fold function returns the final result of the iterative reduction of the list. Examples The following example demonstrates the fold function: Code example (pact): pact>(fold (+) 0 [100 10 5]) 115 In this example, (+) is used as the function to apply, which is addition in this case. The fold function starts with an initial value of 0 and iteratively adds each element of the list [100 10 5] to the previous result. Here's the breakdown: - Initial value: 0 - First iteration: 0 + 100 = 100 - Second iteration: 100 + 10 = 110 - Third iteration: 110 + 5 = 115 The final result of the fold operation is 115. The fold function is commonly used for operations that require accumulating results over a list in Pact contracts.",
    "source": "pact-5/general/fold.md",
    "title": "fold"
  },
  {
    "content": "format Use format to input specified variables into a template string in the location specified using curly braces ({}) as template placeholders. Basic syntax To input variables into a template string where specified by the {} placeholders, use the following syntax: Code example (pact): (format template variables) Arguments Use the following arguments to specify the template string and variables for the format Pact function: Argument | Type | Description template | string | Specifies the template string with {} placeholders. variables | [any] | Specifies the variables to insert into the template placeholders. Return value The format function returns a new string with the values from the specified variables replacing the placeholder curly braces {} from the template string. Examples The following example demonstrates how to use the format function with \"My {} has {}\" as the template string with two {} placeholders: Code example (pact): pact> (format \"My {} has {}\" [\"dog\" \"fleas\"]) \"My dog has fleas\" In this example, the format function replaces the placeholders in the template string with the specified values [\"dog\", \"fleas\"] to return the result \"My dog has fleas\". The format function is often used to create dynamic strings with variables inserted into specific locations in Pact contracts. For example, you can use the variables to store dynamic values like the current time: Code example (pact): (enforce (>= curr-time release-time) (format \"Funds locked until {}. Current time: {}\" [release-time curr-time]))",
    "source": "pact-5/general/format.md",
    "title": "format"
  },
  {
    "content": "hash-keccak256 Use hash-keccak256 to compute the hash of a list of unpadded base64url-encoded inputs VALUES. The hash is computed incrementally over all of the decoded inputs. Basic syntax To compute the hash of a list of inputs, use the following syntax: (hash-keccak256 VALUES) Arguments Use the following argument to specify the list of inputs for the hash-keccak256 Pact function: Argument | Type | Description VALUES | [string] | Specifies the list of unpadded base64url-encoded inputs. Return value The hash-keccak256 function returns a string representing the computed hash value. Examples The following examples demonstrate the hash-keccak256 function: Code example (pact): pact>(hash-keccak256 []) \"xdJGAYb3IzySfn2y3McDwOUAtlPKgic7erYBF2FpHA\" In this example, an empty list [] is provided as input. The hash-keccak256 function computes the hash of the empty list and returns the hash value. Code example (pact): (hash-keccak256 [\"T73FllCNJKKgAQ4UCYC4CfucbVXsdRJYkd2YXTdmW9gPm-tqUCB1iKvzzu6Md82KWtSKngqgdO04hzg2JJbS-yyHVDuzNJ6mSZfOPntCTqktEi9X27CFWoAwWEN4Ir7DItecXm5BEuTYGnFjsxOeMIiLU2sPlX7macWL0ylqnVqSpgt-tvzHvJVCDxLXGwbmaEH19Ov9uJFHwsxMmiZD9Hjl4tOTrqN7THy0tel9rc8WtrUKrg87VJ7OR3Rtts5vZ91EBs1OdVldUQPRP536eTcpJNMo-N0fy-taji6L9Mdt4I4xGqgIfmJxJMpx6ysWmiFVte8vLKl1L5p0yhOnEDsSDjuhZISDOIKC2NeytqoT9VpBQn1T3fjWkF8WEZIvJg5uXTgeqwA46QKV0LE5AlMKgw0cK91T8fnJ-u1Dyk7tCo3XYbx-292iiih8YM1Cr1-cdY5cclAjHAmlglY2iaGXit5. . . [code continues] In this example, a list containing multiple base64url-encoded strings is provided as input. The hash-keccak256 function computes the hash of all the inputs and returns the hash value. The hash-keccak256 function is useful for computing hash values of data for various cryptographic operations in Pact contracts.",
    "source": "pact-5/general/hash-keccak256.md",
    "title": "hash-keccak256"
  },
  {
    "content": "hash-poseidon Use hash-poseidon to compute the Poseidon Hash Function. Note that this is a reference version of the Poseidon hash function. Basic syntax To compute the Poseidon Hash Function using the reference version, use the following syntax: Code example (pact): (hash-poseidon i j k l m n o p) Arguments Use the following arguments to specify the inputs for computing the Poseidon hash using the hash-poseidon Pact function. Argument | Type | Description i, j, k, l, m, n, o, p | integer | Specifies the inputs for the Poseidon hash function. Return value The hash-poseidon function returns an integer representing the computed Poseidon hash. Examples The following examples demonstrate the use of hash-poseidon in the Pact REPL: Code example (pact): pact>(hash-poseidon 1) pact>(hash-poseidon 1 2) pact>(hash-poseidon 1 2 3 4 5 6) pact>(hash-poseidon 1 2 3 4 5 6 7 8) In these examples, different sets of inputs are provided to compute the Poseidon hash using the reference version. The function returns the computed hash value as an integer.",
    "source": "pact-5/general/hash-poseidon.md",
    "title": "hash-poseidon"
  },
  {
    "content": "hash Use hash to compute the BLAKE2b 256-bit hash of a specified value. The resulting hash value is a Base64Url-encoded string without padding. Strings values are converted directly. Other data type values are converted using their JSON representation. Non-value-level arguments are not allowed. By convention, the data type <a> is used to represent a type-bound parameter like the value argument in this function. Basic syntax To compute the BLAKE2b 256-bit hash of a value, use the following syntax: Code example (pact): (hash value) Arguments Use the following argument to specify the value for the hash Pact function: Argument | Type | Description value | <a> | Specifies the value to be hashed. Return value The hash function returns a string representing the computed hash value. Examples The following example demonstrates how to use the hash function to compute a hash for the \"hello\" string value: Code example (pact): pact> (hash \"hello\") \"Mk3PAn3UowqTLEQfNlol6GsXPe-kuOWJSCU0cbgbcs8\" Because \"hello\" is a string value, the hash function computes the BLAKE2b 256-bit hash of the string \"hello\" and returns the hash value. Code example (pact): (hash { 'foo: 1 }) \"h9BZgylRfM4HxcBXr15IcSXXXSz74ZC2IAViGlez4\" In this example, { 'foo: 1 } is a JSON object. The hash function computes the BLAKE2b 256-bit hash of the JSON representation of the object and returns the hash value. The hash function is useful for generating hash values of data for various cryptographic operations in Pact contracts.",
    "source": "pact-5/general/hash.md",
    "title": "hash"
  },
  {
    "content": "identity Use identity to return the provided value. Basic syntax To return the provided value, use the following syntax: (identity value) Arguments Use the following argument to specify the value you want to return using the identity Pact function. Argument | Type | Description value | any | Specifies the value to be returned. Return value The identity function returns the provided value. Examples The following example demonstrates the use of identity within a map function in the Pact REPL: Code example (pact): pact>(map (identity) [1 2 3]) [1 2 3] This example applies the identity function to each element in the list [1, 2, 3], effectively returning the same list.",
    "source": "pact-5/general/identity.md",
    "title": "identity"
  },
  {
    "content": "if Use if to test a condition. If the condition cond is true, evaluate the then expression; otherwise, evaluate the else expression. By convention, the data type <a> is used to represent type-bound parameters that serve as input for functions and expressions or for generic arguments. Basic syntax To test a condition and execute different expressions based on the result, use the following syntax: Code example (pact): (if cond then else) Arguments Use the following arguments to define the condition and expressions to be evaluated based on the outcome of the condition using the if Pact function. Argument | Type | Description cond | boolean | Specifies the condition to be tested. then | <a> | Specifies the expression to be evaluated if the condition is true. else | <a> | Specifies the expression to be evaluated if the condition is false. Return value The if function returns the result of evaluating either the then expression or the else expression, depending on the outcome of the condition. Examples The following example demonstrates the use of if to test a condition in the Pact REPL: Code example (pact): pact>(if (= (+ 2 2) 4) \"Sanity prevails\" \"Chaos reigns\") \"Sanity prevails\" In this example, the condition (= (+ 2 2) 4) evaluates to true, so the expression \"Sanity prevails\" is returned. Code example (pact): pact>(if (= (+ 2 2) 5) \"Sanity prevails\" \"Chaos reigns\") \"Chaos reigns\" In this example, the condition (= (+ 2 2) 5) evaluates to false, so the expression \"Chaos reigns\" is returned.",
    "source": "pact-5/general/if.md",
    "title": "if"
  },
  {
    "content": "int-to-str Use int-to-str to represent an integer value as a string in a specified base. The base can be any integer from 2 to 16, or 64 for unpadded base64URL representation. Only positive values are allowed for base64URL conversion. Basic syntax To represent an integer value as a string in a specified base, use the following syntax: (int-to-str base val) Arguments Use the following arguments to specify the base and integer value you want to convert using the int-to-str Pact function. Argument | Type | Description base | integer | Specifies the base in which the integer value will be represented as a string. It can be any integer from 2 to 16, or 64 for unpadded base64URL representation. val | integer | Specifies the integer value to be converted into a string representation. Return value The int-to-str function returns the string representation of the integer value in the specified base. Examples The following examples demonstrate the use of int-to-str in the Pact REPL: Code example (pact): pact>(int-to-str 16 65535) \"FFFF\" In this example, the integer value 65535 is represented as a string in base 16, resulting in \"FFFF\". Code example (pact): pact>(int-to-str 64 43981) \"XA\" In this example, the integer value 43981 is represented as a string in base 64 (unpadded base64URL), resulting in \"XA\".",
    "source": "pact-5/general/int-to-str.md",
    "title": "int-to-str"
  },
  {
    "content": "is-charset Use is-charset to check whether a string conforms to a supported character set. The character sets currently supported are CHARSETLATIN1 (ISO-8859-1) and CHARSETASCII (ASCII). Support for additional sets, including those up through ISO 8859-5 supplement, will be added in the future. Basic syntax To check whether a string conforms to a specified character set, use the following syntax: (is-charset charset input) Arguments Use the following arguments to specify the character set and input string you want to check using the is-charset Pact function. Argument | Type | Description charset | integer | Specifies the character set to which the input string should conform. Currently supported values are 0 for 'CHARSETLATIN1' (ISO-8859-1) and 1 for 'CHARSETASCII' (ASCII). input | string | Specifies the input string to be checked for conformity to the specified character set. Return value The is-charset function returns a boolean value indicating whether the input string conforms to the specified character set. Examples The following examples demonstrate the use of is-charset in the Pact REPL: Code example (pact): pact>(is-charset CHARSETASCII \"hello world\") true In this example, the input string \"hello world\" conforms to the ASCII character set. Code example (pact): pact>(is-charset CHARSETASCII \"I am nÖt ascii\") false In this example, the input string \"I am nÖt ascii\" contains characters that are not part of the ASCII character set. Code example (pact): pact>(is-charset CHARSET_LATIN1 \"I am nÖt ascii, but I am latin1! \") true In this example, the input string \"I am nÖt ascii, but I am latin1! \" conforms to the ISO-8859-1 (Latin-1) character set.",
    "source": "pact-5/general/is-charset.md",
    "title": "is-charset"
  },
  {
    "content": "length Use length to return the number of elements in a list, a string, or an object. Basic syntax To compute the length of a list, string, or object, use the following syntax: Code example (pact): (length arg) Arguments Use the following argument to specify the value for which you want to compute the length using the length Pact function. Argument | Type | Description arg | list, string, or object | Specifies the list, string, or object that you want to compute the length of. Return value The length function returns an integer representing the length of the specified list, string, or object. Examples The following example demonstrates calculating the length of the list [1, 2, 3] in the Pact REPL: Code example (pact): pact> (length [1 2 3]) 3 The following example calculates the length of the string \"abcdefgh\", resulting in 8. Code example (pact): pact> (length \"abcdefgh\") 8 The following example calculates the length of the object { \"a\": 1, \"b\": 2 }, resulting in 2. Code example (pact): pact> (length { \"a\": 1, \"b\": 2 }) 2",
    "source": "pact-5/general/length.md",
    "title": "length"
  },
  {
    "content": "list-modules Use list-modules to list the modules that are deployed in your current environment and available for loading. Basic syntax To list the modules deployed and available for loading, use the following syntax: Code example (pact): (list-modules) Arguments The list-modules function takes no arguments. Return value The list-modules function returns a list of strings representing the modules that are deployed in your current environment and available for loading. Examples The following example demonstrates how to use the list-modules function in the Pact REPL: Code example (pact): pact> (list-modules) [\"coin\" \"fungible-v2\" \"fungible-xchain-v1\" \"gas-payer-v1\"] In this example, the contract modules that are deployed by default on the development, test, and main network are listed as available for loading. If there are no contracts deployed, the list-modules function returns a empty list. For example: Code example (pact): pact> (list-modules) []",
    "source": "pact-5/general/list-module.md",
    "title": "list-modules"
  },
  {
    "content": "make-list Use make-list to create a list by repeating a specified value a certain number of times. Basic syntax To create a list by repeating a value a specified number of times, use the following syntax: (make-list times value) Arguments Use the following arguments to specify the length of the list and the value to be repeated using the make-list Pact function. Argument | Type | Description times | integer | Specifies the length of the list to be created. value | any | Specifies the value to be repeated to create the list. Return value The make-list function returns a list containing the specified value repeated the specified number of times. Examples The following example demonstrates the use of make-list in the Pact REPL: Code example (pact): pact>(make-list 5 true) [true true true true true] In this example, a list containing the value true repeated 5 times is created using the make-list function.",
    "source": "pact-5/general/make-list.md",
    "title": "make-list"
  },
  {
    "content": "map Use map to apply an application function (app) to each element in a list (list), returning a new list of results. You can use any data type for the list argument as long as the first app function can take that same data type. By convention, data type notation like <a> and <b> are used to represent type-bound parameters that serve as input for functions and expressions or for generic arguments. Basic syntax To apply an application function to each element in a list, use the following syntax: Code example (pact): (map app list) Arguments Use the following arguments to specify the application function and the list of elements to be mapped using the map Pact function. Argument | Type | Description app | function x: <b> -> <a> | Specifies the application function to be applied to each element in the list. list | [<b>] | Specifies the list of elements to be mapped. Return value The map function returns a new list containing the results of applying the application function to each element in the input list. Examples The following example demonstrates the use of map in the Pact REPL: Code example (pact): pact>(map (+ 1) [1 2 3]) [2 3 4] In this example, the application function (+ 1) is applied to each element in the list [1 2 3], resulting in a new list [2 3 4].",
    "source": "pact-5/general/map.md",
    "title": "map"
  },
  {
    "content": "namespace Use namespace to set the current working environment to the specified namespace value. After you declare the namespace you want to work with, all of the modules and functions you define are contained within that namespace. You can access the modules and functions in a namespace by using their fully qualified name. The fully-qualified name includes the namespace string as a prefix before the module name. For example, if you declare a principal namespace such as n14912521e87a6d387157d526b281bde8422371d1 for the module my-calculator, you can call functions in the module using a fully-qualified name similar to the following: n14912521e87a6d387157d526b281bde8422371d1. my-calculator. add If you call the namespace function after the initial declaration, Pact creates a new namespace for all subsequent declarations until either the next namespace call or the end of the transaction. Prerequisites You must define a namespace before you can set your working context to use the namespace function. For information about defining a namespace, see define-namespace. Basic syntax To set the current namespace to a specified value, use the following syntax: Code example (pact): (namespace namespace) Arguments Use the following argument to specify the namespace to be set using the namespace Pact function. Argument | Type | Description namespace | string | Specifies the name of the namespace you want to use as your working context. Return value The namespace function returns the string representing the namespace that has been set. Examples The following example demonstrates the use of namespace in a Pact script: Code example (pact): (namespace 'my-namespace) In this example, the current namespace is set to 'my-namespace'. All subsequent expressions within the same transaction will be contained in this namespace until a new namespace is set or the transaction ends.",
    "source": "pact-5/general/namespace.md",
    "title": "namespace"
  },
  {
    "content": "negate Use negate to negate a specified integer or decimal value. Note that the integer can be a positive or negative value. Basic syntax To negate a specified value, use the following syntax: Code example (pact): (negate value) Arguments Use the following argument to specify the value for negation. Argument | Type | Description value | integer or decimal | Specifies the value to be negated. Return value The negate function returns the negation of the specified value. Examples The following example demonstrates how to use the negate function to negate a positive decimal value in a Pact REPL: Code example (pact): pact> (negate 1. 0) -1. 0 The following example demonstrates how to use the negate function to negate a negative decimal value in a Pact REPL: Code example (pact): pact> (negate -3. 0) 3. 0",
    "source": "pact-5/general/negate.md",
    "title": "negate"
  },
  {
    "content": "pact-id Use pact-id to return the ID if called during the current pact execution, failing if not. Basic syntax To return the ID during the current pact execution, use the following syntax: (pact-id) Return value The pact-id function returns a string representing the ID of the current pact execution. Examples The pact-id function is called without any arguments. It returns the ID if called during the current pact execution. Code example (pact): (pact-id) In this example, pact-id is called to retrieve the ID of the current pact execution.",
    "source": "pact-5/general/pact-id.md",
    "title": "pact-id"
  },
  {
    "content": "pact-version Use pact-version to obtain the current Pact build version. Basic syntax To obtain the current Pact build version, use the following syntax: (pact-version) Return value The pact-version function returns a string representing the current Pact build version. Examples The pact-version function is called without any arguments to obtain the current Pact build version. Code example (pact): pact>(pact-version) \"5. 0\" In this example, (pact-version) is called, which returns the current Pact build version as a string.",
    "source": "pact-5/general/pact-version.md",
    "title": "pact-version"
  },
  {
    "content": "poseidon-hash-hack-a-chain Use poseidon-hash-hack-a-chain to compute the Poseidon Hash Function. Note: This is a reference version of the Poseidon hash function used by Hack-a-Chain. Basic syntax To compute the Poseidon Hash Function using the reference version, use the following syntax: (poseidon-hash-hack-a-chain i j k l m n o p) Arguments Use the following arguments to specify the inputs for computing the Poseidon hash using the poseidon-hash-hack-a-chain Pact function. Argument | Type | Description i, j, k, l, m, n, o, p | integer | Specifies the inputs for the Poseidon hash function. Return value The poseidon-hash-hack-a-chain function returns an integer representing the computed Poseidon hash. Examples The following examples demonstrate the use of poseidon-hash-hack-a-chain in the Pact REPL: Code example (pact): pact>(poseidon-hash-hack-a-chain 1) pact>(poseidon-hash-hack-a-chain 1 2) pact>(poseidon-hash-hack-a-chain 1 2 3 4 5 6) pact>(poseidon-hash-hack-a-chain 1 2 3 4 5 6 7 8) In these examples, different sets of inputs are provided to compute the Poseidon hash using the reference version. The function returns the computed hash value as an integer.",
    "source": "pact-5/general/poseidon-hash-hack-a-chain.md",
    "title": "poseidon-hash-hack-a-chain"
  },
  {
    "content": "read-decimal Use read-decimal to parse a key string or number value from the top level of the message data body as a decimal. Basic syntax To parse a key string as a decimal, use the following syntax: Code example (pact): (read-decimal key) Arguments Use the following argument to specify the key to be parsed as a decimal using the read-decimal Pact function. Argument | Type | Description key | string | Specifies the key string or number value to parse as a decimal. Return value The read-decimal function returns the parsed value as a decimal. Example The following example demonstrates how to use the read-decimal function in a Pact script. This example parses the value specified for the amount key in the body of a message as a decimal and transfers it from one account to another: Code example (pact): (defun exec () (transfer (read-msg \"from\") (read-msg \"to\") (read-decimal \"amount\"))) You can also use read-decimal to read values from JSON object payloads.",
    "source": "pact-5/general/read-decimal.md",
    "title": "read-decimal"
  },
  {
    "content": "read-integer Use read-integer to parse a key string or number value from the top level of the message data body as an integer. Basic syntax To parse a key string as an integer, use the following syntax: Code example (pact): (read-integer key) Arguments Use the following argument to specify the key to be parsed as an integer using the read-integer Pact function. Argument | Type | Description key | string | Specifies the key string or number value to parse as an integer. Return value The read-integer function returns the parsed value as an integer. Example The following example demonstrates how to use the read-integer function in a Pact script. This example parses the value specified for the age key in the body of a message as an integer: Code example (pact): (read-integer 'age)",
    "source": "pact-5/general/read-integer.md",
    "title": "read-integer"
  },
  {
    "content": "read-keyset Use read-keyset to read the specified key from the message data body as a keyset. A keyset consists of a list of keys (keylist) and, optionally, a predicate function (predfun). Basic syntax To read a key from the message data body as a keyset, use the following syntax: Code example (pact): (read-keyset key) Arguments Use the following argument to specify the key to be read as a keyset using the read-keyset Pact function. Argument | Type | Description key | string | Specifies the name of the key to be read from the message data body as a keyset. Return value The read-keyset function returns the keyset object corresponding to the specified key string. Example The following example demonstrates how to use the read-keyset function in a Pact script. This example reads the object specified for the admin-keyset key from the body of a message as the name of a keyset object: Code example (pact): (read-keyset 'admin-keyset)",
    "source": "pact-5/general/read-keyset.md",
    "title": "read-keyset"
  },
  {
    "content": "read-msg Use read-msg to read a specific key from the top level of the message data body, or to read the data body itself if a key is not provided. In reading the value, this function enforces its corresponding Pact type, such as string, integer, boolean, list, or object. Basic syntax To read the value for a specified key from the body of a message, use the following syntax: Code example (pact): (read-msg key) To read the complete message data body, use the following syntax: Code example (pact): (read-msg) Arguments Use the following argument to specify the key to be read from the top level of the message data body using the read-msg Pact function. Argument | Type | Description key | string | Specifies the key to be read from the message data body (optional). If you don't provide this argument, the function reads the entire data body. Return value The read-msg function returns the value corresponding to the specified key from the message data body, or the entire data body if no key is provided. The data type for the return is its corresponding Pact type. Example The following example demonstrates how to use the read-msg function in a Pact script. This example reads the from and to keys from the data body of a message as strings and the amount as a decimal: Code example (pact): (defun exec () (transfer (read-msg \"from\") (read-msg \"to\") (read-decimal \"amount\"))) This example illustrates how to use the read-msg function to extract specific values from the body of a message for further processing in a Pact script.",
    "source": "pact-5/general/read-msg.md",
    "title": "read-msg"
  },
  {
    "content": "read-string Use read-string to parse the specified key string or number value from the top level of the message data body as a string. Basic syntax To parse a key string as a string, use the following syntax: Code example (pact): (read-string key) Arguments Use the following argument to specify the key to be parsed as a string using the read-string Pact function. Argument | Type | Description key | string | Specifies the key string or number value to parse as a string. Return value The read-string function returns the parsed value as a string. Example The following example demonstrates how to use the read-string function in a Pact script. This example parses the sender from the data body of a message as a string: Code example (pact): (read-string 'sender)",
    "source": "pact-5/general/read-string.md",
    "title": "read-string"
  },
  {
    "content": "remove Use remove to remove an entry associated with a specified key from a specified object. Basic syntax To remove an entry for a key from an object, use the following syntax: Code example (pact): (remove key {object}) Arguments Use the following arguments to specify the key and object for removing an entry using the remove Pact function. Argument | Type | Description key | string | Specifies the key for the entry to be removed from the object. object | object | Specifies the object from which to remove the entry. Return value The remove function returns the modified object with the entry associated with the specified key removed. Example The following example demonstrates how to use the remove function in the Pact REPL. This example removes the entry for the bar key from the given object: Code example (pact): pact> (remove \"bar\" { \"foo\": 1, \"bar\": 2 }) { \"foo\": 1 }",
    "source": "pact-5/general/remove.md",
    "title": "remove"
  },
  {
    "content": "resume Use the resume function to resume execution of a step in a defpact. This function binds to an object produced by the yield function in the prior step of a pact. If the yield function is executed on a different chain, the resume function requires a simple payment verification (SPV) proof. Basic syntax To bind to a yielded object produced by a prior step execution, use the following syntax: Code example (pact): (resume binding) Arguments Use the following argument to specify the binding to be resumed using the resume Pact function. Argument | Type | Description binding | object | Specifies the binding representing the yielded object from the prior step execution. Return value The resume function returns the value bound to the specified BINDING. Example The following example demonstrates how to use the resume function in a Pact script to bind to the yielded object sample produced by the previous step in the execution of a pact: Code example (pact): (resume sample) The following example illustrates using yield and resume functions in defpact steps: Code example (pact): (defpact deposit(sender: string receiver: string guard: guard amount: decimal) @doc \"Deposit KDA from L1 to L2\" @model [ (property (is-unit amount)) (property (is-principal sender)) (property (is-principal receiver)) ] (step (with-capability (LOCK_DEPOSIT sender) (let ((deposit-details: object{deposit-schema} { 'receiver: receiver, 'amount: amount, 'guard: guard } )) (lock-dep. . . [code continues]",
    "source": "pact-5/general/resume.md",
    "title": "resume"
  },
  {
    "content": "reverse Use reverse to reverse the order of specified elements in a list. Basic syntax To reverse a specified list of elements, use the following syntax: Code example (pact): (reverse [elements]) Arguments Use the following argument to specify the elements to be reversed using the reverse Pact function. Argument | Type | Description elements | [any] | Specifies the elements in the list you want to be reversed. Return value The reverse function returns a new list with the elements in reverse order. Example The following example demonstrates how to use the reverse function in the Pact REPL. This example reverses the order of numbers in the list: Code example (pact): pact> (reverse [1 2 3]) [3 2 1] In the following example, the reverse function reverses the order of strings in a list: Code example (pact): pact> (reverse [\"lastname\" \"firstname\" \"age\" \"occupation\"]) [\"occupation\" \"age\" \"firstname\" \"lastname\"] You can also reverse the order of objects in a list. For example: Code example (pact): (reverse [{\"lastname\": \"pistolas\", \"firstname\": \"lola\"} {\"lastname\": \"smith\", \"firstname\": \"tim\"}]) [{\"lastname\": \"smith\", \"firstname\": \"tim\"} {\"lastname\": \"pistolas\", \"firstname\": \"lola\"}] This example illustrates how to use the reverse function to reverse the order of elements in a list in Pact.",
    "source": "pact-5/general/reverse.md",
    "title": "reverse"
  },
  {
    "content": "round Use the round function to round numbers to integers or decimals using banker's rounding. The function returns an integer value if you don't specify precision as an argument. If you specify the precision argument, the function returns a decimal value with the specified precision. Basic syntax To round a decimal value to the nearest integer, use the following syntax: Code example (pact): (round number) To round a decimal value to a specified precision, use the following syntax: Code example (pact): (round number precision) Arguments Use the following arguments to specify the value to be rounded and, optionally, the precision to round to using the round Pact function. Argument | Type | Description number | decimal | Specifies the decimal value to be rounded. precision | integer | Specifies the precision to round to, if applicable (optional). Return value If no precision is specified, the round function returns the rounded value as an integer. If precision is specified, it returns the rounded value as a decimal value. Examples The following examples demonstrate the usage of the round function within the Pact REPL. To round the decimal value 3. 5 to the nearest integer: Code example (pact): pact> (round 3. 5) 4 To round the decimal value 100. 15234 to 2 decimal places: Code example (pact): pact> (round 100. 15234 2) 100. 15",
    "source": "pact-5/general/round.md",
    "title": "round"
  },
  {
    "content": "show Use show to convert a specified value into a string. Basic syntax To convert a value into a string, use the following syntax: Code example (pact): (show value) Arguments Use the following argument to specify the value to be converted to a string using the show Pact function. Argument | Type | Description value | any | Specifies the value to be converted to a string. Return value The show function returns the argument as a string. Examples The following examples demonstrate how to use the show function to convert a value to a string in a Pact REPL: Code example (pact): pact> (show 1) \"1\" pact> (show [1 2 3]) \"[1, 2, 3]\" pact> (show {\"1\": \"hello\", \"2\": \"world\"}) \"{\"1\": \"hello\", \"2\": \"world\"}\"",
    "source": "pact-5/general/show.md",
    "title": "show"
  },
  {
    "content": "sort Use sort to sort a list of primitive values based on the values themselves or a list of objects based on specific fields within the objects. If you're sorting primitive values, they are sorted in ascending numerical or alphabetical order. Basic syntax Because sort is an overloaded function, there are two ways to use it. To sort a list of primitive values, use the following syntax: Code example (pact): (sort [primitives]) To sort a list of objects based on specific fields, use the following syntax: Code example (pact): (sort [fields] [{object1} {object2}. . . ]) Arguments Use the following arguments to specify the values or fields for sorting using the sort Pact function. Argument | Type | Description primitives | [integer, decimal, or string] | Specifies the list of primitive values to be sorted. fields | [list] | Specifies the list of fields within objects to be used for sorting. | object1 | object | Specifies more or more objects to be sorted using the fields parameter. Return value The sort function returns a sorted list of values or objects based on the specified sorting criteria. Examples The following examples illustrate how to use the sort function to sort lists of values or objects in Pact. The following example demonstrates how to the sort a list of primitive values [3, 1, 2] using of the sort function: Code example (pact): pact> (sort [3 1 2]) [1, 2, 3] If you sort a list of string primitive values, they are sorted in alphabetical order. For example: Code example (pact): pact> (sort [\"second\" \"day\" \"minute\" \"hour\"]) [\"day\" \"hour\" \"minute\" \"second\"] To sort a list of objects based on the 'age field: Code example (pact): pact> (sort ['age] [{'name: \"Lin\", 'age: 30} {'name: \"Val\", 'age: 25} {'name: \"Kai\", 'age: 21}]) [{\"name\": \"Kai\", \"age\": 21} {\"name\": \"Val\", \"age\": 25} {\"name\": \"Lin\", \"age\": 30}]",
    "source": "pact-5/general/sort.md",
    "title": "sort"
  },
  {
    "content": "static-redeploy Use static-redeploy to redeploy any module, without any code changes. Redeploying a legacy module will store the new module in the new Pact 5 compact storage format. As a result, redeployed modules require significantly less gas to load. Note that redeploying leaves governance unchanged. Prerequisites You must have deployed the module in a namespace on at least one chain in the development, test, or main network before you can use the static-redeploy function to update the module storage. For information about deploying a module, see Deploy smart contracts. Basic syntax To redeploy an existing module as a Pact 5 module, use the following syntax: Code example (pact): (static-redeploy module) Arguments Use the following argument to specify the module you want to redeploy using the static-redeploy Pact function. | Argument | Type | Description | -------- | ---- | ----------- | module | string | Specifies the module to redeploy. Return value The function returns the unit value () if redeployment is successful. Examples The following example demonstrates how to redeploy the pistolas-vote module that was originally deployed in the free namespace on testnet04 and chain 3 using a YAML transaction request file. Code example (yaml): code: | (static-redeploy \"free. pistolas-vote\") data: vote: keys: [\"401d6346. . . 114c5ae4\"] pred: \"keys-all\" publicMeta: chainId: \"3\" sender: \"k: 401d6346. . . 114c5ae4\" gasLimit: 100000 gasPrice: 0. 0000001 ttl: 7200 networkId: \"testnet04\" keyPairs: - public: \"401d6346. . . 114c5ae4\" secret: \"94df4ba5. . . 2709fd1a\" caps: - name: \"coin. GAS\" args: [] - public: \"401d6346. . . 114c5ae4\" secret: \"94df4ba5. . . 2709fd1a\" caps: [] type: exec After creating the YAML request, you can format and submit the transaction request to the appropriate network and chain /send endpoint. For example: Code example (bash): pact --apireq vote-redeploy. yaml > redeploy. json curl -X POST -H \"Content-Type: application/json\" -d \"@redeploy. json\" \\ https: //api. testnet. chainweb. com/chainweb/0. 0/testnet04/chain/3/pact/api/v1/send",
    "source": "pact-5/general/static-redeploy.md",
    "title": "static-redeploy"
  },
  {
    "content": "str-to-int Use str-to-int to compute the integer value of the string str interpreted in base 10, or in a specified base, if provided. The str argument can be up to 512 characters. If you specify the base argument, it must be between 2 and 16, or 64 to perform unpadded base64url conversion. Each digit in the str argument must be in the correct range for the base. Basic syntax To compute the integer value of a string in base 10, use the following syntax: Code example (pact): (str-to-int str) To compute the integer value of a string in a specified base, use the following syntax: Code example (pact): (str-to-int base str) Arguments Use the following arguments to specify the string value and, optionally, the base for conversion using the str-to-int Pact function. Argument | Type | Description str | string | Specifies the string value to be converted to an integer. base | integer | Specifies the base in which to interpret the string value (optional). Must be between 2 and 16, or 64 for base64url encoding without padding. Return value The str-to-int function returns the integer value computed from the input string str. Examples The following examples demonstrate how to use the str-to-int function to compute the integer value of a string in the Pact REPL. To compute the integer value of the string \"123456\" interpreted in base 10: Code example (pact): pact> (str-to-int \"123456\") 123456 To compute the integer value of the string \"abcdef123456\" interpreted in base 16: Code example (pact): pact> (str-to-int 16 \"abcdef123456\") 188900967593046 To compute the integer value of the string \"spirekey\" interpreted in base 64 for base64url conversion without padding: Code example (pact): pact> (str-to-int 64 \"spirekey\") 196368781690802",
    "source": "pact-5/general/str-to-int.md",
    "title": "str-to-int"
  },
  {
    "content": "str-to-list Use str-to-list to convert a specified string into a list where each element is a single-character string. Converting a string into a list can be useful for performing other more complex string manipulation tasks. Basic syntax To convert a string into a list of single-character strings, use the following syntax: Code example (pact): (str-to-list string) Arguments Use the following argument to specify the string to be converted into a list of single-character strings using the str-to-list Pact function. Argument | Type | Description string | string | Specifies the string to be converted into a list. Return value The str-to-list function returns a list where each element represents a single character from the input string. Examples The following examples demonstrate how to use the str-to-list function within the Pact REPL. To convert the string \"hello\" into a list of single-character strings: Code example (pact): pact> (str-to-list \"hello\") [\"h\", \"e\", \"l\", \"l\", \"o\"] To concatenate spaces between each character in the string \"abcde\": Code example (pact): (concat (map (+ \" \") (str-to-list \"abcde\"))) \" a b c d e\"",
    "source": "pact-5/general/str-to-list.md",
    "title": "str-to-list"
  },
  {
    "content": "take Use the take function to retrieve a specified number of values from a list (or string), or entries with keys specified in keys from an object. If the count argument is negative, values are taken from the end of the list. If the count exceeds the interval (-2^63, 2^63), it is truncated to that range. Basic syntax Because take is an overloaded function, there are two ways to use it. To retrieve a specified number of values from a list or a string, use the following syntax: Code example (pact): (take count [list]) To retrieve entries with specified keys from an object, use the following syntax: Code example (pact): (take keys {object}) Arguments Use the following arguments to specify the number of values to retrieve and the list or object to retrieve them from using the take Pact function. Argument | Type | Description count | integer | Specifies the number of values to retrieve from the list or string. If negative, values are taken from the end. list | [integer, decimal, or string] or string | Specifies the list or string from which to retrieve values. keys | [string] | Specifies the keys for the information you want to retrieve from the specified object. object | object | Specifies the object from which to retrieve entries. Return value The take function returns a subset of values retrieved from the list or from the object based on the specified count or number of keys. Examples The following examples demonstrate how to use the take function in the Pact REPL. To retrieve the first two characters from the string \"abcd\": Code example (pact): pact> (take 2 \"abcd\") \"ab\" To retrieve the last three values from the list [1, 2, 3, 4, 5]: Code example (pact): pact> (take (- 3) [1 2 3 4 5]) [3, 4, 5] To retrieve entries with the key 'name from the object { 'name: \"Vlad\", 'active: false }: Code example (pact): (take ['name] { 'name: \"Vlad\", 'active: false, 'age: 34 }) {\"name\": \"Vlad\"}",
    "source": "pact-5/general/take.md",
    "title": "take"
  },
  {
    "content": "try Use the try function to attempt a pure action, returning a default value in the case of failure. Pure functions and pure expressions perform operations that produce a resulting value with no side effects. In most programming languages, pure functions and expressions always return identical results for identical arguments and don't allow mutable variables or input and output operations. In Pact, you can use the try built-in function to read from database tables and there's no guarantee that a value in a table remains that same between two calls of the same pure action. You can't use the try built-in function to write to database tables. Basic syntax To attempt a pure action and return a default value if the action fails, use the following syntax: Code example (pact): (try default action) Arguments Use the following arguments to specify the default value and the action to be attempted using the try Pact function. Argument | Type | Description default | any | Specifies the default value to be returned if the action fails. action | any | Specifies the action to be attempted. Return value The try function returns the result of the attempted action. If the action fails, it returns the specified default value. Examples The following example demonstrates how to use the try function in the Pact REPL. This example attempts to use the enforce function to specify a condition. If the condition fails, the try function returns the default value 3: Code example (pact): pact> (try 3 (enforce (= 1 2) \"this will definitely fail\")) 3 If the enforce function specifies a condition that succeeds, the try function returns the result. For example, if the condition succeeds, the result is true: Code example (pact): (try 3 (enforce (= 1 1) \"this will definitely fail\")) true In the following example, the default value is a string: Code example (pact): (try \"this enforce fails\" (enforce (= 2 1) \"this will definitely fail\")) \"this enforce fails\"",
    "source": "pact-5/general/try.md",
    "title": "try"
  },
  {
    "content": "tx-hash Use tx-hash to get the hash of the current transaction as a string. Basic syntax To obtain the hash of the current transaction, use the following syntax: Code example (pact): (tx-hash) Return value The tx-hash function returns the hash of the current transaction as a string. Examples The following example demonstrates how to use the tx-hash function in the Pact REPL. This example gets the hash of the current transaction: Code example (pact): (tx-hash) \"DldRwCblQ7Loqy6wYJnaodHl30d3j3eH-qtFzfEv46g\"",
    "source": "pact-5/general/tx-hash.md",
    "title": "tx-hash"
  },
  {
    "content": "typeof Use typeof to return the data type of the specified value. The data type of the specified value is returned as a string. Basic syntax To determine the data type for a value, use the following syntax: (typeof value) Arguments Use the following argument to specify the value for which to determine the type using the typeof Pact function. Argument | Type | Description value | any | Specifies the value for which to determine the type. Return value The typeof function returns the data type of the provided value as a string. Examples The following example demonstrates how to use the typeof function in the Pact REPL. This example returns the data type of the value 'hello: Code example (pact): pact> (typeof 'hello) \"string\" The following example returns the data type of the value 8: Code example (pact): pact> (typeof 8) \"integer\" The following example returns the data type of the value 4. 3: Code example (pact): pact> (typeof 4. 3) \"decimal\"",
    "source": "pact-5/general/typeof.md",
    "title": "typeof"
  },
  {
    "content": "where Use the where function to apply a specified application function (app) to a field (field) to evaluate the field value (value). The function returns a boolean value based on the result of the application. This function is most often used in conjunction with filter and select operations. Basic syntax To apply an application function to a field in a value, use the following syntax: Code example (pact): (where field app) Arguments Use the following arguments to specify the field, application function, and value for evaluation using the where Pact function. Argument | Type | Description field | string | Specifies the field in the value to be evaluated. app | function | Specifies the application function to be applied to the field. value | object: <{row}> | Specifies the value containing the field to be evaluated. Return value The where function returns a boolean value based on the result of applying the specified application function to the field in the value. Examples The following example demonstrates how to use the where function in the Pact REPL. This example applies a condition for filtering a list of objects where the \"age\" field value is less than 20: Code example (pact): (filter (where 'age (> 20)) [{'name: \"Mary\", 'age: 30} {'name: \"Juan\", 'age: 15}]) [{\"age\": 15, \"name\": \"Juan\"}]",
    "source": "pact-5/general/where.md",
    "title": "where"
  },
  {
    "content": "yield Use yield to yield an object for use with the resume function in the subsequent Pact step. Optionally, you can specify a target chain for executing the next step using automated a simplified payment verification (spv) endorsement-based dispatch. Basic syntax To yield an object for use with the resume function, use the following syntax: Code example (pact): (yield object [target-chain]) Arguments Use the following arguments to specify the object and, optionally, the target chain for executing the subsequent step using the yield Pact function. Argument | Type | Description object | object | Specifies the object to be yielded for use with 'resume'. target-chain | string | Specifies the chain ID on which the subsequent step should execute (optional). Return value The yield function returns the yielded object. Examples The following examples demonstrate how to use the yield function in a Pact script. In the following example, the yield function creates an object with one key and value that can be passed to the resume function, Code example (pact): (yield { \"amount\": 100. 0 }) Optionally, you can specify a target chain for resuming the transaction. For example, to set the target chain to chain 8: Code example (pact): (yield { \"amount\": 100. 0 } \"8\") The following example illustrates using yield and resume functions in defpact steps: Code example (pact): (defpact copy-account: string(account: string target: string) (step (with-capability (COPY_ACCOUNT account) (with-read guard-lookup-table account { 'webauthn-guard-name: = guard-name } (webauthn-guard. copy-account guard-name target) (let ((yield-data: object{copy-account-schema} { 'guard-name: guard-name })) (yield yield-data target) ) ) ) ) (step (resume { 'guard-name: = guard-name }. . . [code continues]",
    "source": "pact-5/general/yield.md",
    "title": "yield"
  },
  {
    "content": "zip Use the zip function to combine two lists using a specified function func into a new list. The length of the resulting list is determined by the length of the shortest input list. Basic syntax To combine two lists with a specified function f into a new list, use the following syntax: Code example (pact): (zip func list1 list2) Arguments Use the following arguments to specify the function and the lists that you want to combine using the zip Pact function. Argument | Type | Description func | function | Specifies the function to combine elements from the two lists. list1 | [any] | Specifies the first list to be combined. list2 | [any] | Specifies the second list to be combined. Return value The zip function returns a new list containing elements combined from the input lists according to the specified function func. Examples The following examples demonstrate how to use the zip function in the Pact REPL. This example combines two lists of numbers using the specified addition (+) function a new list: Code example (pact): pact> (zip (+) [1 2 3 4] [4 5 6 7]) [5, 7, 9, 11] The following example combines two lists of numbers using the specified subtraction (-) function to create a new list: Code example (pact): pact>(zip (-) [1 2 3 4] [4 5 6]) [-3, -3, -3] The following example illustrate combining two lists using the multiplication () function to create a new list with its length determined by input list with the fewest items Code example (pact): pact> (zip () [1 2 3 ] [4 5 6 7 8]) [4 10 18]",
    "source": "pact-5/general/zip.md",
    "title": "zip"
  },
  {
    "content": "create-capability-guard Use create-capability-guard to create a predicate function that ensures that specific conditions are true and can be enforced to grant the specified CAPABILITY. By convention, capabilities are defined using all uppercase letters. Basic syntax To create a predicate function that guards the specified CAPABILITY, use the following syntax: Code example (pact): (create-capability-guard CAPABILITY) Arguments Use the following argument to specify the CAPABILITY for the create-capability-guard Pact function. Argument | Type | Description CAPABILITY | capability | Specifies the capability that the predicate function guards. Return value The create-capability-guard function returns a guard that enforces the acquisition of the specified CAPABILITY. Examples The following example demonstrates how to use the create-capability-guard function to create a guard for the GOVERNANCE capability: Code example (pact): (defun create-gas-payer-guard: guard() (create-capability-guard (GOVERNANCE)) ) The conditions specified for the GOVERNANCE capability must evaluate to true for the capability to be acquired and related code where the capability is required to be executed. The following example illustrates how to create a guard for an ESCROWMANAGEMENT account: Code example (pact): (defconst ESCROWID (create-principal (create-capability-guard (ESCROW_MANAGEMENT)) ) \"The escrow will hold all KDA in circulation on the chain\" )",
    "source": "pact-5/guards/create-capability-guard.md",
    "title": "create-capability-guard"
  },
  {
    "content": "create-capability-pact-guard Use create-capability-pact-guard to create a predicate function that ensures that specific conditions are true and can be enforced to grant the specified CAPABILITY for steps defined in a defpact multi-step transaction. By convention, capabilities are defined using all uppercase letters. Basic syntax To create a predicate function that guards the specified CAPABILITY in a defpact multi-step transaction, use the following syntax: Code example (pact): (create-capability-pact-guard CAPABILITY) Arguments Use the following argument to specify the CAPABILITY for the create-capability-pact-guard Pact function. Argument | Type | Description CAPABILITY | capability | Specifies the capability that the predicate function guards. Return value The create-capability-pact-guard function returns a guard that enables the code associated with the specified CAPABILITY to be executed in the context of a defpact multi-step transaction. Examples The following example demonstrates how to use the create-capability-pact-guard function to create a guard for the ESCROW owner capability in adefpact step: Code example (pact): (create-capability-pact-guard (ESCROW owner)) The following example creates a guard for the SALEPRIVATE capability associated with the pact-id for the sales contract being executed: Code example (pact): (defun offer: bool ( id: string seller: string amount: decimal ) @doc \"Initiate sale with by SELLER by escrowing AMOUNT of TOKEN until TIMEOUT. \" @model [ (property (! = id \"\")) (property (! = seller \"\")) (property (>= amount 0. 0)) ] (require-capability (SALEPRIVATE (pact-id))) (let ( (sender (debit id seller amount)) (receiver (credit id (sale-account) (create-capability-pact-guard (SALE_PRIVATE (pact-id))) amount)). . . [code continues]",
    "source": "pact-5/guards/create-capability-pact-guard.md",
    "title": "create-capability-pact-guard"
  },
  {
    "content": "create-module-guard Use create-module-guard to create a predicate function with the specified name that ensures that specific conditions are true for the current module. Module guards are typically used to enable a module to perform administrative operations independently outside of the module itself, for example, to own coins in an external ledger, or to perform administrative operations internally on its database, for example, to own and manage certain assets. Basic syntax To define a predicate function name that guards administrative activity for the current module, use the following syntax: Code example (pact): (create-module-guard name) Arguments Use the following argument to specify the name for the create-module-guard Pact function. Argument | Type | Description name | string | Specifies the name of the predicate function that guards administrative activity for the current module. Return value The create-module-guard function returns a guard with the specified namethat enables the current module to perform administrative operations. Example The following example demonstrates how to use the create-module-guard function to define a guard named \"module-admin-guard\" for the current module: Code example (pact): (create-module-guard \"module-admin-guard\") If the evaluation of the module-admin-guard returns true, the current module is granted administrative privileges.",
    "source": "pact-5/guards/create-module-guard.md",
    "title": "create-module-guard"
  },
  {
    "content": "create-pact-guard Use create-pact-guard to define a predicate function with the specified name that captures the results of the pact-id function for a defpact transaction. When enforced, the guard will only return true if the pact-id at enforcement is the same as the pact-id captured by the create-pact-guard function. This check ensures that the guard will only succeed within the multi-step transaction identified by the pact-id. Basic syntax To define a predicate function by name that captures the results of the pact-id function, use the following syntax: Code example (pact): create-pact-guard name Arguments Use the following argument to specify the name for the create-pact-guard Pact function. Argument | Type | Description name | string | Specifies the name of the predicate function that captures the pact-id for a defpact multi-step transaction. Return value The create-pact-guard function returns a guard with the specified name that captures the pact-id' for a defpact multi-step transaction. Example The following example demonstrates how to use the create-pact-guard function to define a guard named \"pact-id-guard\" that captures the pact-id' for a defpact multi-step transaction: Code example (pact): (create-pact-guard \"pact-id-guard\") This guard ensures that it will only succeed within the multi-transaction identified by the pact id.",
    "source": "pact-5/guards/create-pact-guard.md",
    "title": "create-pact-guard"
  },
  {
    "content": "create-principal Use create-principal to create a principal account that unambiguously identifies a specified guard predicate function. For an introduction to principal accounts, see Accounts, keys, and principals. Basic syntax To create a principal that identifies a guard predicate function, use the following syntax: Code example (pact): create-principal guard Arguments Use the following argument to specify the guard for the create-principal Pact function. Argument | Type | Description guard | guard | Specifies the guard for which to create a principal. Return value The create-principal function returns a string representing a principal that unambiguously identifies the specified guard predicate function. Example The following example demonstrates how to use the create-principal function to create a principal that unambiguously identifies the keyset guard: Code example (pact): (create-principal (read-keyset 'keyset)) This principal can then be used for various purposes such as access control in Pact code.",
    "source": "pact-5/guards/create-principal.md",
    "title": "create-principal"
  },
  {
    "content": "create-user-guard Use create-user-guard to define a custom guard closure whose arguments are strictly evaluated at definition time and supplied to the indicated function at enforcement time. Basic syntax To define a custom guard closure for use in Pact, use the following syntax: Code example (pact): (create-user-guard closure) Arguments Use the following argument to specify the closure for the create-user-guard Pact function. Argument | Type | Description closure | closure | Specifies the custom guard closure to define. The closure is a function that takes no arguments and returns a boolean value. Return value The create-user-guard function returns a guard that uses the specified custom closure function that returns a boolean value. Example The following example demonstrates how to use the create-user-guard function to obtain a keyset, then use the keyset as a custom guard closure function: Code example (pact): (create-user-guard (read-keyset 'my-keyset)) In this example, (read-keyset 'my-keyset) is used as the closure function to capture a keyset to use when the user guard is enforced. This code allows you to define custom user guards based on specific keysets or conditions. The following example defines a user guard for the enforce-fungible-transfer function that must evaluate to true to allow a fungible transfer: Code example (pact): (defun escrow-guard(sale-id: string) (util. guards1. guard-any [ (create-capability-guard (REFUND_CAP sale-id)) (create-user-guard (enforce-fungible-transfer sale-id)) ]) ) (defun enforce-fungible-transfer: bool (sale-id: string) (require-capability (FUNGIBLE-TRANSFER-CALL sale-id) ) )",
    "source": "pact-5/guards/create-user-guard.md",
    "title": "create-user-guard"
  },
  {
    "content": "is-principal Use is-principal to determine whether a principal string conforms to the principal format without proving its validity. Basic syntax To check whether a principal string conforms to the principal format, use the following syntax: Code example (pact): (is-principal principal) Arguments Use the following argument to specify the principal string you want to check using the is-principal Pact function. Argument | Type | Description principal | string | Specifies the principal string to be checked. Return value The is-principal function returns a boolean value indicating whether the specified principal string conforms to the principal format. Examples The following example demonstrates how to use the is-principal function in the Pact REPL to check whether the specified string conforms to the principal format: Code example (pact): pact> (is-principal \"k: 58705e8699678bd15bbda2cf40fa236694895db614aafc82cf1c06c014ca963c\") true The following example demonstrates how to use the is-principal function in an enforce statement: Code example (pact): (defcap LOCKDEPOSIT(sender: string) (enforce (is-principal sender) \"Sender must be a principal account\") ) In this example, the is-principal function ensures that the sender account conforms to the format for principal accounts. If the format is valid, the enforce statement returns true and the LOCKDEPOSIT capability is granted. If the sender isn't a valid principal format, the enforce statement returns the \"Sender must be a principal account\" error message. The following example checks the format of a principal account associated with a capability guard in an enforce statement: Code example (pact): (enforce (is-principal \"c: bF51UeSqhrSjEET1yUWBYabDTfujlAZke4R70I4rrH\") \"Invalid account structure: non-principal account\") <interactive>: 0: 0: Error: Invalid account structure: non-principal account In this example, the length of the specified string doesn't conform to the format for a principal account, so the enforce statement returns the error message.",
    "source": "pact-5/guards/is-principal.md",
    "title": "is-principal"
  },
  {
    "content": "keyset-ref-guard Use keyset-ref-guard to create a guard for the keyset registered as keyset-ref using the define-keyset function. Concrete keysets are themselves guard types. This function is specifically to store references alongside other guards in the database. Basic syntax To create a guard for a keyset registered with the define-keyset function, use the following syntax: Code example (pact): (keyset-ref-guard keyset-ref) Arguments Use the following argument to specify the keyset reference for which you want to create a guard using the keyset-ref-guard Pact function. Argument | Type | Description keyset-ref | string | Specifies the reference to the keyset registered with the define-keyset function. Return value The keyset-ref-guard function returns a guard type corresponding to the specified keyset reference. Examples The following example demonstrates how to use the keyset-ref-guard function to create a guard for the keyset registered as \"my-keyset\" using the define-keyset function: Code example (pact): (keyset-ref-guard \"my-keyset\")",
    "source": "pact-5/guards/keyset-ref-guard.md",
    "title": "keyset-ref-guard"
  },
  {
    "content": "typeof-principal Use typeof-principal to return the protocol type of the specified principal value. If the specified value is not a principal type, then an empty string is returned. Basic syntax To determine the protocol type of a specified principal value, use the following syntax: Code example (pact): (typeof-principal principal) Arguments Use the following argument to specify the principal value that you want to determine the protocol type for using the typeof-principal Pact function. Argument | Type | Description principal | string | Specifies the principal value to determine the protocol type for. Return value The typeof-principal function returns the protocol type of the specified principal value as a string. If the input value is not a principal type, an empty string is returned. Examples The following example demonstrates how to use the typeof-principal function to determine the protocol type of a principal value: Code example (pact): (typeof-principal \"k: 462e97a099987f55f6a2b52e7bfd52a36b4b5b470fed0816a3d9b26f9450ba69\") \"k: \" The following example uses the typeof-principal function to create a namespace using the guard associated with the principal account name: Code example (pact): (defun create-principal-namespace: string ( g: guard ) \" Format principal namespace as Pact hash (BLAKE2b256) of principal \\ \\ in hex truncated to 160 bits (40 characters), prepended with 'n'. \\ \\ Only w: and k: account protocols are supported. \" (let ((ty (typeof-principal (create-principal g)))); ; only w: and k: currently supported (if (or (= ty \"k: \") (= ty \"w: \")) (+ \"n\" (take 40 (int-to-str 16 (str-to-int 64 (hash g))))) (enfor. . . [code continues]",
    "source": "pact-5/guards/typeof-principal.md",
    "title": "typeof-principal"
  },
  {
    "content": "validate-principal Use validate-principal to validate that a principal unambiguously identifies a specified guard. Basic syntax To validate a principal against guard, use the following syntax: (validate-principal guard principal) Arguments Use the following arguments to specify the guard and the principal that you want to validate using the validate-principal Pact function. Argument | Type | Description guard | guard | Specifies the guard to validate against. principal | string | Specifies the principal to be validated. Return value The validate-principal function returns a boolean value indicating whether the provided principal unambiguously identifies the specified guard. Examples The following example demonstrates how to use the validate-principal function to ensure that the principal obtained from reading a keyset matches the specified principal account: Code example (pact): (enforce (validate-principal (read-keyset 'keyset) account) \"Invalid account ID\") The following example uses validate-principal in a function to ensure the merchant and buyer accounts are guarded principal account: Code example (pact): (defun create-order ( order-id: string merchant: string merchant-guard: guard buyer: string buyer-guard: guard order-price: decimal ) @doc \"Creates an order in the order table and reserves funds to the escrow account\" (enforce (! = order-id \"\") \"Order id can not be empty\") (enforce (< 0. 0 order-price) \"Order price is not a positive number\") (enforce (validate-principal merchant-guard merchant) \"Invalid merchant guard\"). . . [code continues]",
    "source": "pact-5/guards/validate-principal.md",
    "title": "validate-principal"
  },
  {
    "content": "define-keyset Use define-keyset to define a keyset with the specified name and keyset guard. I you don't specify a keyset guard, the functions reads the specified keyset name from the message payload to define its keyset guard, which is similar to using the read-keyset function. If the keyset name already exists, the existing keyset is enforced before updating to the new value. Basic syntax To define a keyset as name with keyset, use the following syntax: Code example (pact): (define-keyset name keyset) To read keyset information from the transaction message payload, use the following syntax: Code example (pact): (define-keyset name) Arguments Use the following arguments to specify the inputs for the define-keyset Pact function: Argument | Type | Description name | string | Specifies the name of the keyset to define or read. keyset | string | Specifies the keyset to associate with the name. Return value The define-keyset function returns a string representing the result of defining the keyset. Examples The following example demonstrates how to use the define-keyset function to define a keyset named \"admin-keyset\" to use the keys and predicate function from the specified \"my-keyset\" object: Code example (pact): (define-keyset 'admin-keyset \"my-keyset\") The following example demonstrates how to read the keyset from the message payload and associate it with admin-keyset: Code example (pact): (define-keyset 'admin-keyset) The following example illustrates how to define a keyset by reading an existing keyset: Code example (pact): (define-keyset \"admin-keyset\" (read-keyset 'admin-keyset))",
    "source": "pact-5/keysets/define-keyset.md",
    "title": "define-keyset"
  },
  {
    "content": "enforce-keyset Use enforce-keyset to execute a specified guard or a defined keyset named keysetname to enforce the desired predicate logic. Basic syntax To execute a guard to enforce desired predicate logic, use the following syntax: Code example (pact): (enforce-keyset guard) To require a specified keyset to enforce desired predicate logic, use the following syntax: Code example (pact): (enforce-keyset keysetname) Arguments Use the following arguments to specify the guard or keysetname for the enforce-keyset Pact function: Argument | Type | Description guard | guard | Specifies the guard to execute. keysetname | string | Specifies the name of the defined keyset to enforce. Return value The enforce-keyset function returns a boolean value indicating whether the specified guard or keyset predicate logic was enforced. Examples The following example demonstrates how to use the enforce-keyset function to enforce logic defined in the \"admin-keyset\" predicate function: Code example (pact): (enforce-keyset 'admin-keyset) If the condition specified by the admin-keyset predicate function is satisfied, the enforce-keyset function returns a boolean value of true. The following example enforces the logic defined in the row-guard predicate logic: Code example (pact): (enforce-keyset row-guard) If the condition specified by the row-guard predicate function is satisfied, the enforce-keyset function returns a boolean value of true.",
    "source": "pact-5/keysets/enforce-keyset.md",
    "title": "enforce-keyset"
  },
  {
    "content": "keys-2 Use keys-2 as a keyset predicate function to determine if there are at least two keys that match the keys defined in a keyset. Basic syntax To check whether there are at least two keys that match the keys defined in a keyset, use the following syntax: Code example (pact): keys-2 count matched Arguments Use the following arguments to specify the count of keys in the keyset and the number of matched keys using the keys-2 Pact function. Argument | Type | Description count | integer | Specifies the total count of keys defined in the keyset. matched | integer | Specifies the number of matched keys. Return value The keys-2 function returns a boolean value indicating whether there are at least two keys that match the keys defined in the keyset. Examples The following example demonstrates how to use the keys-2 to check if at least two keys are matched in a keyset where the total number of keys defined in a keyset is three and only one key is matched: Code example (pact): pact> (keys-2 3 1) false The function returns false because the condition of having at least two keys matched is not met.",
    "source": "pact-5/keysets/keys-2.md",
    "title": "keys-2"
  },
  {
    "content": "keys-all Use keys-all as a keyset predicate function to determine if all of the keys defined in the keyset are matched. Basic syntax To check whether all of the keys defined in a keyset are matched, use the following syntax: Code example (pact): (keys-all count matched) Arguments Use the following arguments to specify the count of keys in the keyset and the number of matched keys using the keys-all Pact function. Argument | Type | Description count | integer | Specifies the total count of keys defined in the keyset. matched | integer | Specifies the number of matched keys. Return value The keys-all function returns a boolean value indicating whether all keys in the keyset are matched. Examples The following example demonstrates how to use the keys-all function to check whether all of the keys are matched in a keyset where the total number of keys defined is three: Code example (pact): pact> (keys-all 3 3) true The function returns true because all keys in the keyset are matched.",
    "source": "pact-5/keysets/keys-all.md",
    "title": "keys-all"
  },
  {
    "content": "keys Use keys to return all keys present in a specified table. Basic syntax To retrieve all keys present in a table, use the following syntax: Code example (pact): (keys table) Arguments Use the following argument to specify the table from which you want to retrieve keys using the keys Pact function. Argument | Type | Description table | table: <{row}> | Specifies the table from which keys will be retrieved. Return value The keys function returns a list of strings containing all keys present in the specified table. Examples The following example demonstrates how to use the keys function to retrieve all of the keys present in the \"accounts\" table: Code example (pact): (keys accounts) In this example, all keys present in the \"accounts\" table are returned as a list of strings.",
    "source": "pact-5/keysets/keys.md",
    "title": "keys"
  },
  {
    "content": "abs Use abs to calculate the absolute value of a given number. Basic syntax To calculate the absolute value of a number, use the following syntax: Code example (pact): (abs number) Arguments Use the following argument to specify the number for which you want to calculate the absolute value using the abs Pact function. Argument | Type | Description number | decimal or integer | Specifies the number for which to calculate the absolute value. Return value The abs function returns the absolute value of the number as a decimal or integer, depending on the input type. Examples The following example calculates the absolute value of a decimal number in the Pact REPL: Code example (pact): pact> (abs (- 10. 5 23. 7)) 13. 2 The following example calculates the absolute value of an integer: Code example (pact): pact> (abs (- 10 23)) 13",
    "source": "pact-5/operators/abs.md",
    "title": "abs"
  },
  {
    "content": "add (+) Use + to add numbers, concatenate strings and lists, or merge objects. Basic syntax To add numbers, concatenate strings and lists, or merge objects, use the following syntax: Code example (pact): (+ oper1 oper2) Arguments Use the following arguments to specify the values for addition, concatenation, or merging using the + Pact function. Argument | Type | Description oper1 | integer, decimal, string, [list], or object | Specifies the first operand for addition, concatenation, or merging. oper2 | integer, decimal, string, [list], or object | Specifies the second operand for addition, concatenation, or merging. Return value The + function returns the result of addition for numbers, the concatenated string or list for strings and lists, or the resulting of merging for objects. Examples The following examples demonstrate how to use the + function to add two numbers in the Pact REPL: Code example (pact): pact> (+ 1 2) 3 pact> (+ 5. 0 20. 5) 25. 5 The following examples demonstrate how to use the + function to concatenate strings and lists in the Pact REPL: Code example (pact): pact> (+ \"every\" \"body\") \"everybody\" pact> (+ [1 2] [3 4]) [1 2 3 4] The following example demonstrates how to use the + function to merge objects in the Pact REPL: Code example (pact): pact> (+ { \"foo\": 100 } { \"foo\": 1, \"bar\": 2 }) {\"bar\": 2, \"foo\": 100} In this example, merging the object fields using the + function results in the first operand value replacing the corresponding field in the second operand.",
    "source": "pact-5/operators/add.md",
    "title": "add (+)"
  },
  {
    "content": "and? Use and? to apply a logical AND operation to the results of applying a specified value to application functions func1 and func2, with short-circuit evaluation. You can use any data type for the value argument as long as the two functions take that same data type and return the resulting boolean value for the logical AND operation performed by the and? function. By convention, the data type <a> is used if an argument represents a type-bound parameter like the value argument in this function: Code example (pact): (defun and? : bool (func1: (<a> -> bool) func2: (<a> -> bool) value: <a>)) Basic syntax To apply a logical AND operation to the results of applying a specified value to the functions func1 and func2, use the following syntax: Code example (pact): (and? func1 func2 value) Arguments Use the following arguments to specify the functions and value for the and? operation. Argument | Type | Description func1 | function x: <a> -> bool | Specifies the first function to apply the specified value to. The result of applying the specified value of type <a> returns a boolean value. func2 | function x: <a> -> bool | Specifies the second function to apply the specified value to. The result of applying the specified value of type <a> returns a boolean value. value | <a> | Specifies the value to apply to both func1 and func2 functions. Return value The and? function returns a boolean value based on the result of applying value to func1 and func2 with the logical AND operation. Examples The following example demonstrates how to use the and? function in the Pact REPL: Code example (pact): pact> (and? (> 20) (> 10) 15) false In this example, the and? function applies the value 15 to the function (> 20), with the result being true because 20 > 15 is true. The function then applies the value of 15 to the (> 10) function, with the result being false because 10 > 15 is false. The result from the and? function, therefore, is false because the second condition is false.",
    "source": "pact-5/operators/and-q.md",
    "title": "and?"
  },
  {
    "content": "and Use and to perform a boolean logic AND operation with short-circuiting. Basic syntax To perform a boolean logic AND operation between two boolean values oper1 and oper2, use the following syntax: Code example (pact): (and oper1 oper2) Arguments Use the following arguments to specify the boolean values for the and operation. Argument | Type | Description oper1 | bool | Specifies the first boolean value for the AND operation. oper2 | bool | Specifies the second boolean value for the AND operation. Return value The and function returns a boolean value based on the result of the AND operation between the input boolean values. Examples The following example demonstrates how to use the and function to perform a boolean AND operation between the values true and false in the Pact REPL: Code example (pact): pact> (and true false) false The following example illustrates using the and function to evaluate two expressions to determine whether an account string is valid: Code example (pact): (and (>= (length account) 3) (<= (length account) 256)) In this example, both expressions must evaluate to true for an account string to be valid.",
    "source": "pact-5/operators/and.md",
    "title": "and"
  },
  {
    "content": "bitwise-and (&) Use & to compute the bitwise AND operation between the first integer oper1 value and the second integer oper2 value. Basic syntax To compute the bitwise AND operation between oper1 and oper2, use the following syntax: Code example (pact): (& oper1 oper2) Arguments Use the following arguments to specify the values for bitwise AND operation using the & Pact function. Argument | Type | Description oper1 | integer | Specifies the first operand. oper2 | integer | Specifies the second operand. Return value The & function returns the result of the bitwise AND operation between oper1 and oper2. Examples The following examples demonstrate how to use the & function to perform bitwise AND manipulation of integer values in a Pact REPL: Code example (pact): pact> (& 2 3) 2 pact> (& 5 -7) 1",
    "source": "pact-5/operators/bitwise-and.md",
    "title": "bitwise-and (&)"
  },
  {
    "content": "bitwise-or (|) Use | to compute the bitwise OR operation between the first integer oper1 value and the second integer oper2 value. Basic syntax To compute the bitwise OR operation between the oper1 and oper2 integer values, use the following syntax: Code example (pact): (| oper1 oper2) Arguments Use the following arguments to specify the integers for the bitwise OR operation using the | Pact function. Argument | Type | Description oper1 | integer | Specifies the first integer for the OR operation. oper2 | integer | Specifies the second integer for the OR operation. Return value The | function returns the result of the bitwise OR operation as an integer. Examples The following examples demonstrate how to use the | function to perform bitwise OR manipulation between two integers in a Pact REPL: Code example (pact): pact> (| 2 3) 3 pact> (| 5 -7) -3",
    "source": "pact-5/operators/bitwise-or.md",
    "title": "bitwise-or (|)"
  },
  {
    "content": "bitwise-reverse (~) Use ~ to reverse all bits in the provided integer. Basic syntax To reverse all bits in an integer x, use the following syntax: Code example (pact): (~ x) Arguments Use the following argument to specify the integer for bit reversal using the ~ Pact function. Argument | Type | Description x | integer | Specifies the integer for which to reverse all bits. Return value The ~ function returns the result of reversing all bits in the provided integer. Examples The following example demonstrates how to use the ~ function to reverse all bits in the integer 15: Code example (pact): pact> (~ 15) -16",
    "source": "pact-5/operators/bitwise-reverse.md",
    "title": "bitwise-reverse (~)"
  },
  {
    "content": "ceiling Use ceiling to round up the value of a specified decimal value to the nearest integer or to a specified precision prec as a decimal. Basic syntax To round up the value of a decimal value to the nearest integer, use the following syntax: Code example (pact): (ceiling value) To round up the value of a decimal value to a specified precision as a decimal, use the following syntax: Code example (pact): (ceiling value precision) Arguments Use the following arguments to specify the decimal value and optional precision for the ceiling Pact function. Argument | Type | Description value | decimal | Specifies the decimal value to round up. precision | integer | Specifies the precision to round the specified value to (optional). Return value The ceiling function returns the rounded-up value as an integer or as a decimal based on the input and precision. Examples The following example rounds up a decimal value to the nearest integer in the Pact REPL: Code example (pact): pact> (ceiling 3. 5) 4 The following example rounds up a decimal value to a precision of 2 decimal places: Code example (pact): pact> (ceiling 100. 15234 2) 100. 16 In this example, ceiling rounds up the decimal value 100. 15234 to a precision of 2 decimal places, resulting in 100. 16.",
    "source": "pact-5/operators/ceiling.md",
    "title": "ceiling"
  },
  {
    "content": "dec Use dec to convert a specified integer value to a decimal value. This function can be useful if you need to work with decimal values in Pact but have integer inputs. Basic syntax To convert a specified integer value to a decimal value, use the following syntax: Code example (pact): (dec value) Arguments Use the following argument to specify the integer for the dec Pact function. Argument | Type | Description value | integer | Specifies the integer to cast to a decimal value. Return value The dec function returns the specified integer as a decimal value. Example The following example demonstrates how to use the dec function: Code example (pact): pact> (dec 3) 3. 0",
    "source": "pact-5/operators/dec.md",
    "title": "dec"
  },
  {
    "content": "divide (/) Use / to divide the first argument oper1 by the second argument oper2. Note that you can use this function to divide integer values or decimal values. However, you should use the same type for both oper1 and oper2 values. Basic syntax To divide oper1 by oper2, use the following syntax: Code example (pact): (/ oper1 oper2) Arguments Use the following arguments to specify the values for division using the / Pact function. Argument | Type | Description oper1 | integer or decimal | Specifies the value of the dividend. oper2 | integer or decimal | Specifies the divisor. Return value The / function returns the result of dividing oper1 by oper2. Examples The following examples demonstrate how to use the / function to divide two values in a Pact REPL: Code example (pact): pact> (/ 10. 0 2. 0) 5. 0 pact> (/ 8 3) 2",
    "source": "pact-5/operators/div.md",
    "title": "divide (/)"
  },
  {
    "content": "equal (=) Use = to return true if the first argument oper1 is equal to the second argument oper2. Basic syntax To check if oper1 is equal to oper2, use the following syntax: (= oper1 oper2) Arguments Use the following arguments to specify the values for comparison using the = Pact function. Argument | Type | Description oper1 | integer, decimal, string, time, bool, object, list, modref, guard | Specifies the first value for comparison. oper2 | integer, decimal, string, time, bool, object, list, modref, guard | Specifies the second value for comparison. Return value The = function returns a boolean value indicating whether oper1 is equal to oper2. Examples The following example demonstrates how to use the = function to compare two integer values to check if the first value is equal to the second value: Code example (pact): pact> (= 5 5) true The following example demonstrates how to use the = function to compare two decimal values to check if the first value is equal to the second value: Code example (pact): pact> (= 3. 14 2. 71) false The following example demonstrates how to use the = function to compare two string values to check if the first string is equal to the second string: Code example (pact): pact> (= \"hello\" \"hello\") true The following example demonstrates how to use the = function to compare two time values to check if the first time is equal to the second time: Code example (pact): pact> (= (time \"2023-06-05T10: 00: 00Z\") (time \"2023-06-05T10: 00: 00Z\")) true The following example demonstrates how to use the = function to compare two object values to check if the first object is equal to the second object: Code example (pact): pact> (= { \"name\": \"Alice\", \"age\": 30 } { \"name\": \"Alice\", \"age\": 26 }) false The following example demonstrates how to use the = function to compare two list values to check if the first list is equal to the second list: Code example (pact): pact> (= [1, 2, 3] [1, 2, 3]) true You can also the = function to evaluate variables and expressions. For example: Code example (pact): (enforce (= amount 1. 0) \"Mint can only be 1\")",
    "source": "pact-5/operators/eq.md",
    "title": "equal (=)"
  },
  {
    "content": "exp Use exp to calculate the exponential function of the specified value. Basic syntax To calculate the exponential function of a value, use the following syntax: (exp value) Arguments Use the following argument to specify the value for the exp Pact function: Argument | Type | Description value | integer or decimal | Specifies the value for which to calculate the exponential function. Return value The exp function returns the exponential function of the specified value. Examples The following example demonstrates how to use the exp function to calculate the exponential value for three and round the result of this calculation to precision of six decimal places: Code example (pact): pact> (round (exp 3) 6) 20. 085537",
    "source": "pact-5/operators/exp.md",
    "title": "exp"
  },
  {
    "content": "floor Use floor to round down the value of a decimal value to an integer, or to a specified precision number of decimal places. The floor function is useful for situations where you need to round down decimal values in Pact contracts. Basic syntax To round down a decimal value to an integer, use the following syntax: Code example (pact): (floor value) To round down a decimal value to a specified precision, use the following syntax: Code example (pact): (floor value precision) Arguments Use the following arguments to specify the decimal value and precision for the floor Pact function: Argument | Type | Description value | decimal | Specifies the decimal value to round down. precision | integer | Specifies the precision to round down to for the resulting decimal value (optional). Return value The floor function returns the rounded-down value of the specified decimal: - If only value is provided, it returns an integer. - If precision is provided, it returns a decimal with the specified precision. Examples The following example demonstrates how to use the floor function to round down the 3. 5 decimal value to the nearest integer: Code example (pact): pact> (floor 3. 5) 3 The following example demonstrates how to use the floor function to round down the decimal value 100. 15234 to a decimal value with a precision of two decimal places: Code example (pact): pact> (floor 100. 15234 2) 100. 15 The following example uses the floor function in an expression for calculating a royalty payout: Code example (pact): (royalty-payout: decimal (floor (* sale-price royalty-rate) (fungible: : precision)) )",
    "source": "pact-5/operators/floor.md",
    "title": "floor"
  },
  {
    "content": "greater-than-equal (>=) Use >= to returns true if the first argument oper1 is greater than or equal to the second argument oper2. Basic syntax To check if oper1 is greater than or equal to oper2, use the following syntax: Code example (pact): (>= oper1 oper2) Arguments Use the following arguments to specify the values for comparison using the >= Pact function. Argument | Type | Description oper1 | integer, decimal, string, or time | Specifies the first value for comparison. oper2 | integer, decimal, string, or time | Specifies the second value for comparison. Return value The >= function returns a boolean value indicating whether oper1 is greater than or equal to oper2. Examples The following example demonstrates how to use the >= function to compare two integer values to check if the first value (1) is greater than or equal to the second value (3): Code example (pact): pact> (>= 1 3) false The following example demonstrates how to use the >= function to compare two decimal values to check if the first value (5. 24) is greater than or equal to the second value (2. 52): Code example (pact): pact> (>= 5. 24 2. 52) true The following example demonstrates how to use the >= function to compare two string values to check if the first value (abc) is greater than or equal to the second value (def): Code example (pact): pact> (>= \"abc\" \"def\") false",
    "source": "pact-5/operators/geq.md",
    "title": "greater-than-equal (>=)"
  },
  {
    "content": "greater-than (>) Use > to return true if the first argument oper1 is greater than the second argument oper2. Basic syntax To check if oper1 is greater than oper2, use the following syntax: Code example (pact): (> oper1 oper2) Arguments Use the following arguments to specify the values for comparison using the > Pact function. Argument | Type | Description oper1 | integer, decimal, string, or time | Specifies the first value for comparison. oper2 | integer, decimal, string, time | Specifies the second value for comparison. Return value The > function returns a boolean value indicating whether oper1 is greater than oper2. Examples The following example demonstrate how to use the > function to compare two integer values to check if the first value (1) is greater than the second value (3): Code example (pact): pact> (> 1 3) false The following example demonstrates how to use the > function to compare two decimal values to check if the first value (5. 24) is greater than the second value (2. 52): Code example (pact): pact> (> 5. 24 2. 52) true The following example demonstrates how to use the > function to compare two string values to check if the first value (abc) is greater than the second value (def): Code example (pact): pact> (> \"abc\" \"def\") false",
    "source": "pact-5/operators/gt.md",
    "title": "greater-than (>)"
  },
  {
    "content": "less-than-equal (<=) Use <= to return true if the first oper1 argument is less than or equal to the second oper2 argument. Basic syntax To check if oper1 is less than or equal to oper2, use the following syntax: Code example (pact): (<= oper1 oper2) Arguments Use the following arguments to specify the values for comparison using the <= Pact function. Argument | Type | Description oper1 | <a[integer, decimal, string, time]> | Specifies the first value for comparison. oper2 | <a[integer, decimal, string, time]> | Specifies the second value for comparison. Return value The <= function returns a boolean value indicating whether oper1 is less than or equal to oper2. Examples The following example demonstrates how to use the <= function to compare two integer values to check if the first value (1) is less than or equal to the second value (3): Code example (pact): pact> (<= 1 3) true The following example demonstrates how to use the >= function to compare two decimal values to check if the first value (5. 24) is less than or equal to the second value (2. 52): Code example (pact): pact> (<= 5. 24 2. 52) false The following example demonstrates how to use the >= function to compare two string values to check if the first value (abc) is less than or equal to the second value (def): Code example (pact): pact> (<= \"abc\" \"def\") true",
    "source": "pact-5/operators/leq.md",
    "title": "less-than-equal (`<=`)"
  },
  {
    "content": "ln Use ln to compute the natural logarithm of a specified value. Basic syntax To compute the natural logarithm of a value, use the following syntax: Code example (pact): (ln value) Arguments Use the following argument to specify the value for which you want to compute the natural logarithm using the ln Pact function. Argument | Type | Description value | integer or decimal | Specifies the value for which you want to compute the natural logarithm. Return value The ln function returns the natural logarithm of the specified value. Examples The following example demonstrates how to use the ln function to computer the natural logarithm for the value of 60 and round the result to 6 decimal places: Code example (pact): pact> (round (ln 60) 6) 4. 094345",
    "source": "pact-5/operators/ln.md",
    "title": "ln"
  },
  {
    "content": "log Use log to compute the logarithm of the specified value with the specified base. Basic syntax To compute the logarithm of a specified value with the specified base, use the following syntax: Code example (pact): (log base value) Arguments Use the following arguments to specify the base and value for which you want to compute the logarithm using the log Pact function. Argument | Type | Description base | integer or decimal | Specifies the base of the logarithm. value | integer or decimal | Specifies the value for which you want to compute the logarithm. Return value The log function returns the logarithm of value with base base. Examples The following example demonstrates how to use the log function to computer the logarithm of 256 with base 2: Code example (pact): pact> (log 2 256) 8",
    "source": "pact-5/operators/log.md",
    "title": "log"
  },
  {
    "content": "less-than (<) Use < to return true if the first oper1 argument is less than the second oper2 argument. Basic syntax To check if oper1 is less than oper2, use the following syntax: Code example (pact): (< oper1 oper2) Arguments Use the following arguments to specify the values for comparison using the < Pact function. Argument | Type | Description oper1 | integer, decimal, string, or time | Specifies the first value for comparison. oper2 | integer, decimal, string, time | Specifies the second value for comparison. Return value The < function returns a boolean value indicating whether oper1 is less than oper2. Examples The following example demonstrates how to use the < function to compare two integer values to check if the first value (1) is less than the second value (3): : Code example (pact): pact> (< 1 3) true The following example demonstrates how to use the < function to compare two decimal values to check if the first value (5. 24) is less than the second value (2. 52): Code example (pact): pact> (< 5. 24 2. 52) false The following example demonstrates how to use the < function to compare two string values to check if the first value (abc) is less than the second value (def): Code example (pact): pact> (< \"abc\" \"def\") true",
    "source": "pact-5/operators/lt.md",
    "title": "less-than (`<`)"
  },
  {
    "content": "mod Use mod to compute the remainder of oper1 divided by oper2. Basic syntax To compute the remainder of oper1 divided by oper2, use the following syntax: Code example (): (mod oper1 oper2) Arguments Use the following arguments to specify the integers for which you want to compute the remainder using the mod Pact function. Argument | Type | Description oper1 | integer | Specifies the dividend. oper2 | integer | Specifies the divisor. Return value The mod function returns the remainder of the division of oper1 by oper2. Examples The following example demonstrates how to use the mod function to compute the remainder when 13 is divided by 8: Code example (pact): pact>(mod 13 8) 5",
    "source": "pact-5/operators/mod.md",
    "title": "mod"
  },
  {
    "content": "multiply () Use to multiply the first oper1 argument by the second oper12 argument. Note that you can use this function to multiply integer values or decimal values. However, you should use the same type for both oper1 and oper2 values. Basic syntax To multiply oper1 by oper2, use the following syntax: Code example (pact): ( oper1 oper2) Arguments Use the following arguments to specify the values for multiplication using the Pact function. Argument | Type | Description oper1 | integer or decimal | Specifies the first multiplier. oper2 | integer or decimal | Specifies the second multiplier. Return value The function returns the result of multiplying oper1 by oper2. Examples The following example demonstrates how to use the function to multiply two decimal values: Code example (pact): pact> ( 0. 5 10. 0) 5. 0 The following example demonstrates how to use the function to multiply two integer values: Code example (pact): pact> ( 3 5) 15 These examples illustrate how to use the function to perform multiplication operations in Pact, facilitating arithmetic calculations with both integer and decimal values.",
    "source": "pact-5/operators/mult.md",
    "title": "multiply (*)"
  },
  {
    "content": "not-equal (! =) Use! = to return true if the first oper1 argument does not equal the second oper2 argument. This function allows you to write conditional logic based on whether two values are not equal. Basic syntax To check if oper1 does not equal oper2, use the following syntax: Code example (pact): (! = oper1 oper2) Arguments Use the following arguments to specify the values for comparison using the! = Pact function. Argument | Type | Description oper1 | integer, string, time, decimal, bool, list, object, keyset, guard, or module | Specifies the first value for comparison. oper2 | integer, string, time, decimal, bool, list, object, keyset, guard, or module | Specifies the second value for comparison. Return value The! = function returns true if oper1 does not equal oper2, otherwise false. Examples The following example demonstrates how to use the! = function to check whether two strings are not equal: Code example (pact): pact> (! = \"hello\" \"goodbye\") true In the following example, the! = function ensures that the sender and receiver accounts are not equal to prevent the sender initiating a transfer from also being the receiver of the transfer: Code example (pact): (enforce (! = sender receiver) \"sender cannot be the receiver of a transfer\")",
    "source": "pact-5/operators/neq.md",
    "title": "not-equal (!=)"
  },
  {
    "content": "not? Use not? to apply a logical NOT operation to the results of applying a specified value to an application function. You can use any data type for the value argument as long as the app function takes that same data type and returns the resulting boolean value for the logical NOT operation performed by the not? function. By convention, the data type <a> is used if an argument represents a type-bound parameter like the value argument in this function: Basic syntax To apply a logical NOT operation to the results of applying a specified value to an application function app, use the following syntax: Code example (pact): (not? app value) Arguments Use the following arguments to specify the application function and the value to be applied using the not? Pact function. Argument | Type | Description app | function x: <a> -> bool | Specifies the application function to apply the specified value to. The result of applying the specified value returns a boolean value. value | <a> | Specifies the value to be applied to the application function. Return value The not? function returns a boolean value representing the logical negation of the result of applying the value to the application function. Examples The following example demonstrates how to use the not? function in the Pact REPL: Code example (pact): pact> (not? (> 20) 15) false In this example, the application function is (> 20) and the value is 15. Because the expression 20 > 15 evaluates to true, and not? negates this value, the not? function returns false.",
    "source": "pact-5/operators/not-q.md",
    "title": "not?"
  },
  {
    "content": "not Use not to compute the boolean negation of a specified value. Basic syntax To compute the boolean negation of the specified value, use the following syntax: Code example (pact): (not value) Arguments Use the following argument to specify the boolean value for which you want to compute the negation using the not Pact function. Argument | Type | Description value | bool | Specifies the expression to evaluate that returns the boolean value to be negated. Return value The not function returns the boolean negation of the input value. Examples The following example demonstrates how to use of the not function in the Pact REPL: Code example (pact): pact> (not (> 1 2)) true In this example, the expression (> 1 2) evaluates to false, and the not function negates this value, resulting in true.",
    "source": "pact-5/operators/not.md",
    "title": "not"
  },
  {
    "content": "or? Use or? to apply a logical OR operation to the results of applying a specified value to application functions func1 and func2, with short-circuit evaluation. You can use any data type for the value argument as long as the two functions take that same data type and return the resulting boolean value for the logical OR operation performed by the or? function. By convention, the data type <a> is used if an argument represents a type-bound parameter like the value argument in this function. Basic syntax To apply a logical OR operation to the results of applying a value to two application functions, use the following syntax: Code example (pact): (or? func1 func2 value) Arguments Use the following arguments to specify the functions and the value to be applied using the or? Pact function. Argument | Type | Description func1 | function x: <a> -> bool | Specifies the first function to apply the specified value to. The result of applying the specified value returns a boolean value. func2 | function x: <a> -> bool | Specifies the second function to apply the specified value to. The result of applying the specified value returns a boolean value. value | <a> | Specifies the value to apply to both func1 and func2 functions. Return value The or? function returns a boolean value representing the logical OR operation after evaluating the results from applying the specified value to the two application functions. Examples The following example demonstrates how to use the or? function in the Pact REPL: Code example (pact): pact> (or? (> 20) (> 10) 15) true In this example, the or? function applies the value 15 to the function (> 20), with the result being true because 20 > 15 is true. Because the function performs short-circuit evaluation on the results, the or? function returns true because the first condition is true.",
    "source": "pact-5/operators/or-q.md",
    "title": "or?"
  },
  {
    "content": "or Use or to apply a logical OR operation with short-circuit evaluation. Basic syntax To perform a logical OR operation with short-circuit evaluation, use the following syntax: Code example (pact): (or oper1 oper2) Arguments Use the following arguments to specify the boolean values for which you want to perform the logical OR operation using the or Pact function. Argument | Type | Description oper1 | bool | Specifies the first expression to evaluate that returns the boolean value to perform the logical OR operation on. oper2 | bool | Specifies the second expression to evaluate that returns the boolean value to perform the logical OR operation on. Return value The or function returns a boolean value based on the logical OR operation of the input values. Examples The following example demonstrates how to use the or function in the Pact REPL: Code example (pact): pact> (or (> 20 10) (> 10 15)) true In this example, the or function evaluates the expressions (> 20 10) and (> 10 15). The boolean value returns for the first expression is true because 20 > 15 is true. Because the or function performs short-circuit evaluation on the results, the function returns true because the first expression is true.",
    "source": "pact-5/operators/or.md",
    "title": "or"
  },
  {
    "content": "power-of (^) Use the exponentiation operator ^ to raise the oper1 argument to the power of the oper2 argument. You can use this operator with both integer or decimal values. When the operands are integers, the result is an integer if the exponent is not negative. When the operands are decimals or you use a negative exponent, the result is always a decimal. Basic syntax To raise oper1 to the power of oper2, use the following syntax: Code example (pact): (^ oper1 oper2) Arguments Use the following arguments to specify the base and exponent for raising to a power using the ^ Pact function. Argument | Type | Description oper1 | integer or decimal | Specifies the base value. oper2 | integer or decimal | Specifies the exponent value. Return value The ^ function returns the result of raising oper1 to the power of oper2. Examples The following example demonstrates how to use the ^ function with integer values to raise 2 to the power of 3 in a Pact REPL: Code example (pact): pact> (^ 2 3) 8 The following example demonstrates how to use the ^ function with decimal values to raise 5. 5 to the power of 2. 0 in a Pact REPL: Code example (pact): pact> (^ 5. 5 2. 0) 30. 25 The following example demonstrates using the ^ function with a negative exponent value: Code example (pact): pact> (^ 2 -3) 0. 125",
    "source": "pact-5/operators/pow.md",
    "title": "power-of (^)"
  },
  {
    "content": "shift Use shift to perform a bitwise shift operation on the integer oper1 by oper2 bits. If oper2 is positive, this function shifts oper1 to the left. If oper2 is negative, the function shifts oper1 to the right. Right shifts perform sign extension on signed number types, filling the top bits with 1 if oper1 is negative and with 0 otherwise. Basic syntax To shift the integer oper1 by oper2 bits, use the following syntax: Code example (pact): (shift oper1 oper2) Arguments Use the following arguments to specify the integer values to be shifted using the shift Pact function. Argument | Type | Description oper1 | integer | Specifies the integer value to be shifted. oper2 | integer | Specifies the number of bits to shift oper1 by. Return value The shift function returns the result of shifting oper1 by oper2 bits. Examples The following example demonstrates how to use the shift function to shift the integer 255 to the left by 8 bits: Code example (pact): (shift 255 8) 65280 The following example demonstrates how to use the shift function to shift the integer 255 to the right by 1 bit: Code example (pact): (shift 255 -1) 127 The following example demonstrates how to use the shift function to shift the negative integer -255 to the left by 8 bits: Code example (pact): (shift -255 8) -65280 The following example demonstrates how to use the shift function to shift the negative integer -255 to the right by 1 bit: Code example (pact): (shift -255 -1) -128 These examples illustrate how to use the shift function to perform bitwise shift operations on integers in Pact, either to the left or to the right, with sign extension for right shifts on signed numbers.",
    "source": "pact-5/operators/shift.md",
    "title": "shift"
  },
  {
    "content": "sqrt Use sqrt to compute the square root of the given value. Basic syntax To calculate the square root of a value, use the following syntax: Code example (pact): (sqrt value) Arguments Use the following argument to specify the value for which to compute the square root using the sqrt Pact function. Argument | Type | Description value | integer or decimal | Specifies the value that you want to compute the square root for. Return value The sqrt function returns the square root of the specified value. The return type depends on the type of the input value and whether the square root for the input value is a whole number. Examples The following example demonstrates how to use the sqrt function to calculate the square root of the integer value 25 that returns an integer value: Code example (pact): pact> (sqrt 25) 5 The following example calculates the square root of the decimal value 144. 0 that returns a decimal value: Code example (pact): (sqrt 144. 0) 12. 0 The following example calculates the square root for 48 and rounds the result to four decimal places: Code example (pact): (round (sqrt 48) 4) 6. 9282 This example illustrates how to use the sqrt function to compute the square root of a value in Pact, producing either an integer or a decimal result.",
    "source": "pact-5/operators/sqrt.md",
    "title": "sqrt"
  },
  {
    "content": "subtract (-) Use - to negate a value or to subtract oper2 from oper1. Basic syntax To negate value, use the following syntax: Code example (pact): (- value) To subtract oper2 from oper1, use the following syntax: Code example (pact): (- oper1 oper2) Arguments Use the following arguments to specify the values for negation or subtraction using the - Pact function. Argument | Type | Description value | integer or decimal | Specifies the value to be negated. oper1 | integer or decimal | Specifies the value to be subtracted from. oper2 | integer or decimal | Specifies the value to subtract from oper1. Return value The - function returns the negation of the specified value, or the result of subtracting oper2 from oper1. Examples The following example demonstrates how to use the - function to negate a value in a Pact REPL: Code example (pact): pact> (- 1. 0) -1. 0 The following example demonstrates how to use the - function to subtract integer values in a Pact REPL: Code example (pact): pact> (- 3 2) 1",
    "source": "pact-5/operators/sub.md",
    "title": "subtract (-)"
  },
  {
    "content": "xor Use xor to compute the bitwise exclusive OR (xor) operation between two integer arguments. Basic syntax To compute the bitwise XOR operation between two integers, use the following syntax: Code example (pact): (xor oper1 oper2) Arguments Use the following arguments to specify the integers for the bitwise XOR operation using the xor Pact function. Argument | Type | Description oper1 | integer | Specifies the first integer for the XOR operation. oper2 | integer | Specifies the second integer for the XOR operation. Return value The xor function returns the result of the bitwise XOR operation as an integer. Examples The following examples demonstrate how to use the xor function to compute the bitwise XOR operation between two integers: Code example (pact): (xor 127 64) 63 (xor 5 -7) -4",
    "source": "pact-5/operators/xor.md",
    "title": "xor"
  },
  {
    "content": "Quick reference listing of links for Pact built-in functions. - abs Calculate the absolute value of a number. - acquire-module-admin Grant module administrative privileges for a specified module. - add-time Add a specified number of seconds to a time. - add (+) Add numbers, concatenation for strings, or merge objects. - and? Apply a logical AND operation to a result. - and Perform a boolean logic AND operation. - at Get a value using an index for a list or a key for an object. - base64-decode Decode a base64-encoded string. - base64-encode Encode a string as unpadded base64. - begin-tx Begin a new transaction with an optional name (REPL only). - bind Evaluate an object with bindings. - bitwise-and (&) Compute the bitwise AND operation between arguments. - bitwise-or (|) Computes the bitwise OR operation between two integers. - bitwise-reverse (~) Reverse all bits in the provided integer. - ceiling Round up the value of a decimal to the nearest integer or specified precision. - chain-data Retrieve public metadata. - charset-ascii Use the standard ASCII character set. - charset-latin Use the standard Latin1 character set. - commit-tx Commit the current transaction (REPL only). - compose-capability Request the grant of a capability within a capability. - compose Compose functions to operate on value. - concat Concatenate a list of strings. - constantly Ignore specified arguments. - contains Evaluate the contents of a list, object, or string. - continue-pact Continue a previously-initiated multi-step defpact transaction (REPL only). - continue Continue a previously started defpact step. - create-capability-guard Create a guard to enforce a specified capability. - create-capability-pact-guard Create a guard to enforces a specified capability in an executing defpact step. - create-module-guard Define a guard to enforce the current module administrator predicate. - create-pact-guard Define a guard predicate that captures the pact-id for a defpact step. - create-principal Create a principal that identifies a guard. - create-table Create a table. - create-user-guard Define a custom guard. - days Specify a number of days to add or subtract days from a given time. - dec Convert an integer to a decimal value. - define-keyset Define an authorization keyset from keyset data set in the environment. - define-namespace Create a new namespace or update the guards of an existing namespace. - describe-keyset Retrieve metadata for a specified keyset. - describe-module Get metadata for a specified module. - describe-namespace Describe the specified namespace. - describe-table Get metadata for a specified table. - diff-time Compute the difference in seconds between two specified times. - distinct Return a list with duplicates removed. - div (/) Divide the first argument by the second argument. - do Evaluate a sequence of expressions and return the result from the last expression. - drop Remove values from a list or string. - emit-event Emit a specified capability as an event. - enforce-guard Execute a specified guard or keyset to enforce predicate logic. - enforce-keyset Execute a keyset to enforce predicate logic. - enforce-one Evaluate a series of tests in order. - enforce-pact-version Enforce the runtime Pact version to be within a specified range. - enforce-verifier Enforce that a verifier with the specified name is in scope. - enforce Fail a transaction if an expression evaluates to false. - enumerate Return a sequence of numbers as a list. - env-chain-data Define chain information for transactions in your testing environment (REPL only). - env-data Set transaction data for your testing environment (REPL only). - env-enable-repl-natives Control whether REPL native functions are allowed in module code (REPL only). - env-events Retrieve any accumulated events and optionally clear the event state (REPL only). - env-exec-config Query or set configuration information for transactions in your testing environment (REPL only). - env-gas Query the current gas state or set it to a specific value (REPL only). - env-gaslimit Set the environment gas limit to a specific value (REPL only). - env-gaslog Enable gas logging for a block of code (REPL only). - env-gasmodel Query or update the current gas model (REPL only). - env-hash Set the current transaction hash (REPL only). - env-keys Set the transaction signer keys (REPL only, deprecated). - env-milligas Query the current gas state in units of one one thousandth of a gas unit. - env-module-admin Acquire the module administrative rights for any module loaded in the REPL. - env-namespace-policy Install a managed namespace policy (REPL only). - env-set-debug-flag Set the Pact interpreter debug flags. - env-set-milligas Set the current gas state to a specific value in units of one one thousandth of a gas unit. - env-sigs Set signature keys for signing transactions and granting capabilities (REPL only). - env-verifiers Set transaction verifier names and capabilities. - equal (=) Return true if the first argument is equal to the second argument. - exp Calculate the exponential function of a value. - expect-failure Evaluate an expression and succeed only if the expressions results in an error (REPL only). - expect-that Evaluate an expression and succeed if the resulting value passes a predicate function (REPL only). - expect Evaluate an expression and verify that the result equals an expected value (REPL only). - filter Filter a list by applying a function to each element. - floor Round down the value of a decimal to an integer or to a specified precision. - fold-db Select rows from a table using a predicate and accumulate the results. - fold Reduce a list iteratively by applying a function to each element. - format-time Format a time value using a specified format. - format Format a message using placeholders and variables. - greater-than or equal (>=) Return true if the first argument is greater than or equal to the second argument. - greater-thant (>) Return true if the first argument is greater than the second argument. - hash-keccak256 Compute the hash of a list of inputs. - hash Compute the BLAKE2b 256-bit hash of a value. - hours Add a specific number of hours to a given time. - hyperlane-decode-token-message Decode a base-64-unpadded encoded Hyperlane Token Message into an object. - hyperlane-encode-token-message Encode an object into base-64-unpadded encoded Hyperlane Token Message. - hyperlane-message-id Get the message identifier of a Hyperlane Message object. - identity Return the provided value. - if Test whether a condition is true to determine the operation to perform. - insert Add a new value to a database record in a specified table. - install-capability Specify and provision a managed capability. - int-to-str Represent an integer value as a string in a specified base. - is-charset Check whether a string conforms to a supported character set. - is-principal Check whether a principal string conforms to the principal format. - keys-2 Determine whether a keyset has at least two required keys. - keys-all Determine whether a keyset has all of its required keys. - keys Return all of the keys for a specified table in a module. - keys Return all of the keys for a specified table in a module. - keyset-ref-guard Create a guard for the keyset in the guard database. - length Compute the length of a list, string, or object. - less-than or equal (<=) Return true if the first argument is less than or equal to the second argument. - list-module List modules available for loading. - list-modules List all of the modules deployed on a particular chain using the /local endpoint. - ln Compute the natural logarithm of a specified value. - load Load and evaluate a specified. pact or. repl file. - log Compute the logarithm of the specified value with the specified base. - less-than < Return true if the first argument is less than the second argument. - make-list Create a list by repeating a specified value a certain number of times. - map Apply a function (APP) to each element in a list. - minutes Add a specific number of minutes to a given time. - mod Compute the remainder for the first value divided by the second value. - multiply (*) Multiply the first argument by the second argument. - namespace Set the current namespace to a specified value. - negate Negate a specified integer or decimal value. - not-equal (! =) Return true if the first argument does not equal the second argument. - not? Apply a logical NOT to the results of a function. - not Perform a boolean logic NOT operation. - or? Apply a logical OR to the results a function. - or Perform a boolean logic NOT operation. - pact-id Return the identifier associated with defpact execution. - pact-state Inspect state from most recent defpact execution. - pact-version Get the current Pact build version. - pairing-check Perform pairing and final exponentiation on points for a zero knowledge proof. - parse-time Construct time from a UTC value using a specified format. - point-add Add two points together for a zero knowledge proof. - poseidon-hash-hack-a-chain Compute a hash using the Poseidon hash function used by Hack-a-Chain. - power-of (^) Raise an argument to the power of the second argument. - print Convert a value into a string and print it to the REPL output. - read-decimal Read a key string or number value from the message data as a decimal. - read-integer Read a key string or number value from the message data as an integer. - read-keyset Read a key from the message data as a keyset with a list of keys and a predicate function. - read-msg Read a key from the message data body. - read-string Read a key string or number value from the message data as a string. - read Retrieve information from a specified table based on a given key row. - remove Remove an entry associated with a specified key from an object. - require-capability Check whether a specified capability has been granted. - resume Bind a yielded object value from a defpact step to the execution of the next defpact step. - reverse Reverse the order of elements in a given list. - rollback-tx Roll back the current transaction. - round Perform Banker's rounding to return an integer or decimal value. - scalar-mult Multiply a point by an integer value for a zero-knowledge proof. - select Retrieve full rows or specific columns from a table. - shift Perform a bitwise shift operation on the specified integer by the specified number of bits. - show Convert a specified value into a string. - sig-keyset Build a keyset guard from keys present in message signatures. - sort Sort a list of primitive values or objects. - sqrt Compute the square root of the given value. - static-redeploy Redeploy a module without any code changes. - str-to-int Compute the integer value of the specified string. - str-to-list Convert a string into a list where each element is a single-character string. - subtract (-) Negate an argument or subtract the second argument from the first argument. - take Retrieve a specified number of values from a list, string, or object. - test-capability Acquire or install the capability specified. - time Construct a time object from a UTC value using the %Y-%m-%dT%H: %M: %SZ format. - try Attempt a pure action without input, output, or state-changing operations. - tx-hash Get the hash of the current transaction as a string. - typecheck Run the Pact static type checker on a module. - typeof-principal Return the protocol type of a given principal. - typeof Return a description of the data type for a specified value. - update Update a value for a database record in the specified table. - validate-principal Validate that a principal identifies a specified guard. - verify-spv Perform a platform-specific simplified payment verification (SPV) proof. - where Define a clause to refine the results from filter or select operations. - with-capability Specify the capability that must be granted to perform a privileged operation. - with-default-read Read a row from a specified table and use default values for columns if the row isn't found. - with-read Read a row from a specified table and bind columns names to variables. - write Write or overwrite a value for a database record in the specified table. - xor Compute the bitwise exclusive OR operation between two integers. - yield Yield an object to use with the resume function in a defpact step. - zip Combine two lists using a specified function to create a new list.",
    "source": "pact-5/quick-reference.md",
    "title": "Function quick reference"
  },
  {
    "content": "begin-tx Use begin-tx to begin a new transaction with an optional name. This function is used to create tests that you want to execute using the Pact REPL. In most cases, you include this function in. repl files that test specific application features and failure scenarios. Within the context of a transaction, you can set environment data, load modules, and execute functions. To complete the transaction, use the commit-tx function. The commit-tx function signals the end of a transaction block and can be followed by additional begin-tx and commit-tx blocks. Basic syntax To begin a transaction without a name, use the following syntax: Code example (pact): (begin-tx) To begin a transaction with a specific name, use the following syntax: Code example (pact): (begin-tx name) Arguments Use the following argument to specify an optional name for the transaction when using the begin-tx Pact function. Argument | Type | Description name | string | Specifies the name of the transaction (optional). Return value The begin-tx function returns a string indicating the transaction identifier and the optional name (if provided). Examples The following example demonstrates how to use the begin-tx function to begin a new transaction without a name: Code example (pact): pact> (begin-tx) \"Begin Tx 0\" The following example demonstrates how to use the begin-tx function to begin a new transaction with a specific name: Code example (pact): pact> (begin-tx \"load module\") \"Begin Tx 0: load module\" You can write an empty transaction as a placeholder for the logic to test specific function or failure scenarios. For example, to create a placeholder for the logic that defines a namespace: Code example (pact): (begin-tx \"Define a namespace called 'election\") (commit-tx)",
    "source": "pact-5/repl/begin-tx.md",
    "title": "begin-tx"
  },
  {
    "content": "commit-tx Use commit-tx to commit the current transaction. In most cases, you include this function in. repl files that test specific application features and failure scenarios. Within the context of a transaction started using the begin-tx function, you can set environment data, load modules, and execute functions. You use the commit-tx function to signal the end of a transaction block and can be followed by additional begin-tx and commit-tx blocks. Basic syntax To commit a transaction, use the following syntax: Code example (pact): (commit-tx) Arguments The commit-tx function does not take any arguments. Return value The commit-tx function returns a string indicating the transaction identifier that has been committed. Examples The following example demonstrates how to use the commit-tx function within a Pact REPL: Code example (pact): pact> (begin-tx \"load module\") \"Begin Tx 0: load module\" pact> (commit-tx) \"Commit Tx 0: load module\" In this example, a new transaction—Tx0—is started using (begin-tx), and then (commit-tx) is called to commit the transaction. The function returns a string indicating that \"Tx 0\" has been committed. Note that you should only call the commit-tx function after performing the necessary operations within a transaction. The commit-tx function finalizes the transaction, and any changes made during the transaction are persisted. It's important that you always call the commit-tx function after begin-tx and after any other transaction-related operations to properly commit the transaction. If commit-tx is not called, the transaction remains open and may lead to unexpected behavior or inconsistencies in the system.",
    "source": "pact-5/repl/commit-tx.md",
    "title": "commit-tx"
  },
  {
    "content": "continue-pact Use continue-pact to continue a previously-initiated multi-step transaction defined using a defpact declaration. You must specify the step at which to continue. You can also specify optional parameters for rollback, pact ID, and yielded value. Basic syntax To continue a pact with the specified step, use the following syntax: Code example (pact): (continue-pact step) To continue a pact with the specified step and rollback option, use the following syntax: Code example (pact): (continue-pact step rollback) To continue a pact with the specified step, rollback option, and pact ID, use the following syntax: Code example (pact): (continue-pact step rollback pact-id) To continue a pact with the specified step, rollback option, pact ID, and yielded value, use the following syntax: Code example (pact): (continue-pact step rollback pact-id yielded) Arguments Use the following arguments to customize the behavior of the continue-pact Pact function. Argument | Type | Description step | integer | Specifies the step of the pact to continue. rollback | bool | Specifies whether to perform a rollback (optional). The default is false. pact-id | string | Specifies the identifier of the pact to continue (optional). The default is the pact identifier initiated in the current transaction, if one is present. yielded | object | Specifies the yielded value to be read with the resume function (optional). If not specified, the function uses the yield from the most recent pact execution, if any. The schema of the yielded object is object: <{y}>. Return value The continue-pact function returns a string indicating the result of continuing the pact. Examples The following example demonstrates how to use the continue-pact function to continue a pact with step 1: Code example (pact): (continue-pact 1) The following example demonstrates how to use the continue-pact function to continue a pact with step 1 and perform a rollback: Code example (pact): (continue-pact 1 true) The following example demonstrates how to use the continue-pact function to continue a pact with step 1, without rollback, and specify the pact ID: Code example (pact): (continue-pact 1 false \"[pact-id-hash]\") The following example demonstrates how to use the continue-pact function to continue a pact with step 2, without rollback, specify the pact ID, and provide a yielded value: Code example (pact): (continue-pact 2 false \"[pact-id-hash]\" { \"rate\": 0. 9 })",
    "source": "pact-5/repl/continue-pact.md",
    "title": "continue-pact"
  },
  {
    "content": "env-chain-data Use env-chain-data to define chain information for transactions in your testing environment. You can this function to create an object with one or more of the following fields: - chain-id: The chain identifier (0-19) for the blockchain where the transaction is executed. - block-height: The height of the block that includes the transaction. - block-time: The timestamp of the block that includes the transaction. - prev-block-hash: The hash of the previous block. - sender: The sender of the transaction. - gas-limit: The gas limit for the transaction. - gas-price: The gas price for the transaction. - gas-fee: The gas fee for the transaction. Basic syntax To set one or more chain data fields, use the following syntax: Code example (pact): (env-chain-data {object}) Arguments Use the following argument to specify the chain data you want to set using the env-chain-data Pact function. Argument | Type | Description object | object | Specifies the chain data you want to be set for the transaction. Return value The env-chain-data function returns an object with the chain data you specify. Examples The following example demonstrates how to use the env-chain-data function to set a chain identifier and block time for a transaction: Code example (pact): (begin-tx \"create-token\") (env-chain-data {\"chain-id\": \"3\", \"block-time\": (time \"2023-07-20T11: 26: 35Z\")}) (commit-tx)",
    "source": "pact-5/repl/env-chain-data.md",
    "title": "env-chain-data"
  },
  {
    "content": "env-data Use env-data to set transaction data for your testing environment either as an encoded string or as Pact types coerced to JSON format. Basic syntax To set transaction data, use the following syntax: Code example (pact): (env-data json) Arguments Use the following argument to specify the JSON data when using the env-data Pact function. Argument | Type | Description json | object | Specifies the JSON data to be set for the transaction. The data can be provided as an encoded string or as Pact types that will be coerced to JSON. Return value The env-data function returns a string indicating that the transaction data is being set. Examples The following example demonstrates the usage of the env-data function within a Pact REPL: Code example (pact): pact> (env-data { \"keyset\": { \"keys\": [\"my-key\" \"admin-key\"], \"pred\": \"keys-any\" } }) \"Setting transaction data\" In the following example, the env-data function is used to set up a mock token identifier and account information for testing Marmalade functions: Code example (pact): (env-data { \"token-id\": \"t: YV6-cQBhEEoIXAuNV08aGXLfcucBEGy0Gb1Pj6wOo\", \"account\": \"k: e4c6807d79d8bf4695e10e5678ebf72862f59b71f971d39dd3349f4beeacd6e3\", \"account-guard\": { \"keys\": [\"e4c6807d79d8bf4695e10e5678ebf72862f59b71f971d39dd3349f4beeacd6e3\"], \"pred\": \"keys-all\" } } )",
    "source": "pact-5/repl/env-data.md",
    "title": "env-data"
  },
  {
    "content": "env-enable-repl-natives Use env-enable-repl-natives to control whether REPL native functions are allowed in module code. If you set this function to true to enable REPL native functions in module code, other environment configuration functions like env-sigs are allowed in module code, and you can use these functions in your module definitions. If you set this function to false to disable REPL native functions in module code, other environment configuration functions are not allowed in module code, and attempting to use them will result in an error. Basic syntax To allow REPL native functions to be used in module code, use the following syntax: Code example (pact): (env-enable-repl-natives enable) Arguments Use the following argument to specify whether to enable or disable REPL native functions in module code. Argument | Type | Description enable | bool | Specifies whether to enable or disable REPL native functions in module code. Note that this argument is required. Set it to true to enable REPL native function calls. Set it to false to prevent REPL native functions from being called. Return value The env-enable-repl-natives function returns a string indicating the status of REPL natives. Examples The following example demonstrates how to enable REPL native functions: Code example (pact): (env-enable-repl-natives true) \"Repl natives enabled\" After enabling REPL natives, you can use environment configuration functions like env-sigs in your module code. It's important to note that you should only enable REPL native functions in module code—that is, executable. pact files—if absolutely necessary. Most REPL native functions are intended to be used exclusively in the REPL environment. If you enable access to the REPL native functions in module code, ensure that access to the functions is properly controlled and validated. The following example demonstrates how to disable access to REPL native functions: Code example (pact): (env-enable-repl-natives false) \"Repl natives disabled\"",
    "source": "pact-5/repl/env-enable-repl-natives.md",
    "title": "env-enable-repl-natives"
  },
  {
    "content": "env-events Use env-events to retrieve any accumulated events and optionally clear the event state. Basic syntax To retrieve events and clear the event state, use the following syntax: Code example (pact): (env-events clear) Arguments Use the following argument to specify whether to clear the event state after retrieving the events. Argument | Type | Description clear | bool | Specifies whether to clear the event state after retrieving the events. Note that this argument is required. Set it to true to retrieve events, then clear the event state. Set it to false retrieve events and keep the event state. Return value The env-events function returns an array of objects representing the accumulated events. Each object in the array has the following fields: - name: The fully-qualified name of the event. - params: The parameters associated with the event. - module-hash: The hash of the module that emitted the event. Examples The following example demonstrates how to retrieve events, then clear the event state: Code example (pact): (env-events true) [] In this example, there were no events to retrieve, so an empty list is returned. The following example retrieves three events—TOKEN, MINT, and ACCOUNT-GUARD—without clearing the event state: ```pact (env-events false) [{\"module-hash\": \"DmPuO814Zw0C6RL9ubXTGeyNl0I2-svVHgZp-XqRsOs\", \"name\": \"marmalade-v2. ledger. TOKEN\", \"params\": [\"t: U50F3xof5EnLQFPd0v2vt8PR3GJTAt8DJ2oWFj7eOgA\" 0 [marmalade-v2. non-fungible-policy-v1 marmalade-v2. non-updatable-uri-policy-v1] \"uri\" KeySet {keys: [e4c6807d79d8bf4695e10e5678ebf72862f59b71f971d39dd3349f4beeacd6e3], pred: keys-all}]} {\"module-hash\": \"DmPuO814Zw0C6RL9ubXTGeyNl0I2-svVHgZp-XqRsOs\", \"name\": \"marmalade-v2. ledger. MINT\", \"params\": [\"t: U50F3xof5EnLQFPd0v2vt8PR3GJTAt8DJ2oWFj7eOgA\" \"k: e4c6807d79d8bf4695e10e5678ebf72862f59b71f971d39dd3349f4beeacd6e3\" 1. 0]} {\"module-hash\": \"DmPuO814Zw0C6RL9ubXTGeyNl0I2-svVHgZp-XqRsOs\", \"name\": \"marmalade-v2. ledger. ACCOUNT_GUARD\", \"params\": [\"t: U50F3xof5EnLQFPd0v2vt8PR3GJTAt8DJ2oWFj7eOgA\" \"k: e4c6807d79d8bf4695e10e5678ebf72862f59b71f971d39dd3349f4beeacd6e3\" KeySet {keys: [e4c6807d79d8bf4695e10e5678ebf72862f59b71f971d39dd3349f4beeacd6e3], pred: keys-all}]}] In this example, the formatting is modified for readability.",
    "source": "pact-5/repl/env-events.md",
    "title": "env-events"
  },
  {
    "content": "env-exec-config (DEPRECATED) Use env-exec-config to query or set execution configuration information for executing transactions in your testing environment. You can use this function to set one or more of the following configuration flags: - \"AllowReadInLocal\" - \"DisableHistoryInTransactionalMode\" - \"DisableInlineMemCheck\" - \"DisableModuleInstall\" - \"DisableNewTrans\" - \"DisablePact40\" - \"DisablePact410\" - \"DisablePact42\" - \"DisablePact43\" - \"DisablePact431\" - \"DisablePact44\" - \"DisablePact45\" - \"DisablePact46\" - \"DisablePact47\" - \"DisablePact48\" - \"DisablePact49\" - \"DisablePactEvents\" - \"DisableRuntimeReturnTypeChecking\" - \"EnforceKeyFormats\" - \"OldReadOnlyBehavior\" - \"PreserveModuleIfacesBug\" - \"PreserveModuleNameBug\" - \"PreserveNsModuleInstallBug\" - \"PreserveShowDefs\" Basic syntax To look up the current configuration settings, use the following syntax: Code example (pact): (env-exec-config) To set one or more configuration flags, use the following syntax: Code example (pact): (env-exec-config [flags]) Arguments Use the following argument to specify the configuration data you want to set using the env-exec-config Pact function. Argument | Type | Description flags | [string] | Specifies the configuration flags you want to be set for the execution environment. Return value The env-exec-config function returns the list of configuration flags that have been set for the execution environment. Examples The following example demonstrates how to use the env-exec-config function to enforce key formats and disable Pact events: Code example (pact): (env-exec-config [\"EnforceKeyFormats\" \"DisablePactEvents\"]) [\"DisablePactEvents\" \"EnforceKeyFormats\"] The following example demonstrates how to unset previously-set configuration flags using the env-exec-config function: Code example (pact): (env-exec-config []) [] The following example demonstrates how to check the current configuration settings: Code example (pact): (env-exec-config) []",
    "source": "pact-5/repl/env-exec-config.md",
    "title": "env-exec-config (DEPRECATED)"
  },
  {
    "content": "env-gas Use env-gas to query the current gas state or set it to a specific value. Basic syntax To query the current gas state, use the following syntax: Code example (pact): (env-gas) To set the gas state to a specific value, use the following syntax: Code example (pact): (env-gas gas) Arguments Use the following argument to set the gas state when using the env-gas Pact function. Argument | Type | Description gas | integer | Specifies the value to set the gas state to (optional). Return value When called without arguments, the env-gas function returns an integer representing the current gas state. When called with the gas argument, the env-gas function returns a string indicating that the gas state has been set to the specified value. Examples The following example demonstrates how to use the env-gas function to query the current gas state: Code example (pact): pact> (env-gas) 7 In the following example, the env-gas function resets the current gas state to zero: Code example (pact): pact> (env-gasmodel \"table\") (env-gaslimit 10) (env-gas 0) (map (+ 1) [1 2 3]) \"Set gas model to table-based cost model\" \"Set gas limit to 10\" \"Set gas to 0\" [2 3 4]",
    "source": "pact-5/repl/env-gas.md",
    "title": "env-gas"
  },
  {
    "content": "env-gaslimit Use env-gaslimit to set the environment gas limit to a specific value. Basic syntax To set the environment gas limit to a specific value, use the following syntax: Code example (pact): (env-gaslimit limit) Arguments Use the following argument to set the gas limit when using the env-gaslimit Pact function. Argument | Type | Description limit | integer | Specifies the gas limit to set for the environment. Return value The env-gaslimit function returns a string indicating that the gas limit has been set to the specified value. Examples The following example demonstrates how to use the env-gaslimit function to set a gas limit for the environment: Code example (pact): pact> (env-gaslimit 10) \"Set gas limit to 10\"",
    "source": "pact-5/repl/env-gaslimit.md",
    "title": "env-gaslimit"
  },
  {
    "content": "env-gaslog Use env-gaslog to enable gas logging for a block of code. You can use this function to check the gas required to execute a specific block of code. Basic syntax To enable gas logging for a specific block of code, use the following syntax: Code example (pact): (env-gaslog) code (env-gaslog) Arguments The env-gaslog function does not take any arguments. Return value The env-gaslog function returns the log messages in strings that describe the gas consumed by each operation in the code block. Examples The following example demonstrates how to use the env-gaslog function to report the gas consumed for the specified map function: Code example (pact): (env-gasmodel \"table\") (env-gaslimit 10) (env-gaslog) (map (+ 1) [1 2 3]) (env-gaslog) \"Set gas model to table-based cost model\" \"Set gas limit to 10\" [\"TOTAL: 0\"] [2 3 4] [\"TOTAL: 7\" \"map: GUnreduced: currTotalGas=4: 4\" \"+: GUnreduced: currTotalGas=5: 1\" \": GIntegerOpCost: (1, ): (1, ): Pact48IntThreshold: currTotalGas=5: 0\" \"+: GUnreduced: currTotalGas=6: 1\" \": GIntegerOpCost: (1, ): (2, ): Pact48IntThreshold: currTotalGas=6: 0\" \"+: GUnreduced: currTotalGas=7: 1\" \": GIntegerOpCost: (1, ): (3, ): Pact48IntThreshold: . . . [code continues] In this example, the [\"TOTAL: 0\"] message signals the beginning of gas logging for the map function. The messages after \"TOTAL: 7\" provide details about how the gas was calculated.",
    "source": "pact-5/repl/env-gaslog.md",
    "title": "env-gaslog"
  },
  {
    "content": "env-gasmodel Use env-gasmodel to query or update the current gas model. Basic syntax To query the current gas model, use the following syntax: Code example (pact): (env-gasmodel) To update the gas model to a table-based cost model, use the following syntax: Code example (pact): (env-gasmodel model) To update the gas model to a fixed-rate model with a specific rate, use the following syntax: Code example (pact): (env-gasmodel model rate) Arguments Use the following arguments when using the env-gasmodel Pact function. Argument | Type | Description model | string | Specifies the gas model to set. The supported gas models are table to use a table-based gas model and fixed to use a fixed rate gas model. | rate | integer | Specifies the fixed rate or every operation. This argument is required if you set the model argument to use the fixed gas model. Return value When called with the model argument, env-gasmodel returns a string indicating the updated gas model. When called without arguments, env-gasmodel returns a string describing the current gas model. Examples The following example demonstrates how to use the env-gasmodel function to query the current gas model: Code example (pact): pact> (env-gasmodel) \"Current gas model is 'fixed 1': constant rate gas model with fixed rate 1\" The following example demonstrates how to use the env-gasmodel function to update the current gas model to use a table-based cost model: Code example (pact): pact> (env-gasmodel \"table\") \"Set gas model to table-based cost model\" In the following example, the env-gasmodel function updates the gas model to use a fixed rate of two: Code example (pact): pact> (env-gasmodel \"fixed\" 2) \"Set gas model to constant rate gas model with fixed rate 2\"",
    "source": "pact-5/repl/env-gasmodel.md",
    "title": "env-gasmodel"
  },
  {
    "content": "env-hash Use env-hash to set the current transaction hash. Basic syntax To set the current transaction hash, use the following syntax: Code example (pact): (env-hash hash) Arguments Use the following argument when using the env-hash Pact function. Argument | Type | Description hash | string | Specifies the hash value to set as the current transaction hash. The hash must be an unpadded base64-url encoded BLAKE2b 256-bit hash. Return value The env-hash function returns a string indicating that the transaction hash has been set to the specified value. Example The following example demonstrates how to use the env-hash function to set the transaction hash using the base64-url encoded string for the hello string: Code example (pact): pact> (env-hash (hash \"hello\")) \"Set tx hash to Mk3PAn3UowqTLEQfNlol6GsXPe-kuOWJSCU0cbgbcs8\" The following example illustrates using the env-hash function to create a transaction hash for the test transaction that creates a token: Code example (pact): (env-hash (hash \"create-tokens\"))",
    "source": "pact-5/repl/env-hash.md",
    "title": "env-hash"
  },
  {
    "content": "env-keys (DEPRECATED) Use env-keys to set the transaction signer keys in older version of the Pact REPL. The env-keys function is deprecated in favor of env-sigs. You should use env-sigs for setting transaction signer keys with associated capabilities. Basic syntax To set transaction signer keys in older version of the Pact REPL, use the following syntax: Code example (pact): (env-keys keys) Arguments Use the following argument when using the env-keys Pact function. Argument | Type | Description keys | [string] | Specifies the list of keys to set as transaction signer keys. Return value The env-keys function returns a string indicating that the transaction keys have been set. Example The following example demonstrates how to use the env-keys function to set \"my-key\" and \"admin-key\" as the current transaction signing keys in a Pact REPL: Code example (pact): pact> (env-keys [\"my-key\" \"admin-key\"]) \"Setting transaction keys\"",
    "source": "pact-5/repl/env-keys.md",
    "title": "env-keys (DEPRECATED)"
  },
  {
    "content": "env-milligas Use env-milligas to query the current gas state in units of one one thousandth of a gas unit. This function is similar to the env-gas function, except that one (1) unit of gas is equal to one thousand units of milligas. This function is useful when writing smart contracts with minimal resource consumption to measure gas costs in smaller units than gas. Basic syntax To query the current gas state in units equal to one thousandth of a single unit of gas, use the following syntax: Code example (pact): (env-milligas) Arguments The env-milligas function takes no arguments. Return value When called, the env-milligas function returns an integer representing the current gas state, in units equal to one thousandth of a single unit of gas (milligas). Examples The following example demonstrates how to use the env-milligas function to query the current gas state: Code example (pact): pact> (env-milligas) 7123",
    "source": "pact-5/repl/env-milligas.md",
    "title": "env-milligas"
  },
  {
    "content": "env-module-admin Use env-module-admin to acquire the module administrative rights for any module loaded in the REPL, bypassing any checks. This function is particularly useful for writing tests that require administrative rights such as the ability to write to non-upgradeable module tables in the REPL. Basic syntax To acquire module administrative rights for the module specified, use the following syntax: Code example (pact): (env-module-admin module) Note that the module must be passed in as a module reference. Arguments Use the following argument when using the env-module-admin Pact function. Argument | Type | Description module | modref | Specifies the module for which you want to acquire module administrative rights. Return value On success, the env-module-admin function returns a string that indicates the module administrative rights have been acquired. Example The following example demonstrates how to use the env-module-admin function to acquire the module administrative rights for a non upgradeable module. Code example (pact): pact> (begin-tx) \"Begin Tx 0\" pact> (module m g (defcap g () (enforce false \"non-upgradeable\")). . . . > (defschema foo a: integer). . . . > (deftable tbl: {foo}). . . . > ) Loaded module m, hash rzIEM6JcGI4sNeAPY8eygWmO8pKIx35ezD3x5_GMg pact> pact> (create-table tbl) \"TableCreated\" pact> (commit-tx) \"Commit Tx 0\" pact> pact> (begin-tx) \"Begin Tx 1\" pact> (env-module-admin m); Acquired admin rights to m's tables. \"Acquired module admin for: m\" pact> (write m. tbl \"my-key\" {\"a\": 100}) \"Write succeede. . . [code continues]",
    "source": "pact-5/repl/env-module-admin.md",
    "title": "env-module-admin"
  },
  {
    "content": "env-namespace-policy Use env-namespace-policy to install a managed namespace policy. Basic syntax To install a managed namespace policy, use the following syntax: Code example (pact): (env-namespace-policy allow-root ns-policy-func) Arguments Use the following arguments when using the env-namespace-policy Pact function. Argument | Type | Description allow-root | bool | Specifies whether to allow root-level namespace creation. If set to true, root-level namespaces can be created. If set to false, root-level namespace creation is restricted. ns-policy-func | function | Specifies the namespace policy function. This function takes two arguments: the namespace string (ns) and the namespace admin guard (ns-admin), and returns a boolean value indicating whether the namespace is allowed based on the policy. The function should return true if the namespace is allowed, and false if it is not. Return value The env-namespace-policy function returns a string indicating that the namespace policy has been installed. Example The following example demonstrates how to use the env-namespace-policy function to install a namespace policy in a Pact REPL: Code example (pact): (env-namespace-policy true (my-ns-policy-func))",
    "source": "pact-5/repl/env-namespace-policy.md",
    "title": "env-namespace-policy"
  },
  {
    "content": "env-set-debug-flag Use env-set-debug-flag to display the result of the internal tree transformations that the Pact interpreter performs during program execution. This function lets you inspect Pact trees from modules and terms in the way the CEK machine understands them. This function is primarily suitable for advanced debugging. Basic syntax To set the Pact REPL debug flags, use the following syntax: Code example (pact): (env-set-debug-flag flag) Arguments Use the following argument when using the env-set-debug-flag Pact function. Argument | Type | Description flag | string | Specifies the debug flag to set. The valid values are \"lexer\", \"parser\", and \"desugar\". Return value The env-set-debug-flag function returns debugging details from the Pact interpreter. Examples The following example demonstrates how to use the env-set-debug-flag function to display debugging output from the Pact lexer: Code example (pact): (env-set-debug-flag \"lexer\") set debug flags to [lexer] () pact> (+ 2 3) ----------- Lexer output ----------------- [(, ident<+>, number<2>, number<3>, )] 5 The following example illustrates using the env-set-debug-flag function to display lexer, parser, and desugar debugging output from the Pact interpreter: Code example (pact): pact> (env-set-debug-flag \"parser\") set debug flags to [parser] pact> (env-set-debug-flag \"lexer\") ----------- Parser output ---------------- (env-set-debug-flag \"lexer\") set debug flags to [lexer, parser] () pact> (env-set-debug-flag \"desugar\") ----------- Lexer output ----------------- [(, ident<env-set-debug-flag>, \"desugar\", )] ----------- Parser output ---------------- (env-set-debug-flag \"desugar\") set debug flags to [lexer, parser, desugar] () pact> (fold (+) 0 [ 12 3 -9 30]) ---------. . . [code continues]",
    "source": "pact-5/repl/env-set-debug-flag.md",
    "title": "env-set-debug-flag"
  },
  {
    "content": "env-set-milligas Use env-milligas to set the current gas state to a specific value in units of one one thousandth of a gas unit. This function is similar to the env-gas function, except that one (1) unit of gas is equal to one thousand units of milligas. Basic syntax To set the current milligas state, use the following syntax: Code example (pact): (env-set-milligas milligas) Arguments Use the following argument to set the gas state when using the env-set-milligas Pact function. Argument | Type | Description milligas | integer | Specifies the value to set the milligas state to. Return value When called with the milligas argument, the env-set-milligas function returns a string indicating that the gas state has been set to the specified value. Examples In the following example, the env-set-milligas function resets the current gas state to 0. 01 gas: Code example (pact): pact> (env-set-milligas 10) \"Set milligas to 10\"",
    "source": "pact-5/repl/env-set-milligas.md",
    "title": "env-set-milligas"
  },
  {
    "content": "env-sigs Use env-sigs to set signature keys for signing transactions and granting capabilities. Basic syntax To set the signature keys to use for signing transactionL and granting capabilities, use the following syntax: Code example (pact): (env-sigs sigs) Arguments Use the following argument when using the env-sigs Pact function. Argument | Type | Description sigs | [object] | Specifies the list of signature objects. Each object represents a signer key and its associated caps capabilities. Return value The env-sigs function returns a string indicating that the transaction signature keys and capabilities have been set. Examples The following example illustrates using the env-sigs function to sign a transaction with a specific public key and capability in the Pact REPL: Code example (pact): (env-sigs [{\"key\": \"58705e8699678bd15bbda2cf40fa236694895db614aafc82cf1c06c014ca963c\", \"caps\": [(free. payments. PAYADMIN)]}]) \"Setting transaction signatures/caps\" The following example demonstrates how to use the env-sigs function to set transaction signatures and capabilities for two keys—\"my-test-key\" and \"admin-key\"—without using any public keys in the Pact REPL: Code example (pact): (env-sigs [ {\"key\": \"my-test-key\", \"caps\": [(accounts. USERGUARD \"my-account\")] }, {\"key\": \"admin-key\", \"caps\": []}] ) The following example illustrates using the env-sigs function to grant the MINT capability for the mint function in a simplified transaction: Code example (pact): (begin-tx \"mint\") (use token-sample) (env-data { \"token-id\": \"t: YV6-cQBhEEoIXAuNV08aGXLfcucBEGy0Gb1Pj6w_Oo\", \"account\": \"k: e4c6807d79d8bf4695e10e5678ebf72862f59b71f971d39dd3349f4beeacd6e3\", \"account-guard\": {\"keys\": [\"e4c6807d79d8bf4695e10e5678ebf72862f59b71f971d39dd3349f4beeacd6e3\"], \"pred\": \"keys-all\"} }) (env-sigs [ { \"key\": \"e4c6807d79d8bf4695e10e5678ebf72862f59b71f971d39dd3349f4beeacd6e3\", \"caps\": [(MINT (read-msg \"token-id\") (read-string 'account) 4. 0). . . [code continues]",
    "source": "pact-5/repl/env-sigs.md",
    "title": "env-sigs"
  },
  {
    "content": "env-verifiers Use env-verifiers to set transaction verifier names and capabilities. This function enables you to define a list of objects with the \"name\" key specifying the verifier name, and the \"caps\" key specifying a list of associated capabilities. Basic syntax To set the signature keys for transaction verifiers, use the following syntax: Code example (pact): (env-verifiers [verifiers]) Each verifier is an object that consists of a verifier name and a list of capabilities in the following format: Code example (pact): (env-verifiers [{\"name\": verifiername, \"caps\": [capabilities]}]) For each object, the verifiername is the verifier signature to add to scope, and caps is the list of capabilities that the verifiername is scoped to. Arguments Use the following argument to set verifier information using the env-verifiers Pact function. Argument | Type | Description verifiers | [object] | Specifies the list verifier objects where each object represents a verifier name to add to scope and a list of associated capabilities that the verifier is scoped to. Return value The env-verifiers function returns a string indicating that the transaction verifiers have been set. Examples The following example illustrates using the env-verifiers function to grant the \"COOLZK\" and \"HYPERCHAIN-BRIDGE\" verifiers. Code example (pact): pact> (module accounts g (defcap g () true) (defcap USERGUARD (user: string) true)) Loaded module accounts, hash 8aj3ezifsdCMX3l-A7p6Axbd59YJRsGR4MgDoR9qPgc pact> (module bridge g (defcap g () true) (defcap MINT (coin: string amount: integer) true)) Loaded module bridge, hash 9r3-A9e5vYGyKXTHTQVVq58Z2AJ4vWQeTP1uCTmZdPA pact> (env-verifiers [{'name: \"COOLZK\", 'caps: [(accounts. USER_GUARD \"my-account\")]}, {'name: \"HYPERCHAIN-BRIDGE\", 'caps: [(bridge. MINT \"mycoin\" 20)]}]) \"Setting transaction verifie. . . [code continues]",
    "source": "pact-5/repl/env-verifiers.md",
    "title": "env-verifiers"
  },
  {
    "content": "expect-failure Use expect-failure to evaluate an expression and succeed only if the expressions results in an error. This function enables you to verify that use cases that should failbehave as expected. Basic syntax To expect a failure without specifying the error message, use the following syntax: Code example (pact): (expect-failure doc exp) To expect a failure with a specific error message, use the following syntax: Code example (pact): (expect-failure doc err exp) Arguments Use the following arguments when using the expect-failure Pact function. Argument | Type | Description doc | string | Specifies the documentation string describing the expected failure. err | string | Specifies the expected error message (optional). exp | any | Specifies the expression to evaluate. The expression can be of any Pact type. Return value The expect-failure function returns a string indicating the success or failure of the expected failure. - If the expression exp throws an error, the function returns a string indicating the success of the expected failure, for example, \"Expect failure: success: Enforce fails on false\". - If the expression exp does not throw an error, the function itself throws an error, indicating that the expected failure did not occur. Examples The following example demonstrates how to use the expect-failure function without specifying the expected error message: Code example (pact): pact> (expect-failure \"Enforce fails on false\" (enforce false \"Expected error\")) \"Expect failure: success: Enforce fails on false\" The following example illustrates using the expect-failure function with a specific expected error message: Code example (pact): (expect-failure \"mint fails without MINT capability in scope\" \"Managed capability not installed: (marmalade-v2. ledger. MINT\" (mint (read-msg 'token-id) (read-msg 'account) (read-keyset 'account-guard) 1. 0))) In this example, the doc argument describes the test being performed. The err argument specifies the error message that is returned when the expression is evaluated.",
    "source": "pact-5/repl/expect-failure.md",
    "title": "expect-failure"
  },
  {
    "content": "expect-that Use expect-that to evaluate an expression and succeed if the resulting value passes a predicate function. You can use any data type for the exp argument as long as the pred function can take that same data type and return the resulting boolean value. By convention, the data type <a> is used to represent type-bound parameters that serve as input for functions and expressions or for generic arguments. Basic syntax To evaluate an expression that returns a predicate function, use the following syntax: Code example (pact): (expect-that doc pred exp) Arguments Use the following arguments when using the expect-that Pact function. Argument | Type | Description doc | string | Specifies the documentation string describing the expectation. pred | value: <a> -> bool | Specifies the predicate function that takes the result of exp and returns a boolean. exp | <a> | Specifies the expression to evaluate. The expression can be of any Pact type. Return value The expect-that function returns a string indicating the success or failure of the expectation. Examples The following example demonstrates how to use the expect-that function to evaluate an expression that returns the expected result: Code example (pact): pact> (expect-that \"addition\" (< 2) (+ 1 2)) \"Expect-that: success: addition\" The following example demonstrates how to use the expect-that function to evaluate an expression that returns fails to return the expected result: Code example (pact): pact> (expect-that \"addition\" (> 2) (+ 1 2)) \"FAILURE: addition: did not satisfy (> 2): 3: integer\"",
    "source": "pact-5/repl/expect-that.md",
    "title": "expect-that"
  },
  {
    "content": "expect Use expect to evaluate an expression and verify that the result equals an expected value. Basic syntax To evaluate an expression that returns an expected result, use the following syntax: Code example (pact): (expect doc expected actual) Arguments Use the following arguments when using the expect Pact function. Argument | Type | Description doc | string | Specifies the documentation string describing the expectation. expected | any | Specifies the expected value to compare against the result of actual. actual | any | Specifies the expression to evaluate. The expression can be of any Pact type. Return value The expect function returns a string indicating the success or failure of the expectation. Examples The following example demonstrates how to use the function expect to evaluate an expression that returns an expected result in a Pact REPL: Code example (pact): pact> (expect \"Sanity prevails. \" 4 (+ 2 2)) \"Expect: success: Sanity prevails. \" The following example illustrates using the expect function to verify that the information expected to be inserted into a table is the same as the result of the get-token-info function: Code example (pact): (expect \"Token info is inserted into table\" { \"id\": \"t: YV6-cQBhEEoIXAuNV08aGXLfcucBEGy0Gb1Pj6wOo\", \"supply\": 0. 0, \"precision\": 0, \"uri\": \"test-uri\", \"policies\": [] } (get-token-info \"t: YV6-cQBhEEoIXAuNV08aGXLfcucBEGy0Gb1Pj6wOo\") )",
    "source": "pact-5/repl/expect.md",
    "title": "expect"
  },
  {
    "content": "load Use load to load and evaluate a specified. pact or. repl file. You can reset the REPL state before loading the file by including the optional reset argument set to true. Basic syntax To load a specific. pact or. repl filename, use the following syntax: Code example (pact): (load filename reset) Arguments Use the following arguments when using the load Pact function. Argument | Type | Description filename | string | Specifies the. pact or. repl file you want to load into the Pact REPL. reset | bool | Resets the REPL state before loading if set to true (optional). Return value The load function returns the unit value (). Example The following example demonstrates how to use the load function to load the hello-pact. repl file to interact with its function in the Pact REPL without resetting the current Pact REPL state. In this example, the hello-pact. repl file consists of one expression (+ \"Hello, \" \"Pact! \") that is evaluated and returned in the Pact REPL: Code example (pact): (load \"hello-pact. repl\") \"Loading hello-pact. repl. . . \" \"Hello, Pact! \" If you want to clear the REPL state before loading the file, set the optional reset argument to true. For example, to clear previous votes from the Pact REPL before loading the vote-module. pact file, add true for the reset argument: Code example (pact): (load \"vote-module. pact\" true)",
    "source": "pact-5/repl/load.md",
    "title": "load"
  },
  {
    "content": "pact-state Use pact-state to inspect state from most the recent defpact step execution. This function returns an object with the following fields: - pactId: defpact identifier. - yield: yield result or false if the step didn't produce a yield. - step: executed step number. - executed: indicates if step was skipped because entity did not match. You can clear the defpact state from the REPL by including the optional clear argument set to true. Basic syntax To query the current state of the latest defpact execution, use the following syntax: Code example (pact): (pact-state) To query and clear the defpact state from the REPL, use the following syntax: Code example (pact): (pact-state true) Arguments Use the following argument to clear the most recent defpact step executed from the REPL state: Argument | Type | Description clear | bool | Clear the latest executed defpact from the REPL state (optional). Return value This function returns an object with the following fields: - pactId: defpact identifier - yield: yield result or false, if the step didn't produce a yield - step: executed step - executed: indicates if step was skipped because entity did not match Examples The following example demonstrates creating a module with a defpact, executing the first step, then querying the execution context using the pact-state function: Code example (pact): pact> (module m g (defcap g () true) (defpact foo () (step (yield {\"hello\": 1})) (step \"done! \"))) \"Loaded module m, hash LkeXOLGPdDYhWfXWngJhQmn6-D0pYNaxGHvP_Nyl6Yg\" pact> (foo) {\"hello\": 1} pact> (pact-state) {\"pactId\": \"DldRwCblQ7Loqy6wYJnaodHl30d3j3eH-qtFzfEv46g\", \"step\": 0, \"yield\": {\"hello\": 1}} The following example clears the defpact execution context from the REPL: Code example (pact): (pact-state true) {\"pactId\": \"DldRwCblQ7Loqy6wYJnaodHl30d3j3eH-qtFzfEv46g\", \"step\": 0, \"yield\": {\"hello\": 1}}",
    "source": "pact-5/repl/pact-state.md",
    "title": "pact-state"
  },
  {
    "content": "print Use print to send a specified value as output to the REPL logger (usually standard out). Basic syntax To print a specified value as REPL output, use the following syntax: Code example (pact): (print value) Arguments Use the following argument to specify the value to be printed using the print Pact function. Argument | Type | Description value | any | Specifies the value to be printed. Return value The print function returns the unit value (). Examples The following example demonstrates how to use the print function to print a string in the terminal when using the Pact command-line interpreter interactively: Code example (pact): (typeof (print (+ \"hello \" \"world\"))) \"hello world\" \"unit\" Note that you can only use the print built-in function when using Pact command-line interpreter interactively or in tests written in. repl files. You can't use the print function in Pact modules that you deploy on any network.",
    "source": "pact-5/repl/print.md",
    "title": "print"
  },
  {
    "content": "rollback-tx Use rollback-tx to roll back the current transaction. In most cases, you include this function in. repl files that test specific application features and failure scenarios. Within the context of a transaction started using the begin-tx function, you can set environment data, load modules, and execute functions. You use the rollback-tx function to signal the end of a transaction block that needs to be rolled back and can be followed by additional begin-tx and commit-tx blocks. Basic syntax To roll back a transaction, use the following syntax: Code example (pact): (rollback-tx) Arguments The rollback-tx function does not take any arguments. Return value The rollback-tx function returns a string indicating the transaction identifier that has been rolled back. Examples The following example demonstrates how to use the rollback-tx function within a Pact REPL: Code example (pact): pact> (begin-tx \"load module\") \"Begin Tx 0 load module\" pact> (rollback-tx) \"Rollback Tx 0 load module\" In this example, a new transaction—Tx0—is started using (begin-tx), and then (rollback-tx) is called to roll back the changes from the transaction. The function returns a string indicating that \"Tx 0\" has been rolled back. Note that you should only call the rollback-tx function after performing the necessary operations within a transaction. The rollback-tx function finalizes the transaction, and any changes made during the transaction are rolled back. It's important that you always call the rollback-tx function after begin-tx and after any other transaction-related operations to properly roll back the transaction. If rollback-tx is not called, the transaction remains open and might result in unexpected behavior or inconsistencies if you are expecting changes to be undone.",
    "source": "pact-5/repl/rollback-tx.md",
    "title": "rollback-tx"
  },
  {
    "content": "sig-keyset Use sig-keyset as a convenience to build a keyset from keys present in message signatures, using 'keys-all' as the predicate. Basic syntax To build a keyset from keys present in message signatures, use the following syntax: Code example (pact): (sig-keyset) Arguments The sig-keyset function does not take any arguments. Return value The sig-keyset function returns a keyset guard constructed from all of the signatures specified in the transaction environment data. In most cases, signatures are defined in. repl files or when using the REPL interactively using the env-sigs function. Example The following example demonstrates how to use sig-keyset to construct a keyset guard from the signatures defined for a transaction: Code example (pact): pact> (env-sigs [{\"key\": \"bob\", \"caps\": []}]) \"Setting transaction signatures/caps\" pact> (sig-keyset) KeySet {keys: [bob], pred: keys-all}",
    "source": "pact-5/repl/sig-keyset.md",
    "title": "sig-keyset"
  },
  {
    "content": "test-capability Use test-capability to acquire or install the capability specified. You can use this function to acquire any capability that's not managed or to install any managed capability. The specified capability and any composed capabilities it encompasses are in scope for the rest of the transaction. Basic syntax To acquire or install the capability specified, use the following syntax: Code example (pact): (test-capability (capability)) Arguments Use the following argument when using the test-capabilities Pact function. Argument | Type | Description capability | capability-token | Specifies the capability and scope to test. Return value The test-capability function returns a string that indicates whether the capability has been installed or acquired. Example The following example demonstrates how to use test-capability to acquire a capability for the scope of a REPL transaction: Code example (pact): pact> (module m g (defcap g () true)) \"Loaded module m, hash c5kiBbxH0zDIMPpAlJdXwMNsNiwnZY4YRzkJvvagn1c\" pact> (test-capability (g)) \"Capability acquired\" In this example, the capability isn't a managed capability and doesn't require any arguments. Managed capabilities define a resource that the capability controls access to and a management function that modifies the resource. For example, you might define a managed capability and management function similar to the following: Code example (pact): (defcap PAY (sender: string receiver: string amount: decimal) @managed amount manage-PAY (compose-capability (USER_GUARD sender))) (defun manage-PAY (mgd recd) (let ((bal: decimal (- mgd recd))) (enforce (>= bal 0. 0) \"insufficient balance\") bal)) (defun pay (sender: string receiver: string amount: decimal) (with-capability (PAY sender receiver amount) (transfer sender receiver amount)) ) For this example, the PAY managed capability requires the sender, receiver, and amount arguments: Code example (pact): (begin-tx \"Set capability\") (test-capability (cap-role. PAY \"Alice\" \"Bob\" 3. 0)) (commit-tx)",
    "source": "pact-5/repl/test-capability.md",
    "title": "test-capability"
  },
  {
    "content": "typecheck Use typecheck to run the Pact static type checker on the module you specify. Basic syntax To run the static type checker on the module specified, use the following syntax: Code example (pact): (typecheck module) Arguments Use the following argument when calling the typecheck function: Argument | Type | Description module | string | Specifies the name of the module to run the static type checker on. Return value If type checking for the module is successful, the typecheck function returns the unit value (). If type checking fails, the typecheck function throws an error and ends execution. Examples The following example demonstrates a simple. repl file with the module declaration for a rewards module that then calls the static type checker to check the rewards module: Code example (pact): (module rewards GOV (defcap GOV () true) (defun multiplier (points) (* points 10)) ) (typecheck \"rewards\") If you execute the code in the file by running pact rewards. repl --trace, you see the results of type checking for the module. For example: Code example (bash): rewards. repl: 0: 0-4: 1: Trace: Loaded module rewards, hash d6qkp1SyjmFCUofnsMpdV2W3IOLH8VA9lg0Dqv4cN_M rewards. repl: 6: 0-6: 21: Trace: Typechecking successful for module rewards Load successful If you specify a namespace before the module declaration, you must include the namespace when you call the typecheck function. For example, if the rewards module declaration comes after entering the (namespace \"develop\") namespace, you would call the typecheck function like this: Code example (pact): (typecheck \"develop. rewards\")",
    "source": "pact-5/repl/typecheck.md",
    "title": "typecheck"
  },
  {
    "content": "Reference information for Pact built-in functions that are intended for special usee cases. Pact includes several built-in functions that are intended for very specific use cases, such as integrating with other tools and working with zero knowledge proofs. Commitments - hyperlane-decode-token-message Decode a base-64-unpadded encoded Hyperlane Token Message into an object. - hyperlane-encode-token-message Encode an object into base-64-unpadded encoded Hyperlane Token Message. - hyperlane-message-id Get the message identifier of a Hyperlane Message object. Simple payment verification - verify-spv Perform a platform-specific simplified payment verification (SPV) proof. Zero knowledge (ZK) built-in functions - pairing-check Perform pairing and final exponentiation on points for a zero knowledge proof. - point-add Add two points together for a zero knowledge proof. - scalar-mult Multiply a point by an integer value for a zero-knowledge proof.",
    "source": "pact-5/special-use-cases.md",
    "title": "Specialized functions"
  },
  {
    "content": "verify-spv Use verify-spv to perform a platform-specific simplified payment verification (SPV) proof of a specified type for the specified payload. The format of the payload object and the returned object depends on the type of proof you specify. For information about payload types and return values, see platform-specific documentation. For Chainweb nodes, see the Chainweb API specification. Basic syntax To perform an SPV proof of a specified type on a specified payload, use the following syntax: Code example (pact): (verify-spv type payload) Arguments Use the following arguments to specify the type of SPV proof and the payload for verification using the verify-spv Pact function. Argument | Type | Description type | string | Specifies the type of SPV proof to be performed. payload | object | Specifies the payload object to be used for verification. Return value The verify-spv function returns an object whose format depends on the specific platform and the type of SPV proof being performed. Examples The following example demonstrates how to use the verify-spv function to verify an SPV proof of type \"txout\" using the payload obtained from reading a message: Code example (pact): (verify-spv \"txout\" (read-msg \"proof\"))",
    "source": "pact-5/spv/verify-spv.md",
    "title": "verify-spv"
  },
  {
    "content": "add-time Use add-time to add a specified number of seconds to a given time. Basic syntax To add seconds to a time, use the following syntax: Code example (pact): (add-time time seconds) Arguments Use the following arguments to specify the time to which you want to add seconds using the add-time Pact function. Argument | Type | Description time | time | Specifies the time to which you want to add seconds. seconds | decimal or integer | Specifies the number of seconds to add to the time. Return value The add-time function returns the resulting time after adding the specified number of seconds to the specified time. Examples The following example adds 120 seconds to the specified time \"2024-06-22T12: 00: 00Z\" in the Pact REPL: Code example (pact): pact> (add-time (time \"2024-06-22T12: 00: 00Z\") 120) \"2024-06-22T12: 02: 00Z\" In most cases, you use the add-time function in combination with other functions such hours or minutes as follows: Code example (pact): pact> (add-time (time \"2024-06-22T12: 00: 00Z\") (hours 1)) \"2024-06-22T13: 00: 00Z\" (add-time (time \"2024-06-26T12: 00: 00Z\") (minutes 35)) \"2024-06-26T12: 35: 00Z\"",
    "source": "pact-5/time/add-time.md",
    "title": "add-time"
  },
  {
    "content": "days Use days to specify a number of days. You can use this function in conjunction with the add-time function to add a specified number of days to a specified time. Basic syntax To specify a number of days, use the following syntax: Code example (pact): (days n) Arguments Use the following argument to specify the n number of days for the days Pact function. Argument | Type | Description n | decimal or integer | Specifies the number of days to add. Return value The days function returns the number of seconds in the given number of days as a decimal value. Example The following example demonstrates how to use the days function to return the number of seconds in one day as a decimal value: Code example (pact): (days 1) 86400. 0 The following example demonstrates how to use the days function in combination with add-time: Code example (pact): (add-time (time \"2024-07-22T12: 00: 00Z\") (days 1)) \"2024-07-23T12: 00: 00Z\" In this example, (days 1) adds one day to the specified time \"2024-07-22T12: 00: 00Z\" using the add-time function, enabling straightforward manipulation of time-based information in smart contracts.",
    "source": "pact-5/time/days.md",
    "title": "days"
  },
  {
    "content": "diff-time Use diff-time to compute the difference between time1 and time2 in seconds. Basic syntax To compute the difference between time1 and time2 in seconds, use the following syntax: Code example (pact): (diff-time time1 time2) Arguments Use the following arguments to specify the times for the diff-time Pact function: Argument | Type | Description time1 | time | Specifies the first time for the calculation. time2 | time | Specifies the second time for the calculation. Return value The diff-time function returns the difference between time1 and time2 in seconds as a decimal. Examples The following example demonstrates how to use the diff-time function to compute the difference between the times \"16: 00: 00\" and \"09: 30: 00\" in seconds: Code example (pact): pact> (diff-time (parse-time \"%T\" \"16: 00: 00\") (parse-time \"%T\" \"09: 30: 00\")) 23400. 0 In this example, the function returns the result of this computation as a decimal, representing the time difference between the two specified times.",
    "source": "pact-5/time/diff-time.md",
    "title": "diff-time"
  },
  {
    "content": "format-time Use format-time to format a time value using a specified format. The format-time function is useful for converting time values to human-readable formats in Pact contracts. The format-time function accepts format codes that are derived from the formatting time strftime function time templates. For information about all of the time formats and specifiers, see Time formats. The following table provides a summary of the most common time formatting codes: Format | Purpose %Y | Year with no padding. %m | Month of the year, zero-padded to two characters, \"01\"–\"12\" %d | Day of the month, zero-padded to two characters, \"01\"–\"31\" %H | Hour of the day using a 24-hour clock, zero-padded to two characters, \"00\"–\"23\" %M | Minute of of the hour, zero-padded to two characters, \"00\"–\"59\" %S | Second of the minute, zero-padded to two characters, \"00\"–\"60\" Note that two percentage characters (%%) are interpreted as a literal percentage sign (%), not a time formatting template. Basic syntax To format a time value using a specified format, use the following syntax: Code example (pact): (format-time format time) Arguments Use the following arguments to specify the format and time for the format-time Pact function: Argument | Type | Description format | string | Specifies the format string for the time. time | time | Specifies the time value to format. Return value The format-time function returns a new string with the formatted time value. Examples The following example demonstrates how to use the format-time function to format the time value (time \"2016-07-22T12: 00: 00Z\") using the specified format: Code example (pact): pact> (format-time \"%F\" (time \"2016-07-22T12: 00: 00Z\")) \"2016-07-22\" In this example, \"%F\" is the format string specifying the format of the output. The result of this operation is a formatted string representing the date in the format YYYY-MM-DD. The following example demonstrates how to replace the numeric representing the month of the year with the short name for the month: Code example (pact): pact> (format-time \"%Y-%b-%d\" (time \"2024-07-24T13: 30: 45Z\")) \"2024-Jul-24\"",
    "source": "pact-5/time/format-time.md",
    "title": "format-time"
  },
  {
    "content": "hours Use the hours function to calculate a time duration in hours. You can use this function in combination with the add-time function to add a specific number of hours to a given time. Basic syntax The syntax for the hours function is as follows: Code example (pact): (hours n) Arguments Use the following argument to specify the number of hours for the duration using the hours Pact function. Argument | Type | Description n | integer or decimal | Specifies the number of hours as either a decimal or an integer. Return value The hours function returns a decimal value representing the specified number of hours. Examples The following example illustrates how to use the hours function with the add-time function to add three hours to the time represented by the string \"2024-07-22T12: 00: 00Z\". Code example (pact): (add-time (time \"2024-07-22T12: 00: 00Z\") (hours 3)) \"2024-07-22T15: 00: 00Z\" You can also use the hours function to convert hours specified as a integer or decimal to return the equivalent time in seconds. For example, you can specify hours as an integer to return the number of seconds: Code example (pact): pact> (hours 3) 10800. 0 In the following example, the hours function converts the decimal value 2. 5 hours to the equivalent time in seconds. Code example (pact): pact> (hours 2. 5) 9000. 0 The hours function is useful for performing time calculations in Pact contracts, such as adding or subtracting specific durations from timestamps.",
    "source": "pact-5/time/hours.md",
    "title": "hours"
  },
  {
    "content": "minutes Use minutes to represent a duration of a specified number of minutes. You can use this function in combination with the add-time function to add a specific number of minutes to a given time. Basic syntax To represent a duration of N minutes, use the following syntax: Code example (pact): (minutes n) Arguments Use the following argument to specify the number of minutes for the duration using the minutes Pact function. Argument | Type | Description n | decimal or integer | Specifies the number of minutes for the duration. Return value The minutes function returns the duration in decimal format. Examples The following example demonstrates the use of minutes in combination with add-time in the Pact REPL: Code example (pact): pact> (add-time (time \"2016-07-22T12: 00: 00Z\") (minutes 1)) 2016-07-22 12: 01: 00 UTC",
    "source": "pact-5/time/minutes.md",
    "title": "minutes"
  },
  {
    "content": "parse-time Use parse-time to construct a UTC formatted time string from an input time that uses the specified format. The parse-time function accepts format codes that are derived from the formatting time strftime function time templates. For information about all of the time formats and specifiers, see Time formats. The following table provides a summary of the most common time formatting codes: Format | Purpose %Y | Year with no padding. %m | Month of the year, zero-padded to two characters, \"01\"–\"12\" %d | Day of the month, zero-padded to two characters, \"01\"–\"31\" %H | Hour of the day using a 24-hour clock, zero-padded to two characters, \"00\"–\"23\" %M | Minute of of the hour, zero-padded to two characters, \"00\"–\"59\" %S | Second of the minute, zero-padded to two characters, \"00\"–\"60\" Note that two percentage characters (%%) are interpreted as a literal percentage sign (%), not a time formatting template. Basic syntax To construct a UTC time string from a input time that uses a specified format, use the following syntax: Code example (pact): (parse-time format input) Arguments Use the following arguments to specify the format and input time value for constructing time using the parse-time Pact function. Argument | Type | Description format | string | Specifies the format for parsing the input time to construct the time as a UTC string. input | string | Specifies the input time to be parsed. Return value The parse-time function returns a UTC formatted time constructed from the provided input value that uses the specified format. Examples The following example demonstrates the use of parse-time in the Pact REPL: Code example (pact): pact> (parse-time \"%F\" \"2024-11-06\") \"2024-11-06T00: 00: 00Z\" In this example, the parse-time function constructs a UTC-formatted time value from the input value \"2024-11-06\". The input string uses the %Y-%m-%d format specified in the ISO 8601 standard and identified with the \"%F\" format argument. In the following example, the input string uses the %D and %T format specifiers for date and time: Code example (pact): (parse-time \"%D %T\" \"11/07/24 08: 09: 10\") \"2024-11-07T08: 09: 10Z\" The following example parses an input string that uses the abbreviated month name (%b), the day of the month as a zero-padded string (%d), and the full year (%Y) to a UTC time: Code example (pact): (parse-time \"%b %d %Y %T\" \"Nov 07 2024 08: 09: 10\") \"2024-11-07T08: 09: 10Z\"",
    "source": "pact-5/time/parse-time.md",
    "title": "parse-time"
  },
  {
    "content": "time Use the time function to construct a time object from a UTC value using the ISO 8601 standard Universal Time Coordinated (UTC) date time format: Code example (text): %Y-%m-%dT%H: %M: %SZ The UTC format is the default time format in Pact for all time-related functions. Internally, the time object supports up to microsecond resolution. However, the values returned from the Pact interpreter as JSON are serialized using the default format. If you need higher resolution, you can explicitly format times with the %v template and related codes. Basic syntax To construct a time object from a UTC value, use the following syntax: Code example (pact): (time UTC) Arguments Use the following argument to specify the UTC value for constructing the time object using the time Pact function. Argument | Type | Description UTC | string | Specifies the UTC value in ISO 8601 format (%Y-%m-%dT%H: %M: %SZ). Return value The time function returns a time object constructed from the provided UTC value. Examples The following example demonstrates how to use the time function in the Pact REPL. This example constructs a time object from the UTC value \"2016-07-22T11: 26: 35Z\": Code example (pact): pact> (time \"2016-07-22T11: 26: 35Z\") 2016-07-22 11: 26: 35 UTC This example illustrates how to use the time function to create a time object from a UTC value using the ISO 8601 format in Pact.",
    "source": "pact-5/time/time.md",
    "title": "time"
  },
  {
    "content": "pairing-check Use pairing-check to perform pairing and final exponentiation on points in points-g1 and points-g2 in the Barreto-Naehrig (BN254) elliptic curve, and check if the result is 1. Basic syntax To perform pairing and final exponentiation on points in points-g1 and points-g2, and check if the result is 1, use the following syntax: Code example (pact): (pairing-check points-g1 points-g2) Arguments Use the following arguments to specify the lists of points in G1 and G2 for which you want to perform the pairing check using the pairing-check Pact function. Argument | Type | Description points-g1 | [any] | Specifies the list of points in G1. points-g2 | [any] | Specifies the list of points in G2. Return value The pairing-check function returns a boolean value indicating whether the result of the pairing and final exponentiation is 1. Examples The following example demonstrates how to use the pairing-check function in the Pact REPL: Code example (pact): pact> (pairing-check [point1g1 point2g1] [point1g2 point2g2])",
    "source": "pact-5/zk/pairing-check.md",
    "title": "pairing-check"
  },
  {
    "content": "point-add Use point-add to add two points together that lie on the in the Barreto-Naehrig (BN254) elliptic curve. The BN254 curve is a pairing-friendly curve tht can be used for verifying on-chain zero knowledge proof schemes such as Groth16 and PlonK. You can use this function to add point either in Fq or in Fq2. Basic syntax To add two points together that lie on the Barreto-Naehrig (BN254) elliptic curve, use the following syntax: Code example (pact): (point-add type point1 point2) Arguments Use the following arguments to specify the type of addition and the points to be added using the point-add Pact function. Argument | Type | Description type | string | Specifies the type of point addition to perform. The valid values are \"g1\" and \"g2\". point1 | any | Specifies the first point to be added. point2 | any | Specifies the second point to be added. Return value The point-add function returns the result of adding the specified points together. Examples The following example demonstrates how to use the point-add function to add the two specified points together on the BN256 curve in the Pact REPL: Code example (pact): pact> (point-add 'g1 {'x': 1, 'y': 2} {'x': 1, 'y': 2}) {\"x\": 1368015179489954701390400359078579693043519447331113978918064868415326638035, \"y\": 9918110051302171585080402603319702774565515993150576347155970296011118125764} In this example, the type of addition is g1 and the points are provided as objects with x and y coordinates.",
    "source": "pact-5/zk/point-add.md",
    "title": "point-add"
  },
  {
    "content": "scalar-mult Use scalar-mult to multiply a point that lies on the BN254 by a specified scalar integer value. Basic syntax To multiply a point by a specified scalar integer value, use the following syntax: Code example (pact): (scalar-mult type point1 scalar) Arguments Use the following arguments to specify the type, point, and scalar value for multiplication using the scalar-mult Pact function. Argument | Type | Description type | string | Specifies the type of point to multiply. The valid values are \"g1\" and \"g2\". point1 | point | Specifies the point on the BN254 curve to be multiplied. scalar | integer | Specifies the integer value to multiply the point by. Return value The scalar-mult function returns the result of multiplying the specified point by the scalar value. Examples The following example demonstrates how to use the scalar-mult function to multiply the point { 'x: 1, 'y: 2 } on curve 'g1 by the scalar value 3: Code example (pact): pact> (scalar-mult 'g1 {'x: 1, 'y: 2} 3) {\"x\": 3353031288059533942658390886683067124040920775575537747144343083137631628272, \"y\": 19321533766552368860946552437480515441416830039777911637913418824951667761761}",
    "source": "pact-5/zk/scalar-mult.md",
    "title": "scalar-mult"
  },
  {
    "content": "Learn how to set up a development environment and write a simple smart contract for the Kadena network.\" slug: quickstart import Link from '@docusaurus/Link'; import CodeBlock from '@theme/CodeBlock'; Quick start for Kadena developers Welcome to the Kadena development Quick start guide. Follow these simplified instructions to set up your development environment with a local blockchain and developer tools, then write your first contract using the Pact smart contract programming language. Before you begin Before you begin, verify your computer meets the following basic requirements and has the following tools installed: Access to the internet, an interactive terminal shell, and a web browser. Git version control program. You can verify that git is installed by running git --version on your computer. Node. js, version 18 or higher. You can verify that node. js is installed by running node --version on your computer. npm, the command-line interface for the node package manager. You can verify that npm is installed by running npm --version on your computer. * Docker, version x or higher. You can verify that docker is installed by running docker --version on your computer. If you have everything you need, you can set up your development environment and deploy your first contract with a few basic steps. Install Pact The Pact smart contract programming language is specifically designed for writing smart contracts to run safely and efficiently on the Kadena blockchain network. Follow the appropriate instructions for your operating system to Pact. - Install Pact on Linux - Install Pact on macOS - Install Pact on Microsoft Windows Services for Linux (WSL) For more information about installing Pact, see Installation and setup. Set up a local network The Kadena development network allows you to run a standalone local blockchain node to simulate network operations and to test your smart contracts locally before deploying to a test or production network. To set up the local network, open a terminal shell on your computer then run the following commands to get the development network Docker image and start the network in a Docker container: Code example (bash): git clone https: //github. com/kadena-io/devnet cd devnet npm install docker run --rm --interactive --tty --publish 8080: 8080 --volume kadenadevnet: /data --name devnet kadena/devnet For more information about starting the Kadena development network in a Docker container, see Set up the local network. Install the Kadena command-line interface The Kadena command-line interface (kadena-cli) provides direct access to the Kadena blockchain and commands to create, test, deploy, and manage applications for the Kadena network. You can use the Kadena command-line interface interactively or in scripts and automated workflows. To install and configure the kadena-cli program, open a terminal shell on your computer then run the following commands: Code example (bash): npm install --global @kadena/kadena-cli kadena config init The kadena config init command creates the. kadena configuration folder location in your current working directory and adds default network settings to a networks subfolder, then prompts you to create a wallet. Wallets are an important part of interacting with any blockchain, so you can create one now as part of your initial configuration steps. Follow the prompts displayed to continue setting up your local development environment with a development wallet and an account. For more information about getting started with kadena-cli commands, see Develop with kadena-cli. For command-line reference information, see kadena-cli command reference. Write your first smart contract You can now write and execute a simple greeting smart contract using the Pact smart contract programming language and the Pact interactive interpreter. 1. Open a terminal shell on your computer. 3. Start the Pact interpreter that you installed in the first step by running the following command: ``bash pact ` 2. Copy and paste the following simple greeting module code, then press return: `pact (module greeting GOVERNANCE (defcap GOVERNANCE () true) (defun say-hello(name: string) (format \"Hello, {}! ~ from Kadena\" [name]) ) ) ` You should see the module loaded with output similar to the following: `pact \"Loaded module greeting, hash f1yyXqj5HstOni1QdZmuagUJXbu72VmYiwXua7Vp4-0\" ` 3. Call the say-hello function with a string similar to the following: `pact (say-hello \"Pistolas\") ` The function returns a greeting similar to the following: `pact \"Hello, Pistolas! ~ from Kadena\" ` If you want to deploy this contract on the local development network, copy the module code to a file with the. pact file extension—for example, create a greeting. pact` file—then create a transaction to deploy the module as described in Deploy smart contracts. You can exit the Pact interpreter by pressing control-d on the keyboard. Next steps Congratulations! In this Quick start_, you learned the basics of how to set up a development environment with the Pact programming language, a local development network, and the Kadena developer command-line interface. You also got a first look at how to write and execute a simple Pact contract in the interactive interpreter. You can learn more about these topics in Smart contracts documentation. Here are some suggested next steps: - Start learning the Pact programming language with Get started: Introduction to Pact. - Explore hands-on coding projects in Coding projects. - Learn how to interact with the blockchain and deployed contracts using Kadena API calls and How-to guides. - Join the Kadena Discord community for support and discussions.",
    "source": "quickstart.md",
    "title": "Quick start"
  },
  {
    "content": "Kadena test and production networks rely on bootstrap nodes to establish peer-to-peer communication. When you start chainweb-node on a computer, the chainweb-node program attempts to connect to one or more bootstrap nodes to discover other nodes in the peer-to-peer network. For the connection to succeed, at least one of the bootstrap nodes must be trusted. You can configure Chainweb to connect to specific bootstrap nodes by using the --known-peer-info command-line option or specifying the peer information in a Chainweb configuration file. You can also configure Chainweb to ignore the built-in bootstrap nodes by using the --enable-ignore-bootstrap-nodes command-line option or by setting the ignoreBootstrapNodes configuration option. If you're a node operator and would like to have your Chainweb node included as a bootstrap node, keep in mind the following requirements: - Bootstrap nodes must have a public DNS name and a corresponding TLS certificate that is issued by a widely-accepted Certificate Authority. At a minimum, the certificate must be accepted by the OpenSSL library. - Bootstrap node operators are expected to guarantee reasonable uptime and long-term availability of the nodes. - Bootstrap node operators are expected to monitor node and network health, maintain node operations, and perform timely software updates. To become a bootstrap node operator: 1. Fork the chainweb-node repository. 2. Add your node information to the chainweb-node/src/P2P/BootstrapNodes module. 3. Create a pull request to have your change reviewed and approved. Testnet bootstrap nodes Currently, Kadena testnet04 has the following bootstrap nodes running on port 443: - us1. testnet. chainweb. com - us2. testnet. chainweb. com - eu1. testnet. chainweb. com - eu2. testnet. chainweb. com - ap1. testnet. chainweb. com - ap2. testnet. chainweb. com Mainnet bootstrap nodes Currently, Kadena mainnet01 has the following bootstrap nodes running on port 443: - us-e1. chainweb. com - us-e2. chainweb. com - us-e3. chainweb. com - us-w1. chainweb. com - us-w2. chainweb. com - us-w3. chainweb. com - jp1. chainweb. com - jp2. chainweb. com - jp3. chainweb. com - fr1. chainweb. com - fr2. chainweb. com - fr3. chainweb. com",
    "source": "reference/bootstrap.md",
    "title": "Chainweb bootstrap nodes"
  },
  {
    "content": "Command-line options and usage information for running the chainweb-node binary. You can configure many aspects of Chainweb node operations using configuration settings in one or more configuration files or by specifying command-line options and arguments. Configuration settings are loaded in order first from one or more configuration file locations that you specify using --config-file options then from the command-line options in the order you specify them. Configuration settings that are loaded later overwrite settings that were previously loaded. You can specify configuration file locations by providing local file system paths or remote HTTP or HTTPS URLs. Remote URLs must start with either \"http: //\" or \"https: //\". Basic usage The basic syntax for setting chainweb-node command-line options is: Code example (bash): chainweb-node [option] [arguments] Node information options Use this option | To do this| --config-file filename | Specify the local path or the URL of a file that contains configuration settings in YAML or JSON format. If you specify more than one --config-file option, the files are loaded in the order that they are specified on the command line. You can specify configuration file locations by providing local file system paths or remote HTTP or HTTPS URLs. Remote URLs must start with either \"http: //\" or \"https: //\". | -? , -h, --help | Display usage information as standard output, then exit. --info | Display a brief summary that describes the Chainweb version number and revision (commit) hash as standard output, then exit. --license | Display the license agreement for the software as standard output, then exit. --long-info | Display a complete list of packages and dependencies as standard output, then exit. --print-config | Display the current configuration of the node as standard output. This option is an alias for the --print-config-as=full option. --print-config-as full | minimal | diff | Choose whether to display the full configuration settings, only the settings you have explicitly set, or only the settings that are different from the default settings. -v, --version | Display the Chainweb version number and revision (commit) hash as standard output, then exit. General blockchain options Use this option | To do this -v, --chainweb-version networkId | Specify the Chainweb network identifier for the node. Valid values are development, testnet04, testnet05, and mainnet01. The default is mainnet01. --database-directory path | Specify the path to the chainweb-node database root folder. --header-stream | Enable the endpoint for streaming block updates. For information about streaming block updates, see Stream block header event updates. --no-header-stream | Unset the --header-stream option and disable streaming block updates. --enable-tx-reintro | Enable transactions from losing forks of the chain to be resubmitted. --disable-tx-reintro | Unset the --enable-tx-reintro option and prevent transactions from losing forks to be resubmitted. --enable-reset-chain-databases | Reset chain databases when the node starts. --disable-reset-chain-databases | Disable resetting of chain databases when the node starts. --reorg-limit max | Specify the maximum allowed reorganization depth. For more information, see Recovering from deep forks. --pre-insert-check-timeout microseconds | Specify the maximum number of microseconds allowed for the transactions validation in the PreInsertCheck command. --allowReadsInLocal | Enable direct database reads of smart contract tables in local queries. --no-allowReadsInLocal | Disable direct database reads of smart contract tables in local queries. Development mode options Use this option | To do this --fork-upper-bound upperBound | Specify the latest fork for the node to enable (development mode only). --block-delay delay | Specify the block delay in seconds per block (development mode only). --disable-pow | Disable the proof-of-work check (development mode only). Peer-to-peer options Use this option | To do this --p2p-hostname hostname | Set the hostname or IP address for the local peer to enable peer-to-peer communication. --p2p-port portNumber | Set the port number for the local peer to enable peer-to-peer communication. --p2p-interface interface | Set the interface for the peer-to-peer REST API endpoints to bind to. For more information, see the HostPreference documentation. --p2p-certificate-chain certificate | Specify the PEM-encoded X509 certificate or certificate chain used by the local peer for peer-to-peer communication. --p2p-certificate-chain-file file | Specify a file with the PEM-encoded certificate chain. Providing the certificate-chain as a text string takes precedence over using a file for peer-to-peer communication. --p2p-key key | Specify the PEM-encoded X509 certificate key used by the local peer for peer-to-peer communication. The default is null. --p2p-certificate-key-file file | Specify a file with the PEM-encoded certificate key. A textually provided certificate key has precedence over using a file for peer-to-peer communication. --p2p-max-session-count count | Specify the maximum number of sessions that can be active at any time. --p2p-max-peer-count count | Specify the maximum number of entries allowed in the peer database. --p2p-session-timeout seconds | Specify the maximum number of seconds to allow for a session to try to connect before timing out the connection. --known-peer-info [ peerId@ ]hostaddress | Specify the peer information that is added to the list of known peers. You can specify this option multiple times on the command-line. --enable-ignore-bootstrap-nodes | Specify that you want to ignore the hard-coded bootstrap nodes for the network. --disable-ignore-bootstrap-nodes | Unsets the option to ignore bootstrap nodes to restore communication with the hard-coded bootstrap nodes for the network. --enable-private | Specify that you want this node to be private and only communicate only with its initially configured known peer nodes. --disable-private | Unsets the make the node private to enable the node to communicate with other nodes in the network. --bootstrap-reachability [0, 1] | Specify the number of bootstrap nodes that must be reachable when the node starts up as a fraction of the bootstrap nodes available. The default value of 0. 5 indicates that half of the bootstrap nodes must be reachable for the node to connect to the network. Memory pool options Use this option | To do this --enable-mempool-p2p | Enables the memory pool peer-to-peer network for the local node. --disable-mempool-p2p | Unsets the --enable-mempool-p2p option to disable the memory pool peer-to-peer network for the local node. --mempool-p2p-max-session-count count | Specify the maximum number of memory pool peer-to-peer sessions that are active at any time. --mempool-p2p-session-timeout seconds | Specify the maximum number of seconds to allow for a memory pool peer-to-peer session to try to connect before timing out the connection. --mempool-p2p-poll-interval seconds | Specify the poll interval for synchronizing memory pool sessions. Gas options Use this option | To do this| --block-gas-limit max | Specify the upper bound for the sum of all transaction fees allowed in a block. The total fees for all transaction must not exceed the value you set for the max argument. | | --log-gas | Logs the gas fees consumed by Pact commands. | --no-log-gas | Disables the --log-gas option to stopping logging the gas consumed by Pact commands. | --min-gas-price price | Specify the minimum gas price allowed for an individual transaction in a block. The gas fee for any individual transaction in a block cannot be below the value you set for the price argument. | Pact options | Use this option | To do this | --------------- | ---------- --pact-queue-size max | Specify the maximum size of the Pact internal queue. --full-historic-pact-state | Keep the full historic Pact state n the database. You should only only set this option for custodial or archive nodes. --no-full-historic-pact-state | Reset the --full-historic-pact-state option from true to false. --module-cache-limit bytes | Set the maximum size of the per-chain checkpointer module cache in bytes. --enable-local-timeout seconds | Enable timeout support for /local endpoint calls. Cut options Use this option | To do this --fast-forward-block-height-limit height | Set the limit for fast-forwarding block height (null means no limit). If you set the --only-sync-pact option, chain synchronization uses this block height. If you haven't set the --only-sync-pact option, this option is ignored. --cut-fetch-timeout microseconds | Set a timeout for fetching cuts in microseconds. --initial-block-height-limit height | Reset the initial cut to this block height (null means no limit). --prune-chain-database none | headers | headers-checked | full | Specify a database pruning strategy to run when the node starts. You can specify the strategy are none, headers, headers-checked, or full. Note that database pruning can take several hours. Service API options | Use this option | To do this | --------------- | ---------- --service-port port | Specify the port number for exposing the service API. --service-interface interface | Set the interface for the service REST API endpoints to bind to. For more information, see the HostPreference documentation. --service-payload-batch-limit max | Set the upper limit for the number of payload batches that can be returned in response to a service API request. Note that increasing this upper limit can make payload requests a potential attack vector for Denial of Service (DoD) attacks. Mining options Use this option | To do this| --enable-mining-coordination | Enable the mining coordination API for the node. --disable-mining-coordination | Reset the --enable-mining-coordination option from true to false to disables the mining coordination API for the node. --mining-public-key key | Set the public key for a miner account in hexadecimal encoding. Account names typically use the prefix k: followed by the account public key. You can specify this option multiple times. --mining-request-limit max | Specify the maximum number of mining work requests that can be made within a 5 minute period. --mining-update-stream-limit max | Specify the maximum number of concurrent update streams that the node can support. --mining-update-stream-timeout seconds | Set the maximum number of seconds to keep an update stream open. --mining-payload-refresh-delay seconds | Specify the frequency with which the mining payload is refreshed. --enable-node-mining | Enable in-node mining. Only use this option for internal network testing. --disable-node-mining | Unset the --enable-node-mining option. --node-mining-public-key key | Set the public key for a miner account in hexadecimal encoding. Account names typically use the prefix k: followed by the account public key. You can specify this option multiple times. Synchronization and replay options Use this option | To do this --only-sync-pact | Synchronize the Pact databases to the latest cut, then terminate the node process. --no-only-sync-pact | Unset the --only-sync-pact option. --read-only-replay | Replay the block history non-destructively. --no-read-only-replay | Unset the --read-only-replay option. --sync-pact-chains JSON list of chain ids | Specify a list of chain identifiers to synchronize in JSON format. If the list is empty or this option is unset, all chains are synchronized. Backup options Use this option | To do this --enable-backup-api | Enable the backup API. --disable-backup-api | Disable the backup API. | --backup-directory directory | Specify the directory where database backups are located when you use the /make-backup endpoint to start backup jobs. | Logging options Use this option | To do this --log-level quiet | error | warn | info | debug | Set the logging level threshold for log messages. --log-policy block | raise | discard | Select an option for how to deal with a congested logging pipeline. --exception-limit max | Set the maximum number of backend failures before the node should raise an exception. --exception-wait seconds | Set the time to wait in seconds after an backend failure has occurred. --exit-timeout seconds | Set the timeout for flushing the log message queue on exit. -c, --color color | Specify whether to use ANSI terminal colors in the log output. --log-format format | Specify the format to use for writing logs to the specified log output location. The log format can be text or json. --log-handle location | Specify where the logs are written. Valid location are stdout, stderr, file: filename, or es: [apikey]: URL. --enable-telemetry-logger | Enable the telemetry logger. --disable-telemetry-logger | Disable the telemetry logger. -c, --telemetry-color color | Specify whether to use ANSI terminal colors in the output. --telemetry-log-format format | Specify the format to use for writing telemetry logs to the specified log output location. The log format can be text or json. --telemetry-log-handle location | Specify where the logs are written. Valid location are stdout, stderr, file\\: filename, or es\\: [apikey]: URL. | --cluster-id label | Specify a label to add to all log messages from this node. --log-filter-rule KEY\\: VALUE\\: LOGLEVEL[\\: RATE] | Define a log filter rule. Log messages that match the filter rule are discarded if they don't meet the log level threshold you specify. --log-filter-default LOGLEVEL: RATE | Define a default log filter. This filter is applied to all messages that don't match any other log filter rule. --queue-size max | Set the maximum size of the internal logger queue.",
    "source": "reference/chainweb-cli.md",
    "title": "chainweb-node command-line"
  },
  {
    "content": "The `@kadena/kadena-cli` library provides commands for creating applications and interacting with the Kadena network interactively or by using scripts from the command-line. The commands in this section support creating and managing accounts. Use kadena account to add, manage, and fund onchain accounts with fungible tokens, for example, by transferring coin. Basic usage The basic syntax for the kadena account command is: Code example (bash): kadena account <action> [arguments] [flags] Actions Use the following actions to specify the operation you want to perform. Use this action | To do this add | Add an account from an existing key or from an existing wallet. delete | Delete one or more existing accounts. details | Get details for an account. fund | Fund an existing or new account. list | List available account information. name-to-address | Resolve a. kda name to a k: address (kadena names) address-to-name | Resolve a k: address to a. kda name (kadena names) Flags You can use the following optional flags with kadena account commands. | Use this flag | To do this | ------------- | ----------- | -h, --help | Display usage information. | -q, --quiet | Eliminate interactive prompts and confirmations to enable automation of tasks. | -V, --version | Display version information. | --json | Format command results sent to standard output (stdout) using JSON format. | --yaml | Format command results sent to standard output (stdout) using YAML format. kadena account add Use kadena account add to add a new local account manually from existing keys or from a wallet. The parameters required depend on the type of account you specify using the --from command-line option. Use --from key to add an account manually from existing local keys. Use --from wallet to add an account to an existing wallet. Basic usage The basic syntax for the kadena account add command is: Code example (bash): kadena account add --from key | wallet [arguments] [flags] Arguments for using a local key You can use the following command-line arguments with the kadena account add --from key command: | Use this argument | To do this | | ----------------- | ------------------------------------------ | | -f --from key | Specify the type of account to add. Use --from key to add an account manually from existing keys. | | -l, --account-alias aliasName | Specify an alias for the account. | -f, --fungible fungible | Specify the fungible module name. The default is coin. -p, --predicate predicate | Specify the predicate to use for the account. You can specify on the the keys-all, keys-any, or keys-2 built-in predicates or a custom predicate. -k, --public-keys publickey1, publickey2, . . . | Specify a comma-separated list of public keys. -v, --verify | Verify account details on the blockchain. -n, --network networkName | Specify the name of the network if you want to verify the account details on the blockchain. -c, --chain-id id | Specify the chain identifier if you want to verify the account details on the blockchain. -a, --account-name accountName | Provide an account name. If you want to verify the account details on the blockchain, you must provide the network name and chain identifier. Arguments for using a wallet You can use the following command-line arguments with the kadena account add --from wallet command: Use this argument | To do this| -f, --from wallet | Specify the type of account to add. Use --from wallet to add a wallet account. | -l, --account-alias aliasName | Specify an alias for the account. -a, --account-name accountName | Provide an account name. -f, --fungible fungible | Specify the fungible module name. The default is coin. -k, --public-keys publickey1, publickey2, . . . | Specify a comma-separated list of public keys. -p, --predicate predicate | Specify the predicate to use for the account. You can specify on the the keys-all, keys-any, or keys-2 built-in predicates or a custom predicate. -w, --wallet-name walletName | Provide the name of the wallet. | --password-file passwordFile | Specify the path to a file containing the password for the wallet. Alternatively, passwords can be passed via stdin. This option is only required only if you choose auto generate keys from the wallet. Examples To add account information interactively, run the following command: Code example (bash): kadena account add This command prompts you to select the method for providing the public keys for the new account. If you have a wallet, you can add a new account based on the public key and secret key pair generated for that wallet. If you have other public keys that you want to use, you can add an account by entering the keys manually. To add an account locally from an account that exists on the Kadena test network and chain identifier 1, run a command similar to the following: Code example (bash): kadena account add --from=key --account-alias=pistolas-testnet --account-name=k: bbccc99ec9eeed17d60159fbb88b09e30ec5e63226c34544e64e750ba424d35e --fungible=coin --verify --network=testnet --chain-id=1 This command verifies the account details on the Kadena test network and displays a confirmation message similar to the following: Code example (bash): The account configuration \"pistolas-testnet\" has been saved in. kadena/accounts/pistolas-testnet. yaml To add an account by providing public keys manually, you can run a command similar to the following: Code example (bash): kadena account add --from=\"key\" --account-alias=pistolas-publickey --account-name=k: 3e7e7db00e2e575a5260b8705ab7663574b186657451d6990316af6bc5108b59 --fungible=\"coin\" --public-keys=3e7e7db00e2e575a5260b8705ab7663574b186657451d6990316af6bc5108b59, 99d30af3fa91d78cc06cf53a0d4eb2d7fa2a5a72944cc5451311b455a67a3c1c --predicate=keys-any This command prompts you to specify whether you want to verify the account information before adding the account. For example: Code example (bash): ? Do you want to verify the account on chain? (Use arrow keys) ❯ Yes, verify the account on chain before adding No, add the account without verifying on chain To add an account from a wallet, you can run a command similar to the following: Code example (bash): kadena account add --from=\"wallet\" --wallet-name=\"walletname\" --account-alias=\"accountalias\" --fungible=\"coin\" --public-keys=\"7c8939951b61614c30f837d7b02fe4982565962b5665d0e0f836b79720747cb2\" --predicate=\"keys-all\" To add an account from a wallet and automatically generate new keys, you can run a command similar to the following: Code example (bash): kadena account add --from=\"wallet\" --wallet-name=\"wallet-name\" --account-alias=\"accountaliastesting\" --fungible=\"coin\" --public-keys=\"yourpublickey, generate\" --predicate=\"keys-all\" --password-file=\". /kadenawallet-pw. txt\" kadena account details Use kadena account details to retrieve information about a specified account. The account details include the account balance, the guard public keys and predicate, and the account name. To get this information, you must specify the Kadena network and chain identifier for the account. Basic usage The basic syntax for the kadena account details command is: Code example (bash): kadena account details [arguments] [flags] Arguments You can use the following command-line arguments with the kadena account details command: | Use this argument | To do this | -a, --account accountAlias | Specify the account alias or account name you want to retrieve details about. This argument is required. -n, --network networkName | Specify the name of the network where the account exists. This argument is required. -f, --fungible fungible | Specify the type of fungible asset, for example, coin or nft. This argument is required. -c, --chain-ids id | Specify the chain identifier or a range of chain identifiers. For example, you can specify a single chain identifier (1), a continuous range of chain identifiers (0-3), individual chain identifiers (0, 1, 5) or all chains (all). This argument is required. Examples To get account details for a specific account alias on the Kadena test network and chain 0 formatted as JSON output, you can run a command similar to the following: Code example (bash): kadena account details --json --account=pistolas-testnet --network=testnet --chain-ids=0 This command returns output similar to the following: Code example (bash): Details of account \"pistolas-testnet\" on network \"testnet04\" [ { \"0\": { \"guard\": { \"pred\": \"keys-all\", \"keys\": [ \"bbccc99ec9eeed17d60159fbb88b09e30ec5e63226c34544e64e750ba424d35e\" ] }, \"balance\": 2. 99334437103, \"account\": \"k: bbccc99ec9eeed17d60159fbb88b09e30ec5e63226c34544e64e750ba424d35e\" } } ] To get account details for a specific account name on the Kadena test network and chain 1, you can run a command similar to the following: Code example (bash): kadena account details --account=k: bbccc99ec9eeed17d60159fbb88b09e30ec5e63226c34544e64e750ba424d35e --network=testnet --chain-ids=1 This command prompts you to specify fungible type. For example: Code example (bash): ? Enter the name of a fungible: coin You can press Return to accept the default and display account details similar to the following: Code example (bash): Details of account \"k: bbccc99ec9eeed17d60159fbb88b09e30ec5e63226c34544e64e750ba424d35e\" on network \"testnet04\" Name ChainID Public Keys Predicate Balance k: bbccc99ec9ee. . . . 4e750ba424d35e 1 bbccc99ec9eeed17d60159fbb88b09e30ec5e63226c34544e64e750ba424d35e keys-all 305. 98040161094 Executed: kadena account details --account=\"k: bbccc99ec9eeed17d60159fbb88b09e30ec5e63226c34544e64e750ba424d35e\" --network=\"t. . . [code continues] You can specify a range of chain identifiers to query multiple chains at once. Use a comma to specify discrete chains or a hyphen to specify a continuous range of chain identifiers. For example, to get details for an account on the development network chains 1 and 5, you can run a command similar to the following: Code example (bash): kadena account details --account=pistolas-dev --network=devnet --chain-ids=1, 5 This command displays account details similar to the following: Code example (bash): Name ChainID Public Keys Predicate Balance k: 5ec41b89d323. . . . bc76dc5c35e2c0 1 5ec41b89d323398a609ffd54581f2bd6afc706858063e8f3e8bc76dc5c35e2c0 keys-all 24 k: 5ec41b89d323. . . . bc76dc5c35e2c0 5 5ec41b89d323398a609ffd54581f2bd6afc706858063e8f3e8bc76dc5c35e2c0 keys-all 24 To get account information for a continuous range of chain identifiers, you can run a command similar to the following: Code example (bash): kadena account details --account=pistolas-dev --network=devnet --chain-ids=2-4 This command displays account details similar to the following: Code example (bash): Details of account \"pistolas-dev\" on network \"development\" Name ChainID Public Keys Predicate Balance k: 5ec41b89d323. . . . bc76dc5c35e2c0 2 5ec41b89d323398a609ffd54581f2bd6afc706858063e8f3e8bc76dc5c35e2c0 keys-all 24 k: 5ec41b89d323. . . . bc76dc5c35e2c0 3 5ec41b89d323398a609ffd54581f2bd6afc706858063e8f3e8bc76dc5c35e2c0 keys-all 24 k: 5ec41b89d323. . . . bc76dc5c35e2c0 4 5ec41b89d323398a609ffd54581f. . . [code continues] To get account information for all chain identifiers, you can run a command similar to the following: Code example (bash): kadena account details --account=pistolas-dev --network=devnet --chain-ids=all kadena account fund Use kadena account fund to add funds to an account on the testnet or development networks. This command also creates the account, if it doesn't exist. Note that you can't use this command to fund an account on the Kadena main network. If a faucet contract isn't available on the development network for the specified chain identifier, you can use the --deploy-faucet option to fund accounts on the development network. Although you can run this command multiple times, there's a limit to the number of coins you can request. You can request up to 20 coins per network. If you select more than one chain in the request, the coins are distributed equally over the chain identifiers you specify. For example, if you request 20 coins for the development network and chains 0-3, each chain receives five coins. Code example (bash): kadena account fund [arguments] [flags] Arguments You can use the following command-line arguments with the kadena account fund command: Use this argument | To do this -a, --account accountAlias | Specify an alias to store your account information. This argument is required. -m, --amount amount | Specify the number of coins to transfer to fund the account. This argument is required. -n, --network networkName | Specify the name of the network where you want to fund an account. The valid values are devnet and testnet. This argument is required. -c, --chain-ids chainIds | Specify the chain identifiers where you want to fund the account. You can specify individual identifiers, ranges, or all for all chains. This argument is required. -d, --deploy-faucet | Deploy a coin faucet contract to fund the account on the local development network. Examples To fund an account on a single specific chain, you can run a command similar to the following: Code example (bash): kadena account fund --account=\"pistolas-testnet\" --amount=\"10\" --network=\"testnet\" --chain-ids=\"3\" If the account doesn't exist on the specified chain, the command displays information similar to the following: Code example (bash): Success with Warnings: Account \"k: bbccc99ec9eeed17d60159fbb88b09e30ec5e63226c34544e64e750ba424d35e\" does not exist on Chain ID(s) 3. So the account will be created on these Chain ID(s). Transaction explorer URL for Chain ID \"3\": https: //explorer. chainweb. com/testnet/tx/dk-speer0XDAFika0az2k8i4AzlrtjMPGHZ6gIlF0A ✔ Funding account successful. Account \"k: bbccc99ec9eeed17d60159fbb88b09e30ec5e63226c34544e64e750ba424d35e\" funded with 10 coin(s) on Chain ID(s) \"3\" in testnet04 network. Use \"kadena. . . [code continues] To fund an account on a local development network by deploying a faucet contract, you can run a command similar to the following: Code example (): kadena account fund --account=\"myalias\" --amount=\"20\" --network=\"devnet\" --chain-ids=\"17\" --deploy-faucet This command requires you to have the development network running on your local host or accessible from your local computer. For information about setting up a local development network, see Set up a local development network. You can specify a range of chain identifiers to fund an account across multiple chains. Use a comma to specify discrete chains or a hyphen to specify a continuous range of chain identifiers. For example, to fund an account on the development network chains 1 and 3, you can run a command similar to the following: Code example (bash): kadena account fund --account=\"myalias\" --amount=\"10\" --network=\"devnet\" --chain-ids=\"1, 3\" To fund an account across a continuous range of chain identifiers, you can run a command similar to the following: Code example (bash): kadena account fund --amount=\"20\" --account=\"chainweaver-0\" --network=\"devnet\" --chain-ids=\"3-6\" This command displays the request keys for the transaction on each chain, then confirmation similar to the following: Code example (bash): Transaction explorer URL for Chain ID \"3\": http: //localhost: 8080/explorer/development/tx/KCnnIKZG3hiurKUVJUMK17ED55G7pj6xy8Ng4Sfj154 Chain ID \"4\": http: //localhost: 8080/explorer/development/tx/Zu3xmLGRQ6lYN1jBUKpVRDZB3tRwy-PConW5Sb8YD0 Chain ID \"5\": http: //localhost: 8080/explorer/development/tx/phM7ODgdNpdLyUD64xhaStWmA3ywk-1sjVFUM8tiDsQ Chain ID \"6\": http: //localhost: 8080/explorer/development/tx/GpibIRZ1DNBiSuxxWszUMsHmZQoiy6uDsE3zVmq3To ✔ Funding account successful. Account \"k: 5ec41b89. . . [code continues] To fund an account across all chains on the testnet, you can run a command similar to the following Code example (bash): kadena account fund --amount=2 --account=pistolas-dev --network=devnet --chain-ids=all If you try to fund an account too soon after a previous fund request, the command will fail with an error similar to the following: Code example (bash): Error on Chain ID 3 - Failed to transfer fund: \"Coin can be requested every 30 minutes\" kadena account name-to-address Use kadena account name-to-address to resolve a. kda name to a k: account name By convention, accounts with the k: prefix are Kadena account principals with a single public key and the keys-all predicate. Code example (bash): kadena account name-to-address [arguments] [flags] Arguments You can use the following command-line arguments with the kadena account name-to-address command: Use this argument | To do this -n, --network networkName | Specify the name of the network where the account exists. -a, --account-kdn-name kdaAccountName | Specify the. kda name to resolve to a k: account. Examples To map the specified. kda name to an account that uses the k: prefix followed by a public key, you can run a command similar to the following: Code example (bash): kadena account name-to-address --network=\"mainnet\" --account-kdn-name=\"kadena. kda\" kadena account address-to-name Use kadena account address-to-name to resolve an account name with the k: prefix to a. kda name. Code example (bash): kadena account address-to-name [arguments] [flags] Arguments You can use the following command-line arguments with the kadena account address-to-name command: | Use this argument | To do this | | --------------------- | ----------------------------------------- | | -n, --network networkName | Specify the name of the network where the account exists. | | -a, --account-kdn-address accountName | Specify the k: account name to resolve to a. kda name | Examples To map the specified k: account name to a. kda address, you can run a command similar to the following: Code example (bash): kadena account address-to-name --network=\"mainnet\" --account-kdn-address=\"k: 1d5a5e10eb15355422ad66b6c12167bdbb23b1e1ef674ea032175d220b242ed4\" kadena account list Use kadena account list to list information for a specific account or for all available accounts. Code example (bash): kadena account list [arguments] [flags] Arguments You can use the following command-line arguments with the kadena account list command: Use this argument | To do this -a, --account-alias accountAlias | Specify the alias for the account to list. Examples To list information for a specific account, you can run a command similar to the following: Code example (bash): kadena account list --account-alias=pistolas-dev This command displays information similar to the following for the specified account: Code example (bash): Alias Name Public Key(s) Predicate Fungible pistolas-dev k: 5ec41b89d323. . . . bc76dc5c35e2c0 5ec41b89d3. . . . dc5c35e2c0 keys-all coin To list information for all account, you can run a command similar to the following: Code example (bash): kadena account list --account-alias=\"all\" This command displays information similar to the following for all available account: Code example (bash): Alias Name Public Key(s) Predicate Fungible chainweaver-0 chainweaver-0 0f4d6ddea3. . . . 357ef6da9f keys-all coin pistolas-dev k: 5ec41b89d323. . . . bc76dc5c35e2c0 5ec41b89d3. . . . dc5c35e2c0 keys-all coin pistolas-kda k: 61cf22aa8f20. . . . 7743bf6c355546 61cf22aa8f. . . . bf6c355546 keys-all coin pistolas-local k: ad833b6bbfc7. . . . 28f3249fd5e105 ad833b6bbf. . . . 249fd5e105 keys-all coin pistolas-publickey k. . . [code continues] kadena account delete Use kadena account delete to delete a local account. Code example (bash): kadena account delete [arguments] [flags] Arguments You can use the following command-line arguments with the kadena account delete command: Use this argument | To do this -a, --account-alias accountAlias_ | Specify the alias of the account you want to delete. -c, --confirm | Confirm that you want to delete the specified account. Examples To delete an account interactively, run the following command: Code example (bash): kadena account delete This command prompts you to select the account alias that you want to delete, then confirm your selection. To delete a specific account, you can run a command similar to the following: Code example (bash): kadena account delete --account-alias test-wallet --confirm This command displays confirmation similar to the following: Code example (bash): The selected account alias \"test-wallet\" has been deleted To delete all accounts, you can run the following command: Code example (bash): kadena account delete --account-alias=\"all\" --confirm",
    "source": "reference/cli/cli-account.md",
    "title": "kadena account"
  },
  {
    "content": "The `@kadena/kadena-cli` library provides commands for creating applications and interacting with the Kadena network interactively or by using scripts from the command-line. The commands in this section support creating and viewing an initial configuration folder and default settings for the development environment. Use kadena config to set up and manage configuration settings for the Kadena CLI environment. To get started with the CLI, use kadena config init to create a. kadena configuration folder. The configuration folder stores information about your development environment, including: - Default network settings for the Kadena development, test, and main networks. - Transaction templates for constructing transactions locally and sending transactions to the blockchain. - Local keys, wallets, and accounts that you create for the development environment. - Keys, wallets, and accounts you import from existing chains. Basic usage The basic syntax for the kadena config command is: Code example (bash): kadena config <action> [arguments] [flags] Actions Use the following actions to specify the operation you want to perform. | Use this action | To do this init | Initialize the kadena configuration folder with configuration settings for the Kadena CLI to use. path | Display the path to the configuration folder currently in use. Flags You can use the following optional flags with kadena config commands. | Use this flag | To do this | ------------- | ----------- | -h, --help | Display usage information. | -q, --quiet | Eliminate interactive prompts and confirmations to enable automation of tasks. | -V, --version | Display version information. | --json | Format command results sent to standard output (stdout) using JSON format. | --yaml | Format command results sent to standard output (stdout) using YAML format. kadena config init Use kadena config init to create a configuration folder in the directory of your choice. The command automatically initializes the configuration folder with default network settings for the Kadena development, test, and main networks and adds transaction templates to your development environment. You can also use this command to create your first wallet and account, so you can sign transactions locally for development and testing. By default, the initial configuration settings are written to a. kadena folder in your current working directory and the settings can be used from anywhere within that directory. For example, if you run kadena config init in the /home/user/projects/my-kadena-project folder, the configuration settings are available from anywhere inside that project directory. By using a working directory for the configuration folder, you can use different configuration settings in different folders. Alternatively, you can run kadena config init with the --global command-line option to add the configuration folder as a global directory inside of your home directory. This option enables you to use the same configuration settings from any folder on your computer. Configuration settings that are defined in a local working directory take precedence over configuration settings defined in the home directory. If you add more than one configuration folder to your development environment, you can use the kadena config show command to see details about the development environment you have configured in your working or global directory. Basic usage The basic syntax for the kadena config command is: Code example (bash): kadena config init [arguments] [flags] Arguments You can use the following command-line arguments with the kadena config init command: Use this argument | To do this -g, --global | Initialize the configuration folder in the current user's home directory, so that it's available globally. For example, this option creates the ~/. config/kadena directory. -c, --create&#8209; wallet | Create a new wallet. Set to true to generate keys and create a new wallet. &#8209; w, &#8209; &#8209; wallet&#8209; name walletName | Specify a name for the new wallet. &#8209; &#8209; password&#8209; file passwordFile | Specify the path to a file containing the password for the wallet being created. Alternatively, you can specify the password from standard input (stdin). -L, --legacy | Use the ChainWeaver ED25519 signature scheme to generate keys when creating a wallet. -a, --create&#8209; account | Create an account using the first wallet key. Set to true to use the first wallet key to create a new local account. -l, --account&#8209; alias aliasName | Create an account alias to store your account details, if creating an account. Examples To create the Kadena CLI configuration folder and initial settings interactively, run the following command: Code example (bash): kadena config init This command creates the. kadena configuration folder in your current working directory and prompts you to create a new wallet. To make the Kadena CLI configuration folder and initial settings available globally from your home directory, run the following command: Code example (bash): kadena config init --global This command creates a global kadena folder in your home directory—for example, as ~/. config/kadena—so you can use the configuration settings from any folder. The command then prompts you to create a new wallet. To create the Kadena CLI configuration folder with a new wallet and account in the current working directory, run a command similar to the following: Code example (bash): kadena config init --create-wallet=\"true\" --wallet-name=\"myfirstwallet\" --create-account=\"true\" --account-alias=\"dev_account\" To create the Kadena CLI configuration folder without creating a new wallet or account, run the following command: Code example (bash): kadena config init --create-wallet=\"false\" kadena config show Use kadena config show to display the location of the configuration folder currently being used and details about the development environment you have configured in your working or global directory. If you add more than one configuration folder to your development environment, you can use the kadena config show command to see the location of the configuration folder that's used for your current directory. To display the location of the configuration folder currently being used, run the following command: Code example (bash): kadena config show The command displays the path to the Kadena CLI configuration folder and additional details about your development environment. For example: Code example (bash): Currently using the following config: Config path /Users/pistolas/. kadena Wallet path /Users/pistolas/. kadena/wallets Number of wallets 3 Default template path /Users/pistolas/. kadena/transaction-templates Number of templates 6 Network path /Users/pistolas/. kadena/networks Number of networks 3. . . [code continues]",
    "source": "reference/cli/cli-config.md",
    "title": "kadena config"
  },
  {
    "content": "The `@kadena/kadena-cli` library provides commands for creating applications and interacting with the Kadena network interactively or by using scripts from the command-line. The commands in this section support creating a frontend application using popular frontend frameworks. Use kadena dapp to create new frontend applications. Basic usage The basic syntax for the kadena dapp command is: Code example (bash): kadena dapp <action> [arguments] [flags] Actions Use this action | To do this add | Create a new application project from a frontend framework template. Flags You can use the following optional flags with kadena dapp commands. | Use this flag | To do this | ------------- | ----------- | -h, --help | Display usage information. | -q, --quiet | Eliminate interactive prompts and confirmations to enable automation of tasks. | -V, --version | Display version information. | --json | Format command results sent to standard output (stdout) using JSON format. | --yaml | Format command results sent to standard output (stdout) using YAML format. kadena dapp add Use kadena dapp add to create a new frontend application directory from a frontend framework template. This command enables you to start a new project from the following commonly-used frontend frameworks: - Angular - Nextjs - Vuejs Basic usage The basic syntax for the kadena dapp add command is: Code example (bash): kadena dapp add [arguments] [flags] Arguments You can use the following command-line arguments with the kadena dapp add command: Use this argument | To do this| project-directory | Specify the name of application project directory. | -t, --dapp-template | Specify the type of project to create by selecting a frontend framework template. The valid templates are vuejs, nextjs, and angular. | Examples To create a new project called my-to-do using the Angular template, you can run a command similar to the following: Code example (bash): kadena dapp add --dapp-template=\"angular\" my-to-do This command prompts you to install missing required dependencies, if needed. After you install any missing dependencies, you can change to the new project directory to see the template files and folders for an Angular project plus a pact folder with some starter code for a Pact module (message-store. pact) and for testing the Pact module in the Pact REPL (message-store. repl). For example Code example (bash): ls -al my-to-do drwxr-xr-x 15 pistolas staff 480 May 16 12: 50. drwxr-xr-x 27 pistolas staff 864 May 16 12: 49. . -rw-r--r-- 1 pistolas staff 82 May 16 12: 49. prettierignore -rw-r--r-- 1 pistolas staff 315 May 16 12: 49. prettierrc. json drwxr-xr-x 5 pistolas staff 160 May 16 12: 49. vscode -rw-r--r-- 1 pistolas staff 467 May 16 12: 49 README. md -rw-r--r-- 1 pistolas staff 2495 May 16 12: 49 angular. json drwxr-xr-x 688 pistolas staff 22016. . . [code continues]",
    "source": "reference/cli/cli-dapp.md",
    "title": "kadena dapp"
  },
  {
    "content": "The `@kadena/kadena-cli` library provides commands for creating applications and interacting with the Kadena network interactively or by using scripts from the command-line. The commands in this section support creating and managing key pairs. Use kadena key to generate and manage public and secret keys. Basic usage The basic syntax for the kadena key command is: Code example (bash): kadena key <action> [arguments] [flags] Actions Use the following actions to specify the operation you want to perform. Use this action | To do this generate | Generate random public and secret key pairs. list | List available keys. Flags You can use the following optional flags with the kadena key command. | Use this flag | To do this | ------------- | ----------- | -h, --help | Display usage information. | -q, --quiet | Eliminate interactive prompts and confirmations to enable automation of tasks. | -V, --version | Display version information. | --json | Format command results sent to standard output (stdout) using JSON format. | --yaml | Format command results sent to standard output (stdout) using YAML format. kadena key generate Use kadena key generate to generate a random public and secret key. Basic usage The basic syntax for the kadena key generate command is: Code example (bash): kadena key generate [arguments] [flags] Arguments You can use the following command-line arguments with the kadena key generate command: Use this argument | To do this -a, --key-alias keyAlias | Set an alias for the key to store on the local filesystem. -n, --key-amount keyAmount | Specify the number of key pairs to generate. The default is one key pair. -l, --legacy | Generate keys using ChainWeaver key derivation methods (ED25519 signature scheme). Examples To generate one random public and secret key pair interactively, run the following command: Code example (bash): kadena key generate This command prompts you to enter the alias you want to use for the key and the number of keys to generate. For example: Code example (bash): ? Enter an alias for your key: bob-dev? Enter the amount of keys you want to generate (alias-{amount} will increment) (default: 1): 1 After you respond to the prompts, the command displays confirmation that the keys were generated and where the key is stored on the local filesystem. For example: Code example (bash): Generated Plain Key Pair(s): Public key 277ca529e0871cc277c84728ce3486947768cc8ff2c2894801f4d13a4b1fe4b7 The Key Pair is stored in your working directory with the filename(s): bob-dev. yaml Executed: kadena key generate --key-alias=\"bob-dev\" --key-amount=\"1\" To generate three random public and secret key pairs that are compatible with Chainweaver, run a command similar to the following: Code example (bash): kadena key generate --key-alias=\"chainweaver-keys\" --key-amount=\"3\" --legacy The confirmation message displays the public keys and the files created on the local filesystem for the keys. For example: Code example (bash): Generated Legacy Plain Key Pair(s): Public key 0f4d6ddea36e22a9eb7e7f16bdff359d2027b3be08ccd206f27eba357ef6da9f e5b451fbe95c9f9220be8f4d6909eb508c98da35a5ac7f99bd4630e3a30880d5 8d8748e61291f5cc9d86b4f30929383aeeb940cc692826a3349fb0367f795d44 The Key Pair is stored in your working directory with the filename(s): chainweaver-keys-0. yaml chainweaver-keys-1. yaml chainweaver-keys-2. yaml kadena key list Use kadena key list to list available keys. Basic usage The basic syntax for the kadena key list command is: Code example (bash): kadena key list [arguments] [flags] Arguments You can use the following command-line arguments with the kadena key list command: Use this argument | To do this -d, --directory directory | Specify the path to the configuration folder on the local filesystem. The default is the current working directory. Examples To list all keys in the current working directory, run the following command: Code example (bash): kadena key list The command displays output similar to the following: Code example (bash): Listing keys in the working directory: Filename Public Key Legacy bob-dev. yaml 277ca529e0871cc277c84728ce3486947768cc8ff2c2894801f4d13a4b1fe4b7 No chainweaver-keys-0. yaml 0f4d6ddea36e22a9eb7e7f16bdff359d2027b3be08ccd206f27eba357ef6da9f Yes chainweaver-keys-1. yaml e5b451fbe95c9f9220be8f4d6909eb508c98da35a5ac7f99bd4630e3a30880d5 Yes chainweaver-keys-2. yaml 8d8748e61291f5cc9d86b4f30929383aeeb940cc692826a3349fb. . . [code continues] To list keys in a directory other than your current working directory and format the output as JSON, run a command similar to the following: Code example (bash): kadena key list --directory ~/My-Kadena --json The command returns the output using JSON format. For example: Code example (bash): [ { \"alias\": \"bob-dev. yaml\", \"filepath\": \"MY-KADENA/bob-dev. yaml\", \"legacy\": false, \"publicKey\": \"277ca529e0871cc277c84728ce3486947768cc8ff2c2894801f4d13a4b1fe4b7\", \"secretKey\": \"017a1af4a13cfbe28878f7b6097d30ba36d1c5609d41798a309a6beac6faef13\" }, { \"alias\": \"chainweaver-keys-0. yaml\", \"filepath\": \"MY-KADENA/chainweaver-keys-0. yaml\", \"legacy\": true, \"publicKey\": \"0f4d6ddea36e22a9eb7e7f16bdff359d2027b3be08ccd206f27eba357ef6da9f\", \"secretKey\": \"L0R4RzFq. . . [code continues]",
    "source": "reference/cli/cli-key.md",
    "title": "kadena key"
  },
  {
    "content": "The `@kadena/kadena-cli` library provides commands for creating applications and interacting with the Kadena network interactively or by using scripts from the command-line. The commands in this section support creating and managing network configuration settings. Use kadena network to set up and manage network settings for your development environment. The kadena config init command creates default network settings for the Kadena development, test, and main networks. You can use the kadena network subcommands to view and modify the network settings to suit your needs. Basic usage The basic syntax for the kadena network command is: Code example (bash): kadena network <action> [arguments] [flags] Actions Use the following actions to specify the operation you want to perform. Use this action | To do this add | Add a new network. set-default | Set a network to be the default choice in selection prompts. list | List all available networks. update | Update properties for an existing network. delete | Delete an existing network. Flags You can use the following optional flags with kadena network commands. | Use this flag | To do this | ------------- | ----------- | -h, --help | Display usage information. | -q, --quiet | Eliminate interactive prompts and confirmations to enable automation of tasks. | -V, --version | Display version information. | --json | Format command results sent to standard output (stdout) using JSON format. | --yaml | Format command results sent to standard output (stdout) using YAML format. kadena network add Use kadena network add to add a new set of network settings to your development environment. Basic usage The basic syntax for the kadena network add command is: Code example (bash): kadena network add [arguments] [flags] Arguments You can use the following command-line arguments with the kadena network add command: Use this argument | To do this -a, --network-name networkName | Set the name of the network. The valid values are devnet, testnet, and mainnet. -i, --network-id networkId | Set the identifier for the network. The network identifier is a similar to the network name but uniquely identifies the network. For example, valid values include development, testnet04, and mainnet01. -s, --network-host networkHost | Set the host for the network. -e, --network-explorer-url networkExplorerUrl | Set the block explorer URL for the network. -o, --network-overwrite | Confirm that you want to overwrite existing network configuration settings. Examples To add network information interactively, run the following command: Code example (bash): kadena network add To add network settings for the Kadena test network, run a command similar to the following: Code example (bash): kadena network add --network-name=\"testnet\" --network-id=\"testnet08\" --network-host=\"https: //api. testnet. chainweb. com\" --network-explorer-url=\"https: //explorer. chainweb. com/testnet/tx/ --network-overwrite=\"yes\" kadena network set-default Use kadena network set-default to specify the network to use as your default network in your development environment. You can specify the network as none to remove a previously-set default network. Basic usage The basic syntax for the kadena network set-default command is: Code example (bash): kadena network set-default [arguments] [flags] Arguments You can use the following command-line arguments with the kadena network set-default command: | Use this argument | To do this | | ----------------- | --------------------------------------------- | -n, --network networkName | Specify the name of network you want to set as the default. The valid values are devnet, testnet, and mainnet. --confirm | Confirm the change you are making to set or remove the default network. Examples To add network information interactively, run the following command: Code example (bash): kadena network set-default To set testnet as the default network for your development environment, run the following command: Code example (bash): kadena network set-default --network=\"testnet\" --confirm To remove the default network setting, run the following command: Code example (bash): kadena network set-default --network=\"none\" --confirm kadena network update Use kadena network update to update properties for an existing network. Basic usage The basic syntax for the kadena network update command is: Code example (bash): kadena network update [arguments] [flags] Arguments You can use the following command-line arguments with the kadena network update command: | Use this argument | To do this -n, --network networkName | Specify the network you want to update. The valid values are devnet, testnet, and mainnet. -a, --network-name networkName | Update the name of the specified network. -i, --network-id networkId | Update the identifier for the network. The network identifier is a similar to the network name but uniquely identifies the network. For example, valid values include development, testnet04, and mainnet01. -s, --network-host networkHost | Update the host for the specified network. -e, --network-explorer-url networkExplorerUrl | Update the block explorer URL for the specified network Examples To update network information interactively, run the following command: Code example (bash): kadena network update To update the network name and identifier for the development network, run a command similar to the following: Code example (bash): kadena network update --network=\"devnet\" --network-id=\"devnet03\" --network-name=\"my-devnet\" To update network settings for the Kadena main network, run a command similar to the following: Code example (bash): kadena network update --network=\"mainnet\" --network-id=\"mainnet01\" --network-host=\"https: //api. chainweb. com\" --network-explorer-url=\"https: //explorer. chainweb. com/mainnet/tx/ kadena network list Use kadena network list to list all available networks. Basic usage The basic syntax for the kadena network list command is: Code example (bash): kadena network list [flags] Examples To display information about all available networks, run the following command: Code example (bash): kadena network list The command displays network information similar to the following: Code example (bash): Network Network ID Network Host Network Explorer URL Default Network devnet development http: //localhost: 8080 http: //localhost: 8080/explorer/development/tx/ No mainnet mainnet01 https: //api. chainweb. com https: //explorer. chainweb. com/mainnet/tx/ No testnet testnet04 https: //api. testnet. chainweb. com https: //explorer. chainweb. com/testnet/tx/ No To display the output for this command using YAML format, you can run the following command: Code example (bash): kadena network list --yaml The command displays network information in YAML format similar to the following: Code example (bash): networks: - network: devnet networkId: development networkHost: http: //localhost: 8080 networkExplorerUrl: http: //localhost: 8080/explorer/development/tx/ - network: mainnet networkId: mainnet01 networkHost: https: //api. chainweb. com networkExplorerUrl: https: //explorer. chainweb. com/mainnet/tx/ - network: testnet networkId: testnet04 networkHost: https: //api. testnet. chainweb. com networkExplorerUrl: https: //explorer. chainweb. com/testnet/tx/ kadena network delete Use kadena network delete to remove a network and its configuration settings from your development environment. Basic usage The basic syntax for the kadena network delete command is: Code example (bash): kadena network delete [arguments] [flags] Arguments You can use the following command-line arguments with the kadena network delete command: | Use this argument | To do this | | ---------------- | -------------------------------- | | -n, --network networkName | Specify the name of the network you want to delete. The valid values are devnet, testnet, and mainnet. | | -d, --network-delete | Confirm that you want to delete the network. | Examples To delete network information interactively, run the following command: Code example (bash): kadena network delete To delete the mainnet network information from your development environment, run the following command: Code example (bash): kadena network delete --network=\"mainnet\" --network-delete=\"yes\"",
    "source": "reference/cli/cli-network.md",
    "title": "kadena network"
  },
  {
    "content": "The `@kadena/kadena-cli` library provides commands for creating applications and interacting with the Kadena network interactively or by using scripts from the command-line. The commands in this section support creating and managing transactions. Use kadena tx and transaction templates to create, sign, test, send, and manage transactions. Basic usage The basic syntax for the kadena tx command is: Code example (bash): kadena tx <action> [arguments] [flags] Actions Use the following actions to specify the operation you want to perform. Use this action | To do this add | Select a template and add a transaction. sign | Sign a transaction using your wallet or using a key pair. test | Test a signed transaction using a local endpoint without submitting it to the blockchain. send | Send a signed transaction to the network. status | Get the status of a transaction. list | List transactions. local | Submit Pact code as a local call. | history | Display a formatted list of transactions with their details. Flags You can use the following optional flags with kadena tx commands. | Use this flag | To do this | ------------- | ----------- | -h, --help | Display usage information. | -q, --quiet | Eliminate interactive prompts and confirmations to enable automation of tasks. | -V, --version | Display version information. | --json | Format command results sent to standard output (stdout) using JSON format. | --yaml | Format command results sent to standard output (stdout) using YAML format. kadena tx add Use kadena tx add to create transactions from transaction templates. Transaction templates enable you to provide and customize input to generate transactions for multiple networks and across chains using common patterns. After you provide values for template variables, you can generate and save transaction as API request files that are ready for you to sign, test, and submit for execution. Basic usage The basic syntax for the kadena tx add command is: Code example (bash): kadena tx add [arguments] [flags] Arguments You can use the following command-line arguments with the kadena tx add command: | Use this argument | To do this | -t, --template templateName | Specify the path to the transaction template file you want to use. Template files are located in the transaction-templates directory and have the. ktpl file extension. This argument is required. -d, --template-data templateData | Specify the path to a file with the values that you want to use for template variables. This argument is optional. -o, --out-file generatedOutput | Specify the path for the generated transaction file. -l, --holes | Display a list of the template variables that are required for the specified transaction template. Templates The Kadena CLI automatically creates and stores default templates in the configuration folder on your local computer. By default, the templates are located in the. kadena/transaction-templates folder in your working directory. The default templates in the. kadena/transaction-templates folder cover the most common types of transactions: - The transfer. ktpl template simplifies the process of transferring tokens between accounts. - The safe-transfer. ktpl template simplifies safe transfer operations that validatethe sender and receiver account information to prevent common mistakes like sending to an incorrect address. These templates make it easier to construct and execute common operations without writing custom code. You can also add your own templates to the transaction-templates folder to make them available for generating transactions using the kadena tx add command. Examples The kadena tx add command enables you to create transactions using templates in combination with the input values you specify. The default templates—transfer and safe-transfer—to enable to you create transactions that transfer tokens between accounts. After you use kadena tx add to generate the transaction request and save it in a file, you can use other commands to sign and submit the request with minimal effort. To generate a transaction from a template interactively, you can run the following command: Code example (bash): kadena tx add This command then prompts you to select the template to use and to provide information about the account to transfer from and the account to transfer to. For example: Code example (bash): ? Which template do you want to use: transfer. ktpl? File path of data to use for template. json or. yaml (optional): ? Template value from-acct: k: bbccc99ec9eeed17d60159fbb88b09e30ec5e63226c34544e64e750ba424d35e? Template value to-acct: k: 5ec41b89d323398a609ffd54581f2bd6afc706858063e8f3e8bc76dc5c35e2c0? Template value amount: 2. 0? Template value chain: 1? Template value network: testnet04? Template value from-key: bbccc99ec9eeed17d60159fbb88b09e30ec5e63226c34544e64e750ba424d35e? Where do. . . [code continues] Be sure to use the account name—for example, the principal account name with the k: prefix—for transferring funds between account and not the account alias. WHen specifying the network, you must use the network identifier—for example, development, testnet04, or mainnet01—rather than the network name. After you respond to the prompts, the command displays the transaction you constructed and confirms the location of the file containing the unsigned transaction. For example: Code example (bash): { \"cmd\": \"{\\\"payload\\\": {\\\"exec\\\": {\\\"code\\\": \\\"(coin. transfer \\\\\\\"k: bbccc99ec9eeed17d60159fbb88b09e30ec5e63226c34544e64e750ba424d35e\\\\\\\" \\\\\\\"k: 5ec41b89d323398a609ffd54581f2bd6afc706858063e8f3e8bc76dc5c35e2c0\\\\\\\" 2. 0)\\\", \\\"data\\\": {}}}, \\\"nonce\\\": \\\"\\\", \\\"networkId\\\": \\\"testnet04\\\", \\\"meta\\\": {\\\"sender\\\": \\\"k: bbccc99ec9eeed17d60159fbb88b09e30ec5e63226c34544e64e750ba424d35e\\\", \\\"chainId\\\": \\\"1\\\", \\\"creationTime\\\": 1716319427, \\\"gasLimit\\\": 2300, \\\"gasPrice\\\": 0. 000001, \\\"ttl\\\": 600}, \\\"signers\\\": [{\\\"pubKey\\\": \\\"bbccc9. . . [code continues] kadena tx sign Use kadena tx sign to sign a transaction you've previously created. You can sign the transaction using your wallet key or by manually entering one or more public and secret key pairs. Basic usage The basic syntax for the kadena tx sign command is: Code example (bash): kadena tx sign [arguments] [flags] Arguments You can use the following command-line arguments with the kadena tx sign command: Use this argument | To do this -s, --tx-sign-with signingMethod | Specify the signing method. The valid values are wallet or keyPair. -w, --wallet-name walletName | Specify the name of the wallet if you are signing with a wallet. --password-file passwordFile | Specify the path to a file that stores the password for your wallet. If you don't have the password stored in a text file, you can enter it as standard input. -k, --key-pairs keyPairs | Specify each public and secret key pair as comma-separated strings. For example, specify the key pair using the following format publicKey=xxx, secretKey=xxx. If specifying more than one key pair, use a semi-colon (; ) between key pairs. -u, --tx-unsigned-transaction-files unsignedTransactionFiles | Specify one or more the unsigned transaction file to sign. If specifying more than one file, use a comma-separated list. | -d, --directory configDirectory | Specify the path to the configuration folder. The default is the current working directory. | -l, --legacy | Sign using the ED25519 signature scheme for compatibility with Chainweaver. | Examples To sign a transaction interactively, run the following command: Code example (bash): kadena tx sign This command prompts you to select a signing method, the transaction to sign, and keys to use. For example: Code example (bash): ? Select an action: Sign with wallet? Select a transaction file: Transaction: tx-wip. json? 1 wallets found containing the keys for signing this transaction, please select a wallet to sign this transaction with first: Wallet: cw-desktop? Enter the wallet password: ******* After you enter the password, the transaction is signed and saved to a file. For example, you should see output similar to the following: Code example (bash): Command 1 (hash: fnfc-hZ9Lz0xzydBkURoL-Muxg0X80MIVKojIoJy9fQ) will now be signed with the following signers: Public Key Capabilities bbccc99ec9ee. . . . 750ba424d35e coin. TRANSFER(k: bbccc99ec9ee. . . . 750ba424d35e, k: 5ec41b89d323. . . . bc76dc5c35e2c0, 2) coin. GAS() Transaction executed cod. . . [code continues] To sign a transaction with a public and secret key pair, you can run a command similar to the following: Code example (bash): kadena tx sign --tx-sign-with=\"keyPair\" --wallet-name=\"testwallet\" --tx-unsigned-transaction-files=\"transaction-(request-key)-signed. json\" kadena tx test Use kadena tx test to test the execution of a signed transaction against a specified network by making a Local call. By executing the transaction using the /local API endpoints, you can verify Pact smart contracts with actual data in the coin contract tables. You can use this command to check account information and to determine whether transactions will be executed successfully and without incurring transaction fees. Basic usage The basic syntax for the kadena tx test command is: Code example (bash): kadena tx test [arguments] [flags] Arguments You can use the following command-line arguments with the kadena tx test command: Use this argument | To do this -d, --directory configDirectory | Specify the path to the configuration folder. The default is the current working directory. -s, --tx-signed-transaction-files signedTxFiles | Specify one or more signed transaction files to sign in a comma-separated list. -n, --tx-transaction-network network | Specify a comma-separated list of networks to be used for executing the transaction in order of transaction. For example, to test executing a transaction on the Kadena development, test, and main networks in that order, you can set this argument to devnet, testnet, mainnet. Examples To sign a transaction interactively, run the following command: Code example (bash): kadena tx test This command prompts you to select a signed transaction file, then displays the execution results with output similar to the following: Code example (bash): -------------------------------------------------------------------------------- txSignedTransaction test result: -------------------------------------------------------------------------------- Transaction info: fileName: transaction-fnfc-hZ9Lz-signed. json transactionHash: fnfc-hZ9Lz0xzydBkURoL-Muxg0X80MIVKojIoJy9fQ Response: Response: gas: 509 result: status: success data: Write succeeded. . . [code continues] kadena tx send Use kadena tx send to send a signed transaction to the specified network. Basic usage The basic syntax for the kadena tx send command is: Code example (bash): kadena tx send [arguments] [flags] Arguments You can use the following command-line arguments with the kadena tx send command: Use this argument | To do this -d, --directory configDirectory | Specify the path to the configuration folder. The default is the current working directory. -s, --tx-signed-transaction-files signedTxFiles | Specify one or more signed transaction files to sign in a comma-separated list. --tx-transaction-network network | Specify a comma-separated list of networks to be used for executing the transaction in order of execution. For example, to execute a transaction on the Kadena development, test, and main networks in that order, you can set this argument to devnet, testnet, mainnet. --poll | Poll the blockchain repeatedly for the current status of a sent transaction. Examples To send a transaction interactively, run the following command: Code example (bash): kadena tx send This command prompts you to select a signed transaction file, then displays the execution results with output similar to the following: Code example (bash): kadena tx send? Select a transaction file: Transaction: transaction-fnfc-hZ9Lz-signed. json ⠋ Sending transactions. . . Transaction detail for command with hash: fnfc-hZ9Lz0xzydBkURoL-Muxg0X80MIVKojIoJy9fQ Network ID Chain ID testnet04 1 ✔ Completed Transaction: fnfc-hZ9Lz0xzydBkURoL-Muxg0X80MIVKojIoJy9fQ submitted with request key: fnfc-hZ9Lz0xzydBkURoL-Muxg0X80MIVKojIoJy9fQ Executed: kadena tx send --tx-signed-transaction-files=\"transaction-fnfc-hZ9Lz-signed. json\" --tx-transaction-ne. . . [code continues] To poll the blockchain for the transaction results until the transaction is executed, you can run a command similar to the following: Code example (bash): kadena tx send --tx-signed-transaction-files=\"transaction-JRk5jPdjTW-signed. json\" --poll kadena tx status Use kadena tx status to retrieve the status of a transaction on the Kadena blockchain. By providing a transaction request key and specifying the network and chain id, you can query the current state of your transactions. This command supports additional options for polling, allowing for real-time status updates until the transaction is finalized. Basic usage The basic syntax for the kadena tx status command is: Code example (bash): kadena tx status [arguments] [flags] Arguments You can use the following command-line arguments with the kadena tx status command: Use this argument | To do this -k, --request-key requestKey | Specify the request key for the transaction you submitted. -n, --network network | Specify the Kadena network that you sent the transaction to. For example, you can set this argument to devnet, testnet, or mainnet. -c, --chain-id chainId | Specify the Kadena chain identifier that you sent the transaction to. --poll | Poll the blockchain repeatedly for the current status of a sent transaction. Examples To check the status of a transaction interactively, you can run a command similar to the following: Code example (bash): kadena tx status This command prompts you to specify the request key, network, and chain identifier and returns the current status of the transaction identified by the provided request key. If the transaction hasn't been completed, you can use the --poll option to continuously monitor the status of the transaction until it Polling checks the transaction status every 60 seconds until the transaction is confirmed. To poll the blockchain for transaction results using a request key, you can run a command similar to the following: Code example (bash): kadena tx status --request-key=JRk5jPdjTWseiE1MeQXq4FT2drpKsVJz4UBen6DT3ro --chain-id=1 --network=testnet --poll If the specified transaction has been executed, you should see output similar to the following: Code example (bash): ✔ Completed Transaction Status: success Chain ID 1 Transaction Status success Transaction ID 6023995 Gas 736 Block Height 4311429 Event: coin. TRANSFER k: 5ec. . . [code continues] kadena tx list Use kadena tx list to list the transactions you've created from transaction templates. The output from the command indicates whether the transaction has been signed. Basic usage The basic syntax for the kadena tx list command is: Code example (bash): kadena tx list [arguments] [flags] Arguments You can use the following command-line arguments with the kadena tx list command: Use this argument | To do this -d, --directory configDirectory | Specify the path to the configuration folder. The default is the current working directory. Examples To list the transactions in your current working directory, you can run the following command: Code example (bash): kadena tx list This command displays output similar to the following: Code example (bash): Filename Signed my-code. json Yes transaction-kQSKbcjN3z-signed. json Yes tx-simple. json No tx-transfer-testnet. json No kadena tx local Use kadena tx local to submit Pact code as a local call. This command can be useful for testing Pact code without submitting the transaction to the blockchain. Basic usage The basic syntax for the kadena tx local command is: Code example (bash): kadena tx local [arguments] [flags] Arguments You can use the following command-line arguments with the kadena tx local command: Use this argument | To do this -n, --network networkName | Specify the Kadena network to connect to for calling the /local endpoint. The default is the /local endpoint on the Kadena test network. -c, --chain-id chainID | Specify the chain identifier to connect to for calling the /local endpoint. Valid values are \"0\" to \"19\". The default is the /local endpoint on chain 0. -g, --gas-limit gasLimit | Specify a gas limit for executing the local transaction. Examples To execute a simple Pact expression using the /local endpoint on the default network and chain, you can run a command similar to the following: Code example (bash): kadena tx local \"(+ 2 2)\" This command evaluates the (+ 2 2) expressions displays the following output: Code example (bash): Local transaction on network testnet chain 0: 4 To execute a Pact expression using the /local endpoint on a specific chain and set a gas limit for the transaction, you can run a command similar to the following: Code example (bash): kadena tx local --network testnet --chain-id 3 --gas-limit 4 \"( 3 4)\" If the gas limit is too low, the command fails with an error message similar to the following: Code example (bash): Local transaction on network testnet chain 3: Error from local call: Gas limit (4) exceeded: 6 If you adjust the gas limit, the command succeeds: Code example (bash): kadena tx local --network testnet --chain-id 3 --gas-limit 10 \"(* 3 4)\" Local transaction on network testnet chain 3: 12 To execute a Pact command that includes strings, you can escape the inner quotations marks with a command similar to the following: Code example (bash): kadena tx local --chain-id 3 '(base64-encode \"once in a lifetime\")' The command evaluates the expression and displays the following output: Code example (bash): Local transaction on network testnet chain 3: \"b25jZSBpbiBhIGxpZmV0aW1l\" kadena tx history Use kadena tx history to list your transactions history. Basic usage The basic syntax for the kadena tx history command is: Code example (bash): kadena tx list [arguments] [flags] Arguments You can use the following command-line arguments with the kadena tx history command: Use this argument | To do this -d, --directory configDirectory | Specify the path to the configuration folder. The default is the current working directory. Examples To list the transaction history in your current working directory, you can run the following command: Code example (bash): kadena tx history This command displays output similar to the following: Code example (bash): Request Key EYh5uvPiUSBXS0KC7XDVKQxabgm7jXtdrayCBKXRs Network Host http: //localhost: 8080 Network ID development Chain ID 3 Time 2024-06-18 14: 06 Status success Transaction ID 1438 Request Key m32rYeSP3iBoNZNZhkknHTDdIokPzBjy3xeI-Md1Dn0 Network Host http: //localhost: 8080. . . [code continues] To format the output in JSON, you can include the --json command-line options: Code example (bash): kadena tx history --json ```bash { \"EYh5uvPiUSBXS0KC7XDVKQxabgm7jXtdrayCBKXRs\": { \"dateTime\": \"2024-06-18T21: 06: 51. 366Z\", \"cmd\": \"{\\\"payload\\\": {\\\"exec\\\": {\\\"code\\\": \\\"(coin. transfer-create \\\\\\\"k: 0b8fb7b68f6e058143d5c57094a9be9835811d936ae486120ef036cc4ff9b31a\\\\\\\" \\\\\\\"k: 6887c4cce24a0ac69e0db0e3e1db6d2d97edb6b7935da7c19f1651b71ade398f\\\\\\\" (read-keyset \\\\\\\"account-guard\\\\\\\") 2. 0)\\\", \\\"data\\\": {\\\"account-guard\\\": {\\\"keys\\\": [\\\"6887c4cce24a0ac69e0db0e3e1db6d2d97edb6b7935da7c19f1651b71ade398f\\\"], \\\"pred\\\": \\\"keys-all\\\"}}}}, \\\"nonce\\\": \\\"\\\", \\\"networkId\\\": \\\"development\\\", \\\"meta\\\": {\\\"sender\\\": \\\"k: 0b8fb7b68f6e058143d5c57094a9be9835811d936ae486120ef036cc4ff9b31a\\\", \\\"chainId\\\": \\\"3\\\", \\\"creationTime\\\": 1718744764, \\\"gasLimit\\\": 2000, \\\"gasPrice\\\": 1e-8, \\\"ttl\\\": 7200}, \\\"signers\\\": [{\\\"pubKey\\\": \\\"0b8fb7b68f6e058143d5c57094a9be9835811d936ae486120ef036cc4ff9b31a\\\", \\\"clist\\\": [{\\\"name\\\": \\\"coin. TRANSFER\\\", \\\"args\\\": [\\\"k: 0b8fb7b68f6e058143d5c57094a9be9835811d936ae486120ef036cc4ff9b31a\\\", \\\"k: 6887c4cce24a0ac69e0db0e3e1db6d2d97edb6b7935da7c19f1651b71ade398f\\\", 2]}, {\\\"name\\\": \\\"coin. GAS\\\", \\\"args\\\": []}]}]}\", \"networkId\": \"development\", \"chainId\": \"3\", \"networkHost\": \"http: //localhost: 8080\", \"status\": \"success\", \"txId\": 1438 } }",
    "source": "reference/cli/cli-tx.md",
    "title": "kadena tx"
  },
  {
    "content": "The `@kadena/kadena-cli` library commands for creating applications and interacting with the Kadena network interactively or by using scripts from the command-line. The commands in this section support creating and managing wallets. Use kadena wallet to add, manage, and fund onchain accounts with fungible tokens, for example, by transferring coin. Basic usage The basic syntax for the kadena wallet command is: Code example (bash): kadena wallet <action> [arguments] [flags] Actions Use the following actions to specify the operation you want to perform. | Use this action | To do this | | --------------- | ----------------------------------- | | add | Add a new local wallet. | | import | Import or restore a wallet from its 12-word secret phrase. | | generate-key | Generate a new random public and secret key pair for your wallet from its existing secret phrase. | | change-password | Update the password for your wallet. | | delete | Delete an existing wallet from the local filesystem. | | list | List wallet information. | Flags You can use the following optional flags with kadena wallet commands. | Use this flag | To do this | ------------- | ----------- | -h, --help | Display usage information. | -q, --quiet | Eliminate interactive prompts and confirmations to enable automation of tasks. | -V, --version | Display version information. | --json | Format command results sent to standard output (stdout) using JSON format. | --yaml | Format command results sent to standard output (stdout) using YAML format. kadena wallet add Use kadena wallet add to add a new local wallet to the filesystem. Basic usage The basic syntax for the kadena wallet add command is: Code example (bash): kadena wallet add [arguments] [flags] Arguments You can use the following command-line arguments with the kadena wallet add command: | Use this argument | To do this | -w, --wallet-name walletName | Specify the name of the wallet. --password-file passwordFile | Specify the path to a file that stores the password for your wallet. If you don't have the password stored in a text file, you can enter it as standard input. -l, --legacy | Generate a legacy wallet using the ED25519 signature scheme to be compatible with Chainweaver. | -a, --create-account | Create an account using the first wallet key. Enter true to create an account using the first public key from the wallet. Enter false to skip account creation. | | -l, --account-alias accountAlias | Specify an account alias to store your account details. | Examples To add a wallet interactively, run the following command: Code example (bash): kadena wallet add This command prompts you to enter the wallet name and password, and, optionally, to create a new account using the public key from the wallet. For example: Code example (bash): ? Enter your wallet name: sf-wallet? Enter the new wallet password: ? Not using a password will store your wallet unencrypted. Are you sure? (y/n): n? Enter the new wallet password: *****? Re-enter the password: **? Create an account using the first wallet key? Yes? Enter an alias for an account: sf-account To add a wallet using a password file instead of standard input (stdin), you can run a command similar to the following: Code example (bash): kadena wallet add --wallet-name=sf-wallet --password-file=my-pwd This command prompts you to specify whether you want to create a new account using the public key from the wallet. If you select No, the command displays wallet information similar to the following: Code example (bash): ==================================================== == 🚨 IMPORTANT: Mnemonic Phrase 🚨 == ==================================================== Mnemonic Phrase: provide act country elbow unhappy rigid have letter pluck fame thank abandon Please store the mnemonic phrase in a SAFE and SECURE place. This phrase is the KEY to recover your wallet. Losing it means losing access to your assets. ==================================================== First keypair generated publicKey: f4ebafe19bc0f02c5. . . [code continues] To create a new wallet and an account without interactive prompting, you can run a command similar to the following: Code example (bash): kadena wallet add --wallet-name=sf-wallet --password-file=my-pwd --create-account=true --account-alias=sf-dev-account kadena wallet import Use kadena wallet import to import or restore a local wallet using an existing 12-word mnemonic phrase. Basic usage The basic syntax for the kadena wallet import command is: Code example (bash): kadena wallet import [arguments] [flags] Arguments You can use the following command-line arguments with the kadena wallet import command: | Use this argument | To do this | -m, --mnemonic-file mnemonicFile | Specify the path to a file that stores your 12-word mnemonic phrase file used to generate keys for your wallet. If you don't have the mnemonic phrase stored in a text file, you can enter the 12-word phrase as standard input. --password-file passwordFile | Specify the path to a file that stores the password for your wallet. If you don't have the password stored in a text file, you can enter it as standard input. -w, --wallet-name walletName | Specify the name of the wallet. -l, --legacy | Use the ED25519 signature scheme to generate keys from the mnemonic phrase so that the wallet is compatible with Chainweaver. Examples To import a wallet interactively, run the following command: Code example (bash): kadena wallet import This command prompts you to enter the 12-word mnemonic phrase, wallet name, and password as standard input. To import a Chainweaver wallet using a password stored in a text file, you can run a command similar to the following: Code example (bash): kadena wallet import --wallet-name=\"chainweaver-wallet\" --password-file=\"my-cw-pwd. txt\" --legacy This command prompts you to enter the 12-word mnemonic phrase, then imports the wallet with a conformation similar to the following: Code example (bash): ✔ Wallet imported successfully ==================================================== == 🚨 IMPORTANT: Mnemonic Phrase 🚨 == ==================================================== Mnemonic Phrase: recall skirt derive occur mad system camera fringe mom list company search Please store the mnemonic phrase in a SAFE and SECURE place. This phrase is the KEY to recover your wallet. Losing it means losing access to your assets. ==================================================== Wallet Storage Locatio. . . [code continues] kadena wallet generate-key Use kadena wallet generate-key to generate a new public and secret key pair from the 12-word mnemonic phrase for an existing wallet. Basic usage The basic syntax for the kadena wallet generate-key command is: Code example (bash): kadena wallet generate-key [arguments] [flags] Arguments You can use the following command-line arguments with the kadena wallet generate-key command: | Use this argument | To do this | -w, --wallet-name walletName | Specify the name of the wallet. -n, --amount amount | Specify how many public and secret key pairs to generate. The default is one (1). -i, --start-index startIndex | Specify an index to start generating keys at. --password-file passwordFile | Specify the path to a file that stores the password for your wallet. If you don't have the password stored in a text file, you can enter it as standard input. -a, --key-alias keyAlias | Specify an optional alias for the generated keys. Examples To generate one new public and private key pair for the sf-wallet, you can run a command similar to the following: Code example (bash): kadena wallet generate-key --wallet-name=\"sf-wallet\" This command prompts you for the wallet password, number of keys to generate, and a key alias. For example: Code example (bash): Enter the wallet password: **? Amount of keys to generate: 1? Alias for the generated key (optional): sf-1 After you respond to the prompts, the command displays confirmation similar to the following: Code example (bash): ✔ Keys generated successfully Public key Index 9de797dc0cb16c3eea4d26a5417b2e0c81ee8c1c1d7b358ebb6afaf6a3ca23a5 1 Wallet Storage Location. kadena/wallets/sf-wallet. yaml Executed: kadena wallet generate-key --wallet-name=\"sf-wallet\" --amount=\"1\" --key-alias=\"sf-1\" To generate keys from a wallet using a password stored in a text file, you can run a command similar to the following: Code example (bash): kadena wallet generate-key --wallet-name=\"sf-wallet\" --amount=\"3\" --key-alias=\"sf-3\" --password-file=my-pwd This command displays confirmation similar to the following: Code example (bash): ✔ Keys generated successfully Public key Index 14de87a379114013a20bf4f00ec32c8a0ac3f64046cab80ac8062bc8319dc5e0 2 c218080d0ffb4024070946ee25e38675e0408d6ea94c9a5fc937340d223b919c 3 8eea71dbe7f13c11c1e4f796f1206639004e9b648abc57c1a1f32cc57464dbcc 4 Wallet Storage Location. kadena/wallets/sf-wallet. yaml To generate a key at a specific starting index, you can run a command similar to the following: Code example (bash): kadena wallet generate-key --wallet-name=\"chainweaver-wallet\" --amount=1 --start-index=100 --key-alias=cw This command prompts you for the wallet password, then displays confirmation similar to the following: Code example (bash): ✔ Keys generated successfully Public key Index 78d02f5d8981068333f5e06e428fba2e78fbe27d3075aeb3f3f7c6a0dec74cf2 100 Wallet Storage Location. kadena/wallets/chainweaver-wallet. yaml Executed: kadena wallet generate-key --wallet-name=\"chainweaver-wallet\" --amount=\"1\" --start-index=\"100\" --key-alias=\"cw\" kadena wallet change-password Use kadena wallet change-password to change the password for an existing wallet. Basic usage The basic syntax for the kadena wallet change-password command is: Code example (bash): kadena wallet change-password [arguments] [flags] Arguments You can use the following command-line arguments with the kadena wallet change-password command: | Use this argument | To do this | -w, --wallet-name walletName | Specify the name of the wallet. --password-file passwordFile | Specify the path to a file that stores the current password for your wallet. If you don't have the password stored in a text file, you can enter it as standard input. --new-password-file newPasswordFile Specify the path to a file that stores the new password for your wallet. If you don't have the password stored in a text file, you can enter it as standard input. -c, --confirm | Confirm that you want to change the wallet password. Examples To change the password for your wallet interactively, run the following command: Code example (bash): kadena wallet change-password --wallet-name=\"mywalletname\" --confirm This command prompts you to select a wallet, enter your current password, enter a new password, and confirm your changes. For example: Code example (bash): ? Select a wallet: Wallet: my-chainweaver-wallet? Enter your current password: *************? Enter the new wallet password: **? Re-enter the password: ** You are about to update the password for this wallet. If you lose your password the wallet can not be recovered. ? Do you wish to update your password? (Use arrow keys) ❯ Yes No If you select Yes* to change the wallet password, the command displays conformation of the change similar to the following: Code example (bash): Wallet password successfully updated. . Wallet location: . kadena/wallets/my-chainweaver-wallet. yaml Executed: kadena wallet change-password --wallet-name=\"my-chainweaver-wallet\" --confirm To change the password for your wallet using passwords stored in local files, you can run a command similar to the following: Code example (bash): kadena wallet change-password --wallet-name=my-chainweaver-wallet --password-file=my-pwd --new-password-file=my-cw-pwd. txt --confirm kadena wallet delete Use kadena wallet delete to delete an existing wallet. Basic usage The basic syntax for the kadena wallet delete command is: Code example (bash): kadena wallet delete [argument] [flag] Arguments You can use the following command-line arguments with the kadena wallet delete command: | Use this argument | To do this | -w, --wallet-name walletName | Specify the name of the wallet. -c, --confirm | Confirm that you want to delete the specified wallet. Examples To delete wallets interactively, run the following command: Code example (bash): kadena wallet delete This command prompts you to select all wallets or a specific wallet and confirm that you want to delete the selected wallet. To delete a single specific wallet deletion, you can run a command similar to the following: Code example (bash): kadena wallet delete --wallet-name=my-chainweaver-wallet --confirm This command displays conformation similar to the following: Code example (bash): The wallet: \"my-chainweaver-wallet\" and associated keys have been deleted. To delete all wallets, run the following command: Code example (): kadena wallet delete --wallet-name=all --confirm kadena wallet list Use kadena wallet list to list information for an existing wallet or for all wallets. Basic usage The basic syntax for the kadena wallet list command is: Code example (bash): kadena wallet list [argument] [flag] Arguments You can use the following command-line arguments with the kadena wallet list command: | Use this argument | To do this | -w, --wallet-name walletName | Specify the name of the wallet. Examples To list information about a specific wallet, you can run a command similar to the following: Code example (bash): kadena wallet list --wallet-name=sf-wallet This command displays key information similar to the following: Code example (bash): Wallet: sf-wallet Alias Index Public key N/A 0 967ea530ad415376d94049a33a06985a5f4d559acdeee9cecccd882982d03ef1 sf-1 1 9de797dc0cb16c3eea4d26a5417b2e0c81ee8c1c1d7b358ebb6afaf6a3ca23a5 sf-3 2 14de87a379114013a20bf4f00ec32c8a0ac3f64046cab80ac8062bc8319dc5e0 sf-3 3 c218080d0ffb4024070946ee25e38675e0408d6ea94c9a5fc937340d223b919c sf-3 4 8eea71dbe7f13c11c1e4f796f1206639004e9b648abc57c1a1f32cc57464dbcc To list information for all wallets and display the output in YAML format, you can run a command similar to the following: Code example (bash): kadena wallet list --wallet-name=\"all\" --yaml This command displays information for all wallets similar to the following: Code example (bash): Wallet: chainweaver-wallet (legacy) Alias Index Public key N/A 0 1b03e0f9b1f981f21484164e4d05febbb6f71fea34033f5d6a7f45c0ee9712af cw 100 78d02f5d8981068333f5e06e428fba2e78fbe27d3075aeb3f3f7c6a0dec74cf2 Wallet: pistolas Alias Index Public key N/A 0 61cf22aa8f209b1a5549242601b4a217f034e3d931b6522ccb7743bf6c355546 N/A 1 ad833b6bbfc72fb7d18b88cd5b4349f82b2f015be8e4b5e7a. . . [code continues] kadena wallet export Use kadena wallet export to export a public and secret key pair from a wallet as unencrypted text. This command returns the exported keys to standard output (stdout) in YAML format by default. Basic usage The basic syntax for the kadena wallet export command is: Code example (bash): kadena wallet export [arguments] [flags] Arguments You can use the following command-line arguments with the kadena wallet liexportst command: | Use this argument | To do this | -w, --wallet-name walletName | Specify the name of the wallet. -i, --key-index keyIndex | Specify the index of the key you want to export. --password-file passwordFile | Specify the path to a file that stores the password for your wallet. If you don't have the password stored in a text file, you can enter it as standard input. Examples To export key information for the sf-wallet key at index 3 in YAML format, you can run a command similar to the following: Code example (bash): kadena wallet export --wallet-name=sf-wallet --key-index=3 This command prompts you for the wallet password, then displays the public and secret keys as unencrypted text. For example: Code example (bash): Warning: this will print the keypair unencrypted. publicKey: c218080d0ffb4024070946ee25e38675e0408d6ea94c9a5fc937340d223b919c secretKey: 25b4a6b924c167cae4ee7d975c2b121ec5bb533a3b9578017d0784cd8547517a Executed: kadena wallet export --wallet-name=\"sf-wallet\" --key-index=\"3\" To use the password stored in a local file and save the exported key to a file in JSON format, you can run a command similar to the following: Code example (bash): kadena wallet export --wallet-name=sf-wallet --password-file=my-pwd --key-index=3 --json > mykey. json",
    "source": "reference/cli/cli-wallet.md",
    "title": "kadena wallet"
  },
  {
    "content": "Quick reference for common tasks that enable an exchange to interact with the Kadena blockchain. This guide provides a quick reference for how to perform the most common tasks when an exchange or a similar application needs to interact with the Kadena blockchain. The information is this guide is similar to topics covered elsewhere in the documentation. For example, you can see similar information in the following topics: - Common task quick reference - Create new accounts - Check account balances - Sign and submit transactions However, this guide assumes that you are operating an exchange and need to interact with the Kadena blockchain programmatically using scripts and, potentially, automation. This guide also assumes the following: - You host one or more Chainweb nodes that you control and monitor. - You have one or more Chainweb nodes that connect to the Kadena test network or main production network. - You are familiar with Kadena single-key and multi-key accounts, account naming conventions, and the use of keysets. For more information about working with accounts and keys, see Accounts, keys, and principals. - You want to use the Kadena client libraries to write scripts that perform common tasks, like creating transactions and listening for events. This guide includes code examples written in TypeScript for all of the common exchange-related activity. If you aren't already hosting your own Chainweb node, see Get started running a node for an introduction to setting up a Chainweb node. Connect to specific chains You can interact with the Kadena network through any of its separate chains. The chains—with chain identifiers 0 through 19—share a common view of blockchain history through consensus, but operate independently and in parallel. Because the chains operate independently and you must specify the chain identifier that you want to send transactions to, you can write a custom host generator function that specifies the node host name or IP address of the node you manage and the specific chains you want to interact with. The following example illustrates creating a Kadena client connection that connects the host kadena-node. my-exchange. tld but only interacts with chains 0, 1, and 2: Code example (typescript): // Import the createClient function from the library. import { createClient } from '@kadena/client'; // This customHostGeneratorFunction specifies the chainweb-node hostname // and specific chains for API calls. const customHostGeneratorFunction = ({ networkId, chainId }) => { if (! [0, 1, 2]. includes(chainId)) { throw new Error('Exchange only conducts business on chains 0, 1, and 2. '); } const hostname = 'kadena-node. my-exchange. tld'; return https: //${hostname}/chainweb/0. 0/${netw. . . [code continues] For more information about the @kadena/client libraries, see Get started with Kadena client. For more information about interacting with the Kadena coin contract and developing custom interfaces, see the client-utils repository and npm package. Generate an account on the blockchain For exchanges, the recommended best practice is to use a multi-signature account to manage the funds that are owned by the exchange. With a multi-signature account, you can apply the four-eyes principle to require transactions to be approved by at least two people. The four-eyes principle, sometimes referred to as the two-person rule, is a broadly-accepted security method that ensures certain activities—such as the transfer of assets—are approved by at least two authorized individuals. Exchanges can apply this principle to prevent errors, fraud, or malicious behavior using the built-in predicates for multi-signature accounts: - keys-all requires all authorized account keys to sign every transaction. - keys-2 requires at least two of any number of authorized account keys to sign every transaction. - keys-any requires that any single authorized account key signs every transaction. Typically, exchanges use the keys-2 predicate for the account that manages funds owned by the exchange and two or more authorized account keys. You can create a multi-signature account and associated keys by using any wallet that supports the Kadena network and native KDA currency. For example, you can create keys and accounts by using any of the following wallets: - Chainweaver v3 (built by Kadena). You can also import accounts and keys from previous versions of Chainweaver. - Kadena CLI Wallet (built by Kadena). You can also use @kadena/kadena-cli to import accounts and keys from previous versions of Chainweaver, from other wallets, or from public and private key pairs you've generated using other tools. - Other Kadena ecosystem wallets. You can also create an account using any of the wallets developed by third parties that support the Kadena network. ! Kadena ecosystem wallets Using Chainweaver 1. Open Chainweaver v3 and click Add new profile to create a wallet or Recover your wallet to import information from a backup file or recovery phrase. If creating a new wallet, type a Profile name and select a security method. If recovering a wallet, provide the backup file or recovery phase to import keys and accounts. After creating or importing the wallet, the list of your assets on the Kadena Mainnet network is displayed by default. You can change the current network to Testnet or add another network by clicking Settings. ! Chainweaver network selection 2. Click + Account, then select Create Multi-Sig. 3. Type an account alias name, select or enter the public keys for the account, and select a predicate, then click Create account. - Fungible Contract: Select KDA (coin). - Alias: Type an alias for the w: account name. - Key: Select or enter each public key for the multi-signature account. - Predicate: Select one of the built-in predicates to use for the multi-signature account. <! --! Select the keys and predicate for the account--> 4. Verify the new account is listed with a w: prefix in the list of assets. ! Multi-signature account Note that the account has no funds. At this point, the account isn't associated with any of the chains in the network. You must add funds on at least one specific chain in the network you've selected for the account to become active and available for use. If you are setting up this multi-signature account on the Testnet network, you can fund the account directly from Chainweaver by clicking Fund on Testnet in the account details, or by using the Developer Tools Testnet faucet. 5. Click the multi-signature account alias to view its details, then click Fund on Testnet to fund the account. ! Fund on Testnet in Chainweaver v3 After the transaction is mined into a block, you can click Chain Distribution to see the chain that received funds on the Testnet network. If needed, you can transfer funds to your account on another chain. If you're funding an account on the Mainnet network, you must acquire funds through another exchange. Using mnemonic phrases To use mnemonic phrases programmatically, you can use the @kadena/hd-wallet library. For more information about this library, see the npm package. Using client utilities The following example demonstrates how to create a Kadena account with two public keys and the keys-2 predicate requiring both signatures to sign transaction on the Kadena main network and chain 0: Code example (typescript): import { createAccount } from '@kadena/client-utils/coin'; const result = await createAccount( { account: 'k: ' + publicKey, keyset: { pred: 'keys-2', keys: [publicKeyA, publicKeyB], // two public keys for a 2-of-2 multisig // keys: [publicKeyA, publicKeyB, publicKeyC], // three public keys for a 2-of-3 multisig }, gasPayer: { account: 'gasPayer', publicKeys: [''] }, chainId: '0', }, { host: customHostGeneratorFunction, defaults: { networ. . . [code continues] Retrieve balances The following example illustrates using the getBalance function from the @kadena/client-utils library: Code example (typescript): import { getBalance } from '@kadena/client-utils/coin'; const balance = await getBalance( 'k: my-wallet-address', 'mainnet01', '0', // chainId customHostGeneratorFunction, // You can pass the hostname or a generator function. ); console. log(Balance: ${balance}); Create, sign, and send a transaction To create a transaction manually, you can combine the Pact. builder and Pact. modules functions: - Pact. builder to create an unsigned transaction request to execute in the transaction request. - Pact. modules. <module>. <function> to create a Pact expression. The following example demonstrates how create, sign, and send a transfer transaction manually using the @kadena/client library: Code example (typescript): async function transfer( sender: string, senderAPublicKey: string, senderBPublicKey: string, receiver: string, amount: IPactDecimal, ): Promise<void> { const transaction = Pact. builder. execution( // pact expression Pact. modules. coin. transfer(sender, receiver, amount), ) // add signers. addSigner(senderAPublicKey, (signFor) => [ // add capabilities signFor('coin. GAS'), signFor('coin. TRANSFER', sender, receiver, amount), ]) // if s. . . [code continues] The following code illustrates signing with a known public and secret keypair: Code example (typescript): import { Pact, createClient, isSignedTransaction, createSignWithKeypair } from '@kadena/client'; import { IKeyPair } from '@kadena/client'; async function transfer( sender: string, senderAPublicKey: string, senderBPublicKey: string, receiver: string, amount: IPactDecimal, ): Promise<void> { const unsignedTransaction = Pact. builder. execution( // pact expression Pact. modules. coin. transfer(sender, receiver, amount), ) // add signers. addSigner(senderPublicK. . . [code continues] Note that you can also use transaction templates and @kadena/kadena-cli to create, sign, and send transactions. You can automate the flow by using command-line options to execute transactions without interactive prompts. For more information about using @kadena/kadena-cli to automate transaction processing, see Kadena-cli commands. Check the status of a transaction There are two primary ways to check the status of a transaction programmatically: - You can check the status of a single transaction by passing the requestKey hash for the transaction when calling the getStatus function. - You can poll for the status of one or more transactions until the transaction request returned a result. Single check Code example (typescript): const client = createClient(/ omitted options, see \"Low Level Client\"/); // requestKey is the hash of the submitted transaction client. getStatus({ chainId, networkId, requestKey }); Polling check Code example (typescript): client. pollStatus( { networkId: 'mainnet01', chainId: '0', requestKey: 'tx-hash' }, { confirmationDepth: 10 }, ); Estimate gas usage To get an estimation of the gas usage, you can execute a local call. Note that the gas estimation can be different from the actual gas by a transaction when the transaction is executed on the blockchain. State changes that are recorded on the blockchain can influence the branches the code takes, and, as a result, affect the gas required to execute the transaction. Code example (typescript): // We do not need to send signatures to check gas estimation. // However, signatures can influence the direction of the code, thus gas usage. const response = await client. local(unsignedTx, { preflight: true, signatureVerification: false, }); if (response. result. status === 'failure') { throw response. result. error; } const gasEstimation = response. gas; Listens for events There are several ways you can listen for events emitted by transactions that are executed on the blockchain. For example, you can listen for coin. TRANSFER events in the following ways: - Use the chainweb-stream server package with the @kadena/chainweb-stream-client to listen for specific events. - Use third-party indexing services such as Kadindexer or Tatum to listen for specific events. - Implement a custom listener using the @kadena/chainwebjs` package. Monitoring and incident management As an exchange, it is particularly important for you to monitor node operations and network activity. If you notice suspicious transactions or are informed about unusual transaction activity, you should work with mining node operators and pool node operators to determine if the transaction is preventing other transactions from being processed, consuming excessive resources, or causing any nodes to fail. Often, adjusting transaction fees can mitigate transaction processing delays and minimize the affect for end users who are submitting transactions. If the network experiences an incident affecting transaction processing, you should pause all deposit and withdrawal activity until normal operations resume.",
    "source": "reference/exchange-integration.md",
    "title": "Exchange integration guide"
  },
  {
    "content": "This technical specification describes the JSON representation for different guards returned by the chain. In the technical specification for the guard types, the following types all correspond to JSON types: - String - Number - Array[*] - Bool - Objects ({\"field\": type}) Keyset guards The keyset guard is the backward-compatible keyset as originally defined in Pact. This guard is also referred to as a concrete keyset that's defined in the environment. Using the keyset type is the one instance where you can restrict a guard subtype. For all other guards, the guard type obscures the implementation type to discourage you from using guard-specific control flow, which would be against best practices. In general, you should use the guard type unless you have a specific need to use a keyset. Type definition Code example (json): { \"keys\": Array[String], \"pred\": String } Examples Code example (json): { \"admin-keyset\": { \"keys\": [ \"58705e8699678bd15bbda2cf40fa236694895db614aafc82cf1c06c014ca963c\" ], \"pred\": \"keys-all\" } } Code example (pact): (define-keyset \"admin-keyset\" (read-keyset \"admin-keyset\")) (enforce-guard (read-keyset \"admin-keyset\")) Principal account prefix Each type of principal and guard uses a unique prefix, so they are easy to recognize. If you use the create-principal function to a create principal account for a keyset guard, the principal account uses one of the following prefixes: - k: for single key keysets - w: for multiple keys keysets KeysetRef guard You can install concrete keyset guards in the REPL environment by using the define-keyset function. However, if you want to store a reference to a defined keyset, you must use a string type. To make REPL environment keysets interoperate with concrete keysets and other guards, you can use the KeysetRef guard to indicate that a defined keyset is used instead of a concrete keyset. Type definition Code example (json): { \"keysetref\": { \"ns\": String? , \"ksn\": String } } Examples Code example (pact): (enforce-guard (keyset-ref-guard \"foo\")) (update accounts user { \"guard\": (keyset-ref-guard \"foo\") }) User guard User guards allow you to design an arbitrary predicate function to enforce the guard, given some initial data. With user guards, you can implement any type custom predicate logic that can't be expressed by other built-in guard types. For example, you might want to customize the guard to allow one of two different keysets to sign: - One keyset registers the keys for the members of a board of directors. - A second keyset registers the keys for union representatives. You can then design a user guard to require two separate keysets to be enforced: Code example (pact): (defun both-sign (board union) (enforce-keyset board) (enforce-keyset union)) (defun install-both-guard () (write guard-table \"both\" { \"guard\": (create-user-guard (both-sign (read-keyset \"board) (read-keyset \"union\"))) })) (defun enforce-both-guard () (enforce-guard (at \"guard\" (read guard-table \"both\")))) User guards can be very flexible and powerful. They can be stored in the database and passed around like plain data. However, user guards are pure functions that don't allow access to a database during evaluation of the guard. Type definition Code example (json): { \"fun\": String, \"args\": Array[PactValue] } Examples The following example illustrates how to write a custom hash timelock guard to implement atomic swaps. Code example (pact): (create-hashlock-guard (secret-hash timeout signer-ks) (create-user-guard (enforce-hashlock secret-hash timeout signer-ks))) (defun enforce-hashlock (secret-hash timeout signer-ks) (enforce-one [ (enforce (= (hash (read-msg \"secret\")) secret-hash)) (and (enforce-keyset signer-ks) (enforce (> (at \"block-time\" (chain-data)) timeout) \"Timeout not passed\")) ])) Principal account prefix Each type of principal and guard uses a unique prefix, so they are easy to recognize. If you use the create-user-guard function to create a principal account for a user guard, the principal account uses the following prefix: - u: for user guards Capability guard Capabilities are in-module rights that can only be enforced within the declaring module, and offer scoping and the other benefits. Because user guards are required to be pure functions, they can't take database state into account. If you need to access database state, you can define a guard that requires a capability to be brought into scope. With this type of guard, you can retrieve database state when you bring the capability into scope. Type definition Code example (json): { \"cgName\": String, \"cgArgs\": Array[PactValue], \"cgPactId\": String? } For information about PactValue types, see Pact values. Principal account prefix Each type of principal and guard uses a unique prefix, so they are easy to recognize. If you use the create-capability-guard function to create a principal account for a capability guard, the principal account uses the following prefix: - c: for capability guards Module guard (DEPRECATED) Modules always guard access to the tables and functions that are defined within the module. For example, when you create a table, you must specify a module name. This requirement ensures that tables are fully encapsulated or guarded by the module and that direct access to the table through data-access functions can only be authorized by the administrative owner of the module. However, within module functions, table access is unconstrained. This behavior gives you flexibility in designing data access, and ensures that the module is the main point of entry for all data-related interactions. Within a module, only the module code or a transaction having module administrative privileges can write directly to a module table or upgrade the module. Module guards aren't required to protect these in-module operations. Instead, module guards are intended to allow a Pact module or smart contract to autonomously own or manage an asset outside of the module, for example, to own coins in an external ledger or manage assets in an internal ledger alongside other non-module owners. If a module guard is enforced: - The enforce-guard function must called from within the module. or - Module governance must be granted to the current transaction. For more information about module management, see Governance. Type definition Code example (json): { \"moduleName\": ModuleName, \"name\": String } Examples The create-module-guard function takes a string argument to allow you to name the guard with text that indicates the purpose or role of the guard. Code example (pact): (enforce-guard (create-module-guard \"module-owned-asset\")) Pact guard (DEPRECATED) Pact guards are a special guard that only pass if called in the specific defpact execution in which the guard was created. Pact guards turn defpact executions into autonomous processes that can own assets, and is a powerful technique for trustless asset management within a multi-step operation. Type definition Code example (json): { \"pactId\": String, \"name\": String } Examples The following example illustrates the use of a pact guard for an escrow transaction modeled as a two-step defpact declaration. In this example, the funds go into a account named after the pact-id identifier, guarded by a pact guard. This means that only code in a subsequent step of that particular pact execution—that is, having the same pact-id as the previous—can satisfy the guard. Code example (pact): (defpact escrow (from to amount) (step (with-capability (ESCROW) (init-escrow from amount))) (step (with-capability (ESCROW) (complete-escrow to amount)))) (defun init-escrow (from amount) (require-capability (ESCROW)) (create-account (pact-id) (create-pact-guard \"escrow\")) (transfer from (pact-id) amount)) (defun complete-escrow (to amount) (require-capability (ESCROW)) (with-capability (USER_GUARD (pact-id)); ; enforces guard on account (pact-id) (transfer (pact-id) to amou. . . [code continues] Union Code example (json): Union = Keyset | KeysetRef | UserGuard | CapabilityGuard | ModuleGuard | PactGuard Pact value literals The following pseudo code provides type information for decoding Pact values returned by guards: Code example (json): Union PvLiteral = PvString | PvInteger | PvDecimal | PvBool PvString = String You can treat an integer as a JSON number if it's between the range -9007199254740991 <= n && n <= 9007199254740991 or as a string you need to decode an integer that exceeds the range: PvInteger = {\"int\": (Number | String) } You can treat an integer as a JSON number if it's between the range -9007199254740991 <= n && n <= 9007199254740991 or as a string you need to decode an integer that exceeds the ran. . . [code continues] Pact value union types The following pseudo code provides type information for decoding Pact values returned by recursive guards: Code example (json): Union PactValue = PvLiteral | PvList | PvGuard | PvObject | PvModRef | PvTime | PvCapToken PvList = Array[PactValue] PvGuard = Guard PvObject = { f: PactValue | f in {String} } // Fields can be any string, but their value is a pact value: PvModRef = { \"refName\": String, \"refSpec\": Array[ModuleName]) // See # Misc type for module names PvTime = { \"time\": String } | { \"timep\": String } // There's specific formatting here depending on the UTC denom. // See https: //github. com/kadena-io/pact/bl. . . [code continues]",
    "source": "reference/guard-json.md",
    "title": "Guard JSON representation"
  },
  {
    "content": "The `@kadena/kadena-cli` library provides a complete set of commands for creating applications and interacting with the Kadena network interactively or by using scripts from the command-line. Kadena-cli commands The Kadena command-line interface (kadena-cli) provides direct access to the Kadena blockchain and to commands that help you create, test, deploy, and manage applications for the Kadena network. You can use the Kadena command-line interface to perform tasks interactively or in scripts and automated workflows that don't allow interactive input. The Kadena CLI has one primary entry point—the kadena parent command. By providing a single entry point for performing a wide range of tasks, the Kadena CLI integrates naturally into the typical development workflow. With commands designed specifically for building, testing, and managing Kadena-based applications, you can focus on building innovative applications using familiar tools and processes. Prerequisites Before you use the Kadena command-line interface, verify the following basic requirements: - You have node, version 18 or later, installed. - You have the pnpm package manager installed. Depending on your development environment, you can install pnpm using a standalone script or using a package manager. For example, you can run the command brew install pnpm or npm install --global pnpm to install pnpm on your local computer. For more information about installing pnpm on different operating systems, see Installation. Run pnpm --version to verify that you have pnpm installed and the version you are running. Installation The Kadena CLI is packaged in a TypeScript library. You can install the Kadena CLI (@kadena/kadena-cli) using the npm or pnpm package manager. To install globally using npm, run the following command: Code example (npm): npm install -g @kadena/kadena-cli To install globally using pnpm, run the following command: Code example (pnpm): pnpm install -g @kadena/kadena-cli To verify the package is installed and display usage information, type kadena and press Return: Code example (shell): kadena Command overview You can use the kadena parent command with different flags and subcommands to perform different types of operations. The basic syntax for running kadena commands is: Code example (shell): kadena <subcommand> <action> [arguments] [flag] The following diagram provides an overview of the kadena command-line interface: ! Kadena command-line interface at a glance Command subjects and syntax Commands in the Kadena CLI are organized into categories that describe the subject of the action you want to perform. The commands are structured using the following basic format: Code example (shell): kadena <subject> [. . . <subject>] <action> [--flags] [args] For example, you can create and manage all wallet-related information by specifying wallet as the command subject. Available subjects Use the following command subjects to select the category of information for the operation you want to perform. | Use this command subject | To do this | ------------------------ | ----------- | account | Create, fund, and manage accounts that contain fungibles assets. | config | Configure the initial context and properties for working with the kadena command-line interface. | dapp | Create and manage an application project using a frontend framework template. | key | Generate and manage public and secret keys. | network | Create and manage network information. | tx | Create and manage transactions. | wallet | Generate keys and manage wallets. Global flags Flag | Description --help | Display usage information. --json | Use JSON format to display relevant result data in standard output (stdout) stream. --quiet | Eliminate interactive prompts and confirmations. --version | Display version information. --yaml | Use YAML format to display relevant result data in standard output (stdout) stream. Command-specific help To get help on a specific subject, use the --help flag: Code example (shell): kadena <subject> --help Interactive execution You can run all commands without any arguments by responding to prompts interactively from the command line. You can skip prompting for any argument by passing your response as part of the command you want to run. Interactive prompting is designed to make command execution more intuitive and easy to follow with a guided user experience. If you run a command in the Kadena CLI without specifying all of the required options, the CLI automatically prompts you to provide the missing information. This guided approach ensures that you provide all necessary information to successfully execute every command. To run commands with interactive prompting, type the kadena entry point, the command subject, and the action you want to take without any arguments. For example, if you want to add a new wallet but aren't sure of all the required flags and arguments, you can run the following command: Code example (shell): kadena wallet add The CLI then guides you through the necessary steps, asking for the information required to add the new wallet. Interactive prompting is especially useful for new users or for users who are less familiar with using command-line tools. It also helps you learn about the arguments required to run different commands, so over time you can reduce or skip interactive prompting by entering arguments directly on the command line. By allowing you to run commands interactively, the Kadena CLI provides the following key benefits: - Ease of use: Reduces the need to remember all command arguments and options upfront. - Guided execution: Ensures that all required inputs are collected before executing a command. - Flexibility: Allows for a more conversational and less rigid interaction with the CLI. If you want to disable all interactive prompts and confirmation messages, you can use the --quiet flag. The --quiet flag enables you to automate tasks in environments where interactive input is impractical, such as continuous integration (CI) pipelines. If you include the --quiet flag in a command, the command suppresses all interactive prompts and skips confirmations, so that the command executes uninterrupted. This mode ensures that automated processes can run smoothly and efficiently, without the need for manual intervention. JSON or YAML output You can use the --json or --yaml flag to format output from the results of a command in JSON or YAML format. The results are displayed in the selected format on standard output (stdout). You can then pipe the output into a file or to other programs. For example, to format network information using JSON format, you can run the following command: Code example (shell): kadena network list --json The command then displays the results in JSON format: Code example (shell): { \"networks\": [ { \"network\": \"devnet\", \"networkId\": \"devnet01\", \"networkHost\": \"https: //localhost: 8080\", \"networkExplorerUrl\": \"http: //localhost: 8080/explorer/development/tx/\" }, { \"network\": \"mainnet\", \"networkId\": \"mainnet01\", \"networkHost\": \"https: //api. chainweb. com\", \"networkExplorerUrl\": \"https: //explorer. chainweb. com/mainnet/tx/\" }, { \"network\": \"testnet\", \"networkId\": \"testnet04\", \"networkHost\": \"https. . . [code continues] The --json and --yaml options don't affect logging of informational messages, warnings, or errors. Log messages are sent to standard error (stderr) instead of standard output (stdout). You can disable the logging of informational messages by setting the KADENA_LOG=output environment variable. Legacy mode The --legacy flag ensures that the output format for commands related to wallets, keys, and transactions aligns with earlier cryptographic standards and with existing workflows and tools, such as Chainweaver. This flag is especially useful if you need to interact with tools that rely on a legacy format for processing transactions or if you need to maintain backwards compatibility for a wallet or other application. Code example (shell): kadena [command] --legacy Legacy mode is available for the following commands: Code example (shell): kadena wallet add kadena key generate kadena tx sign",
    "source": "reference/kadena-cli-ref.md",
    "title": "kadena-cli command reference"
  },
  {
    "content": "The @kadena/client library provides a TypeScript-based API for interacting with Pact smart contracts and Chainweb nodes using frontend frameworks. The @kadena/client library provides a TypeScript-based API for interacting with smart contracts and Chainweb nodes on the Kadena network. The library includes modules to help you perform the following types of common tasks: - Create commands - Sign transactions - Submit transactions - Query transaction results If you only need to interact with the coin contract, you can use the functions in the @kadena/client-utils/coin library instead of the @kadena/client library for a simpler API. Get started with Kadena client One of the most important features of the Kadena client library is that helps you create command objects with the correct structure. You can then construct and sign transactions to send the command to the blockchain network. After you submit a transaction for processing, you can use the Kadena client to listen for the transaction results. The following example illustrates the structure of a command object: Code example (typescript): interface ICommand { cmd: string; // stringified command of <IPactCommand> type hash: string; // cmd-hash sigs: Array<{ sig: string } | undefined>; // array of signatures } interface IPactCommand { payload: | { exec: { code: string; data: Record<string, unknown>; }; } | { cont: { pactId: string; step: number; rollback: boolean; data? : Record<string, unknown>; proof? : string | null. . . [code continues] If your use case is simple enough that you can create the JSON directly, you don't need to use the functions in the Kadena client library. You can also use some parts of the library, without using everything. If you prefer to learn from code, check out the client-examples. Install You can download and install the @kadena/client library with the following command: Code example (bash): npm install @kadena/client Import After you install the library, you can import @kadena/client functions into a TypeScript or JavaScript program with the following statement: Code example (typescript): import { createClient, Pact } from '@kadena/client'; The library also exports functional programming utilities under @kadena/client/fp for more flexibility when using a functional programming approach. To import functional programming utilities, include the following statement in your TypeScript or JavaScript program. Code example (typescript): import { composePactCommand } from '@kadena/client/fp'; Calling Pact modules Interacting with the Kadena blockchain network and Chainweb nodes is mostly a matter of calling smart contract functions. From the client perspective, you need to write Pact code in a string and pass it to the IPactCommand. payload. exec. code interface. Without code completion and validation, writing the Pact code string manually is error-prone and vulnerable to code injection. To simplify the process, you can use Pact. modules to help you: - Write type-safe functions. - Perform Pact type conversion. - Avoid code injection. You can skip this part of the client library if your code is just a simple constant string. Basic usage Use Pact. modules with the following format: Code example (typescript): import { Pact } from @kadena/client; Pact. modules[${namespace}. ${moduleName}]functionName; Parameters Parameter | Type | Description. . . args | PactValue[] | List of arguments. Code example (typescript): // the pseudo code of PactValue type type PactValue = | string | number | boolean | Date | { int: string } | { decimal: string } | PactValue[] | Record<string, PactValue>; Examples To create the code for the coin. transfer function: Code example (typescript): import { Pact } from @kadena/client; const code = Pact. modules. coin. transfer(\"alice\", \"bob\", { decimal: '1. 1' }); // code === '(coin. transfer \"alice\" \"bob\" 1. 1)' To create the code for the free. my-module. my-function function that converts a list, objects, and date to valid Pact code: Code example (typescript): import { Pact } from @kadena/client; const code = Pact. modules[\"free. my-module\"]. \"my-function\" }]); // code === '(free. my-module. my-function [\"first\" {\"time\": (time \"2023-07-20T14: 55: 11Z\")} ])' Create type definitions You can use @kadena/pactjs-cli to create the type definitions for the Pact module you use. After you generate the type definitions file, the code editor in your development environment should provide code completion for functions and capabilities. To create a type definition file for the coin contract: Code example (bash): npx @kadena/pactjs-cli contract-generate --contract coin --api https: //api. testnet. chainweb. com/chainweb/0. 0/testnet04/chain/0/pact; Creating commands As illustrated in Get started with Kadena client, a command is a JSON object with three keys: cmd, hash, and sig. There are two types of commands: - Execution commands - Continuation commands You can create the JSON object without using the Kadena client library. However, using the library and Pact. builder to create the command object simplifies the process. Pact. builder. execution You can use Pact. builder to create an execution command object, IPactCommand. payload. exec. code. Most transactions are execution (exec) commands that complete in a single step. Execution commands are also be used for the first step in transactions that are defpact multi-step transactions. Code example (typescript): Pact. builder. execution(. . . codes): IBuilder Parameter | Type | Description. . . codes | string[] | List of input for a function. Examples To use strings for the command code: Code example (typescript): const builder: IBuilder = Pact. builder. execution( (coin. transfer \"alice\" \"bob\" 1. 1), ); To use Pact. modules for the command code: Code example (typescript): const builder: IBuilder = Pact. builder. execution( Pact. modules. coin. transfer('alice', 'bob', { decimal: '1. 1' }), ); Pact. builder. continuation You can use Pact. builder to create a continuation command object, IPactCommand. payload. cont, which is the type of transaction used for additional steps of defpact multi-step transactions. Code example (typescript): Pact. builder. continuation(contData): IBuilder Parameter | Type | Description contData | object | Continuation data includes a unique defpact identifier, whether the transactions rolls back a previous transaction, the transaction step that the continuation represents with the first step being step 0, and a simple payment verification proof if one is generated by calling the /spv endpoint. The contData object consists of the following properties: Code example (json): { pactId: string, rollback: boolean, step: number, data? : Record<string, any>, proof? : null \\| string } Example The coin. cross-chain function is a defpact multi-step transaction that burns tokens in the source chain and mints tokens in the destination chain. After the first step completes successfully, you can call the second step by using the continuation command object. Code example (typescript): const builder: IBuilder = Pact. builder. continuation({ pactId, rollback: false, step: 1, proof: spvProof, }); addSigner You can use the addSigner method to add public keys and capabilities for a transaction signer to the command. You can call addSigner multiple times to add multiple signers to the transaction. Later, the Chainweb node checks whether all required signers have signed the transaction or not. Code example (typescript): Pact. builder. execution(. . . codes). addSigner(signerOrSignersList, capabilityCallback): IBuilder Parameter | Type | Description signer | string or object | Public key of the signer or the signer object (this can also be a list of signers if all of the signers sign for the same capabilities). capabilityCallback | (signFor) => ReturnType<signFor>[] | Allows you to scope what the signer is signing for to a specific list of capabilities. Code example (): { pubKey: string; scheme? : 'ED25519' \\| 'ETH' \\| 'WebAuthn'; address? : string; } \\| ISigner[] Chainweb supports the following signature schemes for public keys: - ED25519 - WebAuthn - ETH The default signature scheme is ED25519. You can pass just the public key if the signature scheme is ED25519. If the scheme is not ED25519, you must pass a signer object that includes the pubic key and the signature scheme. Examples To add a signer public key for a coin contract transfer: Code example (typescript): // ED25519 key const alicePublicKey = 'e7f4da07b1d200f6e45aa6492afed6819297a97563859a5f0df9c54f5abd4aab'; Pact. builder. execution(Pact. modules. coin. transfer('alice', 'bob', { decimal: '1. 1' })). addSigner(alicePublicKey, (signFor) => [ signFor('coin. TRANSFER', 'alice', 'bob', { decimal: '1. 1' }), ]); To add a signer that uses the WebAuthn scheme: Code example (typescript): Pact. builder. execution(Pact. modules. coin. transfer('alice', 'bob', { decimal: '1. 1' })). addSigner({ pubKey: webAuthnPublicKey, scheme: 'WebAuthn' }, (signFor) => [ signFor('coin. TRANSFER', 'alice', 'bob', { decimal: '1. 1' }), ]); To add a list of signers with no capabilities: Code example (typescript): Pact. builder. execution('(free. my-module. my-function)'). addSigner([ 'ED25519publicKey', { pubKey: 'WebAuthnpublicKey', scheme: 'WebAuthn' }, ]); To add a list of signers with similar capabilities: Code example (typescript): Pact. builder. execution(Pact. modules. coin. transfer('alice', 'bob', { decimal: '1. 1' })) // e. g. , Alice's account is guarded by two keys. addSigner(['firstpublicKey', 'secondpublicKey'], (signFor) => [ signFor('coin. TRANSFER', 'alice', 'bob', { decimal: '1. 1' }), ]); const equivalentPactCommand = { payload: { exec: { code: '(coin. transfer \"alice\" \"bob\" 1. 1 )', data: {}, }, }, signers: [ { pubKey: 'firstpublicKey', scheme: 'ED25519', . . . [code continues] addData You can use addData to add data to the IPactCommand. payload. exec. data or IPactCommand. payload. cont. data command. This data is readable in the smart contract later. You can also use this data in the code you set in the command. Code example (typescript): Pact. builder. execution(. . . codes). addData(key, value): IBuilder Parameter | Type | Description key | string | The key associated with the data you're sending. value | PactValue | Data that you want to send. Examples To transfer with parameters in data: Code example (typescript): Pact. builder. execution('(coin. transfer (read-string \"sender\") (read-string \"receiver\") 1. 1)'). addData(\"sender\", sender). addData(\"receiver\", sender): IBuilder To use transfer-create and send the receiver guard: Code example (typescript): Pact. builder. execution( '(coin. transfer-create \"alice\" \"bob\" (read-keyset \"bob-guard\") 1. 1)', ). addData('bob-guard', { keys: ['bob-public-key'], pred: 'keys-all', }); addKeyset Because keysets are often included as data in commands, you can use the addKeyset method as an alternative to the addData method to add a keyset to a command. Code example (typescript): Pact. builder. execution(. . . codes). addKeyset(name, pred, . . . keys): IBuilder Parameter | Type | Description name | string | The name associated with the keyset. pred | \"keys-all\"\\ | \"keys-2\"\\ | \"keys-any\" \\ | string | One of the built-in predicate functions or a user-defined predicate function. . . . keys |. . . string[] | List of public keys in the keyset. Examples To use readKeyset and addKeyset helper functions with transfer-create: Code example (typescript): Pact. builder. execution( Pact. modules. coin'transfer-create', { decimal: '1. 1' }, ), ). addKeyset('bob-guard', 'keys-all', 'bob-public-key'); To use transfer-create as string code: Code example (typescript): Pact. builder. execution( '(coin. transfer-create \"alice\" \"bob\" (readKeyset \"bob-guard\") 1. 1)', ). addKeyset('bob-guard', 'keys-all', 'bob-public-key'); setMeta You can use setMeta to add metadata to a command. Code example (typescript): Pact. builder. execution(. . . codes). setMeta(meta): IBuilder Parameter | Type | Description meta | object | Add a metadata object to the command. The meta object consists of the following properties: Property | Type | Default value | Description chainId | \"0\" to \"19\" | undefined | Chain identifier for the chain. Valid values are from 0 to 19. senderAccount | string | undefined | The account address that you want to pay transaction fees from. gasLimit | number | 2500 | Maximum units of gas that you want to allow to be deducted when running the transaction. gasPrice | number | 1. 0e-8 | Price of each gas unit based on KDA (e. g. , 0. 0000001). ttl | number | 28800 | Time-to-live (ttl) for the transaction to be valid in seconds. The default value is 8 hours. creationTime | number | Date. now() / 1000 | Transaction creation time in seconds. Examples Code example (typescript): Pact. builder. execution('(coin. transfer \"alice\" \"bob\" 1. 1)') // \"bob is paying gas fee\". setMeta({ chainId: \"02\", senderAccount: \"bob\" }): IBuilder; setNonce You can use setNonce function to set IPactCommand. nonce to a custom nonce for the transaction. Otherwise, the nonce is set using the kjs: ${timestamp} function. Code example (typescript): Pact. builder. execution(code). setNonce(nonce): IBuilder Parameter | Type | Description nonce | string | Custom nonce for the transaction. Examples Code example (typescript): Pact. builder. execution('(coin. transfer \"alice\" \"bob\" 1. 1)') // \"bob is paying gas fee\". setNonce(\"a-custom-nonce\"): IBuilder; setNetworkId You can use setNetworkId to set IPactCommand. network to specify the network for the transaction. Code example (typescript): Pact. builder. execution(code). setNetworkId(networkId): IBuilder Parameter | Type | Description networkId | string | Network identifier, for example, \"mainnet01\" or \"testnet04\". Examples Code example (typescript): Pact. builder. execution('(coin. transfer \"alice\" \"bob\" 1. 1)') // \"bob is paying gas fee\". setNetworkId(\"testnet04\"): IBuilder; Creating transactions After you set all parts of the command, you can create the transaction object by calling the createTransaction method. This method adds all of the default values to the command, converts cmd to a string, and adds the hash. You must add signatures to the transaction object using a wallet to submit the transaction to the blockchain. For information about adding signatures from a wallet, see Signing transactions. Code example (typescript): const transaction: IUnsignedCommand = Pact. builder. execution(code). createTransaction(); //: { cmd: \"stringified-command\", hash: \"command-hash\", sig: [] }; Examples Code example (typescript): const transaction = Pact. builder. execution(Pact. modules. coin. transfer(senderAccount, receiverAccount, amount)). addSigner(senderKey, (signFor) => [ signFor('coin. GAS'), signFor('coin. TRANSFER', senderAccount, receiverAccount, amount), ]). setMeta({ chainId: '0', senderAccount }). setNetworkId(NETWORKID). createTransaction(); const output = { cmd: '{\"payload\": {\"exec\": {\"code\": \"(coin. transfer \\\\\"k: dc20ab800b0420be9b1075c97e80b104b073b0405b5e2b78afd29dd74aaf5e46\\\\\" \\\\\"k: 2f48. . . [code continues] getCommand If you prefer to have the non-stringified version of the command, you can use getCommand. Code example (typescript): const transaction: IPactCommand = Pact. builder. execution(code). getCommand(); Examples Code example (typescript): const command = Pact. builder. execution(Pact. modules. coin. transfer(senderAccount, receiverAccount, amount)). addSigner(senderKey, (signFor) => [ signFor('coin. GAS'), signFor('coin. TRANSFER', senderAccount, receiverAccount, amount), ]). setMeta({ chainId: '0', senderAccount }). setNetworkId(NETWORKID). getCommand(); const output = { payload: { exec: { code: '(coin. transfer \"k: dc20ab800b0420be9b1075c97e80b104b073b0405b5e2b78afd29dd74aaf5e46\" \"k: 2f48080efe54e6eb670. . . [code continues] initialPactCommand If you find yourself repeating certain parts of methods for different commands, you can create your own command builder by using the createTransactionBuilder function. This function allows you to set all of the default values once and then reuse them in createTransaction. Parameter | Type | Description initial | Partial<IPactCommand> | The initial Pact command values that you want to reuse. Code example (typescript): const builder: ITransactionBuilder = createTransactionBuilder(initialPactCommand); Examples To create a transaction builder with network and chain already set: Code example (typescript): // Pre-configure the builder export const txBuilder = createTransactionBuilder({ networkId: \"mainnet01\", meta: { chainId: \"1\" } }); // Then somewhere in the code const command = txBuilder. execution(Pact. modules. coin. transfer(senderAccount, receiverAccount, amount)). addSigner(senderKey, (signFor) => [ signFor('coin. GAS'), signFor('coin. TRANSFER', senderAccount, receiverAccount, amount), ]). setMeta({ senderAccount }) const output = const output = { payload: {. . . [code continues] Signing transactions After creating the command, you need to sign it using the appropriate private keys. The signing process is usually managed with a wallet. Kadena has two protocols for signing transactions, each serving different purposes: - Sign API: This API allows users to send their sign requests to the wallet. The wallet is then responsible for creating and signing the transaction simultaneously. With this approach, the wallet has more freedom, making it more suitable for simple transactions. - Quicksign: This API is designed to give dApps full control over the command, with the wallet only responsible for adding signatures. This is the recommended method if you are using the command builder from this library. Wallets typically have their own API for communicating with applications. You can use the API provided by the wallet, or, depending on the wallet, use one of the wallet-specific wrapper functions for convenience. Sign function interface The sign function can be used two ways: If you pass a single transaction to the function, it returns the single signed (or partially signed) transaction. If you pass a list of transactions to the function, it returns the list of signed (or partially signed) transactions. Code example (typescript): interface ISignFunction { (transaction: IUnsignedCommand): Promise<ICommand | IUnsignedCommand>; ( transactionList: IUnsignedCommand[], ): Promise<Array<ICommand | IUnsignedCommand>>; } Single transaction Parameter | Type | Description tx | IUnsignedCommand | The transaction to be signed. List of transactions Parameter | Type | Description tsList | IUnsignedCommand[] | List of the transactions to be signed. Chainweaver You can use createSignWithChainweaver to sign a transaction using Chainweaver. It's a factory function that returns the actual sign function. This function uses the quicksign protocol. Code example (typescript): createSignWithChainweaver(options: { host? : string }): ISignFunction Parameter | Type | Description option | object | option including host URL default { host: 'http: //127. 0. 0. 1: 9467' } Examples To sign one transaction using Chainweaver: Code example (typescript): const signWithChainweaver = createSignWithChainweaver(); const transaction = Pact. builder. execution(Pact. modules. coin. transfer(senderAccount, receiverAccount, amount)). addSigner(senderKey, (signFor) => [ signFor('coin. GAS'), signFor('coin. TRANSFER', senderAccount, receiverAccount, amount), ]). setMeta({ chainId: '0', senderAccount }). setNetworkId(NETWORKID). createTransaction(); const signedTx = signWithChainweaver(transaction); To sign two transactions using Chainweaver: Code example (typescript): const signWithChainweaver = createSignWithChainweaver(); const [txOneSigned, txTwoSigned] = signWithChainweaver([txOne, txTwo]); WalletConnect The WalletConnect protocol and helper functions are based on KIP-017. You must use the WalletConnect protocol to create a walletConnect client and session before you can use the helper functions to sign transactions. Wallet Connect sign method The createWalletConnectSign function returns the sign function using the sign protocol. The return object might contain different data than what you would pass from the transaction builder because the sign protocol lets the wallet create the transaction. Code example (typescript): createWalletConnectSign(client, session, walletConnectChainId): (transaction: IUnsignedCommand): Promise<ICommand | IUnsignedCommand> Parameter | Type | Description client | Client | The wallet-connect client object. session | SessionTypes. Struct | The wallet-connect session object. networkId | string | The network identifier, for example, mainnet01 or testnet04. The identifier can include the kadena: prefix, for example, kadena: mainnet01. Examples Code example (typescript): const signWithWalletConnect = createWalletConnectSign( client, session, 'mainnet01', ); const signedTx = signWithWalletConnect(tx); Wallet Connect quicksign method The createWalletConnectQuicksign function returns the sign function using thequicksign protocol. Code example (typescript): createWalletConnectQuicksign(client, session, walletConnectChainId): ISignFunction Parameter | Type | Description client | Client | The wallet-connect client object. session | SessionTypes. Struct | The wallet-connect session object. networkId | string | The network identifier, for example, mainnet01 or testnet04. The identifier can include the kadena: prefix, for example, kadena: mainnet01. Examples Code example (typescript): const quicksignWithWalletConnect = createWalletConnectQuicksign( client, session, 'mainnet01', ); const signedTx = quicksignWithWalletConnect(tx); EckoWallet The following functions provide the sign and quicksign protocols for EckoWallet to return a sign function and other properties: Code example (typescript): const { isInstalled, isConnected, connect } = createEckoWalletSign(); const { isInstalled, isConnected, connect } = createEckoWalletQuicksign(); isInstalled You can use isInstalled to check if the EckoWallet extension is installed in the browser. Code example (typescript): isInstalled(): boolean isConnected You can use isConnected to check if the application is already connected to EckoWallet. Code example (typescript): isConnected(): Promise<boolean> connect You can use connect to send a connection request to EckoWallet. Code example (typescript): connect(networkId: string): Promise<boolean> createEckoWalletSign The createEckoWalletSign function uses the sign protocol to communicate with EckoWallet. The return object might contain different data than what you would pass from the transaction builder because the sign protocol lets the wallet create the transaction. Code example (typescript): createEckoWalletSign(options: { host? : string }): (transaction: IUnsignedCommand): Promise<ICommand | IUnsignedCommand> Examples To sign a transaction using EckoWallet: Code example (typescript): const signWithEckoWallet = createEckoWalletSign(); // the wallet will create the completed one const partialTx = Pact. builder. execution(Pact. modules. coin. transfer(senderAccount, receiverAccount, amount)). addSigner(senderKey, (signFor) => [ signFor('coin. GAS'), signFor('coin. TRANSFER', senderAccount, receiverAccount, amount), ]). setMeta({ chainId: '0' }). setNetworkId(NETWORKID). createTransaction(); const signedTx = signWithEckoWallet(partialTx); createEckoWalletQuicksign The createEckoWalletQuicksign function uses the quicksign protocol to communicate with EckoWallet. Code example (typescript): createEckoWalletQuicksign(options: { host? : string }): ISignFunction Examples To sign one transaction using the quicksign protocol and EckoWallet: Code example (typescript): const quicksignWithEckoWallet = createEckoWalletQuicksign(); const tx = Pact. builder. execution(Pact. modules. coin. transfer(senderAccount, receiverAccount, amount)). addSigner(senderKey, (signFor) => [ signFor('coin. GAS'), signFor('coin. TRANSFER', senderAccount, receiverAccount, amount), ]). setMeta({ chainId: '0', senderAccount }). setNetworkId(NETWORKID). createTransaction(); const signedTx = quicksignWithEckoWallet(partialTx); To sign two transactions using the quicksign protocol and EckoWallet: Code example (typescript): const quicksignWithEckoWallet = createEckoWalletQuicksign(); const [txOneSigned, txTwoSigned] = quicksignWithEckoWallet([txOne, txTwo]); Sign with a public and secret key pair If you have a secret key in a safe environment—for example, a server environment or CI test pipeline—you can sign transactions with the createSignWithKeypair function to returns the sign function. The IKeyPair interface is defined as followis: Code example (typescript): interface IKeyPair { publicKey: string; secretKey: string; } Code example (typescript): createSignWithKeypair(keyOrKeys: IKeyPair | IKeyPair[]): ISignFunction Examples To sign with one key pair: Code example (typescript): const signWithKeypair = createSignWithKeypair({ publicKey, secretKey }); const tx = Pact. builder. execution(Pact. modules. coin. transfer(senderAccount, receiverAccount, amount)). addSigner(senderKey, (signFor) => [ signFor('coin. GAS'), signFor('coin. TRANSFER', senderAccount, receiverAccount, amount), ]). setMeta({ chainId: '0', senderAccount }). setNetworkId(NETWORKID). createTransaction(); const signedTx = signWithKeypair(tx); To sign with several key pairs: Code example (typescript): const signWithKeypair = createSignWithKeypair([firstKeyPair, secondKeyPair]); const signedTx = signWithKeypair(tx); addSignatures If you already have the signature for a transaction, you can use the addSignatures function to add the signature to the transaction. All signatures you add should either include a public key, or none of them should. If the signatures don't include the public keys, then the number of signatures must match the number of signers, and the signatures are matched based on their order. Code example (typescript): addSignatures(transaction, . . . signatures): IUnsignedCommand | ICommand Parameter | Type | Description transaction | IUnsignedCommand | The partially signed or unsigned transaction. . . . signatures | Array of objects or strings { sig: string; pubKey: string } or { sig: string } | List of signatures to be added to the transaction. Examples To add a signature manually with a public key: Code example (typescript): const signedTx = addSignatures(partiallySignedTx, { sig: 'signature-str', pubKey: 'publicKey', }); To add a signature based on the signer order: Code example (typescript): const signedTx = addSignatures( twoSignersTx, { sigOne: 'signature-str' }, { sigTwo: 'signature-str' }, ); Communicating with the network Kadena exposes endpoints for communicating with Chainweb nodes through the [Pact REST API}(https: //api. chainweb. com/openapi/pact. html). You can use any REST client to call these endpoints. However, the Kadena client library also provides functions to make these call more convenient for frontend frameworks. createClient To use the helper functions for communicating with Chainweb nodes, you must first use the createClient function to return the IClient interface. Code example (typescript): createClient( host? : string | (options: {chainId: ChainId; networkId: string}) => string, options? : { confirmationDepth? : number } ): IClient interface IClient { getStatus: (transactionDescriptors: ITransactionDescriptor[] | ITransactionDescriptor) => Promise<IPollResponse>; submit: { (transaction: ICommand): Promise<ITransactionDescriptor>; (transactionList: ICommand[]): Promise<ITransactionDescriptor[]>; } send: { (transaction: ICommand): Promise<ITransactionDescriptor. . . [code continues] You can use object destructuring to extract specific functions. Code example (typescript): const { submit, local, pollCreateSpv } = createClient(); Parameter | Type | Description host | string \\ | (options: {chainId: ChainId; networkId: string}) => string | The Pact service URL as a string or the function that returns the URL. options | { confirmationDepth? : number } | Additional options for the client. It has only one property now: confirmationDepth, which can be used in the poll endpoint. Default value is 0. Both host and options are optional. The default value of host is a function that returns the Chainweb node URLs for mainnet and testnet. If you want to use different URLs, you must specify the host parameter. The networkId and chainId parameters are read from the command object and passed to the URL generator function. Examples To create a client for the development network and a specific chain identifier (1): Code example (typescript): const client = createClient( 'http: //127. 0. 0. 1: 8080/chainweb/0. 0/development/chain/1/pact', ); To create a client for the development network that covers multi-chain and uses the URL generator function for more flexibility: Code example (typescript): const devNetClient = createClient( ({ chainId, networkId }) => http: //127. 0. 0. 1: 8080/chainweb/0. 0/${networkId}/chain/${chainId? ? '1'}/pact, ); To create a client that uses mainnet but not Kadena main network nodes: Code example (typescript): const client = createClient(({ chainId, networkId }) => { switch (networkId) { case 'mainnet01': return http: //my-node-url/chainweb/0. 0/${networkId}/chain/{${chainId}}/pact; case 'testnet04': return http: //my-test-node-url/chainweb/0. 0/${networkId}/chain/{${chainId}}/pact; default: throw new Error('UNKNOWNNETWORK'); } }); To create a client with a confirmationDepth of 5 that waits for five new blocks to be added to the chain before reading the result of a transaction: Code example (typescript): const { submit, pollStatus } = createClient(undefined, { confirmationDepth: 5, }); Submitting transactions You can use the submit or submitOne functions to submit data to the blockchain. These functions use the Pact /send endpoint. The client send function is a deprecated alias for the submit function with the same interface. To submit one transaction using the submit function: Code example (typescript): const { submit } = createClient(); submit(tx): Promise<ITransactionDescriptor>; interface ITransactionDescriptor { networkId: string; chainId: ChainId; requestKey: string } Parameter | Type | Description tx | ICommand | The command object ready to submit. To submit a list of transactions using the submit function: Code example (typescript): const { submit } = createClient(); submit(txList): Promise<ITransactionDescriptor[]>; Parameter | Type | Description txList | ICommand[] | List of command objects ready to submit. In most cases, you should store the result of this function so you can fetch the result of the request. The submitOne function is the same as submitting one transaction using the submit function. For example: Code example (typescript): const { submitOne } = createClient(); submitOne(tx): Promise<ITransactionDescriptor>; Parameter | Type | Description tx | ICommand | The command object ready to submit. Getting transaction results After you submit a transaction, you need to query for the result using a request key. You can query transaction results by calling the /listen or /poll endpoint. - The /listen endpoint is a blocking request. It only accepts one request key and returns the results when the transaction result is ready. If you use this endpoint, the HTTP request remains open for a while. - The/poll endpoint accepts a list of request keys and responds immediately with the current status of the request key. The Kadena client library exposes the following functions to use the /listen or /poll endpoint in different scenarios: - getStatus - pollStatus - listen - pollOne These functions all return the result of a transaction with the following ICommandResult interface: Code example (typescript): interface ICommandResult { reqKey: string; txId: number | null; result: | { status: 'success'; data: PactValue; } | { status: 'failure'; error: object; }; gas: number; logs: string | null; // for defpact functions continuation: null | { pactId: PactTransactionHash; step: Step; stepCount: number; executed: boolean | null; stepHasRollback: boolean; continuation: { def: string; args: PactValue; . . . [code continues] getStatus This function calls /poll and returns the result of requests. Code example (typescript): const { getStatus } = createClient(); getStatus(transactionDescriptor: TransactionDescriptor[] | ITransactionDescriptor): Promise<{ [requestKey: IBase64Url]: { [requestKey: string] ICommandResult}; }> Parameter | Type | Description transactionDescriptor | TransactionDescriptor[list] | One or more request keys to be queried pollStatus This function calls /poll in intervals and returns the result of all requests when all are ready. Code example (typescript): const { pollStatus } = createClient(); pollStatus( transactionDescriptor: TransactionDescriptor[] | ITransactionDescriptor, pollOptions: { onPoll? : (id: string) => void; timeout? : Milliseconds; interval? : Milliseconds; confirmationDepth? : number; } ): IPollRequestPromise<{ [requestKey: IBase64Url]: { [requestKey: string] ICommandResult}; }> interface IPollRequestPromise extends Promise { [requestKey: IBase64Url]: Promise<ICommandResult> } Parameter | Type | Description transactionDescriptor | TransactionDescriptor[list] | One or more request keys to be queried. pollOptions | object | Optional poll configuration settings. onPoll | string | Identifier for the callback that is called each time the node is polled for the status of a request key. This callback might be called several times if the request is not ready yet. timeout | time | Specifies a timeout in milliseconds to stop polling if the result is not ready. The default is 180000 milliseconds (3 minutes). interval | time | Specifies the delay between retry attempts. The default is 5000 milliseconds (5 seconds). confirmationDepth | number | Sets the confirmationDepth for getting the response. This setting overrides the one you set in the createClient function. Return value The return value is a special type of promise that enables you to listen for each individual request through the requests property. Alternatively, you can await the result without using the requests property to handle most use cases. Examples Poll the status of a request: Code example (typescript): const result = await pollStatus(request, {}); Poll the status of several requests and get the result for each one immediately: Code example (typescript): const resultPromise = pollStatus([firstRequest, secondRequest, thirdRequest]); // Notify the UI from the result of each request as soon as it's available resultPromise. requests['first-request-key']. then((res) => { UI. notify(res); }); resultPromise. requests['second-request-key']. then((res) => { UI. notify(res); }); resultPromise. requests['third-request-key']. then((res) => { UI. notify(res); }); // The final result object const finalResult = await resultPromise; listen listen is another function for fetching the result of one request. It uses the /listen endpoint, which is a blocking endpoint. Note: If your network or firewall configuration doesn't allow keeping HTTP connections open for a long time, then it's better to use pollOne which has the same interface but uses /poll under the hood. Code example (typescript): const { listen } = createClient(); listen(transactionDescriptor: TransactionDescriptor[] | ITransactionDescriptor): Promise<ICommandResult> Parameter | Type | Description transactionDescriptor | TransactionDescriptor | The request object including requestKey, networkId, and chainId. pollOne The pollOne function fetches the result of only one request using the /poll endpoint. Code example (typescript): const { pollOne } = createClient(); pollOne(transactionDescriptor: TransactionDescriptor[] | ITransactionDescriptor): Promise<ICommandResult> Parameter | Type | Description transactionDescriptor | TransactionDescriptor | The request object including requestKey, networkId, and chainId. Reading data Apart from transactions, you can also send read requests to the node. This mainly utilizes the /local endpoint. These kinds of requests return the result immediately since you don't need to submit data. You can also use these functions to validate your transaction before calling the /send endpoint to avoid transaction failure, as in some scenarios you need to pay gas even for failed transactions. The following functions all use the /local endpoint: - local - dirtyRead - preflight - signatureVerification - runPact local The local function is the most generic function that utilizes the /local endpoint. Code example (typescript): local( transaction: ICommand | IUnsignedCommand, options? : { preflight? : boolean; signatureVerification? : boolean; } ): Promise<ICommandResult & { preflightWarnings? : string[] }>; The return type is ICommandResult with preflightWarnings when it is set to true. Parameter | Type | Description transaction | ICommand or IUnsignedCommand | The signed or unsigned command object. options | object | Optional configuration settings. preflight | boolean | Runs the code in the preflight mode to simulate submitting the transaction. You can also use this option to preview the estimated gas that the transaction would consume. The default is true. signatureVerification | boolean | Runs the signature verification in the node for the transaction. The default is true. Examples Use a local call to avoid submitting an incorrect transaction: Code example (typescript): // Check if the transaction and signatures are correct const response = await client. local(signedTx); if (response. result. status === 'failure') { // Throw if the transaction fails to avoid paying gas for a failed transaction throw response. result. error; } const request = await client. submit(signedTx); Use local call for gas estimation: Code example (typescript): // We don't need to send signatures to check gas estimation; const response = await client. local(unsignedTx, { preflight: true, signatureVerification: false, }); if (response. result. status === 'failure') { throw response. result. error; } const gasEstimation = response. gas; dirtyRead Alias for local where both preflight and signatureVerification are false. This function is useful when your code only needs to read data from the node. Code example (typescript): dirtyRead(transaction: ICommand | IUnsignedCommand): Promise<ICommandResult>; Parameter | Type | Description transaction | ICommand or IUnsignedCommand | The signed or unsigned command object Examples Get account balance Code example (typescript): const tr = Pact. builder. execution(Pact. modules. coin'get-balance'). setMeta({ chainId: '0' }). setNetworkId('mainnet04'). createTransaction(); // We don't need to submit a transaction for just reading data, // so instead we just read the value from the local data of the blockchain node const res = await dirtyRead(tr); if (res. result. status === 'failure') { throw res. result. error; } const balance = res. result. data; preflight Alias for local where preflight is true but signatureVerification is false. Code example (typescript): preflight(transaction: ICommand | IUnsignedCommand): Promise<ICommandResult>; Parameter | Type | Description transaction | ICommand or IUnsignedCommand | The signed or unsigned command object signatureVerification Alias for local where preflight is false but signatureVerification is true. Code example (typescript): signatureVerification(transaction: ICommand | IUnsignedCommand): Promise<ICommandResult & { preflightWarnings? : string[] }>; Parameter | Type | Description transaction | ICommand or IUnsignedCommand | The signed or unsigned command object runPact If you just want to see the result of a pact code and don't want to create a command object, you can use the runPact function. This function creates a command object internally. Code example (typescript): runPact(code: string, data? : Record<string, unknown>, options? : { chainId: ChainId; networkId: string }): Promise<ICommandResult>; Parameter | Type | Description code | string | Pact code data | Record, string, or unknown | Data to be sent with the transaction options | object chainId | string | Specifies the chain identifier that you want to send the transaction to. The valid values are \"0\" to \"19\". networkId | string | Specifies the network identifier that you want to send the transaction to. Examples Code example (typescript): const { runPact } = createClient(); const result = await runPact( (coin. getBalance \"alice\"), {}, { networkId: 'mainnet01', chainId: '1' }, ); Requesting simple payment verification (spv) You need SPV proof mainly for cross-chain transactions - but it's not limited to this, and you can request SPV proof for all kinds of transactions. There are two functions for this purpose, both of which use the /spv endpoint: - createSPV - pollCreateSPV createSPV Request SPV proof if it's ready. Code example (typescript): createSpv(transactionDescriptor: ITransactionDescriptor, targetChainId: ChainId): Promise<string>; Parameter | Type | Description transactionDescriptor | object | Specifies the request key, network identifier, and chain identifier for the transaction that you want to create a simple payment verification (spv) proof for. targetChainId | string | Specifies the chain identifier that consumes this proof. pollCreateSPV Poll for the SPV proof and await until it's ready. Code example (typescript): pollCreateSpv( transactionDescriptor: ITransactionDescriptor, targetChainId: ChainId, pollOptions? : { onPoll? : (id: string) => void; timeout? : Milliseconds; interval? : Milliseconds; } ): Promise<string>; Parameter | Type | Description transactionDescriptor | object | Specifies the request key, network identifier, and chain identifier for the transaction that you want to create a simple payment verification (spv) proof for. targetChainId | string | Specifies the chain identifier that consumes this proof. pollOptions | object | Optional poll configuration settings. onPoll | string | Identifier for the callback that is called each time the node is polled for the status of a request key. This callback might be called several times if the request is not ready yet. timeout | time | Specifies a timeout in milliseconds to stop polling if the result is not ready. The default is 180000 milliseconds (3 minutes). interval | time | Specifies the delay between retry attempts. The default is 5000 milliseconds (5 seconds). Examples Code example (typescript): const request = await submit(crossChainTx); const response = await pollOne(request); // create spv proof for the transaction const spvProof = await pollSpvProof(request); const continuationTx = Pact. builder. continuation({ pactId: response. continuation. pactId, rollback: false, step: 1, proof: spvProof, }). addMeta({ chainId: targetChainId, // using gas station for paying gas fee senderAccount: 'kadena-xchain-gas', }). createTransaction(); const contRequest. . . [code continues] Functional programming to compose Pact commands For additional flexibility, you can use the functional programming (FP) API to create Pact commands. The functional programming (FP) API supports the same functions as the command builder API. In fact, the command builder API uses the functional programming (FP) API under the hood. To reduce redundancy, this section lists the common functions with examples for using the composePactCommand function rather than repeating the full function descriptions and parameter tables. Importing functions To use the functional programming (FP) API, import functions from the @kadena/client/fp package. For example: Code example (typescript): import { composePactCommand, execution } from '@kadena/client/fp'; composePactCommand The composePactCommand function let you compose parts of the Pact command and create the final command objects. The function accepts pure JSON as well as reducer functions. This function eventfully returns the IPartialPactCommand interface that is converted to a string for the cmd key in the JSON command object. Code example (typescript): type CommandReducer = (cmd? : IPartialPactCommand | (() => IPartialPactCommand)) => IPartialPactCommand; composePactCommand(. . . reducersOrPartialCommands: Array<IPartialPactCommand | CommandReducer> ): CommandReducer The return value is also a CommandReducer function that you can pass to another composePactCommand call. Eventually, when you call the function, it also adds the default values. Parameter | Type | Description. . . reducersOrPartialCommands | Array <IPartialPactCommand \\ | CommandReducer> | List of command reducers or partial Pact commands. Examples Code example (typescript): const pactCommand = composePactCommand( { payload: { exec: { code: '(+ 1 1)' } } }, (cmd) => ({. . . cmd, meta: { chainId: '1' } }), { networkId: 'testnet04' }, )(); const pactCommand = { payload: { exec: { code: '(+ 1 1)' } }, meta: { gasLimit: 2500, gasPrice: 1e-8, sender: '', ttl: 28800, creationTime: 1690416000, chainId: '1', }, networkId: 'testnet04', nonce: 'kjs: nonce: 1690416000000', signers: [], }; execution To create IPactCommand. payload. exec. code: Code example (typescript): execution(. . . codes): { payload: { exec: { code: string, data: {} } }} For example, using strings: Code example (typescript): const command: IPactCommand = composePactCommand( execution((coin. transfer \"alice\" \"bob\" 1. 1)), )(); For example, using Pact. modules: Code example (typescript): const command: IPactCommand = composePactCommand( execution(Pact. modules. coin. transfer('alice', 'bob', { decimal: '1. 1' })), )(); continuation To create IPactCommand. payload. cont: Code example (typescript): continuation(contData: { pactId? : string; step? : number; rollback? : boolean; data? : Record<string, unknown>; proof? : string | null; }): { payload: { cont: { pactId? : string; step? : number; rollback? : boolean; data? : Record<string, unknown>; proof? : string | null; }; }; }; For example: Code example (typescript): const command: IPactCommand = composePactCommand( continuation({ pactId, rollback: false, step: 1, proof: spvProof, }), )(); addSigner To add IPactCommand. signers: Code example (typescript): addSigner(signerOrSignersList, capabilityCallback): CommandReducer; For example, add a signer: Code example (typescript): // ED25519 key const alicePublicKey = 'e7f4da07b1d200f6e45aa6492afed6819297a97563859a5f0df9c54f5abd4aab'; composePactCommand( execution(Pact. modules. coin. transfer('alice', 'bob', { decimal: '1. 1' })), addSigner(alicePublicKey, (signFor) => [ signFor('coin. TRANSFER', 'alice', 'bob', { decimal: '1. 1' }), ]), ); Add a signer with WebAuthn scheme: Code example (typescript): composePactCommand( execution(Pact. modules. coin. transfer('alice', 'bob', { decimal: '1. 1' })), addSigner({ pubKey: webAuthnPublicKey, scheme: 'WebAuthn' }, (signFor) => [ signFor('coin. TRANSFER', 'alice', 'bob', { decimal: '1. 1' }), ]), ); Add a list of signers with no capabilities: Code example (typescript): composePactCommand( execution('(free. my-module. my-function)'), addSigner([ 'ED25519publicKey', { pubKey: 'WebAuthnpublicKey', scheme: 'WebAuthn' }, ]), ); Add a list of signers with similar capabilities: Code example (typescript): const pactCommand = composePactCommand( execution(Pact. modules. coin. transfer('alice', 'bob', { decimal: '1. 1' })), // e. g. , Alice's account is guarded by two keys addSigner(['firstpublicKey', 'secondpublicKey'], (signFor) => [ signFor('coin. TRANSFER', 'alice', 'bob', { decimal: '1. 1' }), ]), )(); const equivalentPactCommand = { payload: { exec: { code: '(coin. transfer \"alice\" \"bob\" 1. 1 )', data: {}, }, }, signers: [ { pubKey: 'firstpublicKey', . . . [code continues] addData To add data to IPactCommand. payload. exec. data or IPactCommand. payload. cont. data: Code example (typescript): addData(key, value): CommandReducer For example, to transfer with parameters in data: Code example (typescript): composePactCommand( execution( '(coin. transfer (read-string \"sender\") (read-string \"receiver\") 1. 1)', ), addData('sender', sender), addData('receiver', sender), ); Send the receiver guard: Code example (typescript): composePactCommand( execution( '(coin. transfer-create \"alice\" \"bob\" (read-keyset \"bob-guard\") 1. 1)', ), addData('bob-guard', { keys: ['bob-public-key'], pred: 'keys-all', }), ); addKeyset To add a keyset: Code example (typescript): addKeyset(name, pred, . . . keys): CommandReducer For example, to add a keyset using the readKeyset helper function: Code example (typescript): composePactCommand( execution( Pact. modules. coin'transfer-create', { decimal: '1. 1' }, ), ), addKeyset('bob-guard', 'keys-all', 'bob-public-key'), ); setMeta To add IPactCommand. meta metadata properties to a command: Code example (typescript): setMeta(meta): CommandReducer For example: Code example (typescript): composePactCommand( execution('(coin. transfer \"alice\" \"bob\" 1. 1)'), // \"bob is paying gas fee\" setMeta({ chainId: '02', senderAccount: 'bob' }), ); etNonce To manually set IPactCommand. nonce: Code example (typescript): setNonce(nonce): { nonce: string }; For example: Code example (typescript): composePactCommand( execution('(coin. transfer \"alice\" \"bob\" 1. 1)'), // \"bob is paying gas fee\" setNonce('a-custom-nonce'), ); setNetworkId To set IPactCommand. network: Code example (typescript): setNetworkId(networkId): { networkId: string } For example: Code example (typescript): composePactCommand( execution('(coin. transfer \"alice\" \"bob\" 1. 1)'), // \"bob is paying gas fee\" setNetworkId('testnet04'), ); createTransaction To create the transaction object: Code example (typescript): createTransaction(pactCommand: IPactCommand): IUnsignedCommand For example: Code example (typescript): const pactCommand = composePactCommand( execution(Pact. modules. coin. transfer(senderAccount, receiverAccount, amount)), addSigner(senderKey, (signFor) => [ signFor('coin. GAS'), signFor('coin. TRANSFER', senderAccount, receiverAccount, amount), ]), setMeta({ chainId: '0', senderAccount }), setNetworkId(NETWORKID), createTransaction(), ); const transaction = createTransaction(pactCommand); const output = { cmd: '{\"payload\": {\"exec\": {\"code\": \"(coin. transfer \\\\\"k: dc20ab800b0420b. . . [code continues]",
    "source": "reference/kadena-client.md",
    "title": "Kadena TypeScript client"
  },
  {
    "content": "Benchmarks and calculations to help you understand expected execution times. There are a number of factors that influence the time it takes to execute transactions, including network topology and the performance of individual nodes. This section provides benchmarks, estimations, and calculations to help you better understand the time it takes to execute transactions on Chainweb nodes under different circumstances. Single chain transactions On average, single chain transactions take approximately 45 seconds. However, transactions can take much longer than 45 seconds, in particular, if there are mining delays. To give you better insight into how transactions are executed, the following example describes the workflow for a single chain transaction. You start a transaction by submitting a formatted request to the /send endpoint on a node. The code provided by the /send endpoint performs some simple initial checks that validate the transaction has a reasonably high chance of being executed successfully. These initial checks ensure that you learn if a transaction is invalid as soon as possible. If the transaction passes the initial checks, the /send process adds the transaction to the mempool for the local node. The transaction is then gossiped to remote nodes, and, eventually, one of the nodes is selected to mine the next block, and the node includes the transaction in that block. After the mined block is added to its target chain, the block with the transaction result is synchronized on the local node, and a request to the /poll endpoint returns the transaction result. Under normal load, the initial checks should take less than a millisecond for a single transaction. However, if a node in under heavy load—for example, because the PactService is contending with a high volume of /local or /send calls or because the node is catching up—you might experience delays in sending or polling transactions. It's worth noting that if a node is too busy, it will always prioritize staying caught up over sending transactions. The propagation of transactions in the mempool to other nodes takes, on average, 10 seconds, but it can take longer if there are networking delays, such as increased network traffic or slow network connections between nodes. Block propagation back to the local node is usually a matter of seconds. Cross-chain transfers As discussed in Transaction format and flow, a cross-chain transfer is essentially two separate but related transactions. The time it takes to complete a cross-chain transfer can depend on several factors, including the physical distance between the chain nodes in the network, network congestion, and the synchronization of state between the chains involved. For two distant chains—representing the worst case—a cross-chain transfer is expected to take the following time to complete: - The initiating transaction has an average time from submission to completion of 45 seconds. - With the current 20-chain graph, two blocks at most must be propagated to the target chain so that the source and target chain share the same view of state, with an average time of 30 seconds per block. The number of blocks that must be propagated will increase as more chains are added, and will depend on the distance between the chains. - The continuation step is a second transaction, again with an average time of 45 seconds. Therefore, a cross-chain transfer typically takes 2 minutes and 30 seconds to complete. If either the source or target chain is ahead of the other chain, more blocks might be required to synchronize the chains before the transaction can complete, in which case the transfer might take additional time. Local execution In general, calls to the Chainweb /local endpoint return results almost immediately. Depending on how long it takes to execute the Pact code in a transaction, you can typically expect to see results from /local call within seconds, at most. However, it's important to know that /local calls are executed on a single chain and served in a single-threaded, first-come-first-served basis. If a node is under contention—because it's catching up with state, busy processing multiple /local calls, or performing mempool checks—execution could take as long as needed for the request to be serviced in the queue. Block production On average, producing a block takes 30 seconds. The actual time it takes to produce any given block depends on the time required to prepare the block for mining, and the time it takes to mine the block. Before a block can be mined on any chain, it must satisfy specific requirements. To give you better insight into how blocks are produced, the following example describes the workflow and requirements for mining a block. For this example, the target chain for the block is chain 1 on a Kadena network with 20 chains. To start block production on chain 1, the new block candidate must provide the following inputs: - The block header for a block that exists on chain 1 to serve as the parent of the new block. - The block headers for the parent block of the new block on the adjacent chains, which are currently chains 6, 11, and 18 for chain 1. - The sequence of transactions in the new block and the output from running the transactions in the new block. - The nonce and creation time for the new block, which are set by the miner. Block parents and orphans If the block selected to serve as the parent of the new candidate block is superseded by the arrival of a new block on the target chain, the block production process must start over with the new parent block. If the block production process starts over, the new block candidate that was being processed is no longer valid for the continuity of the chain and is deemed an orphaned block. Block height and payload The next step in the block production process involves two requirements that are satisfied in parallel. - The first requirement is to determine whether the chains that are adjacent to the target chain in the chain graph have any blocks at the same height as the parent block. If the adjacent chains have blocks at the same height as the parent block, a new block can be created while satisfying the braiding requirement of the Chainweb protocol. - The second requirement is to produce the block payload on the target chain. Producing the payload involves querying the mempool for a set of transactions that can fit in the block, and executing those transactions on the Pact state. Currently, the gas limit for a block is 150000, and each unit of gas can represent up to 2. 5 microseconds of execution time, leading to a maximum execution time of 375 milliseconds. However, node contention can increase the maximum execution time up to 600 milliseconds. Mining work After the block production requirements are met—that is, the block payload, parent block, and the adjacent parent blocks have been validated—the new block can be mined and added to the target chain. Miners make a request to the node and can receive a new block on any chain that has a new block ready. Mining time follows an exponential distribution where the mean time is such that the average total block time is 30 seconds. Because other parts of the block production process take some time as well, mining time will actually be less than 30 seconds on average. After mining is successful, the new block candidate is added to the target chain on the mining node, and then sent around the chainweb network for other nodes to see. Mining per block Mining a block takes 16 seconds on average with the current 20-chain graph. With the average block production time of 30 seconds and the current 20-chain graph, mining accounts for roughly half of the time it takes to advance each chain by one block. The average time it takes to mine a block is likely decrease as more chains are added. However, the total block production time is expected to remain about 30 seconds on average because chains might spend more time blocked from creating new blocks. In most cases, this delay is caused by adjacent chains that have not yet advanced to the block height required for the target chain to add a new block.",
    "source": "reference/latency.md",
    "title": "Chainweb execution and latency"
  },
  {
    "content": "Describes the schemas, tables, capabilities, and functions defined in the collection policy contract enable you to manage a token collection. The collection policy implements the kip. token-policy-v2 interface to simplify how you can organize tokens into collections. This part of the documentation describes the functions and capabilities defined in the collection policy contract. Source code: collection-policy. pact Schemas and tables The collection schema describes the following information for a token collection: id: string name: string size: integer max-size: integer operator-guard: guard operator-account: string This information is stored in the collection table. The token schema describes the following information for a token in a collection: id: string collection-id: string This information is stored in the token table. Capabilities The collection policy smart contract defines the following capabilities to manage permissions: - GOVERNANCE: Restricts authority to the marmalade-admin keyset and ensures only authorized entities can upgrade the contract. - COLLECTION @event: Regulates collection creation and broadcasts of the COLLECTION event. - TOKEN-COLLECTION @event: Manages token addition to collections and announces such additions. Functions The dutch auction contract defines the following functions to manage token collections: - create-collection: Initiates a collection by defining its name, size, and overseeing entity. - enforce-init: Adds tokens to the collection while abiding by the collection's set size. It also determines the entity permitted to mint the token. - enforce-mint: Ascertain that the minting entity has appropriate permissions. - create-collection-id: Retrieves a collection identifier using the collection's name. - get-collection: Extracts collection details using a collection ID. - get-token: Gleans token details, focusing on its association with a collection, via the token ID.",
    "source": "reference/marmalade/collection-policy.md",
    "title": "Collection policy"
  },
  {
    "content": "Describes the capabilities, schemas, tables, functions, and constants defined in the sales-specific contracts for a conventional auction. Conventional auction sale contract This section provides reference information for writing a smart contract to conduct a conventional auction using Marmalade on the Kadena network. The reference information includes the capabilities, schemas, tables, functions, and constants defined for a conventional auction. Source code: conventional-auction. pact Capabilities The conventional auction smart contract defines the following capabilities to manage permissions: - GOVERNANCE: Defines governance for the contract and is controlled by the keyset defined under the ADMIN-KS constant. - AUCTIONCREATED: Specifies the event emitted when the create-auction function is executed. The emitted event includes the sale-id, token-id, and escrow fields. - MANAGEAUCTION: Identifies a guard to control who can create and update an auction. You must specify the sale-id and token-id parameters when you use this capability in create-auction and update-auction functions. - BIDPLACED: Specifies the event emitted when a bid is place. The emitted event includes the bidder? , bid-amount, and timestamp fields. - PLACEBID: Ensures that the bidder signs the transaction to place the bid. - REFUNDCAP: Protects funds held in escrow to ensure refunds can be made, if necessary. Schemas The conventional auction smart contract defines two schemas. The auctions-schema describes the following information for a conventional auction: - token-id - start-date - end-date - highest-bid - highest-bid-id - reserve-price The bids-schema describes the following information for a conventional auction: - bidder - bidder-guard - bid Tables The conventional auction contract stores auction information in the auctions table and bid information in the bids table. Functions The conventional auction contract defines the following functions to manage token sales using the conventional auction format: - escrow-account: Returns the auction's fungible escrow account name. - escrow-guard: Returns the account guard of the escrow account. - enforce-fungible-transfer: Requires that policy-manager. FUNGIBLETRANSFER_CALL capability is in scope. - enforce-quote-update: Enforces a quote update when required for sale contracts. This function is called by the policy-manager. enforce-buy function to validate that only the winning bidder processes the marmalade. buy call, the escrow payment, and the marketplace fee. - enforce-withdrawal: Enforces a withdrawal when required for sale contracts. This function is called by the policy-manager. enforce-withdraw function to validate that the auction has expired, or that the bid has already been placed. - create-bid-id: Generates a unique bid identifier by hashing the sale-id, bidder, and block-time fields. - create-auction: Allows sellers to create a conventional auction for their token after providing auction information. - update-auction: Allows sellers to update auction information before the auction start time. - retrieve-auction: Retrieves auction information from the auctions table. - retrieve-bid: Retrieves bid information from the bids table. - place-bid: Transfers the bid amount in a fungible currency from the bidder account to an escrow account and records the bids in the blockchain. Constants The conventional auction contract defines the following constant: - ADMIN-KS: Sets the marmalade-sale. marmalade-contract-admin for the GOVERNANCE capability.",
    "source": "reference/marmalade/conventional-auction-ref.md",
    "title": "Conventional auction reference"
  },
  {
    "content": "Provides a technical overview of how to create a custom sales type contract or call an existing sales contract. As discussed in Contract architecture, you can use a sales-specific contract to manage how tokens are sold—for example, by offering tokens for sale in a conventional auction sale contract or a dutch auction sale contract. Although this is a flexible system for managing sales, sales-specific contracts must be registered in the policy manager to ensure that the policy manager can enforce the proper collection and distribution of tokens and funds. Before you can register a sales-specific contract, the contract must be reviewed by an auditor to ensure that the contract logic is safe to use. If you want to create your own sales-specific contract, you can implement the enforce-quote-update interface in your contract, then open a pull request in the Marmalade Github repository to begin the review process. Note that creating a sales-specific contract isn't necessary in most cases. You can implement sales-related logic directly in a policy and attach the policy to a token instead of creating a separate contract. Implement the sale contract interface The sale contract interface is a lightweight interface that must be implemented in any sale contract. The interface is used by the policy manager to enforce the logic defined in the contract. The interface is defined as follows: Code example (pact): (defun enforce-quote-update: bool (sale-id: string price: decimal) @doc \"Read-only Function that is enforced to update quote price at enforce-buy\" ) The function enforce-quote-update is called from the buy step in the ledger and takes two parameters: - sale-id (type: string): This parameter represents the pact-id that is created when the token is offered up for sale in the ledger. - price (type: decimal): This parameter represents the final price associated with the sale. Using a sales-specific contract You can specify the sale contract to use by providing the module name for the contract as part of the quote specification when calling the offer function in the ledger. The following example illustrates the quote specification with the sale-type set to use the marmalade-sale. conventional-auction sale contract: Code example (pact): \"quote\": { \"fungible\": coin, \"sale-price\": 0. 0, \"seller-fungible-account\": { \"account\": \"k: seller\", \"guard\": {\"keys\": [\"seller\"], \"pred\": \"keys-all\"} }, \"sale-type\": \"marmalade-sale. conventional-auction\" } Note that when you reference a specific sale-type, the sale-price for the offer must be 0. 0 because the referenced contract is responsible for updating the final price during the buy step.",
    "source": "reference/marmalade/custom-sales-contracts.md",
    "title": "Custom sales contracts"
  },
  {
    "content": "Describes the capabilities, schemas, tables, functions, and constants defined in the sales-specific contracts for a dutch auction. Dutch auction sale contract This section provides reference information for writing a smart contract to conduct a dutch auction using Marmalade on the Kadena network. The reference information includes the capabilities, schemas, tables, functions, and constants defined for a dutch auction. Source code: dutch-auction. pact Capabilities The dutch auction smart contract defines the following capabilities to manage permissions: - GOVERNANCE: Defines governance for the contract and is controlled by the keyset defined under the ADMIN-KS constant. - AUCTIONCREATED: Specifies the event emitted after the auction is created by the seller. - PRICEACCEPTED: Specifies the event emitted after the buyer successfully executes the marmalade. buy function in a sales contract. - DUMMY: Acts as a placeholder capability for the buyer-guard field. Schema and table The auctions-schema describes the following information for a dutch auction: - token-id - start-date - end-date - start-price - reserve-price - sell-price - price-interval-seconds - buyer - buyer-guard The dutch auction contract stores auction information in the auctions table. Functions The dutch auction contract defines the following functions to manage token sales using the dutch auction format: - enforce-quote-update: Enforces a quote update when required for sale contracts. This function is called by the policy-manager. enforce-buy function to validate that the buyer has transferred the fungible amount equal to current-price set by the dutch auction. The function updates the auctions table with the winner information. - enforce-withdrawal: Enforces a withdrawal when required for sale contracts. This function is called by the policy-manager. enforce-withdraw function to validate that the auction has expired, or that the bid has already been placed. - validate-auction: Validates that the auction information adheres to contract logic in the create-auction and update-auction functions. - create-auction: Allows sellers to create the dutch auction for their token after providing auction information. - update-auction: Allows sellers to update auction information before the auction start time. - retrieve-auction: Retrieves auction information from the auctions table. - get-current-price: Calculates the current auction price by starting with the start-price and gradually reducing the price per price-interval-seconds, always ending with the last time interval at the reserve-price. Constants The dutch auction contract defines the following constants: - ADMIN-KS: Sets the marmalade-sale. marmalade-contract-admin for the GOVERNANCE capability. - DUMMY_GUARD: Acts as a placeholder guard constant for the buyer-guard field.",
    "source": "reference/marmalade/dutch-auction-ref.md",
    "title": "Dutch auction reference"
  },
  {
    "content": "Describes the schemas, tables, capabilities, and functions defined in the guard policy. The guard policy ensures that all token-related actions—minting, burning, transferring, buying, and selling—can only be performed by authorized parties. If you apply the guard policy when you create a token, you can specify who is authorized to perform each type of token activity. This part of the documentation describes the schemas, tables, capabilities, and functions defined in the Marmalade guard policy contract. Source code: guard-policy. pact Schema and table The guard policy smart contract defines one schema and one table. The guards schema describes guard values for mint, burn, sale, and transfer operations. The policy-guards table maps token identifiers to their guard values. Capabilities The guard policy smart contract defines the following capabilities to manage permissions: - GOVERNANCE: Governs contract upgrade access. - GUARDS @event: Emits guard info during enforce-init. - MINT: Applies the mint-guard in enforce-mint. - BURN: Applies the burn-guard in enforce-burn. - SALE: Uses the sale-guard during enforce-offer, enforce-withdraw, and enforce-buy. - TRANSFER: Uses the sale-guard in enforce-transfer. Functions The guard policy smart contract defines the following functions to enforce restrictions of different token activities: - enforce-init: Initializes the policy-guards table with token ID and guard values. - enforce-mint: Validates minting processes. - enforce-burn: Validates burning processes. - enforce-offer: Confirms sale offers with guards and verifies the sale-id. - enforce-withdraw: Checks sale withdrawals and the sale-id. - enforce-buy: Validates buying processes and the sale-id. - enforce-transfer: Validates transfers, checking sender, receiver, and amount.",
    "source": "reference/marmalade/guard-policy.md",
    "title": "Guard policy"
  },
  {
    "content": "Functions and capabilities defined in the Marmalade Ledger contract enable you to manage the token lifecycle and keep track of all token-related activity. The Marmalade token standard provides interfaces that enable you to define, mint, and secure tokens. As discussed in Token standard architecture, the Marmalade ledger contract provides the core functionality to create, manage, and transfer tokens minted using the Marmalade token standard. The ledger contract records and manages all token-related activity to ensure every transaction is accurate, every policy is enforced, and every account is up-to-date. This part of the documentation describes the functions and capabilities defined in the Marmalade ledger contract in the marmalade-v2 namespace. The marmalade-v2 namespace is available on all twenty chains (0-19) in the Kadena test network and the Kadena main network. Source code: ledger. pact create-token-id Use create-token-id to generate a unique token identifier with the specified token identifier. Arguments Use the following arguments to create the token identifier. | Argument | Type | Description | -------- | ---- | ----------- | details | object | Defines token properties using the metadata schema in JSON file format. | creation-guard | guard | Specifies the temporary guard—for example, a keyset—used to generate the token identifier. This guard isn't stored and ensure that only the owner of the creation key can create a specific token identifier. Before creating a token, you must choose a temporary guard. The guard can be - A keyset you've already defined or used in the guard-policy. - A single-use keyset that won't be used again. - Another type guard. This guard becomes part of the hashed data in the token-id string prefixed with t: . Including the guard in the hashed token identifier protects anyone else from creating the token. With this mechanism, only you—as the owner of the creation key—can create the token specified by the token-id string. Example Generate a unique token-id by calling the following function: (ledger. create-token-id details creation-guard) create-token Use create-token to create a token with the specified token identifier. You can apply one or more policies to a token when you create it. Depending on the policies you apply, you might need to grant additional capabilities or pass environment data to execute the function. Arguments Use the following arguments to create a token. | Argument | Type | Description | -------- | ---- | ----------- | id | string | Specifies the unique token identifier generated using the create-token-id function and formatted as t: {token-detail-hash}. | precision | integer | Specifies the number of decimals allowed for the token supply amount. For non-fungible tokens, the precision must be 0, and should be enforced in the policy's enforce-init. | uri | string | Specifies the uniform resource identifier (uri) to an external JSON file containing token metadata. | policies | list| Specifies one or more policy contracts with custom functions to execute at marmalade functions. | creation-guard | guard | Specifies the temporary guard—for example, a keyset—used to generate the token identifier. This guard isn't stored and ensure that only the owner of the creation key can create a specific token identifier. When you submit the create-token transaction, the policy-manager. enforce-init function calls the policy: enforce-init function in the stored token policies and the function is executed. To create a token with this function: - Generate a unique token-id by calling (ledger. create-token-id details creation-guard) - Create the token by calling (ledger. create-token. . . creation-guard) Capabilities The create-token transaction must include the CREATE-TOKEN capability signed with the keyset creation-guard that you used to generate the token identifier. The create-token transaction also requires the marmalade-v2. collection-policy-v1. TOKEN-COLLECTION capability if you apply the collection-policy to create token. Required capabilities and parameters for the create-token function: - marmalade-v2. ledger. CREATE-TOKEN - id - marmalade-v2. collection-policy-v1. TOKEN-COLLECTION - collection-id - token-id Environment data If you apply the guard-policy to create a token, you can add the following information as raw data: - mintguard [guard] (optional) - burnguard [guard] (optional) - saleguard [guard] (optional) - transferguard [guard] (optional) - uriguard [guard] (optional) If you apply the collection-policy to create a token, you can add the following information as raw data: - collectionid [string] If you apply the royalty-policy to create a token, you can add the following information as raw data: - royaltyspec [object] The royaltyspec object includes the following properties: - fungible [string] - creator [string] - creator-guard [guard] - royalty-rate [decimal] mint Use mint to mint the specified token amount to the specified account. Arguments Use the following arguments to mint a token. | Argument | Type | Description | -------- | ---- | ----------- | id | string | Specifies the unique token identifier generated using create-token-id function and formatted as t: {token-detail-hash}. | account | string | Specifies the account that will receive the minted token. | guard | guard | Specifies the guard for the minted token account. | amount | decimal | Specifies the number of tokens to be minted. When you submit the mint transaction, the policy-manager. enforce-mint function calls the policy: enforce-mint function in the stored token policies and the function is executed. Capabilities The mint transaction must include the MINT capability signed with the account that receives the token. The mint transaction also requires the marmalade-v2. guard-policy-v1. MINT capability if you apply the guard-policy and define a mint guard for the token. Required capabilities and parameters for the mint function: - marmalade-v2. ledger. MINT - id - account (receiver of the token) - amount - marmalade-v2. guard-policy-v1. MINT - token-id - account (receiver of the token) - amount burn Use burn to destroy the specified token amount from the specified token owner account. Arguments Use the following arguments to burn a token. | Argument | Type | Description | -------- | ---- | ----------- | id | string | Specifies the unique token identifier generated using create-token-id function and formatted as t: {token-detail-hash}. | account | string | Specifies the token owner account for the token amount to be burned. | amount | decimal | Specifies the number of tokens to be burned. When you submit the burn transaction, the policy-manager. enforce-burn function calls the policy: enforce-burn function in the stored token policies and the function is executed. Capabilities The burn transaction must include the BURN capability signed with the account that owns the token. The burn transaction also requires the marmalade-v2. guard-policy-v1. BURN capability if you apply the guard-policy and define a burn guard for the token. Required capabilities and parameters for the burn function: - marmalade-v2. ledger. BURN - id - account (owner of the token) - amount - marmalade-v2. guard-policy-v1. BURN - token-id - account (owner of the token) - amount transfer Use transfer to transfer the specified token amount from the specified sender to the specified receiver. Arguments Use the following arguments to transfer a token. | Argument | Type | Description | -------- | ---- | ----------- | id | string | Specifies the unique token identifier generated using create-token-id function and formatted as t: {token-detail-hash}. | sender | string | Specifies the sender account that the token will be transferred from. | receiver | string | Specifies the receiver account that the token will be transferred to. | amount | decimal | Specifies the number of tokens to be transferred. When you submit the transfer transaction, the policy-manager. enforce-transfer function calls the policy: enforce-transfer function in the stored token policies and the function is executed. Capabilities The transfer transaction must include the TRANSFER capability signed with the sender that owns the token. The transfer transaction also requires the marmalade-v2. guard-policy-v1. TRANSFER capability if you apply the guard-policy and define a transfer guard for the token. Required capabilities and parameters for the transfer function: - marmalade-v2. ledger. TRANSFER - id - sender - receiver - amount - marmalade-v2. guard-policy-v1. TRANSFER - token-id - sender - receiver - amount transfer-create Use transfer-create to transfer the specified token amount from the specified sender to the specified receiver and creates the receiver account, if the account doesn't exist. Arguments Use the following arguments to transfer a token. | Argument | Type | Description | -------- | ---- | ----------- | id | string | Specifies the unique token identifier generated using create-token-id function and formatted as t: {token-detail-hash}. | sender | string | Specifies the sender account that the token will be transferred from. | receiver | string | Specifies the receiver account that the token will be transferred to. | receiver-guard | guard | Specifies the guard for the receiver account that the token will be transferred to. | amount | decimal | Specifies the number of tokens to be transferred. When you submit the transfer-create transaction, the policy-manager. enforce-transfer function calls the policy: enforce-transfer function in the stored token policies and the function is executed at ledger. transfer-create. The difference between transfer and transfer-create is that transfer-create can be used for both non-existent and existing receiver accounts, with an additional check for the receiver guard if already exists. The transfer can only be used for existing receiveraccount. Capabilities The transfer-create transaction must include the TRANSFER capability signed with the sender that owns the token. The transfer-create transaction also requires the marmalade-v2. guard-policy-v1. TRANSFER capability if you apply the guard-policy and define a transfer guard for the token. Required capabilities and parameters for the transfer-create function: - marmalade-v2. ledger. TRANSFER - id - sender - receiver - amount - marmalade-v2. guard-policy-v1. TRANSFER - token-id - sender - receiver - amount sale Use sale to execute a two-step transaction using the offer and buy steps with a trustless escrow account. Because a sale requires two steps that must be completed in a specific order, the transaction is defined using a pact. For information about the syntax used to define a pact, see defpact. Arguments Use the following arguments to initiate the sale of a token. | Argument | Type | Description | -------- | ---- | ----------- | id | string | Specifies the unique token identifier generated using create-token-id function and formatted as t: {token-detail-hash}. | seller | string | Specifies the seller account that the token will be offered from. | amount | decimal | Specifies the number of tokens to be offered for sale. | timeout | integer | Specifies when the offer is set to expire using a timestamp for the number of seconds from UNIX epoch before the offer can be withdrawn. For example, if you want an offer to expire at midnight on 30 June 2024, you specify the timeout as 1719705600. You can set the timeout argument to zero (0) to allow an offer to be withdrawn at any time by the token owner. offer The first step of a sale pact (step 0) executes the offer function. The offer function transfers the token from the seller's account to the escrow account. The policy-manager. enforce-offer function calls the policy: enforce-offer function in the stored token policies and the function is executed at step 0 of the sale. Capabilities The offer transaction must include the OFFER capability signed with the seller that owns the token. The offer transaction also requires the marmalade-v2. guard-policy-v1. SALE capability if you apply the guard-policy and define a sales guard for the token. Required capabilities and parameters for the offer function: - marmalade-v2. ledger. OFFER - id - seller - amount - timeout - marmalade-v2. guard-policy-v1. SALE - token-id - seller - amount Environment data If the offer is a dutch or conventional auction, you can add the following information as raw data: - quote [object] The quote object includes the following properties: - fungible [string] - sale-price [decimal] - seller-fungible-account [object] - account [string] - guard [guard] - sale-type [string] (optional) withdraw (cont) The sale pact includes a rollback step (step 0-rollback). The rollback step executes the withdraw function. The withdraw function transfers the tokens held in the escrow account for the sale back to the seller. If a timeout is specified, the withdraw function can only be executed after the timeout period has passed. You can execute the withdraw function by sending a continuation (cont) command with the following information: Code example (yaml): pactTxHash: sale-pact-id step: 0 rollback: true For more information about formatting continuation commands, see Transaction formats. The policy-manager. enforce-withdraw function calls the policy: enforce-withdraw function in the stored token policies and the function is executed at step 0-rollback of sale. Capabilities The withdraw transaction must include the WITHDRAW capability signed with the seller that owns the token. The withdraw transaction also requires the marmalade-v2. guard-policy-v1. SALE capability if you apply the guard-policy and define a sales guard for the token. Required capabilities and parameters for the withdraw function: - marmalade-v2. ledger. WITHDRAW - id - seller - amount - timeout - sale-id - marmalade-v2. guard-policy-v1. SALE - token-id - seller - amount buy (cont) The second step of a sale pact (step 1) executes the buy function. The buy function transfers the tokens held in the escrow account to the buyer. The buy function can be executed before timeout. The buyer and buyer-guard information is read from the env-data of the command instead of passing in arguments. Like the withdraw function, the buy function is executed using a continuation (cont) command: Code example (yaml): pactTxHash: sale-pact-id step: 0 rollback: false The policy-manager. enforce-buy function calls the policy: enforce-buy function in the stored token policies and the function is executed at step 1 of sale. Capabilities The buy transaction must include the BUY capability signed with the buyer that is buying the token. The buy transaction also requires the marmalade-v2. guard-policy-v1. SALE capability if you apply the guard-policy and define a sales guard for the token. Required capabilities and parameters for the buy function: - marmalade-v2. ledger. BUY - id - seller - buyer - amount - sale-id - marmalade-v2. guard-policy-v1. SALE - token-id - seller - amount Environment data If the sale is a dutch or conventional auction, you need to add the following information as raw data: - buyer [string] - buyer-guard [guard] - buyerfungibleaccount [string] - updated_price [decimal] update-uri Use update-uri to update the uri for an existing token. Arguments | Argument | Type | Description | -------- | ---- | ----------- | id | string | Specifies the unique token identifier generated using create-token-id function and formatted as t: {token-detail-hash}. | new-uri | string | Specifies the new uri. When you submit the update-uri transaction, the policy-manager. enforce-update-uri function calls the policy: enforce-update-uri function in the stored token policies and the function is executed at ledger. update-uri. Token creators should configure the entity that will be authorized to update the uri's in the guard-policy-v1, or in their custom policies. Capabilities The update-uri transaction must include the UPDATE-URI capability signed with the buyer that is buying the token. The update-uri transaction also requires the marmalade-v2. guard-policy-v1. UPDATE-URI capability if you apply the guard-policy and define a uri guard for the token. Required capabilities and parameters for the update-uri function: - marmalade-v2. ledger. UPDATE-URI - token-id - new-uri - marmalade-v2. guard-policy-v1. UPDATE-URI - token-id - new-uri",
    "source": "reference/marmalade/ledger.md",
    "title": "Ledger contract"
  },
  {
    "content": "The @kadena/client-utils library includes a TypeScript-based API for interacting with Marmalade smart contracts on the Kadena network. The @kadena/client-utils/marmalade library provides a TypeScript-based API for interacting with marmalade smart contracts on the Kadena network. This library is designed to facilitate the creation, management, and utilization of NFTs, leveraging Marmalade’s advanced features such as enforceable royalties, secure escrow accounts, and flexible token policies. Whether you're building applications for minting, transferring, or auctioning NFTs, @kadena/client-utils/maramlade provides the necessary tools to create and send commands to the Kadena network efficiently. This guide will help you get started with installing the library, using its various functions, and integrating it into your projects. Install You can install the @kadena/client-utils library with the following command: Code example (bash): npm install @kadena/client-utils You can import Marmalade functions into TypeScript programs with statements similar to the following example: Code example (typescript): import { mintToken } from '@kadena/client-utils/marmalade'; CommonProps Use the CommomProps interface to access common properties—including metadata for transaction control, additional capabilities, or additional signers—that are used by other functions. Code example (typescript): export interface CommonProps { meta? : { senderAccount? : string; gasLimit? : number; gasPrice? : number; }; capabilities? : { name: string; props: any[]; }[]; additionalSigners? : { keyset: { keys: string[]; pred: BuiltInPredicate; }; capabilities: { name: string; props: any[]; }[]; }[]; } IClientConfig Use the IClientConfig interface to specify the network location to send transactions to when connecting to the Kadena network. Code example (typescript): export interface IClientConfig { host? : string | ((options: INetworkOptions) => string); defaults? : Partial<IPactCommand>; sign: ISignFunction; } // Example using key-pair: const config: IClientConfig = { host: 'http: //127. 0. 0. 1: 8080', defaults: { networkId: 'development', }, sign: createSignWithKeypair([targetAccount]) }; burnToken Use burnToken function to eliminate a specified amount of a token. This operation reduces the total supply of the token. Code example (typescript): burnToken(inputs, config): IEmitterWrapper Inputs Parameter | Type | Description policyConfig | object | Specifies which types of policies are configured for the specified token. This object is used to validate that you have expected types defined for the all of the policies you have selected for a token. tokenId | string | Specifies the token identifier for the token you want to burn. accountName | string | Specifies the account that owns the token you want to burn. chainId | ChainId | Specifies the chain identifier for the chain where you want to burn the specified token. Valid values are 0 to 19. guard | object | Specifies the token owner or the burn guard, if you've configured a burn guard. amount | IPactDecimal | Specifies the amount to burn. Policy configuration object The ICreateTokenPolicyConfig interface identifies the types of policies that are configured for a token as boolean values. The resulting policyConfig object contains properties similar to the following: Code example (json): { \"customPolicies\": false, \"nonUpdatableURI\": false, \"guarded\": true, \"nonFungible\": true, \"hasRoyalty\": true, \"collection\": true } Guard object Depending on whether a token has the guard policy applied and a burn guard defined, the guard object account information might be required to be the token owner or the account specified for the burn guard. For either account, the guard object contains properties similar to the following: Code example (json): { \"account\": \"k: 5a2afbc4564b76b2c27ce5a644cab643c43663835ea0be22433b209d3351f937\", \"keyset\": { \"keys\": [\"5a2afbc4564b76b2c27ce5a644cab643c43663835ea0be22433b209d3351f937\"], \"pred\": \"keys-all\" } } Return value This function returns a boolean value to indicate whether the burn operation was successful or failed. Example Code example (typescript): const result = await burnToken({ chainId, tokenId, accountName: \"k: 5a2afbc4564b76b2c27ce5a644cab643c43663835ea0be22433b209d3351f937\", guard: { account: \"k: 5a2afbc4564b76b2c27ce5a644cab643c43663835ea0be22433b209d3351f937\", keyset: { keys: [\"5a2afbc4564b76b2c27ce5a644cab643c43663835ea0be22433b209d3351f937\"], pred: 'keys-all' } }, amount: new PactNumber(1). toPactDecimal() }, config ). execute(); buyToken Use buyToken to enable the purchase of a specified token within a defined sale configuration. This function handles the transaction between the seller and buyer, including any applicable auction logic. Code example (typescript): buyToken(inputs, config): IEmitterWrapper Inputs Parameter | Type | Description auctionConfig | IAuctionPurchaseConfig | Specifies the type of auction if the token is offered for sale using a conventional or dutch auction. policyConfig | object | Specifies which types of policies are configured for the specified token. This object is used to validate that you have expected types defined for the all of the policies you have selected for a token. tokenId | string | Specifies the token identifier for the token you want to buy. saleId | string | Specifies the Pact identifier for the token sale. amount | IPactDecimal | Specifies the number of tokens you want to buy. chainId | ChainId | Specifies the chain identifier for the chain where the token is offered for sale. Valid values are 0 to 19. seller | object | Specifies account information for the token seller. buyer | object | Specifies the buyer account information and guard. buyerFungibleAccount? | string | Specifies the fungible name if the fungible for the sale is not using the coin contract. Policy configuration object The ICreateTokenPolicyConfig interface identifies the types of policies that are configured for a token as boolean values. The resulting policyConfig object contains properties similar to the following: Code example (json): { \"customPolicies\": false, \"nonUpdatableURI\": false, \"guarded\": true, \"nonFungible\": true, \"hasRoyalty\": true, \"collection\": true } Account information objects Depending on the function, account information objects might consist of different properties. For example, in the context of the buyToken function, the seller object only contains the account name, but the buyer object includes the account information and a keyset guard. Auction-specific parameters There are additional inputs for auctions. The interface for conventional auctions (IConventionalAuctionPurchaseInput) and the interface for dutch auctions (IDutchAuctionPurchaseInput) have the following additional inputs: Parameter | Type | Description updatedPrice | IPactDecimal | Specifies the current auction price. escrow | object | Specifies the escrow sale account in the Marmalade ledger. Return value This function returns the sale-id as a string value. Example Code example (typescript): const result = await buyToken({ chainId, tokenId, saleId, seller: { account: \"k: 5a2afbc4564b76b2c27ce5a644cab643c43663835ea0be22433b209d3351f937\", }, buyer: { account: \"k: 368820f80c324bbc7c2b0610688a7da43e39f91d118732671cd9c7500ff43cca\", keyset: { keys: [\"368820f80c324bbc7c2b0610688a7da43e39f91d118732671cd9c7500ff43cca\"], pred: 'keys-all' } }, amount: new PactNumber(1). toPactDecimal(), timeout }, config ) createAuction Use createAuction to create an auction for a specified token. This function supports both conventional and dutch auction types, allowing the seller to define start and end dates, prices, and other relevant parameters. Code example (typescript): createAuction(inputs, config): IEmitterWrapper Inputs Both conventional auctions and dutch auctions use the following parameters: Parameter | Type | Description auctionConfig | IAuctionPurchaseConfig | Specifies the type of auction to create. Valid vales are conventional and dutch. chainId | ChainId | Specifies the chain identifier for the chain where where you want to create the auction. Valid values are 0 to 19. seller | object | Specifies the account information for the token seller. saleId | string | Specifies the Pact identifier for the token sale. tokenId | string | Specifies the token identifier for the token you want to list. startDate | IPactInt | Specifies the time when auction starts. endDate | IPactInt | Specifies the time when auction ends. reservedPrice | IPactDecimal | Specifies the reserved price for the sale. The following parameters are only used for creating a dutch auction: Parameter | Type | Description startPrice | IPactDecimal | Specifies the initial asking price for the token auction. priceIntervalInSeconds | IPactInt | Specifies the interval for lowering the asking price for the token. Return value This function returns a boolean value to indicate whether creating the auction was successful or failed. Example Code example (typescript): const result = await createAuction({ auctionConfig: { conventional: true, }, saleId: \"\", tokenId: \"t: . . . \", startDate: { int: \"\" }, endDate: { int: \"\" }, reservedPrice: new PactNumber(1). toPactDecimal(), chainId, seller: { account: \"k: 5a2afbc4564b76b2c27ce5a644cab643c43663835ea0be22433b209d3351f937\", keyset: { keys: [\"5a2afbc4564b76b2c27ce5a644cab643c43663835ea0be22433b209d3351f937\"], pred: 'keys-all', }, }, }, co. . . [code continues] createBidId Use createBidId to generate a unique bid identifier for a specified auction. Code example (typescript): createBidId(inputs): string Inputs Parameter | Type | Description saleId | string | Specifies the Pact identifier for the token sale. bidderAccount | string | Specifies the bidder account information. chainId | ChainId | Specifies the chain identifier for the chain where where you want to create a bid identifier. Valid values are 0 to 19. networkId | NetworkId | Specifies the target network for the bid. Valid values are development, testnet04, and mainnet01. host | IClientConfig['host'] | Specifies the target node for the bid. Return value This function returns the bid-id as a string value. Example Code example (typescript): const result = await createBidId({ saleId: \"\", bidderAccount: \"k: 5a2afbc4564b76b2c27ce5a644cab643c43663835ea0be22433b209d3351f937\", chainId: \"0\", networkId: \"development\", host: \"http: //127. 0. 0. 1: 8080\" }); createCollectionId Use createCollectionId to generate a unique collection identifier. Code example (typescript): createCollectionId(inputs): string Inputs Parameter | Type | Description collectionName | string | Specifies the name of the collection. operator | string | Specifies the collection operator. chainId | ChainId | Specifies the chain identifier for the chain where where you want to create the collection identifier. Valid values are 0 to 19. networkId | NetworkId | Specifies the target network for the collection identifier. Valid values are development, testnet04, and mainnet01. host | IClientConfig['host'] | Specifies the target node for the collection identifier. Return value This function returns the collection-id as a string value. Example Code example (typescript): const result = await createCollectionId({ collectionName: \"docs\", chainId: \"0\", operator: { keyset: { keys: [sourceAccount. publicKey], pred: 'keys-all', }, }, networkId: \"development\", host: \"http: //127. 0. 0. 1: 8080\", }); createCollection Use createCollection to initiate the creation of a new collection, specifying its name, size, operator, and other relevant metadata. Code example (typescript): createCollection(inputs, config): IEmitterWrapper Inputs Parameter | Type | Description id | string | Specifies the collection identifier. name | string | Specifies the collection name. size | IPactInt or PactReference | Specifies the number of tokens in the collection. chainId | ChainId | Specifies the chain identifier for the chain where where you want to create the collection. Valid values are 0 to 19. operator | object | Specifies the operator account and guard. meta | object | Specifies the transaction metadata. Return value This function returns a boolean value to indicate whether creating the collection was successful or failed. Example Code example (typescript): const result = await createCollection({ id: \"collection: . . . \", name: \"Docs\", size: new PactNumber(0). toPactInteger(), operator: { account: \"k: 5a2afbc4564b76b2c27ce5a644cab643c43663835ea0be22433b209d3351f937\", keyset: { keys: [\"5a2afbc4564b76b2c27ce5a644cab643c43663835ea0be22433b209d3351f937\"], pred: 'keys-all' } }, chainId: \"0\" }, config ) createTokenId Use createTokenId to generate a unique token identifier. Code example (typescript): createTokenId(inputs): string Inputs Parameter | Type | Description policyConfig | object | Specifies which types of policies are configured for the specified token. This object is used to validate that you have expected types defined for the all of the policies you have selected for a token. policies | Array of strings | Specifies the list of policy names applied to the token. uri | string | Specifies the location of the token metadata JSON file in the form of uniform resource identifier (URI). precision | IPactInt or PactReference | Specifies the token precision. collectionName | string | Specifies the name of the token collection, if applicable. creator | string | Specifies the token creator account information. chainId | ChainId | Specifies the chain identifier for the chain where where you want to create the token identifier. Valid values are 0 to 19. networkId | NetworkId | Specifies the target network for the token identifier. Valid values are development, testnet04, and mainnet01. host | IClientConfig['host'] | Specifies the target node for the token identifier. Policy configuration object The ICreateTokenPolicyConfig interface identifies the types of policies that are configured for a token as boolean values. The resulting policyConfig object contains properties similar to the following: Code example (json): { \"customPolicies\": false, \"nonUpdatableURI\": false, \"guarded\": true, \"nonFungible\": true, \"hasRoyalty\": true, \"collection\": true } Return value This function returns the token-id as a string value. Example Code example (typescript): const result = await createTokenId({ uri: \"ipfs: //. . . \", precision: { int: '0' }, policies: [], creator: { keyset: { keys: [\"5a2afbc4564b76b2c27ce5a644cab643c43663835ea0be22433b209d3351f937\"], pred: 'keys-all' } }, chainId: \"0\", networkId: \"development\", host: \"http: //127. 0. 0. 1: 8080\" }); createToken Use createToken to create a new token with all relevant policies applied. Code example (typescript): createToken(inputs, config): IEmitterWrapper Inputs Parameter | Type | Description policyConfig | object | Specifies which types of policies are configured for the specified token. This object is used to validate that you have expected types defined for the all of the policies you have selected for a token. policies | Array of strings | Specifies the list of policy names applied to the token. uri | string | Specifies the location of the token metadata JSON file in the form of uniform resource identifier (URI). precision | IPactInt or PactReference | Specifies the token precision. collectionName | string | Specifies the name of the token collection, if applicable. creator | string | Specifies the token creator account information. chainId | ChainId | Specifies the chain identifier for the chain where where you want to create the token. Valid values are 0 to 19. guards | IGuardInfoInput | Specifies the parameters for the guard policy, if applicable. royalty | IRoyaltyInfoInput | Specifies the parameters for the royalty policy, if applicable. collection | ICollectionInfoInput | Specifies the parameters for the collection policy, if applicable. Additional inputs for guard policy (IGuardInfoInput) Parameter | Type | Description mintGuard | KeysetGuard or FunctionGuard | Specifies the guard for minting tokens. uriGuard | KeysetGuard or FunctionGuard | Specifies the guard for updating the token metadata and uri. saleGuard | KeysetGuard or FunctionGuard | Specifies the guard for selling tokens. burnGuard | KeysetGuard or FunctionGuard | Specifies the guard for burning tokens. transferGuard | KeysetGuard or FunctionGuard | Specifies the guard for transferring tokens. Additional inputs for royalty policy (IRoyaltyInfoInput) Parameter | Type | Description fungible | object | Specifies the module reference where a fungible token is defined, for example, in the coin contract for KDA. creator | object | Specifies the creator account information and guard. royaltyRate | IPactDecimal | Specifies the royalty percentage to be paid to the creator's account each time a token with this policy applied is sold. The fungible module object identifies the contracts where specified fungible tokens are defined. For Marmalade and KDA tokens, the fungible object contains the following reference specifications: Code example (json): { \"refSpec\": [ { \"namespace\": null, \"name\": \"fungible-xchain-v1\" }, { \"namespace\": null, \"name\": \"fungible-v2\" }], \"refName\": { \"namespace\": null, \"name\": \"coin\" } }, Additional inputs for collection policy (ICollectionInfoInput) Parameter | Type | Description collectionId | string | Specifies the collection to add the token to. Return value This function returns a boolean value to indicate whether creating the token was successful or failed. Example Code example (typescript): const result = await createToken({ uri: \"ipfs: //. . . \", precision: { int: '0' }, policies: [], creator: { keyset: { keys: [\"5a2afbc4564b76b2c27ce5a644cab643c43663835ea0be22433b209d3351f937\"], pred: 'keys-all' } }, chainId: \"0\", }, config ); escrowAccount Use escrowAccount to retrieve the details for a specified escrow account. Code example (typescript): escrowAccount(inputs): string Inputs Parameter | Type | Description saleId | string | Specifies the Pact identifier for the token sale. chainId | ChainId | Specifies the chain identifier for the chain where the escrow account is created. Valid values are 0 to 19. networkId | NetworkId | Specifies the target network for the escrow account. Valid values are development, testnet04, and mainnet01. host | IClientConfig['host'] | Specifies the target node for the escrow account. Return value This function returns the escrow-account as a string value. Example Code example (typescript): const result = await escrowAccount({ saleId: \"\", chainId: \"0\", networkId: \"development\", host: \"http: //127. 0. 0. 1: 8080\" }); getAccountDetails Use getAccountDetails to retrieve detailed information, including the token balance, for a specified account. Code example (typescript): getAccountDetails(inputs): object Inputs Parameter | Type | Description tokenId | string | Specifies the token identifier for the token that you want to retrieve information for. accountName | string | Specifies the account name that you want to retrieve information for. chainId | ChainId | Specifies the chain identifier for the chain from which you want to get account details. Valid values are 0 to 19. networkId | NetworkId | Specifies the target network for retrieving account details. Valid values are development, testnet04, and mainnet01. host | IClientConfig['host'] | Specifies the target node for retrieving account details. Return value This functions returns an object with account details. Example Code example (typescript): const result = await getAccountDetails({ tokenId: \"t: . . . \", accountName: \"k: 5a2afbc4564b76b2c27ce5a644cab643c43663835ea0be22433b209d3351f937\" chainId: \"0\", networkId: \"development\", host: \"http: //127. 0. 0. 1: 8080\" }); getAuctionDetails Use getAuctionDetails to retrieve detailed information for a specified auction. Code example (typescript): getAuctionDetails(inputs): object Inputs Parameter | Type | Description auctionConfig | IAuctionConfig | Specifies the type of the auction. saleId | string | Specifies the Pact identifier for the sale you want to retrieve information for. chainId | ChainId | Specifies the chain identifier for the chain from which you want to get auction details. Valid values are 0 to 19. networkId | NetworkId | Specifies the target network for retrieving auction details. Valid values are development, testnet04, and mainnet01. host | IClientConfig['host'] | Specifies the target node for retrieving auction details. Return value This functions returns an object with auction details. Example Code example (typescript): const result = await getAuctionDetails({ saleId: \"\", chainId: \"0\", networkId: \"development\", host: \"http: //127. 0. 0. 1: 8080\" }); getBid Use getBid to retrieve detailed information, including the bidder and bid amount, for a specific bid placed in the context of a specific auction. Code example (typescript): getBid(inputs): object Inputs Parameter | Type | Description bidId | string | Specifies the identifier for the bid you want to retrieve information for. chainId | ChainId | Specifies the chain identifier for the chain from which you want to get bid details. Valid values are 0 to 19. networkId | NetworkId | Specifies the target network for retrieving bid details. Valid values are development, testnet04, and mainnet01. host | IClientConfig['host'] | Specifies the target node for retrieving bid details. Return value This functions returns an object with bid details. Example Code example (typescript): const result = await getBid({ bidId: \"\", chainId: \"0\", networkId: \"development\", host: \"http: //127. 0. 0. 1: 8080\" }); getCollectionToken Use getCollectionToken to retrieve information about a specific token within a collection. Code example (typescript): getCollectionToken(inputs): object Inputs Parameter | Type | Description tokenId | string | Specifies the token identifier for the token that you want to retrieve information for. chainId | ChainId | Specifies the chain identifier for the chain from which you want to get information about a token in a collection. Valid values are 0 to 19. networkId | NetworkId | Specifies the target network for retrieving information about a token in a collection. Valid values are development, testnet04, and mainnet01. host | IClientConfig['host'] | Specifies the target node for retrieving information about a token in a collection. Return value This functions returns an object with details about a token in a collection. Example Code example (typescript): const result = await getCollectionToken({ tokenId: \"t: . . . \", chainId: \"0\", networkId: \"development\", host: \"http: //127. 0. 0. 1: 8080\" }); getCollection Use getCollection to retrieve detailed information about a specified collection. Code example (typescript): getCollection(inputs): object Inputs Parameter | Type | Description collectionId | string | Specifies the collection identifier for the collection that you want to retrieve information for. chainId | ChainId | Specifies the chain identifier for the chain from which you want to get information about a collection. Valid values are 0 to 19. networkId | NetworkId | Specifies the target network for retrieving information about a collection. Valid values are development, testnet04, and mainnet01. host | IClientConfig['host'] | Specifies the target node for retrieving information about a collection. Return value This functions returns an object with collection details. Example Code example (typescript): const result = await getCollection({ collectionId: \"collection: . . . \", chainId: \"0\", networkId: \"development\", host: \"http: //127. 0. 0. 1: 8080\" }); getCurrentPrice Use getCurrentPrice to retrieve the current price of a token in an auction, reflecting any price adjustments due to auction rules. Code example (typescript): getCurrentPrice(inputs): IPactDecimal Inputs Parameter | Type | Description saleId | string | Specifies the Pact identifier for the sale you want to retrieve information for. chainId | ChainId | Specifies the chain identifier for the chain from which you want to get information about the current price for a token. Valid values are 0 to 19. networkId | NetworkId | Specifies the target network for retrieving information about the current price for a token. Valid values are development, testnet04, and mainnet01. host | IClientConfig['host'] | Specifies the target node for retrieving information about the current price for a token. Return value This functions returns an object with the current price. Example Code example (typescript): const result = await getCurrentPrice({ saleId: \"\", chainId: \"0\", networkId: \"development\", host: \"http: //127. 0. 0. 1: 8080\" }); getEscrowAccount Use getEscrowAccount to retrieve information about an escrow account. Code example (typescript): getEscrowAccount(inputs): object Inputs Parameter | Type | Description saleId | string | Specifies the Pact identifier for the sale you want to retrieve information for. chainId | ChainId | Specifies the chain identifier for the chain from which you want to get information about an escrow account. Valid values are 0 to 19. networkId | NetworkId | Specifies the target network for retrieving information about an escrow account. Valid values are development, testnet04, and mainnet01. host | IClientConfig['host'] | Specifies the target node for retrieving information about an escrow account. Return value This functions returns an object with details about an escrow account. Example Code example (typescript): const result = await getEscrowAccount({ saleId: \"\", chainId: \"0\", networkId: \"development\", host: \"http: //127. 0. 0. 1: 8080\" }); getQuoteInfo Use getQuoteInfo to retrieve information about a specific sale quote. Code example (typescript): getQuoteInfo(inputs): object Inputs Parameter | Type | Description saleId | string | Specifies the Pact identifier for the sale you want to retrieve information for. chainId | ChainId | Specifies the chain identifier for the chain from which you want to get information about a quote. Valid values are 0 to 19. networkId | NetworkId | Specifies the target network for retrieving information about a quote. Valid values are development, testnet04, and mainnet01. host | IClientConfig['host'] | Specifies the target node for retrieving information about a quote. Return value This functions returns an object with quote details. Example Code example (typescript): const result = await getQuoteInfo({ saleId: \"\", chainId: \"0\", networkId: \"development\", host: \"http: //127. 0. 0. 1: 8080\" }); getTokenBalance Use getTokenBalance to retrieve the balance recorded in the ledger for a specified token and a specified account. Code example (typescript): getTokenBalance(inputs): IPactDecimal Inputs Parameter | Type | Description tokenId | string | Specifies the token identifier for the token that you want to retrieve information for. accountName | string | Specifies the account name that you want to retrieve information for. chainId | ChainId | Specifies the chain identifier for the chain from which you want to get balance information for a token. Valid values are 0 to 19. networkId | NetworkId | Specifies the target network for retrieving information about the balance for a token. Valid values are development, testnet04, and mainnet01. host | IClientConfig['host'] | Specifies the target node for retrieving information about the balance for a token. Return value This functions returns an IPactDecimal value representing the token balance. Example Code example (typescript): const result = await getTokenBalance({ tokenId: \"t: . . . \", accountName: \"k: 5a2afbc4564b76b2c27ce5a644cab643c43663835ea0be22433b209d3351f937\", chainId: \"0\", networkId: \"development\", host: \"http: //127. 0. 0. 1: 8080\" }); getTokenInfo Use getTokenInfo to retrieve detailed information about a specific token. Code example (typescript): getTokenInfo(inputs): object Inputs Parameter | Type | Description tokenId | string | Specifies the token identifier for the token that you want to retrieve information for. chainId | ChainId | Specifies the chain identifier for the chain from which you want to get information for the token. Valid values are 0 to 19. networkId | NetworkId | Specifies the target network for retrieving information about the token. Valid values are development, testnet04, and mainnet01. host | IClientConfig['host'] | Specifies the target node for retrieving information about the token. Return value This functions returns an object with token details. Example Code example (typescript): const result = await getTokenInfo({ tokenId: \"t: . . . \", chainId: \"0\", networkId: \"development\", host: \"http: //127. 0. 0. 1: 8080\" }); getUri Use getUri to retrieve the URI associated with a specific token. Code example (typescript): getUri(inputs): string Inputs Parameter | Type | Description tokenId | string | Specifies the token identifier for the token that you want to retrieve information for. chainId | ChainId | Specifies the chain identifier for the chain from which you want to get the URI for the token. Valid values are 0 to 19. networkId | NetworkId | Specifies the target network for retrieving the URI for the token. Valid values are development, testnet04, and mainnet01. host | IClientConfig['host'] | Specifies the target node for retrieving the URI for the token. Return value This function returns the token uRI as a string value. Example Code example (typescript): const result = await getUri({ tokenId: \"t: . . . \", chainId: \"0\", networkId: \"development\", host: \"http: //127. 0. 0. 1: 8080\" }); mintToken Use mintToken function to mint a specified amount of a specified token. Minting a token increases its total supply and assigns ownership of the token to a target account. Code example (typescript): mintToken(inputs, config): IEmitterWrapper Inputs Parameter | Type | Description policyConfig | object | Specifies which types of policies are configured for the specified token. This object is used to validate that you have expected types defined for the all of the policies you have selected for a token. tokenId | string | Specifies the token identifier for the token you want to mint. accountName | string | Specifies the account that you want to assign ownership of the token to. chainId | ChainId | Specifies the chain identifier for the chain where the token is being minted. Valid values are 0 to 19. guard | object | Specifies the token owner or the mint guard, if applicable. amount | IPactDecimal | Specifies the amount to mint. Return value This function returns a boolean value to indicate whether minting the token was successful or failed. Example Code example (typescript): const result = await mintToken({ tokenId: \"t: . . . \", accountName: \"k: 368820f80c324bbc7c2b0610688a7da43e39f91d118732671cd9c7500ff43cca\", amount: new PactNumber(1). toPactDecimal(), guard: { account: \"k: 5a2afbc4564b76b2c27ce5a644cab643c43663835ea0be22433b209d3351f937\" keyset: { keys: [\"5a2afbc4564b76b2c27ce5a644cab643c43663835ea0be22433b209d3351f937\"], pred: 'keys-all' } }, chainId: \"0\", }, config ); offerToken Use offerToken to put a specified token up for sale. Note that you must be the token owner to offer the specified token for sale. Code example (typescript): offerToken(inputs, config): IEmitterWrapper Inputs Parameter | Type | Description policyConfig | object | Specifies which types of policies are configured for the specified token. This object is used to validate that you have expected types defined for the all of the policies you have selected for a token. tokenId | string | Specifies the token identifier for the token that you want to offer for sale. amount | IPactDecimal | Specifies the amount that you want to offer for sale. timeout | IPactInt | Specifies the timeout for when the offer can be withdrawn. You can set this value using the number of seconds from the start of the UNIX epoch or set the timeout to zero (0) to allow an offer to be withdrawn at any time. chainId | ChainId | Specifies the chain identifier for the chain where the token is being offered. Valid values are 0 to 19. seller | object | Specifies the seller account information and guard. auction | ISaleAuctionInfoInput | Additional parameters if you are offering the token using an auction contract. guards | ISaleGuardInfoInput | Additional parameters if you are offering a token that has the guard policy applied. royalty | IRoyaltyInfoInput | Additional parameters if you are offering a token that has the royalty policy applied. Additional inputs for auction contract (ISaleAuctionInfoInput) Parameter | Type | Description fungible | object | Specifies the identifier to specify a fungible token, such as coin or a custom fungible token. price | IPactDecimal | Specifies the price that the token is being offered at. For auction contracts, this setting should be zero (0). sellerFungibleAccount | IPactDecimal | Specifies the seller account information if you are using a custom fungible. saleType | string | Specifies the auction contract type. Valid values are conventional and dutch. Additional inputs for guard policy (ISaleGuardInfoInput) Parameter | Type | Description saleGuard | KeysetGuard or FunctionGuard | Specifies the guard for selling tokens. Additional inputs for royalty policy (IRoyaltyInfoInput) Parameter | Type | Description fungible | object | Specifies the identifier to specify a fungible token, such as coin or a custom fungible token. creator | object | Specifies the creator account information and guard. royaltyRate | IPactDecimal | Specifies the royalty percentage to be paid to the creator's account each time a token with this policy applied is sold. Return value This function returns a boolean value to indicate whether creating the offer was successful or failed. Example Code example (typescript): const result = await offerToken({ tokenId: \"t: . . . \", amount: new PactNumber(1). toPactDecimal(), timeout: new PactNumber(1). toPactInteger(), seller: { account: \"k: 5a2afbc4564b76b2c27ce5a644cab643c43663835ea0be22433b209d3351f937\", keyset: { keys: [\"5a2afbc4564b76b2c27ce5a644cab643c43663835ea0be22433b209d3351f937\"], pred: 'keys-all' } }, chainId: \"0\", }, config ); placeBid Use placeBid to place a bid on a specified token in an active auction. Code example (typescript): placeBid(inputs, config): IEmitterWrapper Inputs Parameter | Type | Description marketplaceConfig | object | Specifies the configuration to collect marketplace fees. saleId | string | Specifies the Pact identifier for the sale. bid | IPactDecimal | Specifies the amount to bid on the token. bidder | object | Specifies the bidder account information and guard. escrowAccount | string | Specifies the escrow account for the bid. chainId | ChainId | chainId | ChainId | Specifies the chain identifier for the chain where the token is being offered. Valid values are 0 to 19. marketplaceFee | IPlaceBidInput | Additional parameters, if using marketplace fees. Marketplace object The marketplaceConfig object specifies whether a marketplace charges fees. For example: Code example (json): { \"marketplaceFee\": true } If true, the IPlaceBidInput interface requires the following additional parameters: Parameter | Type | Description mkAccount | string | Specifies the marketplace account information. mkFeePercentage | IPactDecimal | Specifies the marketplace fee percentage. Return value This function returns a boolean value to indicate whether placing the bid was successful or failed. Example Code example (typescript): const result = await placeBid({ saleId: \"\", bid: new PactNumber(1). toPactDecimal(), bidder: { account: \"k: 5a2afbc4564b76b2c27ce5a644cab643c43663835ea0be22433b209d3351f937\", keyset: { keys: [\"5a2afbc4564b76b2c27ce5a644cab643c43663835ea0be22433b209d3351f937\"], pred: 'keys-all' } }, escrowAccount: \"\", chainId: \"0\", }, config ); transferCreateToken Use transferCreateToken to transfer a specified amount of a specified token from one account to another. Code example (typescript): transferCreateToken(inputs, config): IEmitterWrapper Inputs Parameter | Type | Description policyConfig | object | Specifies which types of policies are configured for the specified token. This object is used to validate that you have expected types defined for the all of the policies you have selected for a token. tokenId | string | Specifies the token identifier for the token that you want to transfer. amount | IPactDecimal | Specifies the amount that you want to transfer. sender | object | Specifies the sender account information and guard. receiver | object | Specifies the receiver account information and guard. chainId | ChainId | Specifies the chain identifier for the chain where the transfer takes place. Valid values are 0 to 19. Return value This function returns a boolean value to indicate whether transferring the token was successful or failed. Example Code example (typescript): const result = await transferCreateToken({ tokenId: \"t: . . . \", amount: new PactNumber(1). toPactDecimal(), sender: { account: \"k: 368820f80c324bbc7c2b0610688a7da43e39f91d118732671cd9c7500ff43cca\", keyset: { keys: [\"368820f80c324bbc7c2b0610688a7da43e39f91d118732671cd9c7500ff43cca\"], pred: 'keys-all' } }, receiver: { account: \"k: 5a2afbc4564b76b2c27ce5a644cab643c43663835ea0be22433b209d3351f937\", keyset: { keys: [\"5a2afbc4564b76b2. . . [code continues] transferToken Use transferToken to transfer a specified amount of a specified token from one account to another. Code example (typescript): transferToken(inputs, config): IEmitterWrapper Inputs Parameter | Type | Description policyConfig | object | Specifies which types of policies are configured for the specified token. This object is used to validate that you have expected types defined for the all of the policies you have selected for a token. tokenId | string | token identifier for the token that you want to transfer. amount | IPactDecimal | Specifies the amount that you want to transfer. sender | object | Specifies the sender account information and guard. receiver | object | Specifies the receiver account information and guard. chainId | ChainId | Specifies the chain identifier for the chain where the transfer takes place. Valid values are 0 to 19. Return value This function returns a boolean value to indicate whether transferring the token was successful or failed. Example Code example (typescript): const result = await transferToken({ tokenId: \"t: . . . \", amount: new PactNumber(1). toPactDecimal(), sender: { account: \"k: 368820f80c324bbc7c2b0610688a7da43e39f91d118732671cd9c7500ff43cca\", keyset: { keys: [\"368820f80c324bbc7c2b0610688a7da43e39f91d118732671cd9c7500ff43cca\"], pred: 'keys-all' } }, receiver: { account: \"k: 5a2afbc4564b76b2c27ce5a644cab643c43663835ea0be22433b209d3351f937\", }, chainId: \"0\", }, config ); updateAuction Use updateAuction to modify an existing auction's details. This function supports updates to both conventional and dutch auction types, enabling changes to start and end dates, prices, and other relevant parameters. Code example (typescript): updateAuction(inputs, config): IEmitterWrapper Inputs Both conventional auctions and dutch auctions use the following parameters: Parameter | Type | Description auctionConfig | IAuctionPurchaseConfig | Specifies the type of auction to update. Valid vales are conventional and dutch. chainId | ChainId | Specifies the chain identifier for the chain where where you want to update the auction. Valid values are 0 to 19. seller | object | Specifies the account information for the token seller. saleId | string | Specifies the Pact identifier for the token sale. tokenId | string | Specifies the token identifier for the token you want to list. startDate | IPactInt | Specifies the time when auction starts. endDate | IPactInt | Specifies the time when auction ends. reservedPrice | IPactDecimal | Specifies the reserved price for the sale. The following parameters are only used for updating a dutch auction: Parameter | Type | Description startPrice | IPactDecimal | Specifies the initial asking price for the token auction. priceIntervalInSeconds | IPactInt | Specifies the interval for lowering the asking price for the token. Return value This function returns a boolean value to indicate whether the update to the auction was successful or failed. Example Code example (typescript): const result = await updateAuction({ auctionConfig: { conventional: true, }, saleId: \"\", tokenId: \"t: . . . \", startDate: { int: \"\" }, endDate: { int: \"\" }, reservedPrice: new PactNumber(1). toPactDecimal(), chainId, seller: { account: \"k: 5a2afbc4564b76b2c27ce5a644cab643c43663835ea0be22433b209d3351f937\", keyset: { keys: [\"5a2afbc4564b76b2c27ce5a644cab643c43663835ea0be22433b209d3351f937\"], pred: 'keys-all', }, }, }, co. . . [code continues] updateUri Use updateUri to update the URI associated with a specified token. You can use this function to modify the metadata associated with the specified token. Note that modifying the metadata for a token also updates the token identifier. You can prevent a token from being upgradeable by applying the non-updatable-uri-policy to the token. Code example (typescript): updateUri(inputs, config): IEmitterWrapper Inputs Parameter | Type | Description policyConfig | object | Specifies which types of policies are configured for the specified token. This object is used to validate that you have expected types defined for the all of the policies you have selected for a token. tokenId | string | Specifies the token identifier for the token that you want to update. uri | string | Specifies the location of the token metadata JSON file in the form of uniform resource identifier (URI) that you want to update. guard | object | Specifies the update URI (uriGuard) account information and guard. chainId | ChainId | Specifies the chain identifier for the chain where the token is being updated. Valid values are 0 to 19. Return value This function returns a boolean value to indicate whether updating the token URI was successful or failed. Example Code example (typescript): const result = await updateUri({ tokenId: \"t: . . . \", uri: \"ipfs: //new-uri\", guard: { account: \"k: 368820f80c324bbc7c2b0610688a7da43e39f91d118732671cd9c7500ff43cca\", keyset: { keys: [\"368820f80c324bbc7c2b0610688a7da43e39f91d118732671cd9c7500ff43cca\"], pred: 'keys-all' } }, chainId: \"0\", }, config ); withdrawToken Use withdrawToken to withdraw a specified token from a sale. Code example (typescript): withdrawToken(inputs, config): IEmitterWrapper Inputs Parameter | Type | Description policyConfig | object | Specifies which types of policies are configured for the specified token. This object is used to validate that you have expected types defined for the all of the policies you have selected for a token. tokenId | string | Specifies the token identifier for the token that you want to transfer. saleId | string | Specifies the Pact identifier for the sale. amount | IPactDecimal | Specifies the amount to withdraw. timeout | IPactInt | Specifies the timeout for when the offer can be withdrawn. seller | object | Specifies the seller account information and guard. chainId | ChainId | Specifies the chain identifier for the chain where the token is being withdrawn. Valid values are 0 to 19. Return value This function returns a boolean value to indicate whether withdrawing the token was successful or failed. Example Code example (typescript): const result = await withdrawToken({ tokenId: \"t: . . . \", saleId: \"\", amount: new PactNumber(1). toPactDecimal(), timeout: new PactNumber(1). toPactInteger(), seller: { account: \"k: 368820f80c324bbc7c2b0610688a7da43e39f91d118732671cd9c7500ff43cca\", keyset: { keys: [\"368820f80c324bbc7c2b0610688a7da43e39f91d118732671cd9c7500ff43cca\"], pred: 'keys-all' } }, chainId: \"0\", }, config );",
    "source": "reference/marmalade/marmalade-client-utils.md",
    "title": "Marmalade client utilities"
  },
  {
    "content": "Describes the schemas, tables, capabilities, and functions defined in the non-fungible policy. The non-fungible policy ensures the uniqueness of digital assets. If you apply this policy to a token, the policy guarantees that the token supply is one with a precision of zero. Source code: non-fungible-policy. pact Capabilities The non-fungible policy smart contract defines the following capability to manage permissions: - GOVERNANCE: Oversees access control for contract modifications. Functions The guard policy smart contract defines the following functions to enforce restrictions of different token activities: - enforce-init: Ensures proper initiation of tokens using a ledger guard. This sets the stage for minting by storing the mint guard associated with the token. - enforce-mint: Regulates the minting process, maintaining a fixed supply of 1 for each token, thus preserving its non-fungible nature.",
    "source": "reference/marmalade/non-fungible-policy.md",
    "title": "Non-fungible policy"
  },
  {
    "content": "Functions and capabilities defined in the Marmalade policy manager contract enforce the policies you select for tokens and token-related operations. contract As discussed in Token standard architecture, the policy manager provides a standard for collecting and distributing fungibles and ensures that all of the policies applied to tokens are enforced. The policy manager provides the following key features: - The ability to customize and manage token behavior and attributes by enforcing built-in and custom policies. - Consistent and predictable policy enforcement. - The ability to stack multiple policies to craft the exact behavior requirement for every token. - A standardized interface for all policies through kip. token-policy-v2. Source code: policy-manager. pact Tables and schemas The policy manager contract defines the following tables and schemas: - Ledgers table: Ensures functions are initiated only from the ledger. - Concrete policies table: Maintains concrete policy information for each token. - Sale whitelist table: Lists valid whitelisted sale contracts. - Quotes table: Archives quotes for quoted sales. - Ledger schema: Contains the module reference governed by the policy manager, adhering strictly to the ledger-v1 interface. - Concrete policies schema: Includes the module reference, strictly using the token-policy-v2 interface. Capabilities The policy manager supports a comprehensive set of capabilities to cover a wide array of functionalities: - GOVERNANCE - QUOTE @event - ESCROW - INIT-CALL - TRANSFER-CALL - MINT-CALL - BURN-CALL - OFFER-CALL - WITHDRAW-CALL - BUY-CALL - SALE-GUARD-CALL - FUNGIBLE-TRANSFER-CALL - UPDATE-QUOTE-PRICE @event - SALE-WHITELIST @event - CONCRETE-POLICY @event - OFFER - BUY - WITHDRAW Functions As a general rule, all of the enforce- functions require the ledger: : -CALL capability to be in scope to ensure that functions are initiated from the ledger. The enforce- functions then extract the policy list from the token input, which lists the associated policies. The policy manager defines the following functions: - enforce-init: Initiates policies: : enforce-init at marmalade-v2. ledger. create-token. - enforce-mint: Executes policies: : enforce-mint at marmalade-v2. ledger. mint. - enforce-burn: Activates policies: : enforce-burn at marmalade-v2. ledger. burn. - enforce-offer: Runs policies: : enforce-offer at marmalade-v2. ledger. offer (step 0 of marmalade-v2. ledger. sale). Here, an optional quote parameter can be accessed in the env-data field. If a quote is identified, the offer saves this quote, and escrow accounts are generated. Otherwise, the offer continues without quotes. - enforce-withdraw: Operates policies: : enforce-withdraw at marmalade-v2. ledger. withdraw (step 1 rollback of marmalade-v2. ledger. sale). - enforce-buy: Engages policies: : enforce-buy at marmalade-v2. ledger. buy (step 1 of marmalade-v2. ledger. sale). - write-concrete-policy: This function registers a concrete policy modref into the concrete policies table. - get-escrow-account: Returns the fungible escrow account created for quoted sales at enforce-offer. The escrow account receives the fungible from the buyer and distributes the fungibles to the policies and the seller at the buy step. - write-concrete-policy: Registers concrete policy modref into the concrete-policies table. - get-concrete-policy: Returns the modref of the concrete policy. - enforce-sale-pact**: Ensures that the sale parameter provided to the function is equal to the ID of the currently executing pact. It does this by calling the pact-id function to retrieve the ID of the currently executing pact and comparing it to the provided sale parameter. If they are not equal, an exception will be thrown.",
    "source": "reference/marmalade/policy-manager.md",
    "title": "Policy manager"
  },
  {
    "content": "Describes the schemas, tables, capabilities, and functions defined in the royalty policy. The royalty policy extends the functionality of the base kip. token-policy-v2 interface to provide specific rules for token actions and royalty payouts during the sale of a non-fungible token. Source code: royalty-policy. pact Schema and table - royalty-schema: Stores royalty-related information for NFTs, like the creator, royalty rate, and the associated fungible token. - royalties Table: Maintains royalty configurations for NFTs managed under the policy, including the token ID and its associated royalty details. Capabilities - GOVERNANCE: Governs contract upgrades. - ROYALTY @event: Emits the token-id and registered royalty information during enforce-init. - ROYALTY-PAYOUT @event: Emits royalty payout information during enforce-buy if a royalty is paid. Functions - enforce-init: Sets initial royalty information for a token, ensuring artists get their royalties. - enforce-buy: Manages royalty payouts during sales. Validates and abides by the agreed terms between buyer and seller. Payload message ROYALTY_SPEC: Initializes and validates a royalty for a fungible token. The royalty-schema object contains necessary fields like fungible, creator, creator-guard, royalty-rate, and quote-policy. Events ROYALTY: Triggered within the enforce-buy function when a sale concludes, and a royalty payment is made to the token's creator. Emitting line: (emit-event (ROYALTY sale-id (at 'id token) royalty-payout creator))",
    "source": "reference/marmalade/royalty-policy.md",
    "title": "Royalty policy"
  },
  {
    "content": "Build a non-fungible token (NFT) marketplace using the Marmalade token standard and Pact smart contracts. Marmalade contracts define a poly-fungible token standard and token policy management for the Kadena blockchain. These contracts provide interfaces for defining, minting, and managing digital items like non-fungible tokens and token collections using Pact smart contracts on the Kadena network. The Marmalade token standard architecture depends on several smart contracts that enable you to manage how tokens are minted, offered for sale, and transferred between accounts. This multi-layered contract architecture simplifies how you create and manage tokens, define marketplace policies, and implement common token features. Core contracts The Marmalade contract architecture provides separate contracts to handle specific tasks. For example, there are separate contracts for managing policies applied to token and for managing auction rules for token sales. This architecture ensures that functions are called in the correct order to complete multi-step transactions. At a high level, the Marmalade architecture consists of the following main contracts: - The Marmalade ledger (marmalade-v2. ledger) contract provides the core functionality of the marketplace with the ability to create, mint, burn, transfer, buy, and sell tokens. - The Marmalade policy manager (marmalade-v2. policy-manager) contract enables token creators to configure rules to control token properties and allowed operations. - Marmalade sale (marmalade-v2. sale-contracts) contracts enable tokens to be offered for sale using sales models that don't rely on a fixed price. Ledger contract The Marmalade ledger contract—marmalade-v2. ledger—is the primary contract that enables buyers and sellers use to interact with the marketplace. This contract keeps track of important information for everyone participating in the marketplace and records every transaction that takes place involving tokens minted with Marmalade. The ledger stores information about tokens, including the token metadata, the policies associated with the token, and the record of token ownership. The main functions in the ledger contract are The Marmalade Ledger plays a central role in enabling you to manage the lifecycle of non-fungible tokens and other digital assets. The ledger contract provides the core functions—such as create-token, mint, burn, transfer, and sale—that are required to create, transfer, and track the ownership of tokens. The ledger contract ensures that all token-related activity is recorded accurately and securely in a transparent, traceable, and tamper-proof way. The ledger contract defines the tables and schemas to store information about accounts and tokens. The ledger contract also defines specific capabilities to perform specific actions and enforce specific conditions when those actions are performed. The tables, schemas, and capabilities defined in the ledger contract ensure that token creators, token owners, and token buyers comply with predefined rules and constraints when they interact. By enforcing rules and constraints through token policies, Marmalade promotes more secure and trustworthy transactions for all marketplace participants. For more technical information about the Marmalade ledger contract, see Ledger contract. Policy manager The Marmalade policy manager contract—marmalade-v2. policy-manager—enables token creators to select multiple policies to configure the specific token features they want to implement. The policy manager acts as a middle layer between the ledger and the individual policies applied to a token. The policy manager gives token creators greater flexibility in defining rules for transferring ownership and managing transactions between buyers and sellers. For example, it's the policy manager contract that enables a sale to require a secure escrow account to complete a token transfer or to guarantee royalty payments. The following diagram provides a simplified view of how the policy manager contract acts as a middle layer between the ledger contract and policies applied to a token in the token creation process: ! Contract workflow to mint a token By using the policy manager contract, you can standardize the rules for creating asset properties, collecting payments, and transferring ownership within a marketplaces, providing a more consistent experience for marketplace participants. With the policy manager contract, you can choose token properties from built-in policies—like the non-fungible policy and royalty policy—or create custom policies to use on their own or in combination with the built-in policies. For more technical details about the Marmalade policy manager contract, see Policy manager contract. Sales-specific contracts Marmalade supports sales-specific contracts to provide flexibility for how tokens can be sold. Sales-specific contracts allow you to define different sales models with different sales mechanics—like auctions or limited offering periods—instead of simply quoting an asking price. When you offer a token for sale in the ledger, you can provide a reference to a specific contract that defines the rules for the sale. For example, the sale contract you reference might have auction rules that specify an opening price and how to handle incoming bids. Depending on the rules defined in the referenced sale contract, the policy manager contract updates the final price of the quote during the buy process. By using a separate contract to define and manage the mechanics of the sales process, you can ensure that buyers and sellers can participate safely without compromising royalty payments. It's important to note that contracts that define a sales model—the sale contract—must be reviewed and registered in the policy manager so that the policy manager can enforce the contract rules. The following diagram provides a simplified view of the interaction between the ledger, policy manager, and a sale contract: ! Contract interaction using a sale contract For information about registered sales-specific contracts, see the conventional sale and dutch sale contract reference. For more information about how to implement the sale contract interface or create a custom sale contract, see Custom sales contracts. Policies Individual policies give you granular control over token properties and token-related activity, including minting, burning, transferring, and buying tokens. Token policies are implemented as smart contracts based on the interfaces defined in the kip. token-policy-v2 standard. There are several built-in policies—called concrete policies—that are configured to handle the most common marketplace use cases. The built-in concrete policies are officially released and maintained to provide ready-to-use implementations of common features that don't require any custom development work. The concrete policies currently available provide the following features: - Guard enforcement policy. If the guard-policy is applied to a token, a keyset or another type of guard must be specified to initiate any token-related activity, bolstering security against unauthorized minting. - Non-fungible token enforcement policy. If the non-fungible-policy is applied to a token, the token is guaranteed to be unique with a maximum supply of one and precision set to zero. - Royalty enforcement policy. If the royalty-policy is applied to a token, you can designate an account to receive royalties each time the token is transferred to a new owner, fostering an ongoing revenue stream from NFT sales. - Collection identification policy. If the collection-policy is applied to a token, the token is identified as part of a collection and can be discovered as an item in a toke list. You can also create custom policies to implement unique rules or enforce specific behavior not covered by the concrete policies. You can find examples of custom policies in the examples/policies repository. Example policies aren't officially released and maintained, but can be useful models for developing your own custom policies. If an example or custom policy seems broadly useful to a general audience, it can be promoted to a concrete policy, contributing to the overall evolution of the Marmalade marketplace.",
    "source": "reference/marmalade/token-standard-architecture.md",
    "title": "Token standard architecture"
  },
  {
    "content": "Use the Kadena Marmalade token standard and policy contracts to build non-fungible or poly-fungible token marketplaces. Marmalade is the name of the Kadena token standard. This token standard defines the interfaces for minting digital items with Kadena smart contracts and protecting those digital items with Kadena token policies. Digital items that are unique, one-of-a-kind assets are most commonly referred to as non-fungible tokens (NFTs). However, the Kadena token standard is implemented as a multi-token or poly-fungible standard that enables you to define, mint, and secure tokens that are fully fungible as interchangeable coins, partially fungible as a limited edition with a fixed supply, or completely non-fungible as unique items. Tokens can also be restricted to a single owner with rules for transferring ownership or support shared ownership with multiple potential stakeholders. As a creator, you have complete control over your token properties and the rules for minting, owning, and transferring tokens. Traditional marketplaces for non-fungible tokens Non-fungible tokens defined using other token standards have two main drawbacks: - Most token standards assume that a change of ownership is always a transfer operation. However, a transfer-based model doesn't take into account the non-transferable nature of a unique asset. Marmalade supports both transfers and sales, with the additional flexibility to use token policies for either operation. - Most token standards don't provide any guarantees that creators will be paid royalties for their work or what they'll be paid from the exchanges that host their work. With Marmalade, Kadena eliminates these issues by making sales contracts and token policies core components of the token standard. Sales contracts In the simplest sense, a sale is typically a three-step process: 1. A seller lists an item for sale with a price. 2. A buyer agrees to pay the seller for the item at a mutually agreed-upon price. 3. The seller receives payment and transfers the item to the buyer. On the Kadena network, Pact smart contracts use pact functions to define multi-step operations like cross-chain transfers and automatic gas payments. The Marmalade token standard also uses pact functions to handle the multi-step nature of a sale. By using pact functions, contracts can define explicit steps that must be executed in a fixed order. The pact definition forms an enforceable sequence of actions that are executed on-chain. The sequence can't be altered and no steps can be skipped. For a transaction to be successful, all parties must complete the actions they are responsible for. All of the sequencing and cryptography required to enforce a sales contract is handled automatically by the Pact language itself. To complete a sale, the pact function defines the following steps: - Offer: A seller who wants to list a digital asset for sale creates an offer. This operation puts the asset into a trustless escrow account that can only be released by later steps in the pact definition. - Buy: A buyer initiates a buy operation with a promised payment and the escrowed asset waits for the step to be completed successfully by the buyer. - Withdraw: If the buyer doesn't complete the transaction within a certain period of time, the pact function can roll back the first step of the transaction and the seller can withdraw the sale. If the seller withdraws, the pact transfers the asset back to the seller's account from the escrow account. Token policies The Marmalade token standard enables creators to specify token policies to control how their assets can be minted, sold, and transferred and how royalties are paid. For example, a token policy might specify that an asset can't be transferred directly to a buyer until a purchase is complete and the royalty distributed to the creator. Token policies are implemented as smart contracts based on the interfaces defined in the kip. token-policy-v2 standard. There are several built-in policies—called concrete policies—that are configured to handle the most common marketplace use cases. For example, if you apply the non-fungible-policy to a token, the token is automatically configured to be minted only once. You can apply built-in policies to any token or write custom policies based on the kip. token-policy-v2 standard. You can also create collections of tokens using the collection-policy to establish marketplace communities that share a common approach to token ownership or token sales. After you create the group of tokens that make up the collection, the entire collection can be discovered from Chainweb events. For example, you can use token policies to define the following types of rules: - You can create tokens with a royalty policy to specify a royalty rate and the account that should receive royalties. - You can use policies to control mint operations such as whether a token is unique, part of a limited series, or a fully fungible coin. - You can use policies to prevent certain tokens from being burned or to be burned only when specific conditions are met. - You can use policies to restrict how tokens are owned and transferred. Preparing to mint a token Before you can mint a token on the blockchain, you must create the digital item and upload it to at least one accessible location such as InterPlanetary File System (IPFS), Arweave, or another content delivery or hosting service. After you have a uniform resource identifier (URI) for locating the digital item, you must also create a metadata file using the JSON schema to record the name, location, and other properties about the item to be minted. You can then create and mint the token for the digital item, generating an on-chain token identifier with a t: prefix. The token identifier includes the hash for the metadata that describes the token to ensure that a digital item can be cryptographically verified to be the original NFT. However, if you update the properties used to create a token—for example, to change a token that represents a character in a game each time the character completes a quest—the hash for the metadata will be different from the original hash and you are, in essence, creating a new token. Optionally, you can use a policy to prevent a token from being updated. Depending on how you apply or configure token policies, you might be the sole owner of the token you mint or share ownership with others. If you're the owner of a token, you have the option to offer the token for sale or transfer the token to another owner. Token sales and trustless escrow If you're the owner of a token, you can start the sales process to find a buyer by selecting and configuring a sale smart contract. You've already seen that a sale is essentially a pact with two steps: the offer step and the buy step. Smart contracts with the sale pact also use a special feature of pacts—pact guards—to govern the trustless escrow account for the token sale. After you offer an asset for sale, the asset is transferred to an account governed by a pact guard. From that point, only that pact guard—identified by its pact ID—can manage the asset in subsequent steps. Let's take a closer look at how a sale takes place, starting with an offer. Offer A seller creates an offer for the asset to be sold. For this example, the offer is a simple sale with a quoted asking price. There are other ways you can sell assets—including conventional auctions and dutch auctions—that implement different sale mechanics, but the general use of the trusted escrow account applies to all types of sales. The offer step transfers the asset from the seller's account in the token ledger to the escrow account. The sale pact assigns an identifier to the SALE event that results from the transfer operation. For example, Bob submits a transaction to offer NFT1 for sale with a price quote of 50 KDA. This transaction: - Removes NFT1 from Bob's account in the token ledger. - Transfers NFT1 to an escrow account associated with a specific sale identifier—sale: 1—in the token ledger. ! Bob starts a sale by offering NFT1 By initiating the sale, Bob loses custody of the asset for a period of time. The sale: 1 pact guard takes ownership of the asset. Buy The buyer who wants to acquire the asset that's been offered for sale sends a continuation transaction for the identifier assigned to the SALE event. For example, Alice sends a continuation transaction for the sale: 1 pact identifier to transfer NFT1 out of the escrow account in the token ledger and into her account. The ledger then debits the sale price of 50. 0 from Alice’s KDA account to credit Bob and executes any other offsetting transaction needed to release the escrowed NFT. For example, the token policy pays any royalty fees or returns any funds as specified in the policy. ! Alice continues the execution of the sale pact With this separation of duties, the sale pact is responsible for transferring the NFT out of escrow and enforcing the timeout. Any other transaction requirements are handled by token policies. Withdraw Sellers can specify a timeout as part of the offer step. If they set the timeout to zero (0) for a sale contract, they can withdraw from the sale at any time if there are no interested buyers for a token. If they set a specific timeout value—for example, to have an offer expire at midnight on 30 June 2024 with a timeout value of 1719705600—they can't pull out of the sale until after the specified timestamp. After the timeout, the seller can send a rollback continuation transaction for the identifier assigned to the SALE event. The withdraw operation then transfers the token out of the escrow account and returns it to the seller. Completing a logical sequence All of the logic required to step through the sales process is automatically handled by the Pact language. The pact definition ensures that step two can only happen after step one and only under the following conditions: - If step one hasn't been rolled back. - If step two hasn't already happened. Similarly, a rollback can’t occur if step one hasn’t happened, or if step two has already happened. With Pact, this logic isn't left to contract programmers. Instead, Pact prevents the contract developer from introducing faulty logic in sequencing the transaction. Using built-in policies The Marmalade token standard defines interfaces for policy-based token management. To simplify token creation using the standard, Kadena provides several built-in token policies for the most common features. You can use the built-in policies—called concrete policies—independently or in combination to provide the specific features you want to implement. For example: - Use the guard policy to prevent unauthorized token activity like minting or burning. - Use the non-fungible policy to ensure that a token can only be minted once and never burned. - Use the royalty policy to specify the account for depositing royalty payments from sales. - Use the collection policy to create token collections for a marketplace. - Use the non-updatable policy to prevent a token URI from being updated. To illustrate how you can use these policies, assume that you want to offer a non-fungible token. You want to ensure that you are the only person authorized to mint the token and that only one token can be minted and owned. You also want to require that the token can only be transferred to a new owner through a sale contract and you'll be paid a royalty any time the token ownership changes. To accomplish this, you can create the token using the marmalade-v2. guard-policy-v1, marmalade-v2. non-fungible-policy-v1, and marmalade-v2. royalty-policy-v1 policies. These policies help to ensure that you are the only person authorized to mint the token, only one token can be minted, and any time the token is transferred to a new owner, you're paid the royalty you specify. After you mint the token, all future sales respect the policies you've put in place. Any new NFT owner can only resell the NFT using the offer, trustless escrow, and royalty enforcement process with a new buyer. Creating custom policies If you find that some combination of concrete policies doesn't meet your needs, you can also use the built-in policies as models for creating your own custom token policies. You can find several examples of custom policies in Marmalade examples. Like concrete policies, custom policies must adhere to the kip. token-policy-v2 interface to be valid.",
    "source": "reference/marmalade/what-is-marmalade.md",
    "title": "What is Marmalade?"
  },
  {
    "content": "The Pact command-line interpreter enables you to run Pact code interactively and test Pact code and modules in an interactive terminal shell. Use the Pact command-line interpreter—also referred to as the Pact read–eval–print-loop (REPL) interactive shell program—to test Pact code and modules in an interactive terminal shell. The Pact command-line program also includes an HTTP server with a built-in REST API that provides commands and options for working with transactions in a simulated production environment. Basic usage Code example (bash): pact [COMMAND] [option] pact [option] FILE Depending on the option you provide, FILE can specify the path to a. pact file to compile or a. repl file to execute. You can specify command-line options before or after the file name. Options You can use the following command-line options with the pact command-line interpreter: | Option | Description | ------ | ----------- | -h, --help | Displays usage information for pact or for a specific command. | -v, --version | Displays version information. | -b, --builtins | Displays the list of Pact built-in native functions. | -g, --genkey | Generates a random public and secret key pair with the ED25519 signature scheme. | -s, --serve config-file | Starts a built-in HTTP server with the configuration file you specify. After you start the server, you can submit API requests to Pact API endpoints to simulate submitting API requests to a Chainweb node and to create transactions for testing purposes. | -r, --findscript file-name | Attempts to execute a. repl file to for the. pact file you specify. | -t, --trace file-name | Displays trace output for each line of code executed in the specified file. | -c, --coverage file-name | Generates a coverage report in the coverage/lcov. info file for the file you specify. | -a, --apireq api-request-yaml | Formats an API request as JSON using the api-request-yaml file you specify. | -l, --local | Formats a request for the /local endpoint on the built-in HTTP server or a Chainweb node. | -u, --unsigned api-request-yaml | Formats an unsigned API request as JSON using the api-request-yamlL file you specify. Commands You can use the following commands with the pact command-line interpreter: | Option | Description | ------ | ----------- | add-sig | Adds a signature to the signature data from standard input (stdin). | combine-sigs | Combines multiple signature files. | sign | Signs arbitrary base64url-encoded data from standard input (stdin). Basic examples To display usage information for the add-sig command, you can run the following command: Code example (pact): pact add-sig --help To generate a new public and secret key pair, you can run the following command: Code example (pact): pact --genkey This command produces output similar to the following snippet: Code example (bash): public: e552972a1a4fc0249fe528dd61c38779266cbebdcb49fdb48511259c28c1013c secret: 3d08b5eba8274ab0f3e137c59e06d20ee234e40d600ac8eae8f3e89c4e24478a To trace the output for a set of transactions defined in the election. repl file, you would run the following command: Code example (pact): pact --trace election. repl This command produces output similar to the following snippet: Code example (bash): election. repl: 1: 0: Trace: Setting transaction data election. repl: 11: 0: Trace: Setting transaction signatures/caps election. repl: 17: 0: Trace: Begin Tx 0: Define principal namespace election. repl: 18: 2: Trace: Namespace defined: n14912521e87a6d387157d526b281bde8422371d1 election. repl: 19: 0: Trace: Commit Tx 0: Define principal namespace election. repl: 21: 0: Trace: Begin Tx 1: Define admin-keyset election. repl: 22: 2: Trace: Namespace set to n14912521e87a6d387157d526b281bde8422371d1 election. repl: 23: 2: Trace: . . . [code continues] Work with transactions using Pact commands You can use the Pact command-line interpreter, built-in HTTP server, and SQLite backend to sign and submit transactions and to format transactions requests so that they can be executed using curl commands or Postman API calls. The following examples illustrate how you can use the Pact built-in HTTP server, command-line options, and API calls to work with transactions in a local development environment. Start the built-in server To start the built-in HTTP server: 1. Open a terminal shell on your local computer. 2. Create a configuration file using YAML format with the following properties: Code example (bash): port - HTTP server port number. persistDir - Directory for persisting database files. If you omit this setting, the server runs in-memory only. logDir - Directory for HTTP logs. pragmas - SQLite pragma statement to use with persistent database files. entity - Entity name for simulating privacy. The default is \"entity\". gasLimit - Gas limit for each transaction. The default is zero (0). gasRate - Gas price per action. The default is zero (0). flags. . . [code continues]bash pact --apireq test-yaml. yaml | curl --json @- http: //localhost: 8081/api/v1/send Code example (): The command returns the request key for the transaction: {\"requestKeys\": [\"rXOJyLWXQAQqMaHP-oIN1GDsKqwwzv-thqY-NZzmtYo\"]} Code example (): To poll for the results of a transaction, you can run a command similar to the following: bash curl -L http: //localhost: 8081/api/v1/poll -H 'Content-Type: application/json' -H 'Accept: application/json' --json '{\"requestKeys\": [\"rXOJyLWXQAQqMaHP-oIN1GDsKqwwzv-thqY-NZzmtYo\"]}' Code example (): In this example, the transaction is complete and the request returns the following response: bash {\"rXOJyLWXQAQqMaHP-oIN1GDsKqwwzv-thqY-NZzmtYo\": {\"gas\": 0, \"result\": {\"status\": \"success\", \"data\": 30}, \"reqKey\": \"rXOJyLWXQAQqMaHP-oIN1GDsKqwwzv-thqY-NZzmtYo\", \"logs\": \"wsATyGqckuIvlm89hhd2j4t6RMkCrcwJe_oeCYr7Th8\", \"metaData\": null, \"continuation\": null, \"txId\": 1}}% ```",
    "source": "reference/pact-cli.md",
    "title": "Pact command-line interpreter"
  },
  {
    "content": "Technical documentation for the Kadena RWA token standard initial minimally-viable product (MVP) contract. The mvp-token contract implements the agent-role-v1 interface. The interface defines the core capabilities and function signatures for adding and managing agents that have permission to perform protected contract operations. The mvp-token contract extends the agent-role-v1 interface by defining additional capabilities and functions to complement the core capabilities and function signatures. Capabilities The mvp-token contract defines the following capabilities: Capability | Implementation required | Description: --------- |: ---------------------- |: ---------- AGENT-ADDED | agent-role-v1 | Event emitted when you add a new agent. AGENT-REMOVED | agent-role-v1 | Event emitted when you use remove an agent. AGENT&#8209; ROLES&#8209; UPDATED | Not required. | Event emitted when you update the roles assigned to an agent. ONLY-AGENT | agent-role-v1 | Managed capability to restrict access to specific functions based on the agent role. ONLY-OWNER | agent-role-v1 | Managed capability to restrict access to specific functions tha can only executed by the contract owner (not used in the mvp-token contract). OWNERSHIP&#8209; TRANSFERRED | agent-role-v1 | Event emitted when you transfer ownership of the contract to a new guard. Functions The mvp-token contract defines the following functions: Function | Implementation required | Description: --------- |: ---------------------- |: ---------- add-agent | agent-role-v1 | Adds a new agent to the contract. enforce-agent | Not required. | Enforces that an address is an agent. get-agent-roles | Not required. | Retrieves the roles assigned to an agent. get-owner-guard | Not required. | Retrieves the guard for the owner. is-agent | agent-role-v1 | Returns a boolean if an address is an agent. only-agent | agent-role-v1 | Ensures access is limited to agents. only-owner | agent-role-v1 | Ensures access is limited to agents (not used in the mvp-token contract). only-owner-or-agent-admin | Not required. | Ensures access is limited to owners or agents with the admin role. remove-agent | agent-role-v1 | Removes an agent from the contract. transfer-ownership | agent-role-v1 | Transfers ownership of the contract. update-agent-roles | Not required. | Updates the roles for an agent. verify-agent-roles | Not required. | Verifies the roles assigned to an agent. Agent role interface The agent-role interface describes the core capabilities and function signatures for managing agents and roles. At a minimum, the mvp-token contract must implement all of the capabilities and functions included in the interface. Event capabilities - AGENT-ADDED: Event for the successful execution of an add-agent transaction. - AGENT-REMOVED: Event for the successful execution of a remove-agent transaction. - OWNERSHIP-TRANSFERRED: Event for the successful execution of a transfer-ownership transaction. Managed capabilities - ONLY-OWNER: Validates whether an address has the owner role before allowing the address to be used to execute a transaction. - ONLY-AGENT: Validates whether an address has the agent role before allowing the address to be used to execute a transaction. State-changing functions - add-agent: Adds a new agent and guard to the contract. - remove-agent: Removes an agent from the contract. - transfer-ownership: Transfers ownership of the contract to a new guard. Utility functions - is-agent: Checks whether an address is an agent and returns a boolean indicating the result of he check. - only-agent: Checks whether an address has acquired the ONLY-AGENT capability to grant access to functions that can only be executed by valid agents. - only-owner: Checks whether an address has acquired the ONLY-OWNER capability to grant access to functions that can only be executed by the operational owner.",
    "source": "reference/real-world-assets/agents-and-roles.md",
    "title": "Agents and roles"
  },
  {
    "content": "Technical reference for the Kadena RWA token standard identity registration interface. The mvp-token contract implements the identity-registry-v1 interface. The interface defines the core capabilities and function signatures for managing investor identities. The mvp-token contract extends the identity-registry-v1 interface by defining additional capabilities and functions to complement the core capabilities and function signatures. Capabilities The mvp-token contract defines the following capabilities: Capability | Implementation required | Description: --------- |: ---------------------- |: ---------- CLAIM-TOPICS-REGISTRY-SET | identity-registry-v1 | Event emitted when the claim topics registry is set for the Identity Registry (not used in the mvp-token contract). COUNTRY-UPDATED | identity-registry-v1 | Event emitted when the numeric country code for an identity is updated (not used in the mvp-token contract). IDENTITY-REGISTERED | identity-registry-v1 | Event emitted when an identity is registered in the identity registry. | IDENTITY-REGISTRY-ADDED | Not required. | Event emitted when an identity registry is added (not used in the mvp-token contract. ) IDENTITY-REMOVED | identity-registry-v1 | Event emitted when an identity is removed from the identity registry. IDENTITY-UPDATED | identity-registry-v1 | Event emitted when identity information is updated (not used in the mvp-token contract). RECOVERY-SUCCESS | Not required. | Event emitted when the balance from a lost wallet address is successfully recovered. TRUSTED-ISSUERS-REGISTRY-SET | identity-registry-v1 | Event emitted when the trusted issuers registry is set for the Identity Registry (not used in the mvp-token contract). Functions The mvp-token contract defines the following functions: Function | Implementation required | Description: --------- |: ---------------------- |: ---------- batch-register-identity | identity-registry-v1 | Registers identities for multiple users. contains-identity | identity-registry-v1 | Checks if a user address is associated with an identity. delete-identity | identity-registry-v1 | Removes a user's identity from the registry. enforce-contains-identity | Not required. | Validates that a user address has a registered identity. investor-country | identity-registry-v1 | Returns the numeric country code for a specified investor address (not used in the mvp-token contract). investor-identity | identity-registry-v1 | Returns the kadenaID for a specified investor address (not used in the mvp-token contract). is-verified | identity-registry-v1 | Checks whether an identity contract corresponding to the specified investor address has the required claims, based on the data fetched from the trusted issuers registry and the claim topics registry (not used in the mvp-token contract). issuers-registry | identity-registry-v1 | Returns the trusted issuers registry linked to the current identity registry (not used in the mvp-token contract). recovery-address | Not required. | Recovers tokens from a lost wallet address into a new wallet. register-identity | identity-registry-v1 | Registers an identity contract (kadenaID) that corresponds to an investor's wallet address. register-identity-internal | Not required. | Provides internal logic—that's called by the contract rather than an agent or owner—to register an investor identity. set-claim-topics-registry | identity-registry-v1 | Replaces the claimTopicsRegistry contract with a new claim topics registry (not used in the mvp-token contract). set-identity-registry | Not required. | (not used in the mvp-token contract). set-trusted-issuers-registry | identity-registry-v1 | Replaces the trustedIssuersRegistry contract with a new contract (not used in the mvp-token contract). topics-registry | identity-registry-v1 | Returns the claim topics registry linked to the current identity registry (not used in the mvp-token contract). update-country | identity-registry-v1 | Updates the numeric country code for a specified investor address (not used in the mvp-token contract). update-identity | identity-registry-v1 | Updates the identity contract that corresponds to a specified investor address (not used in the mvp-token contract). Identity registry interface The identity registry interface describes the core capabilities and function signatures for registering and managing investor identities. The interface also includes foundational support for identity verification and integration with claim topics and trusted issuers registries. At a minimum, the mvp-token contract must implement all of the capabilities and functions included in the interface. Event capabilities - CLAIM-TOPICS-REGISTRY-SET: Event for the successful execution of a set-claim-topics-registry transaction. - TRUSTED-ISSUERS-REGISTRY-SET: Event for the successful execution of a set-trusted-issuers-registry transaction. - IDENTITY-REGISTERED: Event for the successful execution of a register-identity transaction. - IDENTITY-REMOVED: Event for the successful execution of a delete-identity transaction. - IDENTITY-UPDATED: Event for the successful execution of a update-identity transaction. - COUNTRY-UPDATED: Event for the successful execution of a update-country transaction. State-changing functions - batch-register-identity: Allows batch registration of multiple investor identities. - delete-identity: Removes an investor identity from the identity registry. - register-identity: Registers an identity contract (kadenaID) that corresponds to an investor address. - set-claim-topics-registry: Replaces the claimTopicsRegistry contract with a new contract. - set-trusted-issuers-registry: Replaces the actual trustedIssuersRegistry contract with a new contract. - update-country: Updates the numeric country code for to a specified investor address. - update-identity: Updates an identity contract that corresponds to a specified investor address. Utility functions - contains-identity: Checks whether a wallet has an identity registered. - is-verified: Checks whether an identity contract that corresponds to the specified investor address has the required claims, based on the data fetched from the trusted issuers registry and the claim topics registry. - investor-identity: Returns the kadenaID for a specified investor address. - investor-country: Returns the numeric country code for a specified investor address. - issuers-registry: Returns the trusted issuers registry linked to the current identity registry. - topics-registry: Returns the claim topics registry linked to the current identity registry.",
    "source": "reference/real-world-assets/identity-registry.md",
    "title": "Identity registry"
  },
  {
    "content": "Technical documentation for the Kadena RWA token standard initial minimally-viable product (MVP) contract. The mvp-token contract is an example of a real-world asset (RWA) token that can be configured with custom compliance rules for mint, burn, and transfer operations. This sample contract implements Kadena RWA token standard interfaces that are defined in the following modules: - real-world-asset-v1 - agent-role-v1 - identity-registry-v1 - compliance-compatible-v1 The mvp-token contract extends the functionality defined in the Kadena fungible-v2 interface to demonstrate customized mint, burn, transfer, and forced-transfer operations for tokens. The contract also provides pause and freeze functions to demonstrate restricting operations for an entire contract or specific investor accounts. In addition to the functions for managing tokens, the mvp-token contract implements agent roles to enforce transaction signature requirement and an identity registry to manage investor identities and account information. However, the contract doesn't implement identity verification. Because the contract implements the compliance-compatible-v1 interface, you can add one or more compliance contracts to customize the rules for mint, burn, abd transfer operations. The mvp-token contract provides the following sample compliance contracts to demonstrate practical use cases: - max-balance-compliance-v1 - max-investors-compliance-v1 - supply-limit-compliance-v1 Governance The mvp-token contract defines two types of owners: Type | Defined as | Description: --- |: --------- |: ---------- Governance | GOV-KEYSET | Identifies the primary module owner responsible for contract upgrades and initialization. The GOV capability enforces ownership using (enforce-keyset GOV-KEYSET) statement. Operational owner | owner-guard | Specifies the account registered during contract initialization and granted access to specific operational functions. You can update the owner-guard after registration by calling the transfer-ownership function. The operational owner is enforced by the (only-agent \"owner\") function. For more information about this function and other predefined roles, see Agent roles. Initialization Use init to initialize the mvp-token contract with the following information: - Token owner-guard - Token name - Token symbol - Token decimal precision - Kadena on-chain identifier for the owner identity - Compliance module references - Paused state Requirements The signer for an init transaction must be the GOV-KEYSET governance capability owner with the GOV capability. Input parameters Use the following input parameters: Parameter | Type | Description: -------- |: --- |: ---------- name | string | Name of the token being initialized. symbol | string | Symbol to use for the token being initialized. decimals | integer | Decimal precision for the token being initialized. kadenaID | string | Optional placeholder identity for the owner of the token being initialized. compliance | [module{RWA. compliance-v1}] | Compliance rules to apply for the token being initialized. paused | bool | Initial state for the token being initialized. owner-guard | guard | Guard for the identity that owns the token being initialized. State changes The init function makes the following state changes: - Registers token metadata in the token table using the values you specify for the input parameters. - Sets the paused state to true or false based on paused input parameter. - Assigns owner guard to authorize operational control for the specified owner-guard input parameter. - Initializes the specified compliance modules with default compliance parameters. Events The init function emits the following events: - UPDATED-TOKEN-INFORMATION with the parameters name, symbol, MINIMUM-PRECISION, VERSION, and kadenaID. - COMPLIANCE-PARAMETERS with the default compliance parameters for the compliance modules applied to the token. - COMPLIANCE-UPDATED with the list of compliance modules. Error codes The init function reports the following errors: - CMPL-DUP-001 if there are duplicate compliance modules in the input parameters. Transaction signatures and agent roles In the mvp-token contract, many of the functions that enable you to control token transfers or manage identities require the transactions where they are called to be signed by a registered agent or token owner. Some functions also require the agent or owner signing the transaction to have been assigned a specific role and be granted specific capabilities. - Use add-agent to register and assign one or more roles to the agent. - Use remove-agent to remove a previously register agent. Agent roles You can assign the following roles to an agent: - agent-admin grants administrative rights to enable an agent to sign transactions that execute protected functions. - freezer grants an agent permission to pause and resume token transfer operations, to freeze and unfreeze specific investor addresses, and to freeze and unfreeze a specific number of tokens for specific addresses. - transfer-manager grants an agent permission to mint, burn, and forcibly transfer tokens. You assign roles as part of the transaction data when you submit a transaction request to perform a specific operation. Role enforcement Roles are enforcement by calling the following functions: - only-agent ensures that the caller signs the (ONLY-AGENT \"agent-role\") managed capability with a registered agent guard. The agent address is retrieved from the data field, rather than passed as a parameter. Note that the owner role—for example, (ONLY-AGENT \"owner\")—can only be added when calling the init or transfer-ownership function, can only be assigned to one address, and is retrieved directly from the table. - only-owner-or-agent-admin ensures that the caller signs either as an agent with role agent-admin or as the owner role. add-agent Use add-agent to add a new agent or reactivate an existing agent that's not currently active. Requirements The signer for an add-agent transaction must be an agent with the owner role and capability (ONLY-AGENT \"owner\"). Before calling the function, you should verify the following information: - The agent name you intend to add doesn't already exist as an active agent account. - The agent account is a valid principal account. - The agent roles you intend to assign are valid roles that are defined in the contract. Input parameters Use the following input parameters: Parameter | Type | Description: -------- |: --- |: ---------- agent | string | Name of the agent being added. guard | string | Guard for the agent you are adding. roles | [agent-role: string] | One or more roles assigned to the agent you are adding and retrieved from the data field in the transaction. State changes The add-agent function makes the following state changes: - Adds the new agent with the specified agent roles to the registry. - Reactivates the agent if the agent was previously deactivated. Events The add-agent function emits the following events: - ONLY-AGENT with the parameter owner. - AGENT-ADDED with the parameters agent and guard. - AGENT-ROLES-UPDATED with the parameters agent and roles. Error codes The add-agent function reports the following errors: - ACC-PRT-001 if the agent you're attempting to add isn't a principal account. - ROL-STS-001 if the agent name you're attempting to add already exists and is currently active. - ROL-STS-002 if the signer for the transaction isn't a valid active agent. - ROL-STS-003 if the signer for the transaction doesn't have the required role. remove-agent Use remove-agent to remove a specified agent from the registry. Requirements The signer for a remove-agent transaction must be an agent with the owner role and capability (ONLY-AGENT \"owner\"). In addition, the agent must be a registered identity. Input parameters Use the following input parameters: Parameter | Type | Description: -------- |: --- |: ---------- agent | string | Name of the agent being removed. State changes The remove-agent function makes the following state change: - Removes the specified agent from the registry. Events The remove-agent function emits the following events: - ONLY-AGENT with the parameter owner. - AGENT-REMOVED with the parameter agent. - AGENT-ROLES-UPDATED with the parameters agent and roles. Error codes The remove-agent function reports the following errors: - ROL-STS-002 if the signer for the transaction isn't a valid active agent. - ROL-STS-003 if the signer for the transaction doesn't have the required role. pause Use pause to pause transfer operations of the token until resumed. Requirements The signer for a pause transaction must be an agent with the freezer role and capability (ONLY-AGENT \"freezer\"). In addition, the current state for the token must be unpaused (paused false). Input parameters Use the following input parameters: Parameter | Type | Description: -------- |: --- |: ---------- agent | string | Name of the agent with the freezer role and retrieved from the data field for the transaction. State changes The pause function makes the following state change: - Updates the contract's internal state to mark it as paused. Events The pause function emits the following events: - ONLY-AGENT \"freezer\" to indicate that an agent with the freezer role has been invoked. - PAUSED to indicate that the pause transaction request was executed successfully. Error codes The pause function reports the following errors: - PAU-001 if the token is already in a paused state. - ROL-STS-002 if the signer for the transaction isn't a valid active agent. - ROL-STS-003 if the signer for the transaction doesn't have the required role. unpause Use unpause to resume token transfer operations after being paused. Requirements The signer for a unpause transaction must be an agent with the freezer role and capability (ONLY-AGENT \"freezer\"). In addition, the current state for the token must be paused (paused true). Input parameters Use the following input parameters: Parameter | Type | Description: -------- |: --- |: ---------- agent | string | Name of the agent with the freezer role and retrieved from the data field for the transaction. State changes The unpause function makes the following state change: - Updates the contract's internal state to mark it as unpaused. Events The unpause function emits the following events: - ONLY-AGENT \"freezer\" to indicate that an agent with the freezer role has been invoked. - UNPAUSED to indicate that the unpause transaction request was executed successfully. Error codes The unpause function reports the following errors: - PAU-002 if the token is not in a paused state. - ROL-STS-002 if the signer for the transaction isn't a valid active agent. - ROL-STS-003 if the signer for the transaction doesn't have the required role. set-address-frozen Use set-address-freeze to freeze or unfreeze a specific address, restricting or restoring its ability to interact with the token contract. Requirements The signer for a set-address-freeze transaction must be an agent with the freezer role and capability (ONLY-AGENT \"freezer\"). In addition: - The current state for the address must unfrozen if using this function to freeze the specified address (freeze true). - The current state for the address must frozen if using this function to unfreeze the specified address (freeze false). Input parameters Use the following input parameters: Parameter | Type | Description: -------- |: --- |: ---------- agent | string | Name of the agent with the freezer role and retrieved from the data field for the transaction. investor-address | string | Address of the account to freeze or unfreeze. freeze | bool | State you want to set for the specified address. Set to true to freeze the address or false to unfreeze the address. State changes The set-address-freeze function makes the following state changes: - Updates the contract's internal state to mark the specified address as frozen if freeze is set to true. - Updates the contract's internal state to mark the specified address as unfrozen if freeze is set to false. Events The set-address-freeze function emits the following events: - ONLY-AGENT \"freezer\" - ADDRESS-FROZEN with the parameters investor-address and the freeze state. Error codes The set-address-freeze function reports the following errors: - ACC-FRZ-002 if you attempt to freeze an account that's already frozen or unfreeze an account that isn't currently frozen. - ROL-STS-002 if the signer for the transaction isn't a valid active agent. - ROL-STS-003 if the signer for the transaction doesn't have the required role. freeze-partial-tokens Use freeze-partial-tokens to freeze a specific number of tokens in a specified account. The frozen portion of tokens can't be accessed or transferred from the account. Any remaining tokens in the account are available to transfer. Requirements The signer for a freeze-partial-tokens transaction must be an agent with the freezer role and capability (ONLY-AGENT \"freezer\"). In addition: - The token amount must be a positive decimal value and a valid unit amount. - The number of tokens specified by the amount parameter must not exceed the account holder's available balance. Input parameters Use the following input parameters: Parameter | Type | Description: -------- |: --- |: ---------- agent | string | Name of the agent with the freezer role and retrieved from the data field for the transaction. investor-address | string | Address of the account holding the tokens you want to freeze a portion of. amount | decimal | Number of tokens to lock to prevent them from being transferred from the specified account. State changes The freeze-partial-tokens function makes the following state change: - Locks the specified number of tokens held in specified address account to prevent them from being transferred. Events The freeze-partial-tokens function emits the following events: - ONLY-AGENT \"freezer\" to indicate that an agent with the freezer role has been invoked. - TOKENS-FROZEN with the parameters investor-address and amount. Error codes The freeze-partial-tokens function reports the following errors: - FRZ-AMT-002 if the number of tokens specified by the amount parameter exceeds the account holder's available balance. - FRZ-AMT-004 if the number of tokens specified by the amount parameter isn't a positive decimal value or a valid unit amount. - ROL-STS-002 if the signer for the transaction isn't a valid active agent. - ROL-STS-003 if the signer for the transaction doesn't have the required role. unfreeze-partial-tokens Use unfreeze-partial-tokens to unlock a specific portion of frozen tokens in an account. Requirements The signer for an unfreeze-partial-tokens transaction must be an agent with the freezer role and capability (ONLY-AGENT \"freezer\"). In addition: - The number of tokens specified by the amount parameter must be a positive decimal value and a valid unit amount. - The number of tokens specified by the amount parameter must be less than or equal to the account holder's frozen token balance. Input parameters Use the following input parameters: Parameter | Type | Description: -------- |: --- |: ---------- agent | string | Name of the agent with the freezer role and retrieved from the data field for the transaction. investor-address | string | Address of the account holding the tokens you want to unfreeze. amount | decimal | Number of tokens to unlock for the specified account. State changes The unfreeze-partial-tokens function makes the following state change: - Unlocks the specified number of tokens to allow then to be transferred from the specified address. Events The unfreeze-partial-tokens function emits the following events: - ONLY-AGENT \"freezer\" to indicate that an agent with the freezer role has been invoked. - TOKENS-UNFROZEN with the parameters investor-address and amount. Error codes The unfreeze-partial-tokens function reports the following errors: - FRZ-AMT-003 if the number of tokens specified by the amount parameter isn't less than or equal to the account holder's frozen token balance. - FRZ-AMT-004 if the number of tokens specified by the amount parameter isn't a positive decimal value or a valid unit amount. - ROL-STS-002 if the signer for the transaction isn't a valid active agent. - ROL-STS-003 if the signer for the transaction doesn't have the required role. mint Use mint to create new tokens and assign them to a specified account, increasing the total supply. Requirements The signer for a mint transaction must be an agent with the transfer-manager role and capability (ONLY-AGENT \"transfer-manager\"). In addition: - The number of tokens specified by the amount parameter must be a positive decimal value and a valid unit amount. - The account specified by the to parameter must be a registered identity with an address that isn't frozen. - The mint operation must pass all of the checks that are defined by the registered compliance rules. Input parameters Use the following input parameters: Parameter | Type | Description: -------- |: --- |: ---------- agent | string | Name of the agent with the transfer-manager role and retrieved from the data field for the transaction. to | string | Address of the account to receive the tokens. amount | decimal | Number of tokens to transfer to the specified account. State changes The mint function makes the following state changes: - Adds the specified amount number of tokens to the specified receiving address. - Increases the total token supply. - Increments the investor-count if the previous balance for the receiving account was 0. 0. Events The mint function emits the following events: - ONLY-AGENT \"transfer-manager\" to indicate that an agent with the transfer-manager role has been invoked. - TRANSFER with the parameter values for the to account and amount minted into the account. - RECONCILE with the parameter values for the amount and the updated balance for the receiving account. - SUPPLY with the parameter values for the new total token supply. Error codes The mint function reports the following errors: - ACC-FRZ-001 if the receiving account address is frozen. - IDR-001 if the receiving account address isn't a registered identity. - ROL-STS-002 if the signer for the transaction isn't a valid active agent. - ROL-STS-003 if the signer for the transaction doesn't have the required role. burn Use burn to destroy tokens from a specified account, reducing the total supply. Requirements The signer for a burn transaction must be an agent with the transfer-manager role and have the following capabilities: - (ONLY-AGENT \"transfer-manager\") - (TRANSFER investor-address \"\" amount) Before calling the function, you should verify the following information for the account specified by the investor-address parameter: - The investor-address account is a registered identity. - The investor-address account address isn't frozen. - The investor-address account has an unfrozen balance that's greater than the number of tokens specified for the amount parameter. In addition: - The number of tokens specified by the amount parameter must be a positive decimal value and a valid unit amount. - The burn operation must pass all of the checks that are defined by the registered compliance rules. Input parameters Use the following input parameters: Parameter | Type | Description: -------- |: --- |: ---------- agent | string | Name of the agent with the transfer-manager role and retrieved from the data field for the transaction. investor-address | string | Address of the account with the tokens to be burned. amount | decimal | Number of tokens to burn for the specified account. State changes The burn function makes the following state changes: - Deducts the specified amount number of tokens from the specified investor-address account. - Decreases the total token supply. - Decrements the investor-count if the investor-address account balance is 0. 0. Events The burn function emits the following events: - ONLY-AGENT \"transfer-manager\" to indicate that an agent with the transfer-manager role has been invoked. - TRANSFER with the parameter values for the investor-address account and amount burned. - RECONCILE with the parameter values for the amount and the updated balance for the investor-address account. - SUPPLY with the parameter values for the new total token supply. Error codes The burn function reports the following errors: - ACC-FRZ-001 if the investor-address account is frozen. - ACC-AMT-001 if the unfrozen balance in the investor-address account isn't greater than the number of tokens specified for the amount parameter. - ROL-STS-002 if the signer for the transaction isn't a valid active agent. - ROL-STS-003 if the signer for the transaction doesn't have the required role. transfer Use transfer to transfer tokens from one account to another. Requirements The signer for a transfer transaction must be the account that holds the tokens to be transferred from and have the (TRANSFER from to amount) capability. Before calling the function, you should verify the following information: - The sender from account address isn't frozen. - The sender from account has an unfrozen balance that's greater than the number of tokens specified for the amount parameter. - The receiving to account is a registered identity. - The receiving to account address isn't frozen. In addition: - The number of tokens specified by the amount parameter must be a positive decimal value and a valid unit amount. - The transfer operation must pass all of the checks that are defined by the registered compliance rules. - The token contract must not be paused. Input parameters Use the following input parameters: Parameter | Type | Description: -------- |: --- |: ---------- from | string | Name of the account holding the tokens to be transferred. to | string | Name of the account to receive the tokens being transferred. amount | decimal | Number of tokens to transfer from the sender to the receiving account. State changes The transfer function makes the following state changes: - Transfers the specified amount from the sender from account to the receiving to account. - Increments the investor-count if the previous balance for the receiving account was 0. 0. - Decrements the investor-count if the from account balance is 0. 0 after executing the transfer operation. Events The transfer function emits the following events: - TRANSFER with the parameters from, to, and amount. - RECONCILE with the parameters amount, from-balance-change, and to-balance-change. Error codes The transfer function reports the following errors: - TRF-CAP-001 if the capability required to execute a transfer can't be acquired. - TRF-PAUSE-001 if the token contract is currently paused. forced-transfer Use forced-transfer to forcibly transfer tokens from one account to another, bypassing standard transfer restrictions. Requirements The signer for a forced-transfer transaction must be an agent with the transfer-manager role and have the following capabilities: - (ONLY-AGENT \"transfer-manager\") - (TRANSFER investor-address from to amount) Before calling the function, you should verify the following information: - The sender from account must have an account balance that's greater than the number of tokens specified for the amount parameter. - The receiving to account must be a registered identity. - The number of tokens specified by the amount parameter must be a positive decimal value and a valid unit amount. Input parameters Use the following input parameters: Parameter | Type | Description: -------- |: --- |: ---------- agent | string | Name of the agent with the transfer-manager role and retrieved from the data field for the transaction. from | string | Name of the account holding the tokens to be transferred. to | string | Name of the account to receive the tokens being transferred. amount | decimal | Number of tokens to transfer from the sender to the receiving account. State changes The forced-transfer function makes the following state changes: - Transfers the specified amount from the sender from account to the receiving to account. - Unfreezes tokens in the sender from account if the available unfrozen token balance isn't enough to cover the specified amount, but the total account balance is greater than or equal to the specified amount. - Increments the investor-count if the previous balance for the receiving account was 0. 0. - Decrements the investor-count if the from account balance is 0. 0 after executing the forced-transfer operation. Events The forced-transfer function emits the following events: - ONLY-AGENT \"transfer-manager\" to indicate that an agent with the transfer-manager role has been invoked. - TRANSFER with the parameters from, to, and amount. - TOKENS-UNFROZEN to indicate that frozen tokens were required to execute the forced-transfer operation. - RECONCILE with the parameters amount and the investor balance changes. Error codes The forced-transfer function reports the following errors: - FRZ-AMT-003 if the total number of tokens including the currently frozen tokens is insufficient to cover the specified amount parameter. - FRZ-AMT-004 if the number of tokens specified by the amount parameter isn't a positive decimal value or a valid unit amount. - TRF-PAUSE-001 if the token contract is currently paused. - ROL-STS-002 if the signer for the transaction isn't a valid active agent. - ROL-STS-003 if the signer for the transaction doesn't have the required role. register-identity Use register-identity to register an identity contract that corresponds to an investor's wallet address and create an investor account in the investors table for the identity registered in the identities table. Requirements The signer for a register-identity transaction must be an agent with the admin or owner role and capability (ONLY-AGENT \"admin\") or (ONLY-AGENT \"owner\"). Before calling this function, you should verify the following information: - The investor wallet address you are attempting to register is a valid principal account. - The investor identity contract you are attempting to register must not already be active. Input parameters Use the following input parameters: Parameter | Type | Description: -------- |: --- |: ---------- agent | string | Name of the agent with the agent-admin or owner role and retrieved from the data field for the transaction. investor-address | string | Address of the account you are adding to the identity registry. investor-guard | string | Guard for the identity that you are adding to the identity registry. investor-identity | string | Identity is the address of the identity contract stored as the kadenaID in the identities table for the specified investor address and guard. country | integer | Numeric country code as defined in the ISO 3166-1 standard. State changes The register-identity function makes the following state changes: - Adds the investor and identity information specified to the identity registry. - Adds a token account for the investor if the investor account doesn't currently exist. Events The register-identity function emits the following events: - ONLY-AGENT \"owner\" to indicate that an agent with the owner role has been invoked. - ONLY-AGENT \"admin\" to indicate that an agent with the agent-admin role has been invoked. - IDENTITY-REGISTERED with the parameters investor-address, investor-guard, and investor-identity. Error codes The register-identity function reports the following errors: - IDR-003 if the identity contract you're attempt to register is already active. - ACC-PRT-001 if the investor you're attempting to register isn't a valid principal account. - ROL-STS-002 if the signer for the transaction isn't a valid active agent. - ROL-STS-003 if the signer for the transaction doesn't have the required role. delete-identity Use delete-identity to remove an investor identity from the identity registry. Requirements The signer for a delete-identity transaction must be an agent with the admin or owner role and capability (ONLY-AGENT \"admin\") or (ONLY-AGENT \"owner\"). Before calling this function, you should verify the following information: - The investor address you are attempting to delete must exist in the identity registry. - The investor token account must have a balance of 0. 0. Input parameters Use the following input parameters: Parameter | Type | Description: -------- |: --- |: ---------- agent | string | Name of the agent with the agent-admin or owner role and retrieved from the data field for the transaction. | investor-address | string | Address of the account you are removing from the identity registry. | State changes The delete-identity function makes the following state change: - Update the identity information in the registry as inactive. Events The delete-identity function emits the following events: - ONLY-AGENT \"owner\" to indicate that an agent with the owner role has been invoked. - ONLY-AGENT \"admin\" to indicate that an agent with the agent-admin role has been invoked. - IDENTITY-REMOVED wit the parameter investor-address. Error codes The delete-identity function reports the following errors: - IDR-002 if the account balance for the identity is greater than 0. 0. - ROL-STS-002 if the signer for the transaction isn't a valid active agent. - ROL-STS-003 if the signer for the transaction doesn't have the required role. recovery-address Use recovery-address to recover tokens from a lost wallet into a new wallet. Requirements The signer for a recovery-address transaction must be an agent with the admin or owner role and capability (ONLY-AGENT \"admin\") or (ONLY-AGENT \"owner\"). Before calling this function, you should verify the following information: - The balance associated with the specified lost-wallet parameter must be greater than 0. 0. - The account you specify for the new-wallet parameter must be a registered identity. Input parameters Use the following input parameters: Parameter | Type | Description: -------- |: --- |: ---------- agent | string | Name of the agent with the agent-admin or owner role and retrieved from the data field for the transaction. lost-wallet | string | Address of the investor wallet you are attempting to recover. new-wallet | string | Address for the new identity you have registered for the investor. investor-kadenaID | string | Address of the identity contract stored as the kadenaID in the identities table for the specified investor. State changes The recovery-address function makes the following state changes: - Transfers the balance from the specified lost-wallet parameter to the specified new-wallet parameter by executing a forced-transfer operation. - Freezes the new-wallet account if the lost-wallet account was frozen. If the lost-wallet account had a portion of tokens frozen, the same number of tokens are frozen in the new-wallet account. - Deletes the identity information for the lost-wallet account from the identity registry. Events The recovery-address function emits the following events: - ONLY-AGENT \"admin\" to indicate that an agent with the agent-admin role has been invoked. - TRANSFER with the parameters lost-wallet, new-wallet, and balance. - RECONCILE with the parameters balance, lost-wallet-balance-change, and new-wallet-balance-change. - RECOVERY-SUCCESS with the parameters lost-wallet. new-wallet, and investor-kadenaID. - ADDRESS-FROZEN with the parameter new-wallet and true if lost-wallet was frozen and new-wallet is not frozen. - IDENTITY-REMOVED with the parameters investor-address and kadenaID. Error codes The recovery-address function reports the following errors: - FRZ-AMT-002 if the number of frozen tokens exceeds the new-wallet balance. - IDR-001 if the address isn't found in the identity registry. - IDR-002 if the account balance for the identity is greater than 0. 0. - IDR-REC-001 if the lost-wallet balance isn't greater than 0. 0. - ROL-STS-002 if the signer for the transaction isn't a valid active agent. - ROL-STS-003 if the signer for the transaction doesn't have the required role. set-compliance Use set-compliance to specify one or more compliance contracts that you want to apply to the token. Requirements The signer for a set-compliance transaction must be an agent with the owner role and capability (ONLY-AGENT \"owner\"). Before calling this function, you should verify the following information: - The compliance contracts implement the RWA. compliance-v1 interface. - The compliance list does not contain duplicate contracts. - The compliance list must not be the same as current compliance list. Input parameters Use the following input parameter: Parameter | Type | Description: -------- |: --- |: ---------- compliance | list of modules | Compliance contract module names in the form of [module{RWA. compliance-v1}] State changes The set-compliance function makes the following state change: - Assigns the list of compliance contracts to the token. Events The set-compliance function emits the following events: - ONLY-OWNER \"owner\" to indicate that an agent with the owner role has been invoked. - COMPLIANCE-UPDATED with the new list of compliance contracts applied to the token. Error codes The set-compliance function reports the following errors: - GEN-IMPL-002 if an update to the compliance list fails. - ROL-STS-002 if the signer for the transaction isn't a valid active agent. - ROL-STS-003 if the signer for the transaction doesn't have the required role. set-compliance-parameters Use set-compliance-parameters to set the following parameter values for the compliance contract: - max-balance-per-investor - supply-limit - max-investors You can disable enforcement for any compliance rule by setting the corresponding parameter to -1. Requirements The signer for a recovery-address transaction must be an agent with the admin or owner role and capability (ONLY-AGENT \"admin\") or (ONLY-AGENT \"owner\"). Before calling this function, you should verify the following information: - The max-balance-per-investor value must be greater than 0. 0 or disabled with a value of -1. - The supply-limit value must be greater than the current supply or disabled with a value of -1. - The max-investors value must be greater than the current investor count or disabled with a value of -1. Input parameters Use the following input parameter: Parameter | Type | Description: -------- |: --- |: ---------- agent | string | Name of the agent with the agent-admin or owner role and retrieved from the data field for the transaction. compliance-parameters | object | Compliance contract input parameters and values, for example, {\"max-balance-per-investor\": 1000, \"supply-limit\": 100000, \"max-investors\": -1}. State changes The set-compliance-parameters function makes the following state change: - Updates the compliance parameters with the input for the contract. Events The set-compliance-parameters function emits the following events: - ONLY-AGENT \"owner\" to indicate that an agent with the owner role has been invoked. - ONLY-AGENT \"admin\" to indicate that an agent with the agent-admin role has been invoked. - COMPLIANCE-PARAMETERS with the compliance parameter values. Error codes The set-compliance-parameters function reports the following errors: - CMPL-MBPI-001 if the maximum balance per investor is exceeded. - CMPL-SL-001 if the supply limit is exceeded. - CMPL-SL-003 - CMPL-MI-001 if the maximum number of investors is exceeded. - CMPL-MI-004 - GEN-IMPL-002 if an update to any compliance parameter value fails. - ROL-STS-002 if the signer for the transaction isn't a valid active agent. - ROL-STS-003 if the signer for the transaction doesn't have the required role.",
    "source": "reference/real-world-assets/mvp-token.md",
    "title": "mvp-token"
  },
  {
    "content": "This reference provide a summary of syntax conventions for the Pact smart contract programming language. This reference provide a summary of syntactical conventions and reserved keywords for the Pact smart contract programming language. This section doesn't include explanatory text, use case examples, or general information about the Pact language. Therefore, this section is typically not suitable for readers who are new to programming languages or who are looking for a general introduction to using Pact. Text strings Text string literals are delimited using double quotation marks: Code example (pact): pact> \"This is a literal text string\" \"This is a literal text string\" In programs, you can specify multiline strings by putting a backslash before and after whitespace within the quotation marks. For example: Code example (pact): (defun id (a) \"Identity function. \\ \\Argument is returned. \" a) Multiline strings aren't support when using the Pact command-line interpreter interactively. Symbols Symbols are string literals that represent a unique item in the runtime, like a function identifier or a table name. Internally, symbols are treated as string literals. However, if you want to make use of symbols to distinguish identifiers from other strings, precede the string with a single quotation mark. For example: Code example (bash): pact> 'accounts \"accounts\" Symbol notation doesn't support whitespace nor multiline strings. Integers Integer literals are unbounded, and can be positive or negative. Code example (bash): pact> 12345 12345 pact> -922337203685477580712387461234 -922337203685477580712387461234 Decimals Decimal literals have potentially unlimited precision. Code example (bash): pact> 100. 25 100. 25 pact> -356452. 234518728287461023856582382983746 -356452. 234518728287461023856582382983746 Booleans Booleans are represented by true and false literals. Code example (bash): pact> (and true false) false Lists List literals are created with square brackets ([]). Optionally, list items can be separated with commas. Uniform literal lists are given a type in parsing. Code example (bash): pact> [1 2 3] [1 2 3] pact> [1, 2, 3] [1 2 3] pact> (typeof [1 2 true]) \"list\" Objects Objects are dictionaries, created with curly braces ({}) specifying key-value pairs using a colon (: ). For certain applications, such as database updates, keys must be strings. Code example (bash): pact> { \"foo\": (+ 1 2), \"bar\": \"baz\" } {\"bar\": \"baz\", \"foo\": 3} Bindings Bindings are dictionary-like forms, also created with curly braces, to bind database results to variables using the: = operator. Bindings are used in the following functions to assign variables to named columns in a row, or values in an object: - with-read - with-default-read - bind - resume Code example (pact): (defun check-balance (id) (with-read accounts id { \"balance\": = bal } (enforce (> bal 0) (format \"Account in overdraft: {}\" [bal])))) Lambdas Lambda expressions are code blocks that create anonymous functions that can be applied in a local scope, rather than at the top level of a program with the defun keyword. Lambdas are supported in let expressions, and can be as inline arguments for built-in function applications. Code example (pact): ; identity function (let ((f (lambda (x) x))) (f a)); native example (let ((f (lambda (x) x))) (map (f) [1 2 3])); Inline native example: (map (lambda (x) x) [1 2 3]) Type specifiers You can specify types for functions, variables, and objects by using the colon (: ) operator followed by one of the following type literal or a user type specification: - string - integer - decimal - bool - time - keyset - list or [type] to specify the list type - object, which can be further typed with a schema - table, which can be further typed with a schema - module, which must be further typed with required interfaces For example: Code example (pact): (defun mint: bool ( id: string account: string guard: guard amount: decimal ). . . ) Function arguments and return types Code example (pact): (defun prefix: string (pfx: string str: string) (+ pfx str)) Let variables Code example (pact): (let ((a: integer 1) (b: integer 2)) (+ a b)) Schema type literals A schema defined with defschema is referenced by a name enclosed in curly braces ({}). Code example (pact): (defschema token-schema id: string uri: string precision: integer supply: decimal policies: [module{kip. token-policy-v2}] ) (defschema version version: integer ) (deftable tokens: {token-schema}) (deftable versions: {version}) Tables and objects can only take a schema type literal. Code example (pact): (deftable accounts: {account}) (defun get-order: {order} (id) (read orders id)) Module type literals Module references are specified by the interfaces they demand as a comma-delimited list. Code example (pact): module: {fungible-v2, user. votable} Dereference operator The dereference operator: : allows a member of an interface specified in the type of a module reference to be invoked at runtime. Code example (pact): (interface baz (defun quux: bool (a: integer b: string)) (defconst ONE 1) ). . . (defun foo (bar: module{baz}) (bar: : quux 1 \"hi\"); ; invokes 'quux' on whatever module is passed in bar: : ONE; ; directly references interface const ) bless Use the bless keyword to identify a previous version of a module—identified by its hash value—that you want to continue to support. For more information about using the bless keyword in a module declaration, see Dependency management. Basic syntax To support a previous version of a module, use the following syntax model: Code example (pact): (bless HASH) Examples The following example illustrates supporting two previous versions of the provider module: Code example (pact): (module provider 'keyset (bless \"ZHD9IZg-ro1wbx7dXi3Fr-CVmA-Pt71Ov9M1UNhzAkY\") (bless \"bctSHEz4N5Y1XQaic6eOoBmjty88HMMGfAdQLPuIGMw\"). . . ) cond Use the cond keyword to produce a series of if-elseif-else expressions to evaluate one after another. For example, if the first condition evaluated passes, then branch-1 is executed. If the first condition isn't met, the second condition is evaluated and if that condition passes, then branch-2 is executed. The else-branch is only evaluated if all other conditions fail. The cond special form allows you to evaluate a series of if expressions in a more concise manner. Syntactically, the cond form accepts a sequence of conditions: Code example (pact): (cond (a b) (c d) (e f) g) When the conditions are evaluated, the statements are expanded to a series of if statements: Code example (pact): (if a b (if c d (if e f g))) Basic syntax To evaluate a series of conditions, use the following syntax model: Code example (pact): (cond (condition-1 branch-1) [(condition-2 branch-2) [. . . ]] else-branch) Examples The following example demonstrates how to use cond to evaluate multiple branching conditional expressions. Code example (pact): (module medals GOV (defcap GOV () true) (defun award: string (score: integer) (cond ((< score 10) \"Bronze\") ((< score 20) \"Silver\") ((< score 30) \"Gold\") \"Platinum\")) ) If you load this module, you can call the award function to see the conditions evaluated: Code example (pact): pact> (m. award 100) \"Platinum\" pact> (m. award 23) \"Gold\" pact> (m. award 3) \"Bronze\" defcap Use the defcap keyword to signal the start of a capability definition followed by the capability name, required or optional arguments, optional documentation, and the capability body composed of one or more expressions. A defcap code block defines a capability token you want to store in the environment to grant some type of permission or privilege. The body of the code block can consist of one or more expressions. The body of the capability definition is only called with the with-capability and compose-capability functions when the token—parameterized by its arguments—isn't found in the environment. When the code is executed, the arguments are in scope. Basic syntax To define a capability token that grants a permission or a privilege, use the following syntax model: Code example (pact): (defcap name arguments [doc] capability-body. . . ) Examples The following example illustrates defining the USERGUARD capability: Code example (pact): (defcap USERGUARD (user) \"Enforce user account guard (with-read accounts user { \"guard\": guard } (enforce-guard guard))) The following example illustrates defining the DEBIT capability: Code example (pact): (defcap DEBIT (id: string sender: string) (enforce-guard (account-guard id sender)) ) defconst Use the defconst keyword to define a constant name with the specified value and optional documentation or metadata. The value is evaluated when the module is loaded and held in memory for the duration of module execution. Basic syntax To define a constant value, use the following syntax model: Code example (pact): (defconst name value [doc-or-metadata]) Examples The following examples illustrate defining constants with optional documentation: Code example (pact): (defconst COLORRED=\"#FF0000\" \"Red in hex\") (defconst COLORGRN=\"#00FF00\" \"Green in hex\") (defconst PI 3. 14159265 \"Pi to 8 decimals\") The following example illustrates defining the constant PENNY with an explicit type: Code example (pact): (defconst PENNY: decimal 0. 1) defun Use the defun keyword to signal the start of a function definition followed by the function name, required or optional arguments, optional documentation or metadata, and the function body composed of one or more expressions. Arguments are in scope for the function body. Basic syntax To define a function, use the following syntax model: Code example (pact): (defun name [arguments] [doc-or-metadata] function-body. . . ) Examples The following examples illustrate defining an add3 function and a scale3 function: Code example (pact): (defun add3 (a b c) (+ a (+ b c))) (defun scale3 (a b c s) \"multiply sum of A B C times s\" ( s (add3 a b c))) defpact Use the defpact keyword to define a multi-step transaction with the specified name as a pact. The computation for a pact is composed from a sequence of steps that must be executed in a specific order and occur in distinct transactions. The defpact syntax is identical to the defun to be executed in strict sequential order. Basic syntax To define a pact, use the following syntax model: Code example (pact): (defpact name [arguments] [doc-or-metadata] steps. . . ) Examples Code example (pact): (defpact payment (payer payer-entity payee payee-entity amount) (step-with-rollback payer-entity (debit payer amount) (credit payer amount)) (step payee-entity (credit payee amount))) You can nest defpact calls. However, the following restrictions apply: - The number of steps in the child defpact must match the number of steps of the parent defpact. - If a parent defpact step has the rollback field, so must the child. - If a parent step rolls back, so do child steps. - You must call the continue function with the same continuation arguments as the defpact originally dispatched to support multiple nested defpact calls to the same function but with different arguments. The following example shows a well-formed defpact with an equal number of steps, nested rollbacks, and continue calls: Code example (pact): (defpact payment (payer payee amount) (step-with-rollback (debit payer amount) (credit payer amount)) (step payee-entity (credit payee amount))). . . (defpact split-payment (payer payee1 payee2 amount ratio) (step-with-rollback (let ((payment1 (payment payer payee1 ( amount ratio))) (payment2 (payment payer payee2 ( amount (- 1 ratio)))) ) \"step 0 complete\" ) (let ((payment1 (continue (payment payer payee1 ( amount ratio)))) (. . . [code continues] defschema Use the defschema keyword to define a schema of table fields with the specified name. Each field in the schema takes the form of fieldname[: fieldtype]. Basic syntax To define a schema, use the following syntax model: Code example (pact): (defschema name [doc-or-metadata] fields. . . ) Examples The following example illustrates defining the accounts schema and an accounts table: Code example (pact): (defschema accounts \"Schema for accounts table\" balance: decimal amount: decimal ccy: string data) deftable Use the deftable keyword to define a database table with the specified name. The name you specify is used in database functions to identify the table you want to work with. Note the table must still be created with create-table function. Basic syntax To define a table, use the following syntax model: Code example (pact): (deftable name[: schema] [doc-or-metadata]) Examples The following example illustrates defining a schema and an accounts table: Code example (pact): (defschema account \"Row type for accounts table. \" balance: decimal amount: decimal ccy: string rowguard: guard date: time data: object ) (deftable accounts: {account} \"Main table for accounts module. \") do Use the do keyword to evaluate a sequence of expressions and return the last one as the result. Basic syntax To evaluate a sequence of expressions and return the last result, use the following syntax model: Code example (pact): (do (my-expression1) (my-expression2) (my-return-expression)) Examples Code example (pact): pact> (do (print \"hello world! \") (+ 1 2) (+ 121 299)) \"hello world! \" 420 Notice how the return value is the last addition of (+ 121 299). The do keyword evaluates every expression supplied, so if any expression errors along the way, the subsequent expressions will never be evaluated. For example: Code example (pact): pact> (do (enforce false \"boom\") (+ 1 2)) (interactive): 1: 4: boom 1 | (do (enforce false \"boom\") (+ 1 2)) | ^^^^^^^^^^^^^^^^^^^^^^ implements Use the implements keyword to specify that a module implements the specified interface. This keyword requires the module to implement all of the functions, defpacts, and capabilities that are specified in the interface with identical signatures, including the same argument names and declared types. A module that implements an interface can be used as a module reference for the specified interfaces. <! --Note that models declared for the implemented interface and its members will be appended to whatever models are declared within the implementing module. --> Basic syntax To implement an interface in a module, use the following syntax model: Code example (pact): (implements interface) interface Use the interface keyword to define and install an interface with the specified name and optional documentation or metadata. The body of the interface is composed of definitions that will be scoped in the module. Valid expressions in a module include the following: - defun - defconst - defschema - defpact - defcap - use <! --- models--> Basic syntax To define an interface, use the following syntax model: Code example (pact): (interface name [doc-or-metadata] body. . . ) Examples The following example illustrates defining the coin-sig interface with documentation: Code example (pact): (interface coin-sig \"'coin-sig' represents the Kadena Coin Contract interface. This contract \\ \\provides both the general interface for a Kadena's token, supplying a \\ \\transfer function, coinbase, account creation and balance query. \" (defun create-account: string (account: string guard: guard) @doc \"Create an account for ACCOUNT, with GUARD controlling access to the \\ \\account. \" @model [ (property (not (= account \"\"))) ] ) (defun transfer: string (sender: string rece. . . [code continues] let Use the let keyword to bind variables in pairs to over the scope of the code body. In Pact 4, let declarations didn't allow variables within bind-pairs to refer to previously-declared variables in the same declaration. In Pact 4, you could use the let form to enable variables to reference previously-declared variables in the same let declaration. In Pact 5, the let keyword is deprecated and you can replace all let declarations with let declarations. Basic syntax To bind a variable to a value, use the following syntax model: Code example (pact): (let (bind-pair [bind-pair [. . . ]]) body) Examples The following example illustrates binding variables to values in a let declaration: Code example (pact): pact > (let ((x 2) (y 5)) ( x y)) 10 The following example illustrates referencing a previously-declared variable in the same let declaration in Pact 5: Code example (pact): (let ((x 2) (y ( x 10))) (+ x y)) 22 let\\ Use the let keyword to bind variables in pairs over the scope of the code body. In Pact 4, this form of the keyword enables variables to reference previously-declared variables in the same let declaration. In Pact 5, this form is deprecated and you can replace all let declarations with let declarations. Basic syntax To bind a variable to a value, use the following syntax model: Code example (pact): (let (bind-pair [bind-pair [. . . ]]) body) Examples The following example illustrates referencing a previously-declared variable in the same let declaration: Code example (pact): (let ((x 2) (y ( x 10))) (+ x y)) 22 Metadata prefix (@) As several examples demonstrate in this section, you can often embed optional documentation strings in code blocks that use reserved keywords like defun and deftable like this: Code example (pact): (defun average (a b) \"take the average of a and b\" (/ (+ a b) 2)) You can also add metadata by using the @-prefix. Supported metadata fields include: - @doc to provide a documentation string. - @event to emit an event. - @managed to manage specific data associated with a capability. - @model to specify a property that can be checked for correctness in format verification. Code example (pact): (defun average (a b) @doc \"take the average of a and b\" (/ (+ a b) 2)) Embedded documentation strings like \"Row type for accounts table. \" are just a short form of @doc metadata. module Use the module keyword to define and install a module with the specified name that is governed by the specified keyset-or-governance, with optional documentation or metadata. If the keyset-or-governance is a string, the string represents a keyset that has been installed with the define-keyset function that will be checked whenever module administrative privileges are required. If keyset-or-governance is an unqualified atom, it represents a defcap capability that will be acquired if module administrative privileges are requested. The body of a module is composed of definitions are scoped to the module. A module can include the following types of declarations: - defun - defpact - defcap - deftable - defschema - defconst - implements - use - bless Basic syntax To define a module, use the following syntax model: Code example (pact): (module name keyset-or-governance [doc-or-metadata] body. . . ) Examples The following example illustrates a defining the accounts module with a keyset and two functions: Code example (pact): (module accounts 'accounts-admin \"Module for interacting with accounts\" (defun create-account (id bal) \"Create account ID with initial balance BAL\" (insert accounts id { \"balance\": bal })) (defun transfer (from to amount) \"Transfer AMOUNT from FROM to TO\" (with-read accounts from { \"balance\": fbal } (enforce (<= amount fbal) \"Insufficient funds\") (with-read accounts to { \"balance\": tbal } (update accounts from { \"balance\": (- fbal amount) }) (update accou. . . [code continues] step Use the step keyword to define a step within a defpact, such that any prior steps will be executed in prior transactions, and later steps in later transactions. You can include an entity argument to indicate that a specific step is intended for confidential transactions. With this argument, only the specified entity would execute the step, and other participants would skip the execution of the step. Basic syntax To define a step in a defpact, use the following syntax model: Code example (pact): (step expression) (step entity expression) Examples The following example illustrates a defpact for depositing funds with two step transactions: Code example (pact): (defpact deposit(sender: string receiver: string guard: guard amount: decimal) @doc \"Deposit KDA from L1 to L2\" (step (with-capability (LOCKDEPOSIT sender) (let ((deposit-details: object{deposit-schema} { 'receiver: receiver, 'amount: amount, 'guard: guard } )) (lock-deposit sender amount) (enforce (validate-principal guard receiver) \"Guard must be a principal\") (yield deposit-det. . . [code continues] step-with-rollback Use the step-with-rollback keyword to define a step within a defpact similar to using the step keyword except that you specify a rollback-expression. If you include an entity argument, the rollback-expression is only be executed upon failure of a subsequent step, as part of a reverse-sequence \"rollback cascade\" going back from the step that failed to the first step. Without the entity argument, the rollback-expression acts as a cancel function that is be explicitly executed by a participant. Basic syntax To define a step in a defpact, use the following syntax model: Code example (pact): (step-with-rollback expression rollback-expression) (step-with-rollback entity expression rollback-expression) Examples The following example illustrates a defpact for offering a token for sale with one step-with-rollback: Code example (pact): (defpact sale: string ( id: string seller: string amount: decimal timeout: integer ) (step-with-rollback; ; Step 0: offer (let ((token-info (get-token-info id))) (with-capability (OFFER-CALL id seller amount timeout (pact-id)) (marmalade-v2. policy-manager. enforce-offer token-info seller amount timeout (pact-id))) (with-capability (SALE id seller amount timeout (pact-id)) (offer id seller amount)) (pact-id) ). . . [code continues] use Use the use keyword to import the specified module into a namespace. This keyword is only valid at the top-level of a contract or within a module declaration. The specified module can be a string, symbol, or bare atom. You specify the hash argument to validate that the imported module's hash matches specified hash and fail if the hashes are not the same. You can use the describe-module function to query for the hash of a loaded module on the chain. You can also specify an optional list of imports consisting of function, constant, and schema names to import from the specified module. If you explicitly define the function, constant, and schema names to import, only the listed items are available for you to use in the module body. If you don't specify an import list, then every name in the imported module is brought into scope. If two modules are defined in the same transaction, all names are in scope for both modules, and the import behavior defaults to the entire module. Basic syntax To import a specified module, use the following syntax models: Code example (pact): (use module) (use module hash) (use module imports) (use module hash imports) Examples The following example illustrates importing all of the definitions from the accounts module and using the transfer function: Code example (pact): (use accounts) (transfer \"123\" \"456\" 5 (time \"2016-07-22T11: 26: 35Z\")) \"Write succeeded\" The following example illustrates importing all of the definitions from a specific version of accounts module with the hash \"ToV3sYFMghd7AN1TFKdWkw00HjUepVlqKL79ckHGs\" and using the transfer function: Code example (pact): (use accounts \"ToV3sYFMghd7AN1TFKdWkw00HjUepVlqKL79ckHGs\") (transfer \"123\" \"456\" 5 (time \"2016-07-22T11: 26: 35Z\")) \"Write succeeded\" The following example illustrates importing only the transfer and example-fun definitions from the accounts module and using the transfer function: Code example (pact): (use accounts [ transfer example-fun ]) (transfer \"123\" \"456\" 5 (time \"2016-07-22T11: 26: 35Z\")) \"Write succeeded\" The following example illustrates importing only the transfer and example-fun definitions from a specific version of accounts module with the hash \"ToV3sYFMghd7AN1TFKdWkw00HjUepVlqKL79ckHGs\" and using the transfer function: Code example (pact): (use accounts \"ToV3sYFMghd7AN1TFKdWkw00HjUepVlqKL79ckHGs\" [ transfer example-fun ]) (transfer \"123\" \"456\" 5 (time \"2016-07-22T11: 26: 35Z\")) \"Write succeeded\" Expressions Expressions can be literals, atoms, s-expressions, or references. Atoms Atoms are non-reserved barewords that start with a letter or allowed symbol, and contain letters, digits, and allowed symbols. Allowed symbols are %#+-&$@<>=? *! |/. Atoms must resolve to a variable bound by one of the following: - defun definition. - defpact definition. - bindings form. - lambda form. - Symbols imported into the namespace with use. S-expressions S-expressions are formed with parentheses, with the first atom determining if the expression is a special form with a reserved keyword or a function application. If the expression is a function application, the first atom must refer to a definition. An application with less than the required arguments is in some contexts a valid partial application of the function. However, this is only supported in a limited number of Pact functions, such the map, fold, and filter functions. With these functions, the list item can be appended to the application arguments to serially execute the function. Code example (pact): (map (+ 2) [1 2 3]) (fold (+) \"\" [\"Concatenate\" \" \" \"me\"]) Using a partial application with most functions results in a runtime error. References References are multiple atoms joined by a dot. that directly resolve to definitions found in other modules. Code example (pact): pact > accounts. transfer \"(defun accounts. transfer (src, dest, amount, date) \\\"transfer AMOUNT from SRC to DEST\\\")\" pact> transfer Eval failure: transfer<EOF>: Cannot resolve transfer pact> (use 'accounts) \"Using \\\"accounts\\\"\" pact> transfer \"(defun accounts. transfer (src, dest, amount, date) \\\"transfer AMOUNT from SRC to DEST\\\")\" References are preferred over use for transactions because references resolve faster. However, when defining a module, use is preferred for legibility.",
    "source": "reference/syntax.md",
    "title": "Syntax and keywords"
  },
  {
    "content": "Get started as a code contributor to the Kadena project. How to contribute as a developer We appreciate your interested in contributing to the Kadena project. There are a lot of ways to get involved. For example, you can contribute by: - Fixing bugs in existing features, code logic, or code comments. - Suggesting design enhancements. - Implementing new features. - Providing usability testing and feedback. - Translating code or documentation. This guide describes how to get started with contributing as a developer. Set up a local development environment To set up a local development environment for contributing to Kadena: 1. Navigate to the appropriate repository on GitHub. 2. Click Fork tfor he repository on GitHub to create your own copy of the repository. 3. Open a terminal shell on your computer. 2. Clone your fork locally by running the following command: Code example (bash): git clone https: //github. com/YOURUSERNAME/PROJECTNAME. git `` 3. Install dependencies by running the following command: `bash npm install ` 4. Set up pre-commit hooks by running the following command: `bash npm run prepare ` Find issues to work on - Check for open issues in the repository. For example, check the Open issues for the kadena. js - Check for issues labeled good first issue. -. . . [code continues] <type>[optional scope]: <description> [optional body] [optional footer(s)] ` Pull requests 1. Create a new branch from develop. 2. Make your changes and commit them. 3. Push to your fork and submit a pull request to the develop` branch. 4. Ensure your PR description clearly describes the problem and solution. Recognizing contributors We use the All Contributors specification to recognize all types of contributions. After your first contribution is merged, you'll be added to the contributors list in the README. <! -- ### Contribution rewards More updates on this will be added shortly To show our appreciation, we offer the following rewards for significant contributions: - Contributor of the Month recognition - Exclusive project swag for major contributions - Opportunities to speak at project-related events --> Review process 1. Automated tests will run on your pull request. 2. A maintainer will review your contribution. 3. Address any feedback or requested changes. 4. Once approved, a maintainer will merge your contribution. Community - Join the Kadena Discord server for real-time discussions. - Follow Kadena on X or LinkedIn for news and announcements.",
    "source": "resources/contribute-dev.md",
    "title": "Contribute as a developer"
  },
  {
    "content": "Get started as a contributor to Kadena documentation. How to contribute to Kadena documentation Thank you for your interest in contributing to documentation for the Kadena blockchain and the Kadena community. As a member of the community, you are invited and encouraged to contribute to the Kadena technical documentation. There are a lot of ways to get involved. For example, you can contribute by: - Submitting issues. - Offering suggestions for improvements to existing content. - Adding review comments to existing pull requests. - Proposing new content. - Creating new pull requests to fix issues yourself. - Creating pull request for new content other community members might find useful. This guide describes how you can make changes to the documentation website directly by editing source files or indirectly by requesting updates. Before you begin To follow the steps in this guide, verify the following basic requirements: - You have a code editor, a GitHub account, and experience using command-line programs, including git commands and command-line options. - You are familiar with using Markdown to add formatting elements to plain text documents. For information about using Markdown, see the Markdown Guide. - You have the yarn package manager installed. You can run yarn --version to verify that you have yarn installed and the version you are running. Get started You can contribute to documentation by editing existing pages in the GitHub repository or by setting up a local documentation environment. If you want to make a simple fix on an existing page—for example, to fix a typo or make minor changes to a sentence—you can edit documentation pages directly in its GitHub repository. To edit an existing page: 1. Open docs. kadena. io and navigate to the page you want to change. 2. Click Edit this page to open the page in its GitHub repository. 3. Edit the page in GitHub, then click Commit changes. 4. Replace the default commit message with a short description of your change and, optionally, an extended description of the change or why you're proposing the change. 5. Select Create a new branch for this commit and start a pull request, then click Propose changes. 6. Add any additional information to the title or description of the pull request, then click Create pull request. Your pull request will be reviewed by a Kadena team member and merged, if approved. Set up a local development environment The Kadena Developer Documentation website is built using Docusaurus, a modern static website generator. If your contribution is more than a simple change, you'll most likely need to set up a local development environment where you can build and test the documentation that you are proposing to change. The following steps summarize what you need to do. To set up a local development environment for contributing to Kadena documentation: 1. Open a terminal shell on your computer. 2. Clone the kadena-docs repository by running the following command: ``code git clone git@github. com: kadena-docs/kadena-docs. git ` 3. Change to the root of the kadena-docs repository by running the following command: `code cd kadena-docs ` 4. Install the dependencies for the site by running the following command: `code yarn ` 5. Start the local development server and open up a browser window by running the following command: `code yarn start ` All of the content for the Kadena Developer Documentation website is located in the docs directory and its subdirectories. To contribute to documentation, you typically only need to work in the docs folder, its subfolders, and in individual Markdown (. md) pages. Preview documentation changes To preview your documentation changes locally: 1. Navigate to the docs directory: cd docs 2. Start the Docusaurus development server: npm run start 3. Open your browser and go to http: //localhost: 3000 Create working branches and pull requests After you set up a local environment for contributing to documentation, you'll need to create local branches for your pull requests. In most cases, you should strictly limit the changes you include in any single pull request. To create a working branch: 1. Use git switch -c to create a local branch with a prefix that identifies you as the author and a branch name that describes the content you intend to add or change by running a command similar to the following: `text git switch -c my-identifier-prefix/my-branch-name-here ` For example, if your git handle is lola-pistola and you are fixing a typo in the reference folder, you might create a branch like this: `code git switch -c lola-pistola/typo-reference-db-functions 4. Open the file you want to fix in a code editor and make the appropriate changes for the issue you are trying to address. 5. Add the file you changed to the list of staged commits by running a command similar to the following: `text git add path-to-changed-file ` 6. Commit the staged changes with a descriptive commit message by running a command similar to the following: `text git commit -m \"docs: Fix db function type\" ` 7. Push the changes to the remote repository by running a command similar to the following: `text git push origin my-identifier-prefix/my-branch-name-here ` 8. Click Create pull request to start a new pull request and provide any additional information about the changes you made. A member of the Kadena team will review your pull request and approve or request changes. If no changes are required, the Kadena team member will merge your pull request. If a Kadena team member requests changes or clarification, update your pull request and request another review. 9. When you see your changes have been merged, celebrate your success! 🥂 What to contribute Most contributions from the community typically involve corrections or updated examples. However, you can also make valuable contributions in the form of how-to guides or tutorials that help other developers solve specific problems, learn specific skills, or demonstrate specific tasks or by translating topics into a new language. If you would like to contribute, you might be wondering “What is the difference between a ‘how-to’ guide and a tutorial? ”. How-to guides A how-to guide describes how to achieve a goal or complete a task. Only the information that is pertinent to achieving that goal or completing the task is included. With how-to guides, readers have enough information to know what they want to do—for example, open a bank account—but not necessarily enough information to know how to do it. For example, the how-to guide for opening a bank account wouldn't explain what a bank account is or why you might want to open one, but would focus on specific steps such as: 1) Select an institution. 2) Fill out an application. 3) Deposit a minimum amount of currency. Tutorials A tutorial is a hands-on illustration or lesson that enables the reader to achieve a highly-predictable result. Tutorials assume that readers have no prior knowledge on the subject being covered and that they require explicit guidance to complete each step to reach a well-known outcome. A tutorial is like a guided tour that helps the reader complete one organic task from start to finish. For example, a tutorial for opening a bank account would identify an example institution, explicitly describe what to enter for every field of the application using sample information, and specify exactly how much currency to deposit. The single most important aspect of a tutorial is that it should always result in a successful, expected outcome that inspires confidence and delight in the reader. The single most important distinction between a how-to guide and a tutorial is that, in a tutorial, the author decides what the goal should be and the author eliminates all distractions that would detract from the successful achievement of the goal. Translations To translate Kadena documentation: 1. Copy the docs folder and rename it to docs-[LANG]. For example, create a folder named docs-es` for translating topics into Spanish. 2. Translate the content in the new folder. 3. Update the Docusaurus configuration to include the new language.",
    "source": "resources/contribute-doc.md",
    "title": "Contribute to documentation"
  },
  {
    "content": "Defines common concepts and terminology that are generally applicable or specific to decentralized computing, blockchain technology, Kadena, or the Kadena ecosystem. This glossary defines and explains common concepts and terminology that are generally applicable or specific to decentralized computing, blockchain technology, Kadena, or the Kadena ecosystem. A account An account is an entry in the Kadena coin contract ledger—a key-value store—that consists of: - An account name in the form of a string of 3 to 256 LATIN-1 characters (the key row in the coin-table database table). - An account value that holds the decimal balance and a keyset that governs the account. Code example (pact): key: Account name -> value: { Balance, Keys } The keyset specifies the signing requirements for the account and consists of one or more public keys and a predicate that indicates the number of keys that must sign a transaction for the account. address On the Ethereum network, an address serves as both an identity and an account. The address is derived from the last 20 bytes of the ECDSA public key that controls the account prepended with 0x before the hashed key. For example, you might have an address similar to 0x71C7656EC7ab88b098defB751B7401B5f6d8976F on Ethereum. You must have an address—sometimes referred to as your wallet address—to send or receive funds and to access the funds, you must have the corresponding private key. Contracts deployed on the Ethereum network also send and receive transactions using an address. The functions in the contract are executed when the contract receives a transaction request. Contract addresses use the same format as wallet addresses. On the Kadena network, a principal account name is roughly equivalent to an Ethereum address because it establishes a unique identity. For Ethereum, the address establishes a one-to-one relationship with a public and private key pair. For Kadena, principal account names consist of a letter followed by a colon (: ) and a public key or hash that uniquely identifies the account owner. airdrop Tokens that are distributed to selected groups or all addresses on a blockchain network as a free incentive to encourage participation or adoption of a specific blockchain protocol, application, or service. application-specific integrated circuit (ASIC) Application-specific integrated circuits (ASIC) are engineered to perform one type of computation to optimize performance. In a proof-of-work blockchain like Kadena, computers are often optimized with application-specific integrated circuits to compute hash functions for mining blocks. B Bitcoin Bitcoin is the world’s very first cryptocurrency, postulated by ‘Satoshi Nakamoto’ (which is typically presumed to be a pseudonym) in a now-famous white paper called ‘A Peer-to-Peer Electronic Cash System’ in 2008. blockchain A ‘blockchain’ is a distributed digital ledger that’s used to record transactions. It’s an immutable database, which means that information can’t be tampered with or altered once it’s been recorded. If there’s an error in an entry, then a new, revised entry must be made, and both entries will subsequently be visible on the ledger. The name comes from the fact that a blockchain stores data in ‘blocks, ’ individual units that are linked, or ‘chained, ’ together. New data is filed into blocks – and blocks are subsequently chained together – in chronological order, so a blockchain becomes longer and longer as more information is added to it. Each new piece of information is also assigned a timestamp, which makes it easy for users to find out exactly when it was linked to the database. The transparency and immutability of the blockchain makes it a very reliable and trustworthy business resource both for individuals and companies. Kadena is an example of a blockchain. bridge A bridge, in a web3 context, is a protocol which links blockchain systems together, allowing users from one system to send assets and information to another. C capability Capabilities provide a way to manage permissions and authorize certain actions based on specific conditions and separate from transaction signing. Capabilities are a core feature in the Pact smart contract programming language. chain identifier The numeric identifier for a specific chain in the Kadena network. Currently, the chain identifiers are zero (0) through nineteen (19). consensus A consensus mechanism is a system that validates transactions and encodes new information on a blockchain. The most common consensus mechanisms are Proof-of-Work (PoW) and Proof-of-Stake (PoS). Kadena uses Proof-of-Work. cryptocurrency Cryptocurrency is a digital currency secured on a blockchain. The blockchain uses cryptographic proof to secure the currency. This prevents the double spending issue for digital currencies where a currency unit is used for multiple payments without being used up. This is where the cryptocurrency name derives from. Anyone can make a cryptocurrency and they are regulated only by their underlying protocol or DAO. KDA is an example of a cryptocurrency. crypto wallet A crypto wallet is a software program or physical device that allows you to store your digital assets and allow for the sending and receiving of crypto transactions. A crypto wallet consists of two key pairs: private keys and public keys. D decentralized application (dApp) A decentralized application, colloquially called a dapp, is an application constructed on the blockchain. Dapps function autonomously, according to the stipulations in smart contracts. Like any other application on your phone, dapps come with a user interface and are designed to provide some kind of practical utility. decentralized finance (DeFi) Financial services and applications that are not, or mostly not, controlled centrally, as in Centralized Finance. For example, Uniswap is a decentralized exchange, versus Coinbase which is a centralized exchange. decentralized network A network architecture in which every computer is a peer that can receive and respond to requests. The individual peer computers—called nodes—use a consensus model to determine the final state of the network after responding to the requests received. Decentralized networks are generally more fault tolerant than networks that depend on centralized servers responding to incoming client requests. distributed autonomous organization (DAO) Generally, refers to a method of management that has rules coded in software and that has decision making which is not centralized or hierarchical. &#x20; G gas Gas is a unit of measurement that represents the computational effort required to complete a transaction. How much a user spends to complete a transaction is determined by the total amount of gas multiplied by the gas price. &#x20; gas station A gas station is a type of smart contract that manages an autonomous coin contract account that can be used to pay transaction fees on behalf of users. Implementing a gas station contract simplifies onboarding for applications and reduces friction for users who are unfamiliar with blockchain technology, digital wallets, managing keys, and signing transactions. On the Kadena network, gas stations enable developers to abstract transaction costs using a secure capability-guarded principal account. F formal verification Formal verification uses mathematical methods to evaluate all possible paths and outcomes produced by the logic in a a program or smart contract. With formal verification, developers can mathematically verify whether their code works as expected or contains bugs that produce unexpected results. Blockchain applications that handle assets with real world value should include formal verification in the software development process. H hardware wallet Hardware wallets are physical devices that are designed to securely store secret keys. Typically, hardware wallets are considered more secure devices than desktop or smartphone wallets because they aren't used to connect to the internet. By not allowing internet access, hardware wallets reduce the attack vectors malicious parties can use to attempt to tamper with the device remotely. I interoperability Interoperability refers to the ability of multiple blockchains to cooperate and exchange information with one another, enabling virtual assets (such as non-fungible tokens \\[NFTs]), avatars and other pieces of code to move seamlessly from one platform to another. K keys Keys are long strings of numbers used to access the Web3 products stored in your wallet. There are two forms of keys: - Your public key is the string you share with others to request transactions and identify yourself in the ecosystem. &#x20; - Your private key is the string that gives you access to your personal crypto assets and to confirm any transactions – a digital signature. This should never be shared with anyone. &#x20; A public key functions like your bank account number, with the private key being your PIN code. These keys are randomly generated and so can be hard to memorize. Therefore most wallets employ a string of words known as a “seed phrase” to act as a passcode to your keys. keyset A keyset is a Pact construct used to authorize transactions. A keyset consists of one or more public keys and a predicate function that describes the authorization policy for the keys in the keyset. For example, if a keyset has three public keys and the keys-all predicate, then all three keys must sign a transaction for the transaction to be valid. Pact provides three default keyset predicates: - keys-all - keys-any - keys-2 Smart contract module authors can define additional predicates. L layer-1 (L1) blockchains are the foundations of multi-level blockchain frameworks. They can facilitate transactions without support from other blockchain networks. All layer 1 blockchains – including Bitcoin and Ethereum – offer their own native cryptocurrency as a means of accessing their networks. layer 2 (L2) blockchains are built on top of layer 1 blockchains, often enhancing the latter’s performance and expanding its accessibility. Polygon, for example, is a popular layer 2 blockchain that allows users to enjoy the benefits of using the Ethereum network without having to go through that network’s relatively slow transaction speed and costly fees. M mining Mining is the process of validating a transaction in a proof of work blockchain. In mining, a large pool of users compete for tokens to see who can solve a cryptographic puzzle the quickest using computing power. The difficulty of the puzzle scales with the total hash power of the entire network, the hash rate. The costs of mining are well documented, both in the exponential increase in computing power to continue mining and the detrimental environmental impact. module A module is the fundamental logical unit for programs used in Pact smart contracts. All of the functions and data definitions that are required to complete a set of related business operations are defined within the context of a module. For simple contracts, a single module often contains all of the code necessary to create an application or a service. N namespace A namespace is a logical ownership boundary for smart contracts that are controlled by a specific entity. Smart contracts include a namespace declaration to provide a unique prefix for everything—including modules, functions, keysets, and interfaces—defined within the namespace scope. In a local development network, you can define custom namespaces. In public networks, like the Kadena test and main networks, you must use an existing namespace, like \"free\" or \"user\", or register a principal namespace as a static prefix and ownership boundary for the contracts, modules, and keyset definitions that you control. non-fungible token (NFT) Non Fungible Token. Tokens that represent something unique, such as crypto art or collectibles. They cannot be exchanged for something identical. For example, CryptoPunks and Hashmasks. node Nodes are the computers used to secure a blockchain network. These are the engine of the blockchain, supplying the computing power to maintain it, validating transactions, and maintaining the consensus of the blockchain that keeps it secure. The more nodes a blockchain has, the safer it is. However, this increases the computational complexity, amount of energy used, and thus the price for making each transaction. O oracle An oracle is any application that provides data from outside the blockchain or vice-versa. Blockchains can only access data available on their own chains, and so need oracles to add outside or off-chain data. A typical use case is smart contracts that need to incorporate real-world data or bridges that require information from another blockchain to perform an exchange. For example, if a stablecoin needs to keep its value constantly connected to the amount of collateral available to that coin, it would need an oracle to identify how much of that collateral is available. This is because knowledge of the collateral amount is off-chain data that has to be translated to data usable by the blockchain. R Read-eval-print-loop (REPL) Read-eval-print-loop (REPL) is an interactive shell that enables you to run and test code in a terminal. In most cases, a REPL is an interpreter for a specific language or compiler that enables you to write and execute programs from a command-line interface. S smart contracts Smart contracts are self-executing contracts formed using a blockchain. A smart contract is a program that can automatically execute agreements on the blockchain without external oversight, as long as the originally set parameters of the contract are fulfilled. The blockchain ensures that the contract has been considered trustworthy – the validation method and the transparent ledger of previous transactions create the necessary trust. T tokens A token is an electronic proof of asset ownership. These are typically split into two types. Fungible tokens like Kadena are identical, exchangeable tokens; non-fungible tokens (NFTs) are unique and cannot be reproduced. While not every blockchain has a token, most deploy a form of token to take advantage of their utility value. &#x20; Uses for tokens include: - Cryptocurrencies are the most common form of tokens that can be exchanged for goods and services. KDA is an example of a cryptocurrency. - Payment or utility tokens can be used to pay for services but only on the blockchain that produces the token. These could for instance be the in-game currency for a blockchain-based video game. - Governance tokens can be seen as shares in a blockchain, giving you voting rights on major decisions regarding the future direction of that relevant blockchain. - NFTs that prove ownership over a unique digital asset such as art or a venue ticket. time-to-live (TTL) The expiration time—in seconds—for how long a transaction should be considered valid for inclusion in a block after its creation time. In most cases, transactions are processed and included in block in approximately 30 seconds and don't require changes to the default TTL. However, the maximum time a transaction can wait to be included in a block is 48 hours after its initial creation. tokenomics A portmanteau of the words 'token' and 'economics, ' tokenomics refers to all the aspects of a cryptocurrency that can impact the price such as total supply, vesting, and utility. trilemma The Trilemma refers to the problem every blockchain has in having to compromise on either security, decentralization, or scalability. Coined by Vitalik Buterin, one of the Ethereum co-founders, the trilemma points to each of the issues being interconnected: - Increasing decentralization makes the blockchain more computationally complex, slowing down transaction speed (scalability), and requires more work to keep the network secure&#x20; - Highly secure blockchains cannot handle many transactions efficiently and so compromise on scalability&#x20; - Increasing transaction speed requires reducing the computational load in some way. This compromises decentralization and security. Kadena’s innovative PoW consensus mechanism called Chainweb makes it the only blockchain to have solved the infamous blockchain trilemma.",
    "source": "resources/glossary.md",
    "title": "Glossary"
  },
  {
    "content": "Access to the old Kadena documentation for reference. Missing something? Here is access to the old Kadena documentation for reference. Visit the Kadena legacy documentation site Note that the legacy documentation site includes information and links that are out-of date as well as material that has been intentionally removed from the core documentation. For example, if you're interested in learning about the Kadena token standard defined in Marmalade smart contracts, you should review the Non-fungible tokens documentation in the legacy site.",
    "source": "resources/legacy.md",
    "title": "Legacy documentation site"
  },
  {
    "content": "Explore a comprehensive list of tools and solutions built for building on Kadena. Explore a comprehensive list of tools and solutions built for developers building on Kadena. -- Full list of Tools & Solutions coming soon Chainweb Node Client Is a TypeScript library that simplifies connecting to and interacting with Kadena’s Chainweb nodes. Overall, this client library provides a straightforward way to integrate with the Kadena blockchain network, handle node interactions, and build blockchain applications more efficiently. More Info Chainweb Stream Client Is a TypeScript library designed to provide a live stream of data from Kadena’s Chainweb network. Overall, this library makes it straightforward to build real-time, event-driven applications that react to updates on the Kadena blockchain. More Info ChainwebJS Is a TypeScript library that simplifies working with Kadena’s Chainweb network. In short, chainwebjs helps you interact with and manage the details of Kadena’s multi-chain architecture without having to reinvent lower-level functionality. More Info Client Is a TypeScript library that provides straightforward methods for interacting with the Kadena blockchain. Overall, the client library simplifies building applications that communicate with the Kadena network, helping developers focus on app logic rather than complex network interactions. More Info Client Utils Is a TypeScript library providing convenience methods and helpers for interacting with the Kadena network. By offering these common utilities, client-utils helps developers quickly implement reliable, consistent interactions with the Kadena blockchain. More Info Create Kadena App Is a CLI (Command-Line Interface) utility that jump-starts Kadena-based application development. Overall, create-kadena-app is designed to streamline the initial steps of Kadena dApp development, so you can start coding right away with a well-organized, ready-to-use setup. More Info Cross-Chain Finisher & Tracker Finisher Tracker Cryptography Utils Is a TypeScript library that provides foundational cryptographic functionality for Kadena-based applications. Overall, cryptography-utils helps developers implement secure, standards-based cryptography in their Kadena applications with minimal friction. More Info Faucet Fund New Account Fund Existing Account GraphQL Real-Time Updates: Subscribe to Chainweb events (e. g. , blocks or transactions) and receive notifications as soon as they occur. More Info HD Wallet Is a TypeScript library that provides functionality for creating and managing Kadena-compatible HD (Hierarchical Deterministic) wallets. Overall, the hd-wallet library makes it simple to implement secure, recoverable, and scalable key management in your Kadena-powered projects. More Info Kadena CLI Is a command-line interface designed to simplify various tasks related to Kadena development and network interactions. Overall, kadena-cli provides a comprehensive, developer-friendly toolset for interacting with the Kadena ecosystem straight from the command line. More Info Module Explorer Easy Integration: Simple, developer-friendly methods for setting up streams and handling incoming data within your codebase. Visit PactJS Is a TypeScript library designed to streamline interactions with Kadena's Pact smart contracts. By providing a clean abstraction over the low-level details of Pact, the pactjs library empowers developers to rapidly build and deploy smart-contract-enabled dApps on the Kadena blockchain. More Info SpireKey SDK Leverages WebAuthn standards to deliver a secure backend, enabling end users to generate and store keypairs directly on their hardware devices. More Info Wallet SDK Is a TypeScript library focused on simplifying the integration of Kadena wallets into web and dApp environments. Overall, the Wallet SDK makes it straightforward to build robust, user-friendly applications that interact with the Kadena blockchain through secure wallet integrations. More Info",
    "source": "resources/solutions.md",
    "title": "Developer tools and solutions"
  },
  {
    "content": "Provides guidelines, conventions, and recommended practices for contributing This guide describes our approach to building effective documentation, the conventions we follow, and the recommended practices for organizing, crafting, and evolving our information architecture with a clear and consistent voice. Many style rules have equally justifiable alternatives. Following a common style guide is intended to prevent debates over style from getting in the way of documenting Kadena. If you don't see an answer to a style question in this guide, follow your best judgement and keep the style you choose consistent within the page or document you're working on. Organizing information into purpose-driven documents For software documentation, you can structure information using the following information model: - Tutorials are learning oriented and designed to give a newcomer a positive, successful experience. Tutorials should be tested regularly to ensure they don't get stale and that they always provide a successful result. - How-to guides are task oriented with practical steps to achieve a specific goal. These guides assume that readers are know the task they want to complete for a specific scenario but not necessarily how to complete it. - References are information oriented technical descriptions of a system or its components. - Explanations are the conceptual framework for understanding how or why a system works. Explanation provide the context that surrounds what people learn in a tutorial, do in a how-to guide, or look up in reference material. For more detailed information and examples of how to structure documentation using this information model, see [The Grand Unified Theory of Documentation][1]. Structuring content into pages In general, every page of documentation should have a purpose and be self-contained. It's okay for information to be in multiple places and similar content can exist in pages that serve different purposes. For example, you might have conceptual information about secret and public keys in one page and have similar content as context in a how-to topic for generating keys. When possible, you should reuse content rather than duplicate content, but it's perfectly fine to cover the same information in more than one place to serve different purposes. How-to guides A how-to guide describes how to achieve a goal or complete a task. Only the information that is pertinent to achieving that goal or completing the task is included. With how-to guides, readers have enough information to know what they want to do—for example, open a bank account—but not necessarily enough information to know how to do it. For example, the how-to guide for opening a bank account wouldn't explain what a bank account is or why you might want to open one, but would focus on specific steps such as: 1. Select an institution. 2. Fill out an application. 3. Deposit a minimum amount of currency. How-to guides often include links to additional information, but should not include explanations that take the focus away from what the reader wants to accomplish. What's in a how-to guide? In most cases, how-to guides contain the following sections: - Frontmatter with a title, description, and other information. The title should be short and identify the subject of the how-to topic in the fewest words possible. The description should be a sentence that summarizes the content of the topic. Additional information might include a list of keywords or the location of the source file. - One or more introductory paragraphs that explain what the task-at-hand is, the use case or scenario driving the reader to complete the task, and the expected outcome. - A \"Before you begin\" list of prerequisites. Prerequisites can include what you need to do, what you need know, or what you need to have before starting a procedure. For example, if completing a procedure requires the reader to have specific software installed, you should include a description of the software requirement in the \"Before you begin\" section. - Task step sections that break down the how-to procedure into manageable chunks or subtasks with clearly-defined goals. If you're documenting a simple task that can be completed in less than ten steps, you can probably skip breaking it down into more atomic task sections. However, most how-to procedures benefit from being split into subtasks with fewer steps in each is subtask. If a procedure is more than ten steps, you should consider using task step sections. Steps in subtask sections should specify the action the reader should take. In most cases, steps should also describe the result the reader should expect after taking action. - A \"Next steps\" section can be used to add links to logically related topics, if applicable, or to recommend related topics for further reading, such as reference topics related to the procedure completed. Using links, admonishments, and details in how-to guides You should avoid breaking the reader's focus in how-to guides. For example, avoid adding links to other pages or to other sections in the same topic. Avoid inserting notices, tips, admonishments, or other stylized and potentially distracting components unless absolutely necessary. If you include links to external documentation, explain why the reason to go there or what information the reader should expect to find there. For example, use explicit information like \"For more information about launching an EC2 instance, see Launch your instance in the AWS documentation\" instead of \"Read the AWS documentation for more information\". Tutorials Tutorials are designed to give first-time users or new developers hands-on experience completing a set of explicit instructions. Tutorials should be as simple and straightforward as possible, with one or more clear objectives that are consistently achievable. Tutorials must provide a positive learning experience and a successful outcome with no unexpected behavior or unexplained errors. It's okay for a tutorial to include a red herring to illustrate a common misstep but the author must provide a sufficient explanation of the error and how to correct it. What's in a tutorial? Tutorials provide information that's similar to how-to guides but are focused on achieving learning objectives. Typically, a tutorial includes: - Frontmatter with a title, description, and other information. A tutorial might also include a link to a video demonstration that covers the same lesson. Tutorials can also be tagged with a skill level, estimated time to complete, or topic category. For example, tutorials can be assigned a skill level of Beginner, Intermediate, or Advanced or a topic category such as Pact or TypeScript. - One or more introductory paragraphs that explain what the tutorial demonstrates. Introductory information can also include a brief summary of the expected outcome. For example, if a tutorial demonstrates how to create a simple calculator application, you can include a brief descriptions of the functions the application is going to support. - A \"Before you begin\" list of the tools, knowledge, or skills required to complete the tutorial. - Learning objectives that summarize what the reader will accomplish by completing the tutorial. Objectives can be listed under a \"Learning objectives\" heading, but only if this heading is used consistently for all tutorials. - Task steps that the reader must follow in sequence to successfully complete the lesson. The same rules for task sections and steps for how-to guide apply for tutorials. - A \"Next steps\" section is optional because tutorials are often self-contained standalone topics. However, you can use a \"Next steps\" section to add links to logically related topics or to recommend related topics for further reading, such as reference topics related to the lesson just completed. Conceptual explanation guides Conceptual guides explain core concepts and how Kadena, Chainweb, and other tools work at system, component, and operational levels. Conceptual guides can include information about software architecture, blockchain technology, network concepts and protocols, or cryptography. Conceptual guides explain the \"why\" and \"how\" at the foundational level. What's in a conceptual guide? Conceptual guides typically contain the following sections: - Frontmatter with a guide title, description, and other information. - Subsections and body paragraphs that explain that explain concepts, components, system operations, and context to help the reader understand what something is, why it's important, and how it works. - Diagrams to illustrate component relationships, system architecture, or flow of operations. - Links to related topics, where applicable. Reference manuals Reference manuals describe command-line programs with complete command-line option descriptions and examples, language semantics, API methods, and other technical details. Reference information is often organized using alphabetic order and presented in lists or tables. Information should be easy to scan henever possible. What's in a reference manual? Reference manuals typically contain the following sections: - Frontmatter with a guide title, description, and other information. - One or more introductory paragraphs that explain what information the reference covers. - Formatted reference information. The format might resemble a man page or API description with a common set of sections (name, description, syntax, options, examples, and so on) or the format might use lists or tables to present information. - Links to related topics, where applicable. General guidance for engaging content There are three keys to writing content that engages the audience: - Use the second person point of view to directly address the reader. - Use an active voice and present tense whenever possible. - Use a conversational tone that is not too formal or too chummy. Point of view In most cases, address the reader directly using imperative sentences (Run the following command) or as you (You can run the following command). Because tutorials provide a more guided approach to a topic, using the first person plural—we, us, our, ours—is more commonly accepted than in other types of documentation. Use the first person point of view sparingly and with intention. For example, in a tutorial you might use something like \"Let's try that now\" for a conversational tone. However, if you overuse the first person point of view, it can overwhelm the sense of a shared experience and obscure the reader's journey. Don't use “I” or “me” unless it appears in the text of a user interface element. Avoid using “we” in documenting a recommended setting or practice. Using “We recommend. . . ” is ambiguous (\"we\" being who exactly? ) and potentially dangerous if something goes wrong. If there are industry best practices or recommendations, it's okay to indicate that instead of using the royal or editorial \"we\" in documentation. Passive constructions In passive constructions, the object on the receiving end of an action is the subject of the sentence: This value is used for the sid field in the ldap section of the configuration file. In active constructions, the person or object performing an action is the subject of the sentence: You use this value for the sid field in the ldap section of the configuration file. When writing about software, it's often tempting to describe what's happening from the code point of view. However, there's almost always a human being with a goal or task to complete who is initiating the activity that the software is executing. If you keep this human presence in mind, your writing will be more dynamic, easier to follow, and more interesting to read. There are situations where a passive sentence structure might be appropriate, but be wary of using it. Contractions and conversational tone Contractions are generally acceptable because they give documentation a more natural conversational tone—at least for English speakers. Be conscious of when and why you use contractions. To keep the tone conversational but concise, adhere to the following guidelines: - Use simple English words instead of flowery or literary language. - Use “when” to imply eventuality and time. - Use \"if” to imply the possibility of something happening. - Use “since” to imply a period of time. - Use “because” to imply cause and result. - Use “once” to imply something that occurs a single time. - Use “after” to imply something that occurs each time. - Avoid dead language words and phrases even if they are generally accepted as English words in practice. For example: - Instead of “i. e. ”, use “that is” or rewrite the sentence to make the meaning clear without needing extra qualification. - Instead of “e. g. ”, use “for example”. - Instead of “via”, use an appropriate English substitute such as “by”, “through”, \"from\", or “using”. - Instead of “etc. ”, use “and so on” or revise the content to make the term unnecessary. For example, revise to use such as or like followed by an example or two. - Instead of “caveat”, use an appropriate English substitute such as “notice”, “caution”, or “warning”. - Avoid adding unnecessary words or phrases. For example: - Instead of “In order to”, just use “to”. - Instead of “as well as”, just use “and”. - Instead of “and then”, just use “then”. - Avoid jargon, colloquialisms, and idiomatic phrases. - Avoid adverbs and subjective statements. For example: - Experienced developers who ~~truly~~ prefer to skip the tutorial. . . - You can ~~quickly~~ test this code is functioning as expected. . . - You can run the following script to ~~easily~~ deploy a cluster. . . Headings All heading levels should use the following conventions: - Use sentence case. Sentence case means that only the initial word and proper nouns are capitalized. - Use active, present tense verbs in headings wherever appropriate, especially in the context of tutorials and how-to guides. - Use noun phrases for conceptual and reference topics whenever possible. - Minimize the number of words you include in a heading text whenever possible. - Avoid generic headings like \"Overview\" and \"Introduction\", if possible. Generic headings can be conceptually useful, but they don't add value to the content or the navigational experience. - Include at least two sentences of content. A heading should never be immediately followed by another heading. Avoid using headings strictly for navigation. Limit heading levels As a best practice, avoid building an information hierarchy with more than three heading levels. Most content can be effectively organized using two internal heading levels, making it easier to navigate and scan for relevant topics. Topic titles Avoid using gerunds (verbs ending in \"-ing\") in titles and headings. Procedure titles and headings should answer the question: What are you trying to do? For example, if the answer to What are you trying to do? is I want to create an account, the article heading should be Create an account. In most cases, concept and reference topics that aren't related to tasks are named with a noun phrase, such as Blockchain basics. Lists Introduce lists with a heading, a sentence, or a fragment that ends with a colon. - Use bulleted lists for items that don't need to appear in order. - Use numbered lists only for processes and procedures that must be completed in sequential order. Bullets Use the same bullet type for all items in unordered lists. The order of items in a bulleted list can imply importance, but generally all list items are peers. Each list item should start with a capital letter and end with a period unless all of the list items are single words or short phrases of no more than four words. Use parallel sentence structure in phrasing the items in a list. For example, start each item in the list using a noun or a phrase that starts with a verb. Numbered steps Only use numbered paragraphs for steps in procedures. If a procedure has more than nine steps, always consider breaking it into subsections with headings. Ideally, each procedure or subtask: - Should be three to six steps. - Should have minimal embedded paragraphs describing what happens—the result or outcome to expect—in an unnumbered paragraph following the step. - Should not have nested sub-steps. Pronouns Use gender-neutral pronouns, like “they” whenever possible. Generally, you can change any noun from singular to plural to have subject-verb-pronoun agreement and avoid the use of gender-specific pronouns like “he”, “him”, “his” or “she”, “her”, “hers”. Using \"they\" or \"their\" with singular nouns is more generally accepted in modern conversational English, but it's rare you to need to use the disagreeing format in documentation. Be wary of impersonal and potentially ambiguous pronouns such as: - all, another, any - each, either - few, many, neither, none, - one, other - same, several, some, such - this, that, them, these, those If you use any of these impersonal pronouns, be sure you answer “of what? ”, “of which? ”, or “as what? ” in the sentence. Be especially cautious if you start a sentence with an indefinite pronoun like \"This\" followed by a verb. In most cases, the pronoun should be followed by an object. Kadena-specific styles Most of the style suggestions in this guide are general writing recommendations for any type of documentation project. The general recommendations aren't specifically focused on documenting Kadena. The topics in this section cover style conventions that are specifically for Kadena and Kadena documentation. Tone The tone of different articles might vary depending on the target audience. However, most topics in documentation should have a neutral conversational tone that delivers technically accurate information. Code, commands, and configuration - Use backticks around inline code and commands. For example: You can run the docker info command to check whether Docker is currently running. - Use labeled code fence blocks for code snippets so that they render with syntax highlighting and a Copy button. For example: ``pact (namespace 'free) (module hello-world GOVERNANCE (defcap GOVERNANCE () true) (defun say-hello(name: string) (format \"Hello, {}! ~ from: ${publicKey}\" [name]) ) ) `` Diagrams Use the Kadena visual library to create diagrams with a consistent design language. Product names and capitalization Full product names are treated as proper nouns and capitalized. For example, Chainweaver and Pact are proper nouns. Don't capitalize terms that are common words and not proper nouns. For example, don't capitalize common terms like server, node, agent, and so on. Overuse of capitalization makes text more difficult to read. Technical concepts and acronyms Avoid using acronyms if possible. If you use acronyms, be consistent and use the same acronym for any given concept, protocol, or process throughout the entire page. For example, don't use a combination of \"multifactor\", \"2-factor, \" \"two-factor\", \"2fa, \" or \"tfa\" within a given page. Always use the full definition followed by the acronym in parentheses before using the acronym thereafter. For example, use \"Network Level Authentication (NLA)\", not \"NLA (Network Level Authentication)\" or \"NLA\" on its own without its full definition. Search engine optimization (SEO) Every page should have a clearly-worded description in the frontmatter. Descriptions should be full sentences and end with a period. Descriptions should include common keywords related to the subject matter if possible. Terminology and usage conventions This section covers common terminology, style, and usage questions. It includes recommended practices for using punctuation, referring to user interface elements, and selecting the right words for the information you're trying to convey. Above and below Don't use above to mean earlier or as an adjective preceding a noun (the above section) or following a noun (the code above). Use a hyperlink, or use previous, preceding, or earlier. Don't use below to mean later or as an adjective preceding a noun (the below section) or following a noun (the code below). Use a hyperlink, or use later or the following. For example: - Use the preceding code to display information about the database. - Use the following code to display information about the database. Dates and numbers Date formats can depend on context, including the location of a computer and a user's preferences. In most cases, you can use the DD Mon YYYY or DD Month YYYY format for dates. In body text, spell out whole numbers from zero through nine. Use numerals for 10 or greater. Use commas in numbers with four or more digits. Use more than instead of over (over is a spatial term). Emphasis and user interaction Use bold formatting for user interface elements that the user interacts with, including: - Menus and menu commands. - Field and button labels. - Options that can be selected in the user interface. Images Diagrams and illustrations can help readers visualize and internalize complex ideas and processes, so use them liberally but with intention. Images also help to break up long text flows, but they should always reinforce and reflect the text immediately preceding or immediately following the image. If you include screenshots, only include the relevant parts of the screen and use callouts to highlight how what is captured in the image is relevant to the text. Be wary of using diagrams or illustrations that include any information—visual or textual—that is likely to get stale. \"Log in\" and \"sign in\" terminology Most Linux distributions and macOS use log in to describe how a user initiates an interactive session. Windows uses log on. Many modern web-based applications use sign in. - Use sign in or log in as two words with no hyphen when describing an action (verb usage). - Use sign in and sign out as the preferred terminology for actions involving web-based applications unless it contradicts the user interface. - Use login as one word only when it's used as a noun, for example, when using login to mean a user profile or an identity. - Use log-in with a hyphen only when modifying a noun, for example, when describing a log-in window (adjective usage). Optional steps Use (Optional) at the beginning of steps that are optional. For example: - (Optional) Add a custom field. Punctuation and writing mechanics Use the following guidelines for punctuation marks. Punctuation | Usage apostrophe (') | Use in contractions for a conversational tone. Avoid using the possessive form. colon (: ) | Use a colon at the end of the statement that introduces a procedure, bulleted list, or table. comma (, ) | Use a serial comma to separate three or more items in a series, including the item before the conjunction. For example: She bought apples, oranges, and bananas. em dash (—) | Use an em dash (—) to set off a clarifying or parenthetical phrase with more emphasis than parentheses provide. Don't add spaces around an em dash. Don't capitalize the first word after an em dash unless the word is a proper noun. exclamation point (! ) | Avoid using exclamation points in general and never use more than one. semicolons (; ) | Don't use semicolons instead of commas to separate items in a list. If you think the content should use semicolons, consider rewriting it into subtopics or an unordered bullet list. slashes (/) and backslashes () | Avoid using slashes or backslashes except when documenting paths that require either forward or backward slashes. Never use and/or in documentation. Software versions Use or later or and later to refer to multiple versions of software. For example: - Firefox 3. 6 or later - Rust compiler, version 1. 55. 0 and later Special notice paragraphs If there's text that requires more attention than the surrounding body, consider isolating it as a standalone note or tip. However, think twice before adding any type of special notice components or tabbed boxes. These elements can be distracting and too many of them can make the text unreadable. Because they are generally disruptive to the reader's experience, ask yourself if it is really necessary to stop the reader's forward progress by adding a special component. In most cases, it's more effective to integrate the information in the main body of the text. If you use any special notice components at all, use them sparingly. Note—Indicates neutral or positive information that emphasizes or supplements important points of the main text. A note supplies information that may apply only in special cases. Examples are memory limitations, equipment configurations, or details that apply to specific versions of a program. Tip—Helps users apply the techniques and procedures described in the text to their specific needs. A tip suggests alternative methods that may not be obvious and helps users understand the benefits and capabilities of the product. A tip is not essential to the basic understanding of the text. Caution—Advises users that failure to take or avoid a specific action could result in loss of data. Tense Use present tense whenever possible. Use past tense only if you must describe something that has already occurred. Use future tense only if you must describe something that has not yet occurred but can be safely assumed. User interface elements In general, you should avoid referring to user interface elements by describing them as menus, buttons, tabs, dropdown lists, and so on. Instead, documentation should always focus on what the audience needs to do or wants to accomplish—that is, the user interaction—and not the widgets displayed on the screen. When referring to interactions in the user interface, you should generally follow the capitalization that is used for the element unless it is rendered as all capital letters. Because using all capitals is typically considered aggressive in text and most user interface elements that use all capital letters are also text that the user interacts with, you can break the follow the UI rule and use an initial capital letter. Element | How to use it button | Use bold for the button label. Don't include button in the description. For example: Click Submit. checkbox | Use checkbox, not box or check box, if you need to refer to a checkbox in the user interface. Use select and clear with checkboxes, not turn on and turn off, check and uncheck, or unselect and deselect. click | Use click to describe taking action on a standalone button. Do not use click on. Click and select are not interchangeable. dialog | If you need to refer to a dialog box, use dialog. Don't use pop-up window, dialog box, or dialogue box. dropdown | Use dropdown as an adjective, not as a noun. For example, use dropdown list. menu | Use bold for the menu name and menu item names if the user interacts with them. Verb usage Use the following guidelines for common verbs. Verb | How to use it can, may, might | Use the verb can when describing ability, capability, or capacity. Avoid using the verb may because it implies permission. Use the past tense might when describing the possibility or eventuality of an outcome. clear | Use clear rather than deselect or unselect if you have to describe removing a selection from a checkbox. displays | Use the transitive verb displays rather than the intransitive verb appears. Use displays with a direct object. For example, The command displays log messages. ensure | Use ensure to mean to make sure or to guarantee. Remember that this is not interchangeable with assure (to make confident) and insure (to provide insurance). enter, type | Use enter to instruct the user to input a value by pressing the Enter or Return key. Use type to instruct the user to type a value in a field. select | Use select to describe taking action on a menu item, checkbox, or radio button. Note that click and select are not interchangeable. set up, setup | Use set up—two words, no hyphen—when used as a verb. Don't hyphenate. Use setup—one word, no hyphen—when used as an adjective or as a noun. want, wish | Use want instead of wish or desire when the user has a choice of actions. Word choice Use the following guidelines to select the right word based on context. Word in question | How to use it affect, effect | Use affect as a verb and use effect as a noun. allow, enable | Avoid using software as a point of view and consider rewriting to focus on the human interacting with the software. app, application | Use application or applications unless there's a specific reason for using the shorthand term app or apps. back-end, frontend | Using the hyphen in these terms is still more common than not using it. Both forms are acceptable, but for consistency use the hyphen. email | It hasn't been e-mail for thirty-plus years. Never use emails. Don't use email as a verb. file name | Use file name as two words, not filename unless there's a specific reason for using as one word. its, it's | Use its as a possessive meaning belonging to or associated with an object or idea previously mentioned. Because it is a vague pronoun, be sure to check that what it refers to can be easily identified. Use it's only as a contraction for it is or it has. multifactor | Use multifactor without the hyphen for multifactor authentication. please | Avoid using please in documentation unless there's a specific reason for using it. For example, you might use please if quoting the content of a message that asks the user to do something inconvenient. that, which | Use that at the beginning of a clause that's necessary for the sentence to make sense. Don't put a comma before that. Don't use that when introducing a clause referring to people. Use who. Use which at the beginning of a clause that adds supporting or parenthetical information to a sentence. If you can omit the clause and the sentence still makes sense, use which, and put a comma before it. user name, username | Use user name as two words in most cases. However, username is acceptable to indicate a user identity profile name. Best practices and common mistakes This section highlights best practices and common mistakes to avoid. Make every word count Concise sentences are easier to read, comprehend, and translate. - Use simple words with precise meanings. - Remove words that don't add substance. - Avoid using passive, weak, or vague verb constructions—like “have been” or “is done”—if possible. Choose words that have one clear meaning. If you use words that can be both nouns and verbs—for example, words like file, post, mark, screen, record, and report—use sentence structure and context to eliminate ambiguity. When in doubt, choose the simple word or phrase over a more formal or complex one. Avoid flowery language and unnecessary words whenever possible. For example: Choose this | Instead of this use | utilize, make use of remove | extract, take away, eliminate tell | inform, let know to | in order to, as a means to also | in addition connect | establish connectivity Avoid adjectives and adverbs—words that describe how, when, or where. They're tempting, but rarely add value. Unless they're important to the meaning of a statement, leave them out. Be consistent Use one term consistently to represent one concept. For example, avoid using overloaded terms like accounts, keys, and wallets interchangeably or ambiguously. Use the glossary to standardize how terminology should be used. If terminology changes, be prepared to root out old terminology. Dangling prepositions In modern English, it's perfectly acceptable to end a sentence with a preposition. - This is something you might be interested in. Cross-reference formats Most cross references should include information that clarifies what the reader can expect to be found in the referenced topic. For cross references to topics in the Kadena documentation, use the following format: - For more information about viewing audit logs, see Troubleshooting. For cross references to external resources, use the title of the destination instead of the URL of the destination. Avoid using links to unnamed destinations. For example, don't use links like click <ins>here</ins> or see this <ins>article</ins>>. [1]: https: //documentation. divio. com/",
    "source": "resources/writing-guide.md",
    "title": "Writer's style guide"
  },
  {
    "content": "The Kadena Smart contract developers content provides a roadmap for learning how to write smart contracts and frontend user interfaces for applications that run on the Kadena blockchain network. Smart contract development Kadena Developer documentation is organized into three main content areas: - The Smart contracts portion of the documentation is all about learning to write smart contracts and build applications using the Pact smart contract programming language for the Kadena blockchain network. This part of the documentation provides explanations and examples that describe programming language features, introduce Pact-specific concepts and terminology, and expose common programming patterns to help you design and build robust and secure applications. - The Reference portion of the documentation provides complete reference information for the Pact programming language—including syntax, keywords, and built-in functions—and the command-line interfaces you can use to interact with Pact smart contracts and the Kadena blockchain in a development, test, or production environment. - The Coding projects portion of the documentation provides you with opportunities to apply the information covered in Smart contracts to sample projects with hands-on coding challenges. Get started with Pact In Get started, you'll get an introduction to smart contract development, Pact design principles, and how to navigate the documentation. After the introduction, topics align loosely with the software development life cycle, moving from basic concepts and simple examples to more complex topics as you explore Pact language features and common coding patterns. At a high level, topics are organized to cover the following stages of the software development life cycle: - Learn the fundamentals of the programming language. - Build programs with common core components like functions and tables. - Test and debug your code to verify and improve its functionality. - Iterate and update code when changes are required. - Integrate user experiences and frontend frameworks. - Deploy smart contracts for further testing or into production. Reference The Reference content area is where you'll find the information you most frequently need to look up. For example, the Reference content area contains the descriptions and examples for all of the Pact built-in functions. In general, reference information is organized alphabetically and easiest to find by using Search. Coding projects The Coding projects content area provides instructional material for working with the sample projects located in the pact-coding-projects repository. The topics that correspond with the sample projects illustrate concepts in action and complement explanation topics with hands-on exercises and coding challenges. The projects themselves highlight common use cases that can be adapted to many scenarios or extended to address new use cases.",
    "source": "smart-contract-dev.md",
    "title": "Smart contracts"
  },
  {
    "content": "Learn about how public and secret keys are used in accounts and how accounts on Kadena blockchain differ from accounts and addresses on most blockchains. With most blockchains, accounts and account addresses that can send and receive funds are based on generating public and secret key pairs then using your public key as your account name. This “one-to-one” model keeps things simple, but runs into problems when you want to use multiple keys for a single account. For example, you might want an account to represent joint-ownership for partners in a relationship or the officers in a board of directors who must approve expenditures by a majority vote. To handle situations where an account must represent more than one owner, Kadena makes a distinction between keys and accounts. This distinction enables multiple keys to be associated with the same account name. In simple terms, an account name is a unique name on the blockchain that can hold funds with one or more public and secret key pairs that grant access to the account. The keys determine ownership of an account. The rules for how many keys are required to act on behalf of the account are defined in a construct called a keyset. Defining a keyset A keyset is a specific type of guard that consists of one or more public keys and a predicate function that specifies how many of the keys are required to perform an operation. In JSON, a keyset object looks similar to the following example: Code example (json): { \"keys\": [ \"1d5a5e10eb15355422ad66b6c12167bdbb23b1e1ef674ea032175d220b242ed4\", \"4fe7981d36997c2a327d0d3ce961d3ae0b2d38185ac5e5cd98ad90140bc284d0\", \"58705e8699678bd15bbda2cf40fa236694895db614aafc82cf1c06c014ca963c\" ], \"pred\": \"keys-any\" } In this keyset, there are three public keys defined as owners associated with this keyset. The predicate function of keys-any means that any of the three public keys can sign transactions and act on the behalf of the account associated with this keyset. To make this keyset usable for practical purposes in a smart contract, it's assigned a name. You can then reference the name to check whether an action is valid by verifying at least one (keys-any) of these three public keys has authorized it. Code example (json): { \"my-keyset-name\": { \"keys\": [ \"1d5a5e10eb15355422ad66b6c12167bdbb23b1e1ef674ea032175d220b242ed4\", \"4fe7981d36997c2a327d0d3ce961d3ae0b2d38185ac5e5cd98ad90140bc284d0\", \"58705e8699678bd15bbda2cf40fa236694895db614aafc82cf1c06c014ca963c\" ], \"pred\": \"keys-any\" } } In this example, you evaluate the keyset name my-keyset-name and, if the result is true, allow the action to be performed. Defining accounts Keysets are important because they are one part what it takes to define an account. An account is an entry in the Kadena coin contract, the ledger that keeps track of all transfers from one account to another. In the coin contract, an account consists of the following parts: - Key: An account name in the form of a string of 3 to 256 LATIN-1 characters (key). - Vale: An account object that holds the decimal balance of funds in the account and the keyset that governs the account. Code example (text): key: \"Valencia-HOA\" -> value: { 0. 0, { [\"1d5a5e10. . . \", \"\"4fe7981d. . . \", \"\"58705e86. . . \"], \"keys-any\" }} As you saw in the previous example, the keyset consists of one or more public keys and the predicate function that specifies the number of keys that must sign a transaction for the account. There are three built-in predicate options: - keys-all - keys-any - keys-2 For most accounts—where there's only one public key with ownership of the account—the default predicate of keys-all works as you would expect it to, granting ownership of the account to a single party. However, the predicate function is important to consider when creating accounts that require multiple signatures or have multiple owners. For example, the keys-2 predicate requires that at least two public keys defined in the keyset for the account must sign a transaction to authorize the execution of that transaction. The following diagram illustrates the relationship between keys, keysets, and accounts: ! Keys, keysets, and accounts on the Kadena network If you would like to learn more about keys and accounts in Kadena, see Beginner's Guide to Kadena: Accounts + Keysets. Accounts on a multi-chain network The Kadena network is a scalable proof-of-work blockchain with a consensus model that weaves the transactions and blocks from multiple parallel chains into a single and consistent view of the blockchain state. For a visual introduction to how the Kadena Chainweb protocol weaves connections from multiple chains into a single view of state, watch the 3-minute video How Chainweb Works: A Simple Animation. Ultimately, this single view of state is one network. However, each of the parallel chains in the network operates independently. When you create and fund an account on any chain, it only exists on that chain. You can create accounts on more than one chain, but they are essentially independent accounts, with separate account balances and potentially different keysets and owners. Because the chains operate independently, you should always pay close attention to the network and chain identifier you have selected when you are signing and submitting transactions. It's also important to remember that the account name—on its own—doesn't determine the ownership of an account. The keyset associated with an account determines ownership. You could own an account named Alice on chain 0, and someone else could own an account named Alice on chain 5. If you want to own a specific account name across all of the chains in the network, you would need to be the first person to create that account with your keys on each chain. To create a one-to-one relationship between a specific account name and a specific keyset, Kadena introduced the concept of principal accounts. Account names and principals As mentioned in Defining accounts, an account name can be any string. Using an arbitrary string as an account name can be convenient. For example, you might want to create an account with a name that identifies it as a personal or primary account, for example, Lola-Pistola, so that it's easy to differentiate it from an account that you own jointly with another party or a group, for example, Las-Pistolas. However, using arbitrary or vanity account names like these examples can make your account vulnerable to certain kinds of attacks. For example, an attacker might try to frontrun a transaction that creates an account or transfers funds by changing the keyset associated with the account name. One way to prevent an an attacker from trying to impersonate you with a frontrunning attack is to create principal account. A principal is a way to enforce a one-to-one relationship between a guard and a resource that the guard is there to protect, like an account name to protect the ownership of an account balance. If an attacker tries to intercept a transaction by changing an account keyset—the most common type of guard—the new keyset won't match the one defined in the underlying ledger, so the transaction would fail. Keysets and principals Keysets represent the most-commonly used type of guard and are the most similar to how most blockchains protect access to accounts using public and secret keys. As you've already seen, a keyset holds a collection of one or more public keys and a predicate function that defines how many of those keys must sign to authorize an action. In Pact, a guard is an assertion of ownership, for example, the ownership of a particular keyset, capability, or user attribute. By calling a function to enforce the guard, Pact produces a Boolean value that must return true for an associated action to take place. By default, when you define a principal account with a single public key and the keys-all predicate, the result is an account name that starts with the k: prefix, followed by the public key for the account. This naming convention creates a principal account for an individual key. You can use the create-principal built-in function to create a principal account name for a specified keyset guard. The create-principal function returns a string that represents the principal identified by the specified keyset guard. In the following example, the create-principal function creates a principal from the keyset guard with the name valencia-keyset: Code example (pact): (env-data {\"valencia-keyset\": { \"keys\": [\"fe4b6da3. . . 27f608b7\"], \"pred\": \"keys-all\" } }) \"Setting transaction data\" (create-principal (read-keyset \"valencia-keyset\")) \"k: fe4b6da332193cce4d3bd1ebdc716a0e4c3954f265c5fddd6574518827f608b7\" You can also create principal accounts for keysets that have multiple keys and that use either built-in or custom predicate rules. For example, you can define a keyset with two public keys and the built-in predicate keys-any. If you create a principal for this account, the keyset information is used to generate a unique hash and the account is created using the w: prefix, followed by the hash for the guard. In the following example, the create-principal function creates a principal from the keyset guard with the name valencia-hoa: Code example (pact): (env-data {\"valencia-board\": { \"keys\": [\"fe4b6da332193cce4d3bd1ebdc716a0e4c3954f265c5fddd6574518827f608b7\", \"5ec41b89d323398a609ffd54581f2bd6afc706858063e8f3e8bc76dc5c35e2c0\"], \"pred\": \"keys-any\" } }) \"Setting transaction data\" (create-principal (read-keyset \"valencia-board\")) \"w: kar3UPhvtWsLsn5cr5VtNde7CRykgAknLNlDD6BkOPI: keys-any\" Other types of guards In addition to keysets, Pact supports several other types of guards that you can implement in smart contracts. These guards give you flexibility for handling different types of authorization scenarios, and in general, you can use any type of guard to create a principal account by generating a unique hash. Each type of principal and guard uses a unique prefix, so they are easy to recognize. If you create principal accounts for the guards, you'll see that the principal accounts use the following set of prefixes: - k: for single key keysets - w: for multiple keys keysets - u: for user guards - c: for capability guards To learn more about different types of guards and how to use them, see Guards. Transfers within and between chains There are two main ways to move Kadena tokens (KDA) between accounts: - Transfer coins between accounts on the same chain. - Transfer coins between accounts on different chains The primary different between these two types of transfers is who pays the transaction fee to have the transaction included in a block. - With same-chain transfers, the sender must pay the transaction fee. - With cross-chain transfers, the sender and the recipient must both pay a transaction fee. With a cross-chain transfer, you interact with two different blockchains, which requires two separate transactions, one on each chain. If you attempt to send a cross-chain transfer to a recipient with no funds on the destination chain, the transfer operation won't be able to complete. However, anyone with funds on the destination chain can help to pay the required fee, allowing the transfer to finish as intended. Kadena has also set up gas stations cover the cost of transaction fees for cross-chain transfers. If you have an incomplete cross-chain transfer, you can use the Transfer assistant to finish the transaction on the destination chain. To learn more about transfers in Kadena, see Getting started with transfers.",
    "source": "smart-contracts/accounts-keys.md",
    "title": "Accounts, keys, and principals"
  },
  {
    "content": "Get familiar with important Kadena blockchain and Pact language concepts and terminology. The main purpose of a blockchain is to record transactions. Typically, transactions are business events that transfer some form of digital asset from one owner or entity to another. Through the use of modern cryptography, a blockchain can provides guarantees about the authenticity and integrity of the transactions recorded without relying on any central authority or under the control of any government, corporation, or other institution. The decentralized nature of the blockchain depends on having its computational resources distributed across many individual computers. The individual computers in the network—called nodes—run the blockchain software and communicate with each other as a peer-to-peer (P2P) network using the internet and publicly-accessible IP addresses. Nodes provide the bandwidth, processors, memory, and storage capacity to handle incoming transaction requests and validate the transactions results that change the blockchain state. Consensus models The method that a blockchain uses to validate transactions, insert transactions into blocks, and submit blocks to continue the chain is called its consensus model or consensus algorithm. For the Kadena blockchain, the method of adding new blocks to the blockchain is a variation of a proof of work consensus model used by Bitcoin. With the proof-of-work consensus model, the first node to solve a computational problem for a transaction adds the transaction to a block. As new transaction are added to blocks and new blocks are produced, all of the nodes in the network attempt to stay in synch with each other so that there's a consistent view of the blockchain state. The computers used to solve the mathematical problems that validate transactions typically run specialized hardware and are commonly referred to as miners because they earn rewards for the work they do to keep the chain going. The rewards take the form of KDA tokens that are deposited in accounts owned by the node operators. The Kadena proof-of-work consensus model is unique in its use of multiple chains to support horizontal scaling and in the use of degree and diameter network design to identify adjacent peers. Chainweb and parallel chains Networks that rely on a proof-of-work consensus model provide security and decentralization, but are often limited by scalability issues, including: - The number of transactions they can process. - The speed at which they can process transactions. - The energy consumption required to validate transactions. - The high cost of transaction fees when the network in busy. These factors have limited the effectiveness of blockchain networks to handle modern economic activity. The Kadena proof-of-work consensus model is designed to address these scalability issues and deliver a blockchain built for business. The core of the Kadena blockchain is defined in its Chainweb architecture. The Chainweb architecture is based on a proof-of-work consensus model, but introduces the concept of parallel blockchains to minimize latency and maximize throughput. The parallel chains are connected through peer nodes in an adjacency graph that makes efficient use of cross-chain hops for transaction execution and validation. The optimized network connections enable the chains to operate simultaneously to increase transaction processing capacity and reduce transaction costs across all of the chains in the network. The nodes that participate in the network run chainweb-node software to communicate as a peer-to-peer network and to execute transactions. Each parallel chain includes block hashes (Merkle roots) from blocks on peer chains into their headers. By referencing block hashes from peer chains, each chain can validate the consistency of its peer chains and provide a trustless oracle for cross-chain transfers of funds. With this mechanism, the chains are braided together into a single canonical chain that offers an effective hash power that is the sum of the hash rate of each individual chain. Each chain in the network mints its own coin, but all of the chains use same cryptocurrency. Because the chains share a common currency, coins can be transferred cross-chain using a trustless, two-step simple payment verification (SPV) at the smart contract level. Applications and smart contracts Applications that run on a blockchain—often referred to as decentralized applications or dApps—are typically web applications that are written using frontend frameworks like React, Angular, Vue, or Next. js but depend on backend smart contracts to capture, store, modify, and read application data. A smart contract is a program that executes specific instructions under specific conditions that can be programmatically-enforced to ensure that the outcome is recorded and immutable. Smart contracts can be written in different languages for different blockchain networks. For the Kadena network, most smart contracts are written using the Pact smart contract programming language. Pact has several key features that make it well-suited to writing business applications that run as smart contracts on the Kadena network and Chainweb nodes. Namespaces and modules Two important concepts in Pact are namespaces and modules. A namespace is a logical ownership boundary for smart contracts that are controlled by a specific entity. Smart contracts include a namespace declaration to provide a unique prefix for everything—including modules, functions, keysets, and interfaces—that are defined within the namespace scope. The root namespace in the Kadena test and main networks is reserved for built-in contracts like the coin contract. You can't deploy contracts directly in the unpartitioned root namespace. However, Kadena provides the free namespace and the user namespace as publicly-accessible namespaces for testing and training purposes. For local development, you can deploy contracts directly in the local root namespace or define custom namespaces. For public blockchains like the Kadena test and main networks, you must define and register custom namespaces for your projects. Within a namespace, modules are the fundamental building blocks that provide the logic used in all Pact smart contracts. All of the functions and data definitions that are required to complete a set of related business operations are defined within the context of a module. Individual modules are often self-contained logical units that implement a related set of functions. Keysets, capabilities, and guards Keysets define authorization rules for smart contracts. They often determine who can access specific functions in a program and the keys required to sign specific transactions. Capabilities define specific privileges or permissions that must be granted or acquired to perform specific operations within a section of code. Guards provide to enforce specific conditions, including that required keyset is being used or a specific capability token has been granted. A keyset is itself a type of guard. Cross chain and multi-step transactions Pact supports cross-chain and multi-step transactions by enabling you to define a sequence of steps in a defpact declaration. With a defpact declaration, you can emulate an escrow service or orchestrate a process that must be completed in a specific order. Execution modes Pact is designed to use distinct execution modes to address the performance requirements of rapid linear execution on a blockchain. These execution modes are: - Contract deployment. - Transaction execution. - Queries and local execution. Contract deployment When a contract is deployed, the deployment transaction that's sent to the blockchain is comprised of modules, tables, and authorization data. The transaction can also include code that modifies the database, for example, to initialize information that the contract requires. As a general rule, the transaction that you use to deploy a contract on the blockchain should be sent as a single message, so that any error will rollback the entire smart contract as a unit. When contracts are initialized on the blockchain, they identify a namespace that provides context for the contract code and a unique prefix for modules and interfaces defined in the contract. Modules contain the main business logic for the application or service you want to deploy. Interfaces provide access to constant definitions and typed function signatures that are defined outside of a module to be implemented an used in a module. Deploying a contract also requires you to define one or more authorization keysets that have administrative control over the contract modules and tables. Keysets that are defined as data in the runtime environment are then stored in the global keyset database. After setting the runtime context, Pact executes the module and interface declarations and creates required tables to complete the contract deployment. Transaction execution Most of the transactions executed on the blockchain are intended to record business events. For example, business events often involve the handling of assets, payments, ownership transfers, or the completion of contractual agreements. These types of transactions are typically executed using a single call to a specific module function. However, there is no limit on the number statements you can execute in a transaction and you can define transactions that are executed as a sequence of steps. Note that the difference between transaction execution and contract deployment is simply the kind of code executed. There's no difference in how the code itself is evaluated. Queries and local execution In general, querying data that's stored on the blockchain isn't considered a business event where execution and performance are more critical. In addition, queries can often involve larger data payloads that could introduce overhead, bandwidth, and latency issues. To reduce the impact of queries on network operations, queries are handles as local execution requests on the node receiving the message. Historical queries use a transaction hash as a point of reference to avoid race conditions and to allow asynchronous query execution. Pact code doesn't distinguish between transactional execution and local execution. However, the Pact API provides separate endpoints to execute transactions on the blockchain and submit local execution requests. FOr more information about using the Pact API endpoints, see Pact API.",
    "source": "smart-contracts/basic-concepts.md",
    "title": "Basic concepts"
  },
  {
    "content": "Recommendations and reminders for patterns to avoid and practices to follow when writing programs using the Pact smart contract programming language. As a programming language, Pact has some unique features that make it adaptable to writing sophisticated applications, but that are also flexible enough to allow coding mistakes that can make a contract vulnerable to potential misuse. This topic summarizes common mistakes to avoid and best practices you should follow as you develop programs with Pact. Common issues and mistakes The following list summarizes the most common difficulties that developers who are new to Pact encounter or are most likely to misinterpret. - Internal methods are often not guarded by capabilities, allowing any unprivileged user to modify contract state. - Capabilities are often granted in cross-module calls by accident, giving the target module more permissions than it should have in the calling module. - How namespaces, accounts, and guards are used in Pact can be difficult to adjust to for developers familiar with other blockchain ecosystems or programming languages. For example, Solidity developers are used to accounts being public keys and contracts having addresses, and often write smart contracts that only support single key (k: ) accounts or deploy contracts insecurely in the free namespace. - Developers often forget to add types to their contracts, causing type errors that result in failed transactions later on. - Projects often split contract functionality into too many separate contracts—even if they share the same governance—complicating security and the overall design. - Contract operations that require user authorization use the enforce-guard function to require a transaction signature without using a capability. In Pact, capabilities enable users to scope their signature to specific actions—explicitly signaling their consent—so that they know exactly what operations they are authorizing with their signature. However, if you allow unscoped signatures by using enforce-guard without putting it into the body of a capability code block, it's impossible for users for know what actions they are authorizing with their signature. - Developers often avoid defining managed capabilities because they seem complex or to introduce friction by requiring users to explicitly authorize the operation they are signing for. However, managed capabilities prevent transactions from replay operations that could allow funds to be drained from accounts or other operations could have unintended consequences. By requiring a signature, capability guard, or user guard to authorize activity, you can safeguard users from transactions that perform unintended operation when executing contract functions. - Developers sometimes deploy contracts in the free or user namespace, fail to register a principal namespace, or accidentally deploy contracts in more than one namespace. It's important to note, that functions are defined in module declarations, and modules are deployed in namespaces. A payment function defined in the pistolas-retail module that's deployed in the n01234567 namespace is not the same as the payment function defined in the pistolas-retail module that's deployed in the n890abcde namespace. Even if the code is identical, the path to the function uniquely identifies each function. Best practices The following list summarizes patterns, practices, and strategies for writing Pact code and delivering quality projects for the Kadena ecosystem. - Explicitly type all function parameters and results. - Use objects with schemas and use lists with the list item type resolved. For example, use (a: object{mySchema}) and avoid (a: object). Similarly, use (a: [integer]) instead of (a: list). - Run the type checker over the code as you iterate on the implementation. - Create unit tests for every function that fully exercise error cases, especially cases of missing authorization to perform actions. - Be careful when using module references. In particular, keep in mind that when you call into other modules, those modules will be granted the same set of capabilities as the code making the call into those modules. - Use the enforce built-in functions to check for conditions that should terminate transaction execution immediately. The enforce functions ensure that if any invariants are violated, the transaction fails. - Use the /local endpoint when you want to query Pact state in tables or blockchain data. - Use events to send information about transaction results to off-chain software. - Only use select and keys built-in functions in /local queries. - Consider what data must be on chain and any data or operations that might be better suited to off-chain handling. - Plan for longevity and avoid defining functions that grow data structures—like lists—without bounds. In general, gas usage per transaction should not go up over time as your code is used more. - Keep functions that share the same governance in the same module. It’s fine to create composable contracts with reusable utility functions. However, it’s generally a better practice to keep the implementation of core functions in the same module unless the functions are governed by different parties. - Design and document the capabilities your contract requires and the conditions you'll use to enforce that only authorized users have access to privileged operations. Remember that capabilities can provide explicit and fine-grained access control to functions, but only if you enforce the conditions to guard them correctly. Upfront planning can help to ensure you define and grant capabilities precisely where they are needed to make your contract secure. Be sure you know how calling a capability by using the with-capability function differs from calling a capability by using the require-capability function. - Keep in mind that any code executed in the same transaction as the transaction that deploys a contract is granted full administrative privilege over the module, including the ability to update the module and edit module tables. - Create your own principal namespace before deploying contracts on the Kadena test or main production network. - You should always use managed capabilities to guard contract operations that require user authorization and that should only be executed once in a transaction. All capabilities allow users to authorize specific actions. Managed capabilities allow contracts to keep track of how a capability that's been granted in a transaction can be used, either by setting a limit on a protected resource or by preventing the capability from being granted more than once in a transaction. For functions involving assets transfers, you should use managed capabilities to prevent replay attacks within a transaction. Basic auditing for Pact If you're writing smart contracts that handle assets and transferring of ownership, you'll want to ensure that all of the functions involved in those activities are secure. For example, you'll want to ensure that functions don't leak sensitive information like account keys or identifying information that should be kept private. You'll also want to protect functions from unauthorized access and prevent functions from being appropriated and used to drain assets. As a first line of defense against unexpected or malicious behavior, you should review contract code with a few basic auditing principles in mind. In particular, you should pay close attention to the following in your code reviews: - Governance capability, keyset, and enforcement. - All table insert, update, and write operations. - All capability definitions and use cases. Be sure that capabilities are named appropriately and are only brought into scope where they are needed. You should also remove any capabilities you aren't using unless they are required by an interface that you're implementing. - Managed capability use cases. For example, you should verify that the @managed keyword is used for capabilities that should only be allowed once in a transaction. If a capability can be used more than once, you should verify that you have defined an appropriate resource and management function (@managed amount TRANSFER-mgr) and the code for the management function (defun TRANSFER-mgr: decimal). - All external module reference (modref) calls. For example, you should be able to verify whether a capability looks for the correct guard stat's stored in a database table. - All cases where you define, store, and enforce a guard or verifier application. For example, you should be able to verify that a call to an external module doesn't grant any capability that's shouldn't be in scope for the call. - All warning and error messages. For example, you should verify that you check for valid input values and provide clear error messages for invalid values. - Any nested let expressions and cascading if statements. In many cases, complex conditions can be difficult to fully comprehend and can result in the execution of unintended code blocks or code blocks that are never executed. Where possible, you should replace complex conditions with concise and specific functions that are easier to evaluate and test. - All defpact steps. Enforcing access controls As discussed in Capabilities, basic and managed capabilities are critical components for controlling how permissions are granted to users of smart contracts. In addition, most modules define a governance capability as the module owner. Conceptually, capabilities aren't difficult to comprehend or implement. However, if they aren't used correctly, capabilities can make your contract vulnerable to unexpected behavior or to be exploited. The following examples demonstrate patterns and outcomes for governance and basic capabilities. Governance As discussed in Modules and references, every Pact module has a keyset or capability that has full administrative ownership of the module. In most cases, modules define a governance capability. The governance capability for a module is different from other capabilities in two important ways: - The governance capability for a module provides total control over the code defined in the module. With this capability, the module owner can grant capabilities, access tables, modify module functions, and deploy upgraded module code on the blockchain. - External code can attempt to take control of a module by acquiring the module's governance capability. Usually, capabilities can only be granted inside the module they are defined in. In example code for modules, the body of the governance capability is often set to true for simplicity. For example: Code example (pact): (module payments GOV (defcap GOV () true). . . ) If the code associated with a capability—like GOV in this example—is simply set to true, no conditions are being enforced to restrict access and the capability is always granted when requested. Any Pact code can take total control over the module. If you don't enforce any restrictions on the module administrative privileges, anyone can take control of the contract and modify its tables and functions. This vulnerability might seem insignificant while you're testing in a development environment. However, it's important to plan for and implement access controls that prevent unauthorized use of functions that perform any type of sensitive or privileged operation. The following examples demonstrate common patterns to avoid and follow to help you make contract operations more secure. You can find more complex and complete examples in the coin contract and in the marmalade and spirekey repositories. As previously noted, the following pattern is often used in sample code for simplicity: ``pact-bad (namespace \"free\"); Public namespace used for testing only (module YODA0 GOV (defcap GOV () true); Anyone can take over the governance of the module with this capability body (defun hello-world: string (input: string) (format \"Hello {}\" [input])) ) Code example (): However, this pattern makes your contract vulnerable to hijacking with no protections in place to prevent unauthorized access. You should only use this pattern in your local development environment and in the early stages of learning to write Pact code. Another common mistake is to read a keyset or message that doesn't enforce a signing key to grant a capability as illustrated in the following example: pact-bad (namespace \"nd5ff15\") (module YODA1 GOV (defcap GOV () (enforce-keyset (read-keyset \"hello-world\"))); You can put any value into hello-world (defun hello-world: string (input: string) (format \"Hello {}\" [input])) ) Code example (): In this example, the read-keyset function reads whatever value is defined under the \"hello-world\" key in the environment data. The read-keyset function doesn't verify that the value under the \"hello-world\" key represents a valid keyset object, valid values, or a keyset you control. If someone else specifies a valid keyset in the environment data, that keyset would pass the governance check and take control of the module. The following example is similar except that it identifies a specific. . . [code continues]pact (namespace \"nd5ff15\") (module YODA2 GOV (defcap GOV () (enforce-keyset \"nd5ff15. hello-world\")); You must create the keyset on-chain in the same transaction; used to deploy the module (defun hello-world: string (input: string) (format \"Hello {}\" [input])) ) Code example (): This example uses the correct syntax, but the nd5ff15. hello-world keyset could be claimed by someone else if you don't create the keyset in the message payload for the transaction used to deploy the module. The following example illustrates a more secure pattern that defines a keyset, then uses that keyset to control the administrative privileges for a module: pact (namespace \"nd5ff15\") (define-keyset \"nd5ff15. hello-world\" (read-keyset 'ks)) (module YODA3 GOV (defcap GOV () (enforce-guard (keysetrefguard \"nd5ff15. hello-world\")); Correct usage for deploying a module ) (defun hello-world: string (input: string) (format \"Hello {}\" [input])) ) Code example (): In this example, you define a hello-world keyset in the nd5ff15 principal namespace and must include the ks keyset definition in the environment data for testing in the Pact REPL or in the message payload for deployment. Basic capabilities The following example illustrates defining a second capability to control access to a specific function: pact (namespace \"nd5ff15\") (define-keyset \"nd5ff15. hello-world\" (read-keyset 'ks)) (module YODA4 GOV (defcap GOV () (enforce-guard (keysetrefguard \"nd5ff15. hello-world\")) ) (defcap USER (account: string) (enforce-guard (at 'guard (coin. details account)))); This condition requires an account to exist, but will; validate that the account guard matches the signer (defun hello-world: string (input: string account: string) (with-capability (USER account) (format \"Hello {}\" [input]))) ) Code example (): This example requires the coin contract to be loaded and the specified account to exist on-chain. The hello-world function has also been modified to require an account string as an argument. For example: pact (nd5ff15. YODA4. hello-world \"Robot\" \"k: 000ca7383b2267a0ffe768b97b96104d0fb82e576c53e35a6a44e0bb675c53ce\") Code example (): With this pattern, the condition for the USER capability checks that the guard matches the specified account. If the account exists and the condition evaluated is true, the account can run the hello-world function. The USER capability now enforces that only the specified account can run the hello-world function. The following example illustrates using a guard as input to acquire the capability to access a specific function: pact (namespace \"nd5ff15\") (define-keyset \"nd5ff15. hello-world\" (read-keyset 'ks)) (module YODA5 GOV (defcap GOV () (enforce-guard (keysetrefguard \"nd5ff15. hello-world\")) ) (defcap USER (account: string guard: guard) (enforce-guard guard)); This condition requires the guard to be provided as input to sign for the transaction (defun hello-world: string (input: string account: string guard: guard) (with-capability (USER account guard) (format \"Hello {}\" [input]))) ) Code example (): In this example, the hello-world function has been modified to require an account string and a guard as arguments. If the guard is a keyset, you can use the read-keyset function and keyset name to input the keys and predicate for the account. For example, if the guard is the keyset you defined using ks as the keyset name, you could call the function with arguments similar to the following: pact (nd5ff15. YODA5. hello-world \"Robot\" \"k: 4fe7981d36997c2a327d0d3ce961d3ae0b2d38185ac5e5cd98ad90140bc284d0\" (read-keyset 'ks)) \"Hello Robot\" Code example (): The following example illustrates another common enforcement mistake; pact (namespace \"nd5ff15\") (define-keyset \"nd5ff15. hello-world\" (read-keyset 'ks)) (module YODA6 GOV (defcap GOV () (enforce-guard (keysetrefguard \"nd5ff15. hello-world\")) ) (defcap USER (account: string) (enforce (! = account \"\") \"Specify an account\")); Anyone can sign for this capability (defun hello-world: string (input: string account: string) (with-capability (USER account) (format \"Hello {}\" [input]))) ) Code example (): With this pattern, any string used for the account argument passes the enforcement rule for the USER capability, enabling any user to acquire the capability and use the unprotected function. For example, any value can be used with this function: pact (nd5ff15. YODA6. hello-world \"Robot\" \"jae\") \"Hello Robot\" Code example (): The following example illustrates using a hard-coded account string instead of reading a keyset or guard from a table or the message payload: pact (namespace \"nd5ff15\") (define-keyset \"nd5ff15. ks\" (read-keyset 'ks)) (module YODA7 GOV (defcap GOV () (enforce-guard (keysetrefguard \"nd5ff15. ks\")) ) (defcap USER (account: string) (enforce (= account \"k: 4fe7981d36997c2a327d0d3ce961d3ae0b2d38185ac5e5cd98ad90140bc284d0\") \"Invalid account\")) (defun hello-world: string (input: string account: string) (with-capability (USER account) (format \"Hello {}\" [input]))) ) Code example (): If the enforced account string is used, the capability is acquired: pact (nd5ff15. YODA7. hello-world \"Robot\" \"k: 4fe7981d36997c2a327d0d3ce961d3ae0b2d38185ac5e5cd98ad90140bc284d0\") \"Hello Robot\" Code example (): If any other account or arbitrary string is used, the operation fails: pact (n_d5ff15. YODA7. hello-world \"Robot\" \"k: 9a23bf6a61f753d3ffa45c02b33c65b9dc80b8fb63857debcfe21fdb170fcd99\") Error: <interactive>: 9: 4: Invalid account ` Module references As discussed in Modules and interfaces, writing external module reference calls can be an important approach for certain use cases. However, it's also important to prevent capabilities used to protect resources from being brought into scope when calling external modules, functions, or interfaces. - Do use module references when your project requires abstraction, for example, to call into an common interface that requires multiple implementations like tokens in a decentralized exchange. - Don't use module reference calls when your project has a capability that could be acquired outside of its intended scope. - Don't use module references when there's only one implementor of your interface. This just causes indirection for little reason In general, you should scope capabilities that protect resources to coin. transfer operations rather than use fungible: : transfer` external references. As a security enhancement, Pact 5. 3 introduces module reference calls that are ready-only by default. With Pact 5. 3, any module reference function call that reenters the originating module is treated as a read-only call to prevent database modification and code reentry attacks. For more information about read-only module references, see Securing module reference calls.",
    "source": "smart-contracts/best-practices.md",
    "title": "Pact best practices"
  },
  {
    "content": "Capabilities are the primary means by which you can grant granular permissions to perform tasks for which you wan to control access. At a high level, Pact capabilities are a straightforward access control model for smart contracts. With capabilities, you can define specific conditions to authorize specific actions for specific users. Capabilities provide an explicit and transparent way to protect privileged operations, enforce rules before allowing transactions to execute, and ensure smart contract users authorize actions that are performed on their behalf. Because capabilities are a core feature in the Pact smart contract programming language and powerful in how they enable you to manage permissions and resources, it's important to understand what they are, how they work, and how to define them correctly to achieve intended results. Permissions, resources, and events Before getting into the details of how capabilities are defined, you should consider that there are three distinct—but related—use cases for capabilities. You can define capabilities to do the following: - Authorize access to a specific privileged operation. - Manage updates for a specific protected resource. - Report events from operations executed in a transaction. In the most common use case, you define capabilities to manage permissions by enforcing one or more conditions. In combination with guards, these permission-driven capabilities act as gatekeepers to grant access to smart contract functions if the user or contract that controls the guard allows the operation to continue. In general, capabilities protect privileged operations—such as coin. transfer operations—that users must authorize by signing the transaction with their keys or verify in some other way. However, as a contract author, you can define capabilities verify other conditions—such as the account balance or how long it's been since the last transfer operation—before granting the permission requested. If the permission isn't granted, the code where the capability is called won't be executed. You can think of the capabilities that are used to manage permissions as basic capabilities. For more information about defining, acquiring, and scoping basic capabilities, see Expressing basic capabilities In addition to permissions, you can use capabilities to manage values for specified resources. Capabilities that manage resources are called managed capabilities. Managed capabilities have slightly different properties enable users or other contracts to set and update the value for a specified parameter. As a contract author, you can define managed capabilities to allow contract users to manage a resource value, for example, to set a limit on the amount that can be transferred in a given transaction or to define the maximum supply of a resource. For more information about defining and using managed capabilities, see Managed capabilities. Capabilities can also emit events in transaction results. For more information about using capabilities to emit events, see Events. Expressing basic capabilities Basic capabilities enable you to manage permissions by specifying the conditions that allow access to a particular resource or contract function. Therefore, in most cases, you define capabilities inside of the same module declaration as the functions that should use them. Within the module declaration, you define capabilities by specifying the defcap reserved keyword and providing the following information: - A capability name that describes the permission to be acquired or the operation to be protected. - Optional parameters that specify input arguments, properties, or conditions for the capability. - A capability body with the predicate function that determines whether the capability is granted or rejected. This predicate function is evaluated during capability acquisition. The following example defines a basic ALLOWENTRY capability in a registration module: Code example (pact): (module registration GOVERNANCE (defcap GOVERNANCE () true) (defcap ALLOWENTRY (user-id: string) \"Govern entry operation. \" (with-read users-table user-id { \"guard\": = guard, \"active\": = active } (enforce-guard guard) (enforce active \"Only active users allowed entry\")) ) ) In this example, the defcap declaration for the ALLOWENTRY capability consists of the following: - ALLOWENTRY is the name of the capability. - user-id is a parameter that is passed to the capability body to be evaluated. - with-read is the capability body that implements the predicate function. The capability body is evaluated when the with-capability function is called with a specific user-id parameter. For example, if the user-id is bob, the capability body is evaluated when (with-capability (ALLOWENTRY \"bob\"). . . ) is called. In its simplest form, the capability body evaluates one or more conditions to determine whether the permission is granted. If the conditions are met—without exiting or throwing an error—the capability is granted and operations continue. In general, you should test all of the conditions you want to define in the defcap declaration using enforce statements, so that the permission won't be granted if any condition fails. Evaluating and granting permissions The defcap declaration defines the conditions to evaluate to determine whether a permission should be granted (true) or rejected (false). You use the with-capability built-in function whenever you want to check these conditions before allowing a user to perform a privileged operation. For example, the following entry function calls the with-capability function to evaluate the ALLOWENTRY capability before executing two protected operations: Code example (pact): (defun entry (user-id: string) (with-capability (ALLOWENTRY user-id) (add-entry user-id); ; call a protected operation within the with-capability block (update-entry-status user-id); ; update a database within the with-capability block ) (record-audit \"ENTRY\" user-id); ; call an unprotected operation outside of the with-capability block ) As illustrated in this example, the capability applies to the protected operations inside of the with-capability code block. If the capability is granted, it remains in scope for all operations contained within the scope of the with-capability function. In this example, the ALLOWENTRY capability remains in scope for the add-entry and update-entry-status functions. After the code block containing the call to the with-capability function exits, the capability is no longer in scope. In this example, the ALLOWENTRY capability is removed from scope before executing the record-audit function that's outside of the with-capability block. Restricting the capability to the code contained within the with-capability block prevents duplicate testing of the predicate. Capabilities that have already been acquired and that are currently in scope are not re-evaluated. Requiring a capability The with-capability function enables smart contract users to attempt to acquire a specified capability that allows them to perform an operation within a limited scope. The require-capability function requires smart contract users to have already been granted the specified capability before they can execute an operation. The require-capability function doesn't evaluate the conditions to grant a capability. If the required capability wasn't acquired in the context of another function, the function calling the require-capability function fails. For example, you can require the ALLOWENTRY capability to have been acquired and currently in scope before executing the add-entry function like this: Code example (pact): (defun entry (user-id) (with-capability (ALLOWENTRY user-id) (add-entry user-id) (update-entry-status user-id) ) (record-audit \"ENTRY\" user-id) ) (defun add-entry (user-id) (require-capability (ALLOWENTRY user-id)); ; require a previously acquired capability. . . ) By requiring a capability, you can define private or restricted functions than cannot be called directly. In this example, the add-entry function can only be called by code inside the module that grants the ALLOWENTRY capability and can only be called for this user-id in particular, restricting the function to that user. However, it's important to note that the require-capability function doesn't scope to a body of code. The position at which you insert it affects the semantics of the function call and the operations that happen first, before the capability requirement is applied. If you insert the require-capability call at an inappropriate position, you might see unexpected behavior or error messages. In general, you should insert the require-capability call at the beginning of a function call. Composing capabilities A defcap declaration can also include other capabilities, for modular factoring of guard code or to compose an outer capability from smaller, inner capabilities. For example, the following ALLOWENTRY capability declaration includes an inner capability—the DBLOG capability—that's defined its own separate defcap declaration: Code example (pact): (defcap ALLOWENTRY (user-id: string) \"Govern entry operation. \" (with-read users-table user-id { \"guard\": = guard, \"active\": = active } (enforce-guard guard) (enforce active \"Only active users allowed entry\") (compose-capability DBLOG); ; allow db logging while ALLOWENTRY is in scope ) ) (defcap DBLOG () true) Composed capabilities must be defined using defcap declarations in the same module as the parent capability and are only in scope when their parent capability is granted. In many cases, you can use the compose-capability function to improve code logic with clear separation of concerns. The following example illustrates separating the transfer, debit, and credit functions—and corresponding capabilities—so that debit is always called with a corresponding credit operation with the TRANSFER capability being a \"no-guard\" capability that simply encloses the debit and credit calls: Code example (pact): (defcap TRANSFER: bool (from: string to: string amount: decimal) (compose-capability (DEBIT from)) (compose-capability (CREDIT to))) (defcap DEBIT (from: string) (enforce-guard (at 'guard (read table from)))) (defcap CREDIT (to: string) (check-account-exists to)) (defun transfer (from: string to: string amount: decimal) (with-capability (TRANSFER from to amount) (debit from amount) (credit to amount))) (defun debit (user amount) (require-capability (DEBIT user)) (update accoun. . . [code continues] In this example: - The TRANSFER capability protects the debit and credit calls from being used independently. - The DEBIT capability governs the ability to debit, enforcing the guard. - The CREDIT simply creates a restricted capability for the credit function. Calling basic capabilities To give you better insight into how to call capabilities, it's important to consider the concept of scope in Pact modules. Potentially, there are several layers of scope that can you might need to navigate, including: - Top-level scope - Module scope - Outer capability scope for composing capabilities - Inner capability scope for composed capabilities - Signature-based scope You've seen an example of outer and inner capability scope in Composing capabilities. However, it's equally important to know the difference between top-level scope and module scope for capabilities. Top-level scope In Pact, the functions and expressions that you execute outside of a module declaration are often referred to as top-level expressions. Functions and expressions that are defined within a module declaration are within the scope of that module. For example, top-level expressions can include direct calls to built-in functions like the following: Code example (pact): (+ 1 2) (map (- 1) [10 20 30]) In addition, there are several top-level expressions that set context for a module that must be defined outside of the module declaration. For example, you use top-level expressions to define and enter a namespace, define keysets, create tables, and read messages from transaction data. Code example (pact): ; ; Before module declaration (define-namespace dev-namespace (read-keyset \"user-account\" ) (read-keyset \"dev-ks-account\" )) (define-keyset \"dev-namespace. dev-ks-account\" (read-keyset \"dev-ks-account\" )); ; Module declaration (. . . ); ; After module declaration (if (read-msg 'upgrade) [\"upgrade\"] [ (create-table order-table) ] ) Module scope The functions and expressions that are defined in a module declaration are included in the scope of that module. For example, if you define the awards function in the league module declaration, the function is within the scope of the league module. Code example (pact): (module league GOVERNANCE (defcap GOVERNANCE () true) (defun awards (tier: integer) (+ tier 2) ) ) Acquire a capability inside of a module In most cases, capabilities are defined within the scope of a module and you can acquire the access token from within the body of any function defined in the module if you meet the conditions specified in the body of the defcap declaration. Code example (pact): (module league GOVERNANCE (defcap GOVERNANCE () (enforce-keyset leagueadmin)) (defcap LEAGUEOPS (); ; one or more conditions that must pass ) (defun awards (tier: integer) (with-capability (LEAGUEOPS) (+ tier 2)); operation succeeds if the conditions for LEAGUEOPS are met ) ) For example, you can acquire the league. LEAGUEOPS capability by using the with-capability call in any function declaration or defpact step in the league module where the LEAGUEOPS capability is declared. Code example (pact): (module league GOVERNANCE (defcap GOVERNANCE () (enforce-keyset leagueadmin)) (defcap LEAGUEOPS (); ; one or more conditions that must pass ) (defun awards (tier: integer) (with-capability (LEAGUEOPS) (+ tier 2)); operation succeeds if the conditions for LEAGUEOPS are met ) (defpact transfer-portal () (step (with-capability (LEAGUEOPS). . . )); operation succeeds if the conditions for LEAGUEOPS are met (step. . . ) ) ) These examples demonstrate the most common way you acquire the privileges associated with a capability is by calling the with-capability built-in function within a defun or defpact declaration inside of a module declaration. If the conditions specified in the body of the capability declaration are met, permissions are granted and the operation proceeds. The conditions you specify in the body of the capability declaration can vary, but typically enforce some type of guard or key signature. You should also note that you can't acquire a capability inside of a capability declaration. For example, if you try to acquire a capability in the body of a capability declaration, you'll see an error similar to the following: Code example (pact): \"Loading league. pact. . . \" league. pact: 13: 7: with-capability form not allowed within defcap 13 | ((with-capability (LEAGUEOPS) ( tier 2))) | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Acquire a capability outside of a module You can acquire a capability in the top-level—that is, outside of the scope of a module—or within the scope of another module if, and only if, you have the administrative privileges to control the module and satisfy the conditions to acquire the capability. The following example illustrates a module declaration for the west-conf module that defines a GOVERNANCE capability and an UMPIRE capability with conditions set to true to always succeed: Code example (pact): (module west-conf GOVERNANCE (defcap GOVERNANCE () true) (defcap UMPIRE () true). . . ) If you deploy this module or load it into the Pact REPL, the GOVERNANCE capability grants you the administrative privileges for the transactions immediately following the deployment of the module. For example, after you load the west-conf module in the Pact REPL, you can acquire the UMPIRE capability to perform an operation: Code example (pact): (with-capability (west-conf. UMPIRE) ( 3 8)) 24 Because deploying a module grants you administrative privileges for the module, you can perform other privileged operations—like upgrading modules and creating tables—in the same deployment transaction. In this example, there are no conditions that must be met to acquire the UMPIRE capability. If there were conditions to enforce in the body of the defcap declaration for the UMPIRE capability, those conditions would need to be satisfied to perform the requested operation. The previous example demonstrates the principle of using module administrator privileges to bring a capability into scope. However, this example doesn't represent a typical use-case. In most cases, you want to carefully control and restrict access to capabilities to prevent unintended privilege elevation. If access to the module administrator privileges is managed in any way—for example, owned by a specific keyset or guard or if a module is not upgradable—you must be able to acquire the module administrator rights to bring a capability into scope. To acquire module administrator rights for testing purposes in the Pact REPL, you can use the env-module-admin and acquire-module-admin built-in functions. The following example demonstrates using the acquire-module-admin function to access module administrator rights for module-test to upgrade a module: Code example (pact): pact> (module west-conf GOVERNANCE (defcap GOVERNANCE () (enforce false \"non-upgradable\"))) Loaded module west-conf, hash v4XXlmt7RI-HVZvPb69lQhFbh8k-luKCtWtm4OVJVU8 pact> (begin-tx \"Begin a new transaction after deployment\") \"Begin Tx 0 Begin a new transaction after deployment\" pact> (use west-conf) Loaded imports from west-conf pact> (with-capability (GOVERNANCE) ( 3 8)) (interactive): 1: 51: non-upgradable 1 | (with-capability (GOVERNANCE) ( 3 8)) |. . . [code continues] To limit module administrator privileges for a capability to a specific transaction block, you can use the env-module-admin built-in function. Code example (pact): pact> (begin-tx \"Get module admin privileges for a transaction\") \"Begin Tx 1 Get module admin privileges for a transaction\" pact> (use west-conf) Loaded imports from west-conf pact> (with-capability (GOVERNANCE) ( 6 9)) (interactive): 1: 51: non-upgradable 1 | (with-capability (GOVERNANCE) ( 6 9)) | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pact> (env-module-admin west-conf) \"Acquired module admin for: west-conf\" pact> (with-capability (GOVERNANCE) (. . . [code continues] Managed capabilities Most capabilities control permissions to access protected operations. However, Pact also supports managed capabilities. Managed capabilities provide an additional layer of security that requires all parties involved in a transaction to specify the actions they are authorizing with their signature or a guard. By requiring a signature or guard to authorize an action, managed capabilities enable smart contract users to safely interact with otherwise untrusted code. As a smart contract author, you specify that a capability is a managed capability by adding the @managed metadata tag in the defcap declaration body. You can define managed capabilities to manage resources in two different ways: - To update a specific resource dynamically through a management function. - To automatically update a resource once without using a management function. Managed capabilities that use a management function can be called multiple times. Managed capabilities that don't specify a management function can only be called once. Using management functions One of the most common use cases for managed capabilities with management functions is for transfer operations. The following example illustrates this use case with the TRANSFER managed capability and the TRANSFERmgr management function: Code example (pact): (defcap TRANSFER: bool (sender: string receiver: string amount: decimal) @managed amount TRANSFER-mgr (enforce (! = sender receiver) \"same sender and receiver\") (enforce (> amount 0. 0) \"Positive amount\") (compose-capability (DEBIT sender)) (compose-capability (CREDIT receiver)) ) (defun TRANSFER-mgr: decimal (managed: decimal requested: decimal) (let ((newbal (- managed requested))); ; update managed quantity for next time (enforce (>= newbal 0. 0); ; check t. . . [code continues] In this example, the TRANSFER capability allows the sender to approve any number of transfer operations to the receiver up to the managed resource specified by the @managed keyword. In this case, the resource is the amount value and the TRANSFERmgr function checks and updates that resource value each time the TRANSFER capability is called for in the transfer function: Code example (pact): (defun transfer: string (sender: string receiver: string amount: decimal) (enforce (! = sender receiver) \"sender cannot be the receiver of a transfer\") (enforce (> amount 0. 0) \"transfer amount must be positive\") (with-capability (TRANSFER sender receiver amount) (debit sender amount) (with-read coin-table receiver { \"guard\": = g } (credit receiver g amount)) ) ) If transfer operations exceed the amount value, the TRANSFER capability can no longer be brought into scope. Smart contract users set the values for the transfer operation and TRANSFER capability and approve the operation by signing for the capability when they send the transaction to the blockchain. Typically, you allow smart contract users to set the transfer values and approve the operation through the frontend of a smart wallet or a similar application. For example, as a smart contract author, you enable smart contract users to construct and submit transactions that set the sender, receiver, and amount parameters and sign for the TRANSFER capability when they call the transfer operation. In the Pact REPL, you can emulate setting the keys in the environment data and signing the capability. For example: Code example (pact): (env-data {\"alice\": [\"alice\"], \"bob\": [\"bob\"]}) (env-sigs [{\"key\": \"alice\", \"caps\": [(pistolas-coin. TRANSFER \"alice\" \"bob\" 50. 0)]}]) (pistolas-coin. transfer \"alice\" \"bob\" 40. 0) You should note that managed capabilities always require smart contract users to explicitly approve the operation to be performed. If a transaction includes a managed capability, all capabilities involved in the transaction require a signature. Unrestricted keys aren't allowed if a transaction includes a managed capability. In most cases, managed resources represent decimal or integer values, but you can use managed capabilities and management functions to manage any type of resource. For example, you could specify a list or an object as the resource you want to manage, then write a management function that removes names from the list or updates object properties based on some condition. However, the @managed keyword only allows you to specify a single resource to be managed—that is, updated—by the management function. Single-use managed capabilities Managed capabilities that specify a management function update the managed resource dynamically each time the requested capability is acquired. If a managed capability doesn't specify a management function, the requested capability can only be called once in a transaction. Further attempts will fail after the initial grant goes out of scope. In the following example, the VOTE capability is automatically managed to ensure that a validated member can only vote once: Code example (pact): (defcap VOTE (member: string) @managed (validate-member member)) Scoped signatures and verifiers In Pact transaction messages, transaction signers can scope their signature to one or more specific capabilities. By scoping signatures to specific capabilities, smart contract users can restrict guard operations based on that signature. These explicitly-authorized actions are separate from the Pact code that's executed in the transaction. Regardless of the code that runs during the transaction, scoped capabilities ensure that only authorized actions can be performed on the user's behalf. Unlike managed capabilities that require a signature or a guard and a managed resource, most capabilities allow users to sign transactions using an unrestricted signing key. Scoped capabilities provide a transparent way for transaction signers to safely call untrusted code. For example, the sender of a transaction can explicitly sign for the GAS capability to authorize gas payments in the coin contract. By scoping the signature to this capability, the account signature can't be used to access any other code that might be called by the transaction. If a user authorizes a specific capability, the capability is attached to the signature list for the transaction. For example, the following transaction excerpt attaches two capabilities—coin. TRANSFER and coin. GAS—to the public key \"fe4b6da332193cce4d3bd1ebdc716a0e4c3954f265c5fddd6574518827f608b7\" signature: Code example (json): { \"signers\": [ { \"pubKey\": \"fe4b6da332193cce4d3bd1ebdc716a0e4c3954f265c5fddd6574518827f608b7\", \"clist\": [ { \"name\": \"coin. TRANSFER\", \"args\": [\"k: fe4b6da3. . . 27f608b7\" \"k: 4fe7981d. . . 0bc284d0\\\", 2]}, { \"name\": \"coin. GAS\", \"args\": []} ] } ] } The following example illustrates an accounts module with a PAY capability that isn't managed: Code example (pact): (begin-tx) (module accounts GOVERNANCE (defcap GOVERNANCE () (enforce false \"NON-UPGRADABLE\") ) (defschema account balance: decimal account-guard: guard ) (deftable accounts-table: {account}) (defcap PAY (sender: string receiver: string amount: decimal) (enforce-guard (at 'account-guard (read accounts-table sender)))) (defun pay (sender: string receiver: string amount: decimal) (with-capability (PAY sender receiver amount) (transfer sender receiver amount))). . . [code continues] In the Pact REPL, you can attach the signature for the alice key to the accounts. PAY capability by using the env-sigs built-in function as follows: Code example (pact): (env-sigs [{\"key\": \"alice\", \"caps\": [(accounts. PAY \"alice\" \"bob\" 10. 0)]}]) (accounts. pay \"alice\" \"bob\" 10. 0); ; works as the cap matches the signature caps If you modify the scoped capability to use a different receiver or amount, the transaction returns a keyset failure. Code example (pact): (env-sigs [{\"key\": \"alice\", \"caps\": [(accounts. PAY \"alice\" \"carol\" 10. 0)]}]) (accounts. pay \"alice\" \"bob\" 10. 0) For example: Code example (pact): cope-pay. repl: 14: 4: Keyset failure (keys-all): [alice. . . ] 14 | (enforce-guard (at 'account-guard (read accounts-table sender)))) | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ at(accounts. PAY. {z5Kc3VKBgIr085VLRK2n1rMdlmIxi-NN-P7lYfA6xqg} \"alice\" \"bob\" 10. 0): scope-pay. repl: 16: 4-17: 40 at(accounts. pay. {z5Kc3VKBgIr085VLRK2n1rMdlmIxi-NN-P7lYfA6xqg} \"alice\" \"bob\" 10. 0): scope-pay. repl: 40: 0-40: 33 Scoped capabilities can also be installed by verifier plug-ins. Capabilities that are installed by verifier plug-ins are also scoped to the specific capabilities that they install. Verifier plugins are external to Pact. However, they are similar to signature capabilities in that they enable you to specify some type of trusted entity—for example, a signature or a generated proof—that grants the capabilities to perform some type of protected operation. A signature capability can use the (enforce-guard g) function to check that the keyset guard g includes the signer's key. A capability granted by a verifier plug-in can use the (enforce-verifier 'name) function to check that \"name\" is the name of the verifier plug-in. Events In Pact, events are emitted as part of transaction execution and are included in the transaction results. With events, you can monitor transaction results to determine if a specific operation occurred and prove the outcome using a simple payment verification proof. Events are treated as capabilities because they share the following characteristics: - Events, like capabilities, allow arbitrary data to be published under a topic or a name. With capabilities, the capability name is the topic, and the arguments are the data. - Granting permission to acquire a managed capability is, in itself, an event recorded for transaction. Events complete the managed capability lifecycle, where you might install or approve a capability of some quantity on the way in, but not necessarily see what quantity was used. With events, the output of the acquired capability is present in the transaction results. - Capabilities are protected such that they can only be acquired in module code, which is appropriate for events as well. You can emit events for any basic capability by including the @event metadata tag in the defcap declaration. For example: Code example (pact): (defcap BURN: decimal (qty: decimal) @event. . . ) If you include the @event metadata tag in the defcap declaration, the event is emitted any time that capability is successfully acquired. Basic capabilities that aren't managed can emit events any number of times. Managed capabilities emit events automatically without specifying the @event metadata tag. The event for a managed capability is emitted once when the capability is first installed or acquired. Events from managed capabilities include the parameters specified when the capability was installed or acquired. You can use the env-events built-in function to test for emitted events in. repl scripts.",
    "source": "smart-contracts/capabilities.md",
    "title": "Capabilities"
  },
  {
    "content": "Kadena blockchain nodes store information in two different data stores, with a key-value store that keeps track of information about nodes, chains, and blocks and a SQL-based database that stores information about Pact smart contracts and transactions. Kadena blockchain nodes store information in two different data stores. On each Chainweb node, there's a RocksDB key-value store that keeps track of information about the peer network, chains, and blocks. Each node also hosts a set of SQLite database files that store information about Pact smart contracts and transaction results with one file for each chain in the network. The following diagram presents a simplified view of this separation of concerns. ! Data store overview As a smart contract developer, you're primarily interested in writing to and reading from the Pact state, but it's helpful to know how data is organized and optimized for different execution modes and to perform different tasks. The RocksDb database—sometimes referred to as the chain database—is optimized for efficient network communication and resiliency. Pact database operations are optimized for transaction performance. Working with Pact tables Tables are a core component of Pact smart contracts because they enable you to store, manipulate, and read data using familiar patterns. Interacting with Pact databases is much like interacting with any other type of database, but with constraints that reflect the unique requirements of blockchain execution. For example, working with Pact databases is similar to working with other SQL-based databases, with similar database operations. There are built-in functions to insert, read, and update values stored in tables. Function type | Description: ------------ |: ---------- Insert | Insert new rows into a table. Read | Read values from a table. Update | Update values for a column that contains data in a table. Write | Write values for a column in a table, regardless of whether the column contains data or not. Delete | Not available in Pact. If you've worked with other databases or programming languages, you should be familiar with similar functions that enable you to create, read, update, and delete (CRUD) information. However, in Pact, you use the insert function in place of the create functionality to add rows to a table and there isn't a function to delete rows from a table. Although Pact doesn't provide a delete function, you can use an active column in tables to mark table rows as active or inactive. For more information about using an active column to indicate active and inactive rows, see Identifying active and inactive rows. Data access model Most smart contracts use one or more tables to store all of the information required for the application or service that the smart contract provides. You access the information stored in Pact tables by using the table's key-row structure. This access model is similar to using a primary key to access table data in other relational databases. With the Pact key-row model, you access a row of column values by using a single key. As a result of this access model, Pact doesn't support joining tables in a way that an online analytical processing database would support if populated from data exported from the Pact database. However, Pact can record transactions using relational techniques. For example, if you have a Customer table with keys used in a Sales table, a Pact smart contract could include code to look up the Customer record before writing to the Sales table. Null values aren't allowed The Pact database model doesn't support NULL values as a safety feature to ensure totality for transactions and to avoid unsafe control-flow for handling null values. The main function for working with database results is the with-read function. This function will return an error if any column value it attempts to read isn't found. To prevent transactions from failing with these errors, you should ensure that there are values in the columns you attempt to read in a transaction. Versioned history The key-row model is augmented by every change to column values being versioned by a transaction identifier. For example, if you have a table with columns for name, age, and role, you might update the name column in a transaction with the identifier 100, and later update the age and role columns in a transaction identified as 102. If you retrieve historical data for the table, only the change to the name column is returned for transaction identifier 100 and only the change to age and role columns are returned for transaction 102. Table creation Tables are defined by schemas in module declarations. The schema defines the table columns, field values, and field types. The module declaration also specifies the table name to associate with each schema you define. There's no restriction on the number of tables you can create. The tables specified in the module declaration are created after the module declaration, and the table name is prepended with the module name, so that the module becomes the table owner. It’s important to note this distinction between when tables are defined and when tables are created. You define table schemas, the table associated with each schema, and the functions that insert, read, and modify database records inside of module code. You create the tables outside of module code. The module acts as a guard to protect access to database functions and database records. This separation also allows module code to be updated without necessarily recreating the table in Pact state. Table schemas Before you create a table in Pact, you must define its schema. The schema describes the structure of the table by specifying the columns and data types for the values to be stored in the table. Schemas are defined within the Pact module declarations by using the defschema keyword and consist of a series of field names and field types. Each field name specifies a column in the table, and each field type specifies the type of data held in that field. In the following example, the accounts table has three columns with the field names balance, amount, and currency: Field name | Field type: --------- |: ---------- balance | decimal amount | decimal currency | string In this example, the balance and amount columns require decimal as the data type and the currency column requires data to be a string value. You can create the schema for this table in Pact like this: Code example (pact): (defschema accounts \"Schema for accounts table. \" balance: decimal amount: decimal currency: string ) All table schemas you create look similar to this example, but with different field names and data types. Field names must start with a valid alphabetic character, but can contain alphabetic, numeric, and special characters. In general, you should use field names that are short but recognizable. For each field, the field type must be one the data types that Pact supports. Types that are declared in code are enforced at runtime when expressions are evaluated. For tables, any write to a table is type-checked against the table schema to ensure the data matches the expected type. Execution fails if type checking fails. For information about the data types that Pact supports, see Data types. Table definition In Pact, tables are defined inside of the module declaration by using the deftable keyword. The table definition accomplishes two goals: - It associates a table name with a specific table schema of columns and data types. - It defines the table inside of the module namespace. There's no limit to the number of tables you can define in a module. Because the table is defined inside of a module, direct access to the table using database functions is only authorized for the module owner, that is, its administrative keyset or governance capability. However, module functions have unrestricted access to the table by default. With this default behavior, the module acts as the main entry point for all user interaction. You can restrict access to tables inside of the module by using row-level keysets and enforcing the keyset guard for specific functions. The following example illustrates using the deftable keyword to define an accounts-table table that uses the accounts schema: Code example (pact): (deftable accounts-table: {accounts}) Notice that the table and schema are represented as a pair, separated by a colon (: ). The curly braces ({ }) around the schema name are there because the schema is an object. The schema name and table name must be different from one another. In general, you should use table and schema names that are similar to each other or follow a consistent convention to avoid confusion: For example: Code example (pact): (deftable cat-table: {cats}) (deftable asset-tracker: {assets}) Create module tables After you have defined all of the tables for your module inside of the module declaration, you can create those tables outside of the module. Creating the table outside of the module ensures that other parts of the module logic can be redefined or updated without recreating the table. You can created tables after the module declaration by using the create-table function followed by the table name as it's defined in the module declaration. For example: Code example (pact): (create-table accounts-table) (create-table cat-table) (create-table asset-tracker) Insert You can use the insert function to add new data to a table. You can use insert function to add any type of new artifact with a key value. For example, you can use a key value to add a row of data about accounts, customers, loans, or assets. The following example illustrates adding a row to the accounts-table using the insert function with the key value \"account-1\". Code example (pact): (insert accounts-table “account-1” { \"balance\": 12. 3, \"amount\": 0. 0, \"currency\": \"USD\"}) Note that the key must be a string value. This example adds the following row to the accounts-table: | key | balance | amount | currency |: --- |: ------ |: ----- |: ------- | account-1 | 12. 3 | 0. 0 | USD You can also use the insert function inside of another function to add new data to rows in a table from the input values for the function. For example: Code example (pact): (defun create-account (id balance amount currency) (insert accounts-table id { \"balance\": balance, \"amount\": amount, \"currency\": currency }) ) In this example, the row inserted into the accounts-table takes the values entered for the create-account function. Read You can use the read function to read a row of data from a specified table for a specified key value. In the following example, the accounts-table has two rows of data storing the account balance and currency for account-1 and account-2: key | balance | currency account-1 | 4. 00 | USD account-2 | 3. 00 | USD You can use the read function to retrieve the information for the key value. For example, you can get the balance and currency information for account-1 like this: Code example (pact): (read accounts-table account-1 ['balance 'ccy]) You can also use the read function inside of another function like this. Code example (pact): (defun read-accounts (1) (read accounts id [‘balance ‘ccy]) ) In each example, the read functions returns the following values: balance | currency: ------ |: ------- 4. 00 | USD Update You can use the update function to update one or more values in an existing row of a table. Updates enable you to change the status of a column or amend the initial dataset to record a new value. With the update function, you specify the key for the row you want to update, the field you want to update, and the new value for the field in that that row. In most cases, you use update functions in other functions to allow users to input new values. Code example (pact): (update table-name id {\"field\": new-value}) The following example illustrates updating the status field for an asset in the assets-table. Before updating the assetPrice, the assets-table has the following fields and values. assetID | assetName | assetPrice | status: ------- |: --------- |: ---------- |: ------ asset-1 | My Asset | 5. 0 | todo For this example, the asset-update function updates the status column, then reads the value of the updated column. Code example (pact): (defun asset-update (assetId: string new-status: string) (update assets-table assetId { \"status\": new-status }) (read asset-table assetId) ) Select You can use the select function to select values from one or more rows in a table. The select function is similar to the read function except that the read function retrieves information for a single key-row value. The select function enables you to retrieve multiple rows from a table based on the criteria you provide. Because you can specify other criteria and not just a single key-row value, the select function provides you with more flexibility in what information you choose to return. The syntax for the Pact select function is similar to the syntax for standard SQL SELECT statements. In its simplest form, the select statement retrieves all values from a specified table. In the following example, the select statement is used in a select-assets function to return all values from the assets-table: Code example (pact): (defun select-assets () (select assets-table (constantly true)) ) This query returns all of the values currently stored in the assets-table fields. For example: assetId | assetName | assetPrice | status: -------- |: --------- |: ---------- |: ------ asset-1 | My Asset | 5. 0 | todo asset-2 | Asset 2 | 6. 0 | in progress asset-3 | Asset 3 | 7. 0 | done Like standard SQL SELECT statements, you can use a where clause to refine your results. For example, you can return only the assetName and assetPrice for a specific asset name like this: Code example (pact): (select assets-table ['assetName, 'assetPrice] (where 'assetName (= \"Asset 2\"))) This query returns the following values from the sample assets-table: assetName | assetPrice Asset 2 | 6. 0 You can also specify operators—such as greater than (>) or less than (<)—from within the where clause. For example: Code example (pact): (select assets-table (where 'assetPrice (> 6. 0))) This query returns the following values from the sample assets-table: key | assetName | assetPrice | status asset-3 | Asset 3 | 7. 0 | done Select queries and performance You should note that when you write queries using the Pact select function, the select and where operations provide a streaming interface that applies filters to the specified table, then operates on the row set as a list data structure using sort and other functions. Because of the computational overhead, you should avoid using select statements to work with on-chain data. Although it can be convenient to use select statements to retrieve data, you can often return the same results more efficiently using other functions. For example, the following query selects Programmers with salaries >= 90000 and sorts by age in descending order: Code example (pact): (reverse (sort ['age] (select 'employees ['first-name, 'last-name, 'age] (and? (where 'title (= \"Programmer\")) (where 'salary (<= 90000)))))) You can write the same query using the filter function and sorting the resulting list like this: Code example (pact): (reverse (sort ['age] (filter (and? (where 'title (= \"Programmer\")) (where 'salary (< 90000))) employees)) ) For performance reasons, Pact database interactions are optimized for single-row reads and writes. Queries that use the select statement to scan multiple rows in a table can be slow and prohibitively expensive computationally. Therefore, the best practice is to use select statements in local, non-transactional operations and to avoid using select on large tables in functions that perform transactional operations. Transactional and local execution Pact doesn't distinguish between transactional and local execution. However, transactions typically involve business events that must be executed and recorded in a timely fashion. Queries rarely represent a business event, and can often involve data payloads that could impact performance. The best practice is to query data locally on a node by using the /local endpoint. You can also query historical data using the /local endpoint and a transaction identifier as a point of reference. For transactions, you should use the /send endpoint. For more information about transaction execution, see Transaction lifecycle. For more information about Pact endpoints, see Pact API. Keys You can use the keys function from within a module to return all of the key values in a table. For example, you can return the key values for the sample assets-table with the following code: Code example (pact): (module asset-manager ADMIN (defcap ADMIN () true) (defschema assets assetId: string assetName: string assetPrice: decimal status: string ) (deftable assets-table: {assets}). . . (keys assets-table) ) You can also use the keys function within another function. For example: Code example (pact): (defun get-keys (table-name) (keys table-name) ) Row-level keysets Keysets can be stored as a column value in a row, allowing for row-level authorization. The following code indicates how this might be achieved: Code example (pact): (defun create-account (id) (insert accounts-table id { \"balance\": 0. 0, \"keyset\": (read-keyset \"owner-keyset\") })) (defun read-balance (id) (with-read accounts-table id { \"balance\": = bal, \"keyset\": = ks } (enforce-keyset ks) (format \"Your balance is {}\" [bal]))) In this example, the create-account function reads the owner-keyset definition from the message payload using read-keyset, then stores it in the keyset column in the accounts-table table. The read-balance function only allows the owner-keyset to read the balance by first enforcing the keyset using enforce-keyset function. Changing a table schema As noted in Create module tables, you can update contract functions without updating or recreating database tables. However, you can't modify the table schema when you update a contract. In general, Pact doesn't support database migration or schema and table upgrades. To update a database, you must declare new tables and define any data migration functions as part of a module load step for the new module that contains the modified table schema. To update a table schema: 1. Create a new module and declare the new table schema. 2. Add functions to read rows from the old table and write them to the new table. 3. Deploy the updated module with the new table schema on the network. The original table and database state remain unchanged on the blockchain, but won't receive any new information after you deploy the new module. Identifying active and inactive rows Pact doesn't provide a delete function because of the potential issues with performance, data integrity, and data migration that row-level delete operations can introduce. In addition, being able to delete rows or tables violates one of the most important properties of a blockchain environment: that it provides an immutable record of state. Because deleting information from tables could also cause problems for replaying transactions or synchronizing nodes and leave the chain in an unhealthy state, Pact doesn't support deleting rows or tables. However, you can use an active column in tables to identify active table rows on insert, then later flag rows with obsolete information as inactive. Inactive rows remain in the database, but you can write logic to prevent them from being updated or retrieved. For example, you might define the user schema and users-table like this: Code example (pact): (defschema user nickname: string keyset: guard active: bool ) (deftable users-table: {user}) To add new users to the table, you might define a create-user function similar to the following: Code example (pact): (defun create-user (id: string nickname: string keyset: guard active: bool) (enforce-keyset \"free. operate-admin\") (insert users-table id { \"keyset\": keyset, \"nickname\": nickname, \"active\": true } ) ) You can then define a separate function to identify rows—using the id key-row—that are no longer active similar to the following: Code example (pact): (defun tombstone: string (id: string) \"Mark the specified row as inactive\" (update users-table id { \"active\": false }) ) You can then check whether the active column is true or false for a specific row before allowing the row to be updated with code similar to the following: Code example (pact): (defun change-nickname (id: string new-name: string) (with-read users-table id {\"active\": = active} (if (= active true) (update users-table id { \"nickname\": new-name }) (format \"Update NOT ALLOWED for user {}\" [id]))) ) For example, you can set the active column to false for the row identified by tai with a call similar to this: Code example (pact): (tombstone \"tai\") \"Write succeeded\" If you then attempt to update the nickname column for the tai row, you'll see the message that the change isn't allowed: Code example (pact): (change-nickname \"tai\" \"INACTIVE USER Tai's Nickname\") \"Update NOT ALLOWED for user tai\"",
    "source": "smart-contracts/databases.md",
    "title": "Database model"
  },
  {
    "content": "Work with common built-in functions and start write your own function declarations that include variables and types. In Language features and conventions, you were introduced to Pact built-in functions and function categories. In this part of the documentation, you'll begin working with common built-in functions and writing your own function declarations that include variables and types. View built-in functions To view information about Pact built-in functions: 1. Open a terminal shell on your local computer. 2. Display the list of built-in functions by running the following command: Code example (bash): pact --builtins `` You might want to save the output from this command to a file for quick reference. For example: `pact pact --builtins > builtin-functions. txt ` 3. Start the Pact REPL interpreter by running the following command: `bash pact ` 4. View usage information for a specific built-in function by typing the function name in the interpreter. For example, to see information about the format function, type format at the pact> prompt: `. . . [code continues]pact (defun returnPhrase (a b); ; Start of function declaration; ; COMMANDS GO HERE ); ; End of function declaration Code example (): The defun function is a reserved keyword that signals the start of a function declaration. In this example, the function is named returnPhrase and the function accepts inputs with the variable identifiers a and b. The function includes comments by using two semi-colons (; ; ) to start each comment. Let's add this function to your module. To define your first function: 1. Open the code editor—such as Visual Studio Code—on your computer. 2. Open the myModule. pact file you created for y. . . [code continues]pact (defconst variablename variablevalue [optionaltext]) `Code example (): For example, the following statement illustrates defining the constant PI with eight decimal places followed by an optional comment: pact (defconst PI 3. 14159265 \"Pi to 8 decimals\") Code example (): The following example illustrates defining the constant PENNY with an explicit type of decimal: pact (defconst PENNY: decimal 0. 1) Code example (): By convention, constant variables use all uppercase letters. However, this convention isn't required. To use a constant in your module: 1. Open the code editor—such as Visual Studio Code—on your computer. 2. Open the myModule. pact file. 1. Add the constant variable for PI to your module and save your changes. 2. Load the myModule. pact file. 1. Call the addNumbers function with the PI constant. `pact (addNumbers 1. 0 PI) 4. 14159265 ` You can experiment with usi. . . [code continues]pact (let ((x 10)) (+ x 5) ) Code example (): This expression returns the result of adding 5 to x with the value 15. You can also use the let keyword to reference previously-declared variables in the same let declaration. The following example illustrates referencing a previously-declared variable in the same let declaration: pact (let ((x 2) (y (* x 10))) (+ x y)) 22 Code example (): ## Typing in variable declarations Most of the examples you've seen so far haven't explicitly specified the data type being used. However, in practice, you should explicitly identify the data type for each variable you define in a program. By identifying the data type—for example, integer, decimal, boolean, or string—you can ensure that variables can be set and manipulated correctly and without introducing unexpected behavior by mismatching types. For example, to specify that the variable x. . . [code continues]pact (let ((x: integer 10))x) Code example (): You can specify a variable is a decimal value like this: pact (let ((x: decimal 10. 0))x) Code example (): You can specify a variable is a string value like this: pact (let ((state: string \"CA\"))state) \"CA\" Code example (): ## More built-in functions You've already seen how to use several common built-in Pact functions. However, there are many more built-in functions that you'll use frequently in Pact smart contracts, including the following general functions: - namespace - hash - if - enforce Entering a namespace In the Kadena ecosystem, a namespace is conceptually similar to a domain name except that the name is a static prefix that establishes a private boundary for the contracts, keys, and o. . . [code continues]pact ns-my-local-dev. my-calculator. add Code example (): To define and enter a namespace: 1. Open a terminal shell on your local computer. 2. Start the Pact command-line interpreter to open the Pact terminal. 1. Add a user-keyset guard and an admin-keyset guard to your working environment by entering the following lines: `pact (env-data { 'user-keyset: { 'keys: [ 'user-public-key ], 'pred: 'keys-all }, 'admin-keyset: { 'keys: [ 'admin-public-key ], 'pred: 'keys-all } } ) `. . . [code continues]pact pact> (hash \"hello\") \"Mk3PAn3UowqTLEQfNlol6GsXPe-kuOWJSCU0cbgbcs8\" Code example (): Because \"hello\" is a string value, the hash function computes the BLAKE2b 256-bit hash of the string \"hello\" and returns the hash value. If you change the string to “hello1”, the hash function returns different value. For example: pact (hash \"hello1\") \"zbEgnuUZLD7FFPPH9VD91-Ah9KzCeCLqBVL2hGAg8d4\" Code example (): You can also use the hash function to compute the hash for lists, objects, and other data types. For example: pact (hash [1 2 3]) \"qPorDZllGgkv-ZaODZMQE0tUgv2ghZ4G86OTDmKANXg\" Code example (): The following example computes the hash for the JSON representation of an object and returns the hash value: pact (hash { 'foo: 1 }) \"h9BZgylRfM4HxcBXr15IcSXXXSz74ZC2IAViGle_z4\" Code example (): The hash enables you to reference and manipulate the specific data in complex ways. Defining conditions with if statements Because Pact doesn't support recursion or unbounded looping, the if function is particularly useful for testing conditions. The basic format for testing conditions with if statements looks like this: pact (if condition then else) Code example (): If the specified condition is true, evaluate the then expression. If the specified condition is false, evaluate the else expression. The following example demonstrates the use of if to test a condition—whether (2 + 2 =4)—in the Pact REPL: pact pact>(if (= (+ 2 2) 4) \"Sanity prevails\" \"Chaos reigns\") \"Sanity prevails\" Code example (): In this example, the condition (= (+ 2 2) 4) evaluates to true, so the expression \"Sanity prevails\" is returned. pact pact>(if (= (+ 2 2) 5) \"Sanity prevails\" \"Chaos reigns\") \"Chaos reigns\" Code example (): In this example, the condition (= (+ 2 2) 5) evaluates to false, so the expression \"Chaos reigns\" is returned. Enforcing conditions Pact provides several enforce functions that enable you to evaluate conditions and allow or block further operations based on the result. One critical function in Pact is enforce. If you hit an enforce block and invalidate it, it will stop you from executing any further. With the enforce function, you can test whether a specified expression evalua. . . [code continues]pact pact> (enforce (! = (+ 1 3) 5) \"whoops\") true Code example (): Because the specified expression (4! = 5) is true, the function returns true and the operation continues. The following example demonstrates how to use the enforce function to evaluate the expression (2 + 2)! = 4: pact pact> (enforce (! = (+ 2 2) 4) \"The expression is false\") The expression is false at <interactive>: 0: 0: (enforce (native! = True if X does not equal Y. Type: x. . . \"The expression is false\") ` There are many situations where the enforcement functions are useful for testing specific behavior. For example, one of the most common enforcement functions is the enforce-guard function. This function ensures that the logic for a specified guard or keyset` is enforced before protected operations can be executed. You'll learn more about guards and enforcing guard logic in Guards.",
    "source": "smart-contracts/functions-variables-types.md",
    "title": "Functions, variables, and types"
  },
  {
    "content": "Pact is a human-readable smart contract programming language, designed to enable correct, transactional execution on a high-performance blockchain. Start your builder's journey on Kadena by learning about the Pact smart contract programming language. Get started: An Introduction to Pact This part of the Kadena developer documentation is focused on writing smart contracts and developing applications to run on a blockchain. To get started, it's important to know what smart contracts are and the kinds of challenges that you might face in writing them. Smart contracts A smart contract is a program that can automatically execute agreements—in the form of transactions—on the blockchain without any external oversight. The contract ensures that the specific conditions, defined in the code logic to describe the terms of the agreement, are met before executing the transaction programmatically. Smart contracts are deployed and executed on blockchain networks because the blockchain provides a decentralized, immutable, and publicly accessible record of all transactions. This transparency and traceability ensures that the programmatic execution of the contract can been considered trustworthy and verifiable. However, there are several unique challenges involved in writing smart contracts. For example, it's important to ensure that smart contracts can't be accessed by unauthorized parties, that transactions can't be intercepted or manipulated, and that code execution and data storage don't overload blockchain resources. Because a blockchain is a resource-constrained environment, it's particularly important for smart contracts to perform well even when network activity is at its peak. For example, if the code in a smart contract isn't efficient, it can be costly to execute the contract functions. Inefficient code can also delay transaction execution and block validation, affecting the throughput for the entire blockchain network. If a smart contract performs unbounded operations, excessive looping, or recursion, the contract might strain or overload the computational capacity that the blockchain has access to. In worst case scenarios, bugs in a smart contract can result in lost funds for participants or stall the progress of the blockchain. With these challenges and risks in mind, you can see why it's important to avoid common pitfalls and write smart contracts that execute transactions efficiently and securely. Pact smart contracts Pact is an open-source programming language designed specifically for writing smart contracts and developing applications to run on a blockchain. Pact was built to help developers create programs that overcome the challenges associated with writing smart contracts. Pact reflects many of the same approaches to writing smart contracts that are used in other programming languages—such as Solidity or Rust—but with a goal of making contracts less error-prone and less vulnerable to exploits and attacks. Pact is similar to many general purpose languages in its syntax, function declarations, module definitions, and imperative style. However, Pact has several features that make it a safe and performant language for blockchain applications, including the following: - Pact supports a straight-forward database model for storing and manipulating state using database schemas and tables. - Pact contracts can be written and deployed using composable modules, enabling you to iterate, update, and upgrade contract functionality when needed. - Pact limits computational overhead by preventing unbound looping and recursion at the language level. - Pact code is designed to provide transparency that can be inspected in plain text as part of the public record. - Pact transactions can be executed in a single step or as a sequence of steps guaranteed to be executed in a specific order. These features and constraints reduce the risks of writing faulty smart contract code, limit costly performance bottlenecks, and improve readability and reliability of programs running on the blockchain. You'll learn about these language features and more as you progress through the Smart contracts topics. Writing contracts in other languages It's possible to write contracts in other languages, as long as the transactions conform to the expected message format when submitted to a Chainweb node. For example, it's possible to write programs using JavaScript, TypeScript, or Python to emulate Pact smart contracts. However, Pact provides many built-in features and native functions that make smart contract development more efficient and produce more readable results without requiring external libraries to construct compatible commands. Navigating documentation and resources The Smart contracts documentation is for programmers and non-programmers interested in learning how to write programs using the Pact smart contract programming language. This part of the documentation is focused on language features and examples. How the documentation is organized In addition to the language-focused topics in Smart contracts, Kadena developer documentation includes the following top-level sections: - The How-to guides provide examples of the different ways you can perform common tasks. You can use these guides as a quick reference when working with accounts, transactions, or contracts to see instructions for tasks like creating an account, submitting a transaction, or calling a contract function. - Under API, you'll find reference information for the Pact, Peer-to-Peer, and Service REST API endpoints, including query parameters, request and response schemas, and call examples. - The Reference section provides reference information for the Pact programming language—including syntax, keywords, and built-in functions—and the command-line interfaces you can use to interact with Pact smart contracts and the Kadena blockchain in a development, test, or production environment. - In Coding projects, you'll find companion documentation for the sample projects located in the pact-coding-projects repository. - Under Resources, there are links to additional resources, such as the Kadena video library, contributor guidelines, and other tools and projects. Documentation conventions The following conventions are used in the Kadena documentation: - Fixed-width font is used for inline sample code, program names, program output, file names, and commands that you type at the command line. - Bold type is used to highlight menus, commands, buttons, or user interface elements, and to introduce new terms. - Italic type is used for titles, to emphasize specific words, or to indicate variables for which you should substitute an appropriate value. - Square brackets ([ ]) indicate optional arguments in command reference or list data types in the Pact language reference. - Curly braces ({ }) indicate objects with key-value pairs in the Pact language reference. - Vertical bars (|) separate alternative values from which you must make a selection. - An ellipsis (. . . ) indicates that the preceding element can be repeated. - The generic data type <a> is used if an argument represents a type-bound parameter. Contributing to documentation or code As a member of the Kadena community, you are invited and encouraged to contribute to Kadena technical documentation and to the Kadena project code base. There are a lot of ways to get involved. For example, you can contribute by: - Submitting issues. - Offering suggestions for improvements to existing content. - Adding review comments to existing pull requests. - Proposing new content. - Creating new pull requests to fix issues yourself. - Creating pull request for new content other community members might find useful. We value, respect, and appreciate all contributions from the developer community and only ask that you agree to abide by our Code of conduct and Community guidelines. Contribute to documentation Kadena documentation is open source and hosted on GitHub in the kadena-docs repository. To report an issue or make a documentation request, open a New Issue and add the documentation label to it. If you have a GitHub account and want to suggest changes to the documentation, create a branch and open a pull request as described in Contribute to documentation. For details about getting started as a contributor to documentation, see How to contribute to Kadena documentation. For recommendation regarding writing style, documentation conventions, and topic templates, see the Writer's style guide. Contribute to the codebase The Kadena codebase is open source and hosted on GitHub in repositories under two organizations: kadena-io and kadena-community. - Repositories in kadena-io are focused on the Kadena network infrastructure and foundational components like chainweb-node and pact. - Repositories in kadena-community are focused on tooling and projects to help developers build applications on the Kadena network like the TypeScript libraries in kadena. js. For details about getting started as a contributor, see How to contribute as a developer.",
    "source": "smart-contracts/get-started-intro.md",
    "title": "Get started: Introduction to Pact"
  },
  {
    "content": "Guards are an important concept in Kadena that provide a flexible way for you to enforce authorization rules that grant or restrict access based on specific conditions. In Pact, guards provide a flexible way for you to enforce authorization rules that grant or restrict access based on specific conditions. Guards generalize the behavior of keysets and capabilities to specify conditions that must be met before granting access to an account, a privileged operation, or any type of information that the guard is there to protect. Although Pact provides several types of guards to handle different scenarios and use cases, a guard is essentially a predicate function that enables you to test whether a condition is present (true) or not (false) with an enforce-guard function. As you've already seen, a keyset is the most common type of guard. It specifies a list of keys and a predicate function to verify how many keys were used to sign the current transaction. The keyset predicate references a function that compares the public keys in the keyset to the key or keys used to sign the blockchain message. The function accepts two arguments—count and matched—where count is the number of keys in the keyset and matched is how many keys in the message signature match a keyset key. The enforce-keyset function tests whether the required number of matching keys is true or false, determining whether the transaction succeeds with the required number of matched keys or fails because the required number of matched weren't found in the signing set. The following examples illustrate other use cases for guard predicate functions: - Ensure that a user is a member of a privileged group that can execute a certain function. - Verify that a user has provided some secret, such as the preimage data for a hash function, as is often done for atomic swaps. - Enforce that a module is the only owner that can execute a specific function, for example, to debit a protected account. Guards enable you combine all of these types of checks into a single, enforceable rule. For example: Verify the user Alicia is a member of the Executive Board authorized to access the General Fund AND has provided the preimage data AND the transaction is only executable by the module general-fy2025\". Supported guards Guards can have different properties based on what they are intended to protect access to, but can also interoperate with each other seamlessly. You can include any or all of the following Pact guards in a smart contract: - Keyset guard - KeysetRef guard - User guard - Capability guard - Module guard (DEPRECATED) - Pact guard (DEPRECATED) Note that the module guard and Pact guard are DEPRECATED because they are considered unsafe. You can store guards in the Pact database using the guard type. Although Pact defines these different guards to handle different use cases, the most important point to consider in selecting a guard is ensuring it enforces the appropriate conditions to allow or deny access to the appropriate entity, whether that entity is an account balance, a privileged operation, or a customizable user function. Guards and capabilities Guards and capabilities provide similar functionality in terms of authorizing access based on specific conditions. However, there are a few fundamental differences between guards and capabilities: - Guards allow you to define a rule that must be satisfied for an operation or transaction to proceed. They simply provide a way to declare a pass-fail condition—the predicate function—without granting any type of privilege or authorized activity. The Pact guard system is flexible enough to express any rule you can code. - Capabilities allow you to declare how a rule is deployed to grant some authority. In doing so, they enumerate the critical rights that are extended to users of the smart contract, and protect code from being called incorrectly. In addition, you can only grant capabilities inside the module code that declares them. Guards are simply data that can be tested anywhere. For capabilities, this is an important distinction because it ensures an attacker can't elevate privileges from outside of the module code. Keyset guards The keyset guard is the backward-compatible keyset as originally defined in Pact. This guard is also referred to as a concrete keyset that's defined in the environment. Using the keyset type is the one instance where you can restrict a guard subtype. For all other guards, the guard type obscures the implementation type to discourage you from using guard-specific control flow, which would be against best practices. In general, you should use the guard type unless you have a specific need to use a keyset. Examples To create a keyset guard with the name admin-keyset: Code example (json): { \"admin-keyset\": { \"keys\": [ \"58705e8699678bd15bbda2cf40fa236694895db614aafc82cf1c06c014ca963c\" ], \"pred\": \"keys-all\" } } To define a keyset by reading a keyset object: Code example (pact): (define-keyset \"admin-keyset\" (read-keyset \"admin-keyset\")) (enforce-guard (read-keyset \"admin-keyset\")) Principal account prefix Each type of principal and guard uses a unique prefix, so they are easy to recognize. If you use the create-principal function to a create principal account for a keyset guard, the principal account uses one of the following prefixes: - k: for single key keysets - w: for multiple keys keysets KeysetRef guard You can install concrete keyset guards in the REPL environment by using the define-keyset function. However, if you want to store a reference to a defined keyset, you must use a string type. To make REPL environment keysets interoperate with concrete keysets and other guards, you can use the KeysetRef guard to indicate that a defined keyset is used instead of a concrete keyset. Examples Code example (pact): (enforce-guard (keyset-ref-guard \"foo\")) (update accounts user { \"guard\": (keyset-ref-guard \"foo\") }) User guard User guards allow you to design an arbitrary predicate function to enforce the guard, given some initial data. With user guards, you can implement any type custom predicate logic that can't be expressed by other built-in guard types. For example, you might want to customize the guard to allow one of two different keysets to sign: - One keyset registers the keys for the members of a board of directors. - A second keyset registers the keys for union representatives. You can then design a user guard to require two separate keysets to be enforced: Code example (pact): (defun both-sign (board union) (enforce-keyset board) (enforce-keyset union)) (defun install-both-guard () (write guard-table \"both\" { \"guard\": (create-user-guard (both-sign (read-keyset \"board) (read-keyset \"union\"))) })) (defun enforce-both-guard () (enforce-guard (at \"guard\" (read guard-table \"both\")))) User guards can be very flexible and powerful. They can be stored in the database and passed around like plain data. However, user guards are pure functions that don't allow access to a database during evaluation of the guard. Examples The following example illustrates how to write a custom hash timelock guard to implement atomic swaps. Code example (pact): (create-hashlock-guard (secret-hash timeout signer-ks) (create-user-guard (enforce-hashlock secret-hash timeout signer-ks))) (defun enforce-hashlock (secret-hash timeout signer-ks) (enforce-one [ (enforce (= (hash (read-msg \"secret\")) secret-hash)) (and (enforce-keyset signer-ks) (enforce (> (at \"block-time\" (chain-data)) timeout) \"Timeout not passed\")) ])) Principal account prefix Each type of principal and guard uses a unique prefix, so they are easy to recognize. If you use the create-user-guard function to create a principal account for a user guard, the principal account uses the following prefix: - u: for user guards Capability guard Capabilities are in-module rights that can only be enforced within the declaring module, and offer scoping and the other benefits. Because user guards are required to be pure functions, they can't take database state into account. If you need to access database state, you can define a guard that requires a capability to be brought into scope. With this type of guard, you can retrieve database state when you bring the capability into scope. Principal account prefix Each type of principal and guard uses a unique prefix, so they are easy to recognize. If you use the create-capability-guard function to create a principal account for a capability guard, the principal account uses the following prefix: - c: for capability guards",
    "source": "smart-contracts/guards.md",
    "title": "Guards"
  },
  {
    "content": "Start a local development network with a standalone blockchain node. Set up a development network Computers that run the Chainweb network software—the chainweb-node program—are a crucial component of the Kadena blockchain. Nodes provide the compute, storage, and network resources that enable the Kadena blockchain to be secure and decentralized. Nodes also provide the engine for transaction processing, data verification, and executing smart contract functions. Because of the role they play in receiving and processing transactions, it's important to include at least one standalone node as part of your development environment. In most cases, you can run a single node to establish a local development network that you can then use to test smart contract operations in an isolated and controlled environment before deploying to a public test or production network. There are two primary ways you can set up a local development network that includes the chainweb-node program: - You can download a complete local development network that includes the chainweb-node program, a local block explorer, the Pact interpreter that runs in a browser, and other tools. With this option, you can use a default set of tools and configuration settings from a Docker image to run the development network inside of a Docker container. For instructions, see Start the development network. - You can download and run the chainweb-node program as a standalone release binary from its GitHub repository. With this option, you can manually select the tools and configuration settings you want the node to use. For instructions, see Install a standalone node or chainweb-node. Start the development network If you have Docker installed, the simplest way to get a local node running is to download the latest Docker image for the Kadena development network. The development network in the Docker image includes access to additional tools and installs the most commonly-used contracts by default. To run a chainweb-node instance in a Docker container: 1. Open a terminal shell on your computer. 2. Start the Docker service if it isn't configured to start automatically in your local environment. You can run the docker info command to check whether Docker is currently running. 3. Create a new Docker volume by running the following command: Code example (shell): docker volume create kadenadevnet `` 4. Pull the kadenadevnet volume image and start the devnet container by running the following command: `shell docker run --interactive --tty --publish 8080: 8080 --volume kadenadevnet: /data --name devnet kadena/devnet ` Wait for the image to be downloaded to your local environment. 5. Start the local development network by running the following command: `shell docker start devnet ` After you start the. . . [code continues]bash docker run --interactive --tty --publish 8080: 8080 kadena/devnet: latest Code example (): You can stop the network at any time—and reset the blockchain state—by pressing Ctrl-c in the terminal. After you stop the network, restart it using the previous command or one of the commands that follow. If you want to automatically remove the container when you stop it, add the --rm command-line option. For example: shell docker run --rm --interactive --tty --publish 8080: 8080 --volume kadenadevnet: /data --name devnet kadena/devnet Code example (): If you encounter an error where the version of Chainweb is invalid after a certain date (typically after a service update), run the following command to pull the latest version: shell docker run --pull always --interactive --tty --publish 8080: 8080 kadena/devnet: latest Code example (): If you can't run the Pact executable on your local computer, you can mount the. /pact folder for the election project in the Docker container by running the following command: bash docker run --interactive --tty \\ --publish 8080: 8080 \\ --volume. /pact: /pact-cli: ro \\ kadena/devnet: latest ` Connect Chainweaver to the development network By default, the Chainweaver wallet and IDE lets you connect to the Kadena test network and the Kadena main network. However, as you start writing Pact modules, you'll want to test and deploy them on your local development network. Before you can do that, you need to configure Chainweaver to connect to the local host and port number running the development network. To add the development network to Chainweaver: 1. Open or unlock Chainweaver. 2. Click Settings in the Chainweaver navigation panel. 3. Click Network. 4. Under Edit Networks, type the network name development, then click Create. 5. Expand the development network, then add the localhost as a node for this network by typing 127. 0. 0. 1: 8080. If the local computer is still running the development network Docker container, you should see the dot next to the node turn green. 6. Click Ok to close the network settings. After you click Ok, you can see development selected as your current network. All actions you perform in Chainweaver are now executed on the local development network. Install a standalone node If you want full control over node operations, you might want to install and manage chainweb-node as a standalone local node for development or as a node participating in the Kadena test or production public network. There are several options for setting up a Chainweb node in a physical or virtual environment. For example, you can install and run node binaries: - Directly on a physical Linux or macOS computer. - On an Linux or macOS instance with infrastructure from a cloud services provider. - From a Linux image in a Docker container. You can also build the binaries directly from the source code. Minimum system requirements Before installing Chainweb, you should verify that your computer meets the following minimum recommended hardware requirements for running a node: - CPU: Minimum of two (2) CPU cores. - RAM: Minimum of four (4) GB of RAM. - Storage: Minimum 250 GB using a solid state drive (SSD) or fast hard disk drive (HDD). - Network: Publicly-accessible IP address. - Operating system: Linux AMD64 architecture. If you also plan to use the node for mining, to submit transactions, or to query blockchain data, you should verify that your computer meets the following minimum recommended hardware requirements: - Four (4) CPU cores. - Eight (8) GB of RAM. Operating system architecture Most chainweb-node software runs on Linux with AMD64 architectures. If you want to run a Chainweb node on Linux or macOS with ARM64 architecture, you'll need to build the binaries yourself from the source code. You might experience some unexpected behavior when running a node on ARM64 architecture. Note that you should not configure mining for nodes on ARM64 architecture. Running a mining node on ARM64 architecture could cause your node to fork from the network. If you want to run a Chainweb node on Microsoft Windows, you should note that this isn't a supported configuration and requires you to install the latest Windows Services for Linux (WSL) software. If you choose to proceed after installing WSL, you can install the chainweb-node software in the WSL virtual environment rather than using the native Windows operating system. Incoming and outgoing network rules In addition to a publicly-accessible IP address, nodes must be able to communicate with peers and accept incoming messages from other computers in the network. If your computer is behind a firewall or is a virtual guest connecting to the internet through a host computer, you should review your network configuration and open required ports to allow inbound and outbound traffic. For example, you might need to configure port forwarding for port 1789 on your router or host computer to allow inbound connections from remote nodes. Install from release binaries You can download compressed archive files with chainweb-node release binaries for Ubuntu Linux directly from the Releases page in the chainweb-node repository. If you have Ubuntu 20. 04 or Ubuntu 22. 04 on a physical or virtual machine, downloading the binary is the most straightforward installation path. To install from a release archive: 1. Open a terminal shell on the physical or virtual host with the Ubuntu Linux operating system. 2. Update the system with the latest software by running the following command: `bash sudo apt update && sudo apt upgrade ` 3. Install the required packages by running the following command: `bash sudo apt-get install ca-certificates libgmp10 libssl3 libsnappy1v5 zlib1g liblz4-1 libbz2-1. 0 libgflags2. 2 zstd ` If your computer uses the Ubuntu 20. 04 operating system, install the libssl1. 1 package instead of the libssl3 package. 4. Download the archive file from the Releases page. Note that the archive file naming convention includes the chainweb-node version, compiler version, Ubuntu version, and a commit hash identifier using the following format: `text chainweb-<version>. ghc-<version>. ubuntu-<version>. <revision>. tar. gz ` For example, the chainweb-node archive file for Ubuntu 22. 04 looks like this: `text chainweb-2. 26. 1. ghc-9. 6. 5. ubuntu-22. 04. 89b0ac3. tar. gz ` 5. Change to the directory that contains the downloaded file—typically, the Downloads folder—or move the file to a new location. 6. Unzip and extract the compressed archive by running a command similar to the following: `bash tar -xvzf chainweb-2. 26. 1. ghc-9. 6. 5. ubuntu-22. 04. 89b0ac3. tar. gz ` 7. Verify the binary is ready to use and review command-line configuration options by running the following command: `bash. /chainweb-node --help ` You should see usage information about the configuration settings you can specify as command-line options similar to the following truncated output: `bash Usage: chainweb-node [--info] [--long-info] [-v|--version] [--license] [-? |-h|--help] [--print-config-as full|minimal|diff | --print-config] [--config-file FILE] ` From the usage information, you can see that there are a large number of configuration options that you can use to control and operation and behavior of the Chainweb node. Before you start the node, you should review the configuration options and the default values to determine whether you want to make any changes to the configuration of the node. 8. Extract the default configuration settings to create a configuration file for the node by running the following command: `bash. /chainweb-node --print-config > default-config. yaml ` If you want to modify any of the default settings or add features that are disabled by default, you can: - Edit settings in one or more configuration files. - Use corresponding command-line options to control node operations. <! --For more information about editing configuration settings in the configuration file, see Edit the configuration settings. --> <! --For information about using command-line options to control node operations, see the [chainweb-node]() command-line reference. --> 1. Start the node from the release binary by running a command similar to the following: `bash. /chainweb-node ``",
    "source": "smart-contracts/install/local-dev-node.md",
    "title": "Local development network"
  },
  {
    "content": "Update your development environment and smart contracts to use the Pact 5 smart contract language and command-line interpreter. The Pact programming language was designed to optimize the transactional logic in smart contracts executed in a resource-constrained blockchain environment. Pact 5 represents a comprehensive refactoring of the Pact language and command-line interpreter that offers improvements in efficiency, performance, and ergonomics. The improvements in Pact 5 ensure lower transaction costs, faster module loading, and enhanced testing and debugging capabilities. To take advantage of these improvements, you need to update your development environment and smart contracts to use Pact 5. This article covers the basics of upgrading to Pact 5 and details some of the breaking changes that might require you to update and redeploy existing contracts or fix potential coding errors. The timeline for migrating to Pact 5 looks like this: - Chainweb nodes will be upgraded to Pact 5 with the chainweb-node 2. 27 release on 29 January 2025. - The Kadena main production network (mainnet01) will be upgraded to use Pact 5 on 10 February 2025. - The Kadena test network (testnet04) will be upgraded to use Pact 5 on 6 February 2025. - An interim test network (testnet05) is currently available for testing with Pact 5. The testnet05 network will be decommissioned and removed from service on 7 February 2025 after the testnet04 network is upgraded to use Pact 5. Preparing to migrate Ideally, you should test any smart contracts you've written by installing Pact 5 locally before Pact 5 is released on the Kadena main production network. If you install Pact 5 locally in your development environment, you can run all of your existing contract tests that you've defined in REPL files using the Pact 5 binary to verify that they work as expected. For information about installing the Pact 5 binary locally, see Installation and setup. You can also test that existing smart contracts work with Pact 5 by deploying them on the Kadena testnet05 network. You can connect to the testnet05 network by using the API node available at api. testnet05. chainweb. com. For examples of how to deploy contracts, see the Deploy smart contracts guide. Pact 5 will also be deployed by default on the development network that you can run locally beginning with the chainweb-node 2. 27 release. After chainweb-node 2. 27 is released, you can start a local development node to build and test contracts using Pact 5 by default. After upgrading to Pact 5 Most smart contracts written in Pact 4, or earlier, should be compatible with Pact 5 and continue to operate as expected without any issues. However, some of the bugs that were found in earlier versions of Pact and corrected in the Pact 5 implementation might cause unexpected behavior in your contracts or require some type of modification to the contract code. You can find details about new features and the types of issues you might encounter in the remainder of this document. You don't need to redeploy any existing contracts to use Pact 5. However, redeploying will reduce the gas required to execute contract functions, because the newly-deployed version will use the Pact 5 on-disk format. Pact 5 includes a new built-in function for redeploying contracts, so you can take advantage of reduced transaction costs without modifying any contract code or module hashes. Semantic changes Pact 5 includes some changes to correct previously allowed but unintended behavior. These changes might require you to modify your smart contract to conform to Pact 5 that enforces expected behavior. Code examples illustrate the old behavior and how to modify your contract, if necessary. Duplicate capabilities cannot be installed In Pact 4, you could install a managed capability with identical parameters multiple times and specify a different value for the managed parameter in each install-capability expression. This behavior was not the way the install-capability was intended to be used. Using the install-capability function in this way didn't introduce any security issues because you can't install a capability to override a managed parameter specified in a signature. However, the code did result in unexpected behavior as illustrated in the following code sample: Code example (pact): (module m g (defcap g () true) (defun cap-mgr (a: integer b: integer) (let* ((remaining (- a b))) (enforce (>= remaining 0) \"Remaining must be non-negative\") b ) ) (defcap MANAGED (user: string amount: integer) @managed amount cap-mgr true ) (defun managed-example (user: string amount: integer) (with-capability (MANAGED user amount) \"The capability was acquired successfully! \" ) ) ) (install-capability (MANAGED \"stuart\" 1)) (ins. . . [code continues] As illustrated in this example, Pact 4 allows you to install the MANAGED capability twice, but it selects the lexicographically smallest managed parameter. In this case, because 0 comes before 1, so the (MANAGED \"stuart\" 0) capability is selected instead of the (MANAGED \"stuart\" 1) capability, leading to the following output: Code example (pact): pact> (load \"scratch/discreps/install-cap. repl\" true) \"Loading scratch/discreps/install-cap. repl. . . \" \"Loaded module m, hash oT9RPcfHZVhmCzHX3n51FKI0DCUwst06fqGQZu3hKI\" \"Installed capability\" \"Installed capability\" scratch/discreps/install-cap. repl: 8: 5: Error: Remaining must be non-negative at scratch/discreps/install-cap. repl: 8: 5: (enforce (native >= True if X >= Y. Type: x: <a[integer, . . . \"Remaining must be non-negative\") at scratch/discreps/install-cap. repl: 5: 2: (cap-mgr 0 1) at scratch/. . . [code continues] Pact 5 does not allow installing duplicate capabilities, as shown below: Code example (pact): pact> (load \"scratch/discreps/install-cap. repl\" true) \"Loading scratch/discreps/install-cap. repl. . . \" Loaded module m, hash gY4DlgJg2XkK6LPH1H81M5EhPohOSz9ydsucAcRF9w \"Installed capability\" scratch/discreps/install-cap. repl: 26: 0: Capability already installed: (m. MANAGED \"stuart\" 0) 26 | (install-capability (MANAGED \"stuart\" 0)) | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ In most cases, you can correct this issue by simply deleting the invocation of install-capability in your smart contracts because most managed capabilities are signed for, and thus implicitly installed. Using install-capability is only supported for managed capabilities In Pact 4, you can use the install-capability function with any capability, regardless of whether it is a managed capability. However, the sole purpose of this function is to track the value of a managed parameter. Using this function with a capability that isn't a managed capability has no effect. The following code is a minimal reproduction: Code example (pact): (module m g (defcap g () true) (defcap UNMANAGED () 1) ) (install-capability (UNMANAGED)) If you execute this code in Pact 4, the output doesn't report this behavior as an error: Code example (pact): pact> (load \"scratch/discreps/unmanaged-install. repl\" true) \"Loading scratch/discreps/unmanaged-install. repl. . . \" \"Loaded module m, hash hha21FQe4BjRLJ4L5mfHLTBE18QhKFyf-hXlEF21gY\" \"Installed capability\" To prevent mistakes, Pact 5 is more strict, disallowing this behavior: Code example (pact): pact> (load \"scratch/discreps/unmanaged-install. repl\" true) \"Loading scratch/discreps/unmanaged-install. repl. . . \" Loaded module m, hash E4C8JfW1e6rIThBWNDw3GON0COvPQVqm3ZXOWT80iCI scratch/discreps/unmanaged-install. repl: 7: 0: Install capability error: capability is not managed and cannot be installed: m. UNMANAGED 7 | (install-capability (UNMANAGED)) | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Acquiring module administrator privileges for operations Pact requires module administrator privileges to be acquired before performing the following operations: - Upgrading a module. - Accessing or modifying a table. - Acquiring capabilities using the with-capability function. Pact 4 automatically attempts to acquire the module administrator privileges when executing these operations. To prevent contracts from accidentally executing privileged actions, Pact 5 no longer automatically acquires the module administrator privileges except in the case of upgrading a module. To acquire module administrator privileges explicitly, you can use the new acquire-module-admin built-in function, This change makes security boundaries between modules much clearer. For example, in the following contract code, the user Bob acquires module administrator privileges by writing directly to the table foo and gives himself a balance of 10000000000000 using Pact 4: Code example (pact): ; Uncomment the line when running with Pact 4; (env-exec-config [\"DisablePact44\"]) (begin-tx) (env-data {\"admin\": {\"keys\": [\"some-key\"], \"pred\": \"keys-all\"}}) (define-keyset \"admin\" (read-keyset \"admin\")) (module m g (defcap g () (enforce-guard (keyset-ref-guard \"admin\"))) (defschema fooschema user: string balance: integer) (deftable foo: {fooschema}) ) (create-table foo) (commit-tx) (begin-tx) (env-sigs [{\"key\": \"some-key\", \"caps\": []}]); Admin is being acquired here automatically (write. . . [code continues] In this example, the administrator privileges are granted implicitly for the transaction that contains the write function, and the result that gives Bob a balance of 10000000000000 coins might be difficult to spot. In Pact 5, Bob must explicitly acquire the administrative rights for the module. For example: Code example (pact): (acquire-module-admin m) (write m. foo \"bob\" {\"user\": \"bob\", \"balance\": 10000000000000}) By acquiring the administrative rights before sending the (write m. foo \"bob\" {\"user\": \"bob\", \"balance\": 10000000000000}) transaction, it's clearer that the code is performing an administrative operation. Note that this change doesn't affect module deployment or upgrade transactions. Module administrator privileges are requested automatically to redeploy a module. Module hashing In Pact 4, the same contract code would always yield the same module hash. In Pact 5, a module’s hash is computed from both the module itself and the modules it depends on, increasing reliability and integrity. The following REPL script illustrates this: Code example (pact): (begin-tx) (module dependency g (defcap g () true) (defun f () 1) ) (module m g (defcap g () true) (defun use-dependency () (f) ) ) (commit-tx) (begin-tx) (module dependency g (defcap g () true) (defun f () 2) ) (module m g (defcap g () true) (defun use-dependency () (f) ) ) (commit-tx) The output for this code in Pact 4 looks like this: Code example (pact): pact> (load \"module-hashing. repl\" true) \"Loading scratch/discreps/module-hashing. repl. . . \" \"Begin Tx 0\" \"Loaded module dependency, hash QVQ9B6vNg3TNBrLeDH2jR7geVvFGPPHd6OOXthb6kk\" \"Loaded module m, hash tyMLKKg71M2QSEHEJOZn8Q3x9KVWj0ldpkyTTwOEE\" \"Commit Tx 0\" \"Begin Tx 1\" \"Loaded module dependency, hash zp3ZGRtmIeLSZnFsDuhqhsqJ3zcbnQ--R5wSjWCJJXA\" \"Loaded module m, hash tyMLKKg71M2QSEHEJOZn8Q3x9KVWj0ldpkyTTwOEE\" \"Commit Tx 1\" Notice that despite the change in the hash of dependency, the hash for the m module doesn't change. This is no longer the case in Pact 5. In Pact 5, the output for this code looks like this: Code example (pact): pact> (load \"module-hashing. repl\" true) \"Loading scratch/discreps/module-hashing. repl. . . \" \"Begin Tx 0\" Loaded module dependency, hash YTZXSZChVLwUJkpm3dSzidkfVB14Y8smFf7x1CfukY Loaded module m, hash 5BpfxcjVb4usVyuLg25bk821RLu9raD8e76U2zfS3M \"Commit Tx 0\" \"Begin Tx 1\" Loaded module dependency, hash L9gxBgNRNESJIqS0wZN3xDAcuRa1IC3-yNN03mtFttQ Loaded module m, hash D45G9PizSn59QTRyUObLesCM9IEfxrIM5OlpgQXxQg \"Commit Tx 1\" In the Pact 5 output, the hash for the m module reflects the change in the dependencies. This change is required for integrity, because otherwise, modules with the same hash can behave differently. Function names and variable identifiers In Pact 4, it was possible to use variable identifiers with the same name as built-in functions. For example, in Pact 4, you can write a function like the following that uses identity as a variable identifier: Code example (pact): (defun register-identity: bool (user-address: string user-guard: guard identity: string country: integer). . . ) However, identity is a reserved keyword for a built-in function. In Pact 4, you are allowed to override or shadow the function name. Pact 5 doesn't allow this behavior, and variables that use the same name as a built-in function resolve as the built-in function. If you use any variable identifiers with the same name as a built-in function name, you should modify the variable identifier to use a different name if you want to redeploy the contract as a Pact 5 contract. For a list of the reserved built-in function names, see Function quick reference. For a list of reserved keywords, see Syntax and keywords. Integers returned as objects In Pact 5, functions that return integer values return an object with int as the key field and a number as a string or a JSON number. For example, you might see a return value similar to the following: Code example (pact): result: {status: \"success\", data: {int: 1}} According to the Pact specification for encoding and decoding values, if you return a raw JSON number without the int field, the value is a double. If a function returns an object with the int field and a number, the value is an integer. In Pact 4, integer values that were returned as objects were silently converted to doubles in results. The silent conversion of integers to doubles caused tests that were written to expect integer values to fail. In Pact 5, values are returned as described by the Pact codec. Integer values are always returned as objects {int: X} and raw JSON numbers are always interpreted as doubles. Changed or removed built-in functions - pact-version was usable in the REPL and with the /local endpoint to determine the current Pact version. It was removed in Pact 5 due to time constraints. - enforce-pact-version was usable in the REPL and with the /local endpoint to assert on the current Pact version. It was removed in Pact 5 due to time constraints. - list was removed in Pact 5 after it was deprecated with a warning and increased gas costs in Pact 4. (list 1 2 3) is equivalent to [1 2 3]. - decrypt-cc20p1305 and validate-keypair have been removed in Pact 5 due to time constraints and lack of users. - constantly has changed in Pact 5. It now accepts exactly two arguments, and behaves as if it were (lambda (x y) x). - txlog was removed in Pact 5 due to time constraints and lack of users. New built-in functions The following functions are new in Pact 5. - do is a new special form that you can use to sequence statements. For example: Code example (pact): (do (enforce (= 1 2) \"\") (enforce (= 3 4) \"\")) `` - acquire-module-admin is a new function that you can use to explicitly acquire module administrator privileges as described in Acquiring module administrator privileges for operations. - static-redeploy is a new function that you can use to redeploy existing modules into their Pact 5 format, making them cheaper and faster to load, without changing the contract code or. . . [code continues]pact (module m g (defcap g () true) (defschema s a: integer) (deftable my-table: {s}) (defun f () (with-read my-table \"k\" { \"a\": = a b: = b} a)) ) Code example (): To fix this issue, add the comma to the expression. For example: pact { \"a\": = a, \"b': = b } Code example (): ### Schemas are no longer allowed in terms In Pact, a schema is essentially a type definition for an object type. The schema type itself is not a value. The following example is thus invalid: markdown (module m g (defcap g () true) (defschema location city: string) (deftable locations: {location}) (defun get-city(entry: string) (at \"city\" (read location entry)) ) ) Code example (): In this example, the user intended to read the location at entry from the table locations, but instead wrote location, which is the schema. It’s not uncommon for a user to name a schema in a similar fashion as the table that holds object of that schema. In Pact 4, this code can be deployed, and leads to a hard-to-debug issue with a strange error message. In Pact 5, this code cannot be deployed at all. Running the above code with Pact 4 results in the following output: pact pact> (load \"scratch/discreps/schemas-in-term. repl\" true) \"Loading scratch/discreps/schemas-in-term. repl. . . \" \"Loaded module m, hash 2SkSSDLJqjZUSVxaqyXP7BYhP7Zl-D93awJPQeDHOM\" Code example (): In Pact 5, the code output looks like this: pact pact>(load \"scratch/discreps/schemas-in-term. repl\" true) \"Loading scratch/discreps/schemas-in-term. repl. . . \" scratch/discreps/schemas-in-term. repl: 9: 21: Invalid definition in term variable position: location 9 | (at \"city\" (read location entry)) | ^^^^^^^^ ``",
    "source": "smart-contracts/install/migrate-pact5.md",
    "title": "Migrating to Pact 5"
  },
  {
    "content": "Install the Pact smart contract programming language on Linux computers. import CodeBlock from '@theme/CodeBlock'; Install Pact on Linux You can download and install the Pact programming language and interactive interpreter locally on your local computer as prebuilt binary file from a release archive or build Pact directly from its source code. Prerequisites If you are installing Pact 4. x, you should note that this version of Pact requires the z3 theorem prover from Microsoft Research to support formal verification. Starting with Pact 5, Pact no longer supports formal verification using the z3 theorem prover. If you are installing Pact 5, or later, you can continue to the Installation instructions. If you are installing Pact 4. x, you can install and verify the installation of the z3 package on Linux by running the following commands: Code example (bash): sudo apt update sudo apt install z3 z3 --version If z3 is installed properly, you should see output similar to the following: Code example (bash): Z3 version 4. 13. 3 - 64 bit Installation instructions To install Pact on Linux: 1. Navigate to the appropriate Pact Releases page: - Pact Releases to download the latest stable version of Pact 4. x. - Pact 5 Releases to download the latest version of Pact 5. 2. Download the latest pact-<version>-linux-<arch>. tar. gz file for the Linux operating system and architecture you use. 3. Open a terminal and extract the downloaded compressed archive by running the following command: ``bash tar -xvzf pact-<version>-linux-<arch>. tar. gz ` 4. Navigate to the extracted directory: `bash cd pact-<version>-linux-<arch> ` 5. Move the pact binary to a directory in your system PATH, or update your PATH variable. For example, to move the pact binary from the current working directory to the /usr/local/bin directory and update the PATH: `bash sudo mv pact /usr/local/bin export PATH=\"/usr/local/bin: $PATH\" ` 6. Reload the shell configuration. For example, reload the configuration for the bash shell by running the following command: `bash source ~/. bashrc ` Replace ~/. bashrc with ~/. zshrc if you use the zsh shell. 7. Verify the installation by checking the Pact version: `bash pact --version ` 8. View usage information for the pact interactive interpreter by running the following command: `bash pact --help ` For more information about the command-line options, see Pact command-line interpreter. For an introduction to Pact programming and language features, see Pact features and conventions. Troubleshooting If you encounter issues, check the following: - Check the Pact version and, if Pact, version 4. x, is installed, verify that you have z3 installed. `bash pact --version ` This command should display output similar to the following: `bash pact version 4. 13 ` If the Pact version is 4. x, check for the z3 package by running the following command: `bash z3 --version ` If z3 is installed correctly, the command should display output similar to the following: `bash Z3 version 4. 8. 12 - 64 bit ` If necessary, install z3 by running the following commands: `bash sudo apt update sudo apt install z3 z3 --version ` - Verify the pact binary can be located and is in a directory included in your PATH environment variable. First check the path to the pact binary by running the following command: `bash which pact ` This command should display the current path to the pact binary. For example: `bash /usr/local/bin/pact ` If the command doesn't display the path to the pact binary, you should try reinstalling pact from the prebuilt release archive or from the source code. If the which pact command displays the path to the pact binary, check the PATH environment variable to verify the path the the binary is include by running the following command: `bash echo $PATH ` This command should display output similar to the following: `bash /home/pistolas/. nix-profile/bin: /usr/local/sbin: /usr/local/bin: /usr/sbin: /usr/bin: /sbin: /bin: /usr/games: /usr/local/games: /snap/bin ` The $PATH output should include the directory where the pact binary is located. If the PATH environment variable doesn't include the directory, open your shell profile—for example, the ~/. bashrc or ~/. zshrc file—in a text editor. Add the following line at the end of the file: `bash export PATH=\"/path/to/pact-directory: $PATH\" `` Save the shell profile file and exit. Open a new terminal or reload the shell profile to complete the update. - Check Pact GitHub Issues for known issues or to report a problem with installing Pact.",
    "source": "smart-contracts/install/on-linux.md",
    "title": "Install on Linux"
  },
  {
    "content": "Install the Pact smart contract programming language on macOS computers. import CodeBlock from '@theme/CodeBlock'; Install on macOS You can install Pact on macOS by using the Homebrew package manager or by downloading and installing the appropriate binary for the local system architecture. Prerequisites If you want to install Pact on macOS using the Homebrew package manager (recommended), you should verify that you have Homebrew installed by running the following command: Code example (bash): brew --version This command should display output similar to the following: Code example (bash): Homebrew 4. 3. 23 If you don't have Homebrew installed, see Homebrew for installation instructions and additional information about using the package manager. In addition to Homebrew, if you are installing Pact 4. x, you should note that this version of Pact requires the z3 theorem prover from Microsoft Research to support formal verification. Starting with Pact 5, Pact no longer supports formal verification using the z3 theorem prover. If you are installing Pact 5, or later, you can continue to the Installation instructions. If you are installing Pact 4. x, you can install and verify the installation of the z3 package on Linux by running the following commands: Code example (bash): brew install z3 z3 --version If z3 is installed properly, you should see output similar to the following: Code example (bash): Z3 version 4. 13. 3 - 64 bit Installation instructions To install Pact on macOS using Homebrew: 1. Open a terminal shell on your local computer. 2. Update the brew package manager by running the following command: ``zsh brew update ` 2. Install the pact binary and related dependencies by running the following command: `zsh brew install kadena-io/pact/pact ` 7. Verify the installation by checking the Pact version: `bash pact --version ` 8. View usage information for the pact interactive interpreter by running the following command: `bash pact --help ` For more information about the command-line options, see Pact command-line interpreter. For an introduction to Pact programming and language features, see Pact features and conventions. To install Pact on macOS from a compressed archive: 1. Navigate to the appropriate Pact Releases page: - Pact 4 Releases to download the latest stable version of Pact 4. x. - Pact 5 Releases to download the latest version of Pact 5. 2. Download the latest pact-<version>-macos-<arch>. tar. gz file for the macOS operating system and architecture you use. 3. Double-click the downloaded file to extract the contents. 4. Use the Finder to navigate to the pact binary in the extracted directory, select the binary, right-click, then click Open. 5. Click Open to override system setting settings: Troubleshooting If you encounter issues, check the following: - Check the Pact version and, if Pact, version 4. x, is installed, verify that you have z3 installed. `bash pact --version ` This command should display output similar to the following: `bash pact version 4. 13 ` If the Pact version is 4. x, check for the z3 package by running the following command: `bash z3 --version ` If z3 is installed correctly, the command should display output similar to the following: `bash Z3 version 4. 13. 0 - 64 bit ` If necessary, install z3 by running the following command: `bash brew install z3 ` - Verify the pact binary can be located and is in a directory included in your PATH environment variable. First check the path to the pact binary by running the following command: `bash which pact ` This command should display the current path to the pact binary. For example: `bash /opt/homebrew/bin/pact ` If the command doesn't display the path to the pact binary, you should try reinstalling pact using brew, from the prebuilt release archive, or from the source code. If the which pact command displays the path to the pact binary, check the PATH environment variable to verify the path the the binary is include by running the following command: `bash echo $PATH ` This command should display output similar to the following: `bash //Users/pistolas/Library/pnpm: /opt/homebrew/bin: /opt/homebrew/bin: /Library/Frameworks/Python. framework/Versions/3. 12/bin: /opt/homebrew/bin: /opt/homebrew/sbin: /usr/local/bin: /System/Cryptexes/App/usr/bin: /usr/bin: /bin: /usr/sbin: /sbin: /var/run/com. apple. security. cryptexd/codex. system/bootstrap/usr/local/bin: /var/run/com. apple. security. cryptexd/codex. system/bootstrap/usr/bin: /var/run/com. apple. security. cryptexd/codex. system/bootstrap/usr/appleinternal/bin ` The $PATH output should include the directory where the pact binary is located. If the PATH environment variable doesn't include the directory, open your shell profile—for example, the ~/. bashrc or ~/. zshrc file—in a text editor. Add the following line at the end of the file: `bash export PATH=\"/path/to/pact-directory: $PATH\" `` Save the shell profile file and exit. Open a new terminal or reload the shell profile to complete the update. - Check Pact GitHub Issues for known issues or to report a problem with installing Pact.",
    "source": "smart-contracts/install/on-macos.md",
    "title": "Install on macOS"
  },
  {
    "content": "Install the Pact smart contract programming language on the Windows Subsystem for Linux. import CodeBlock from '@theme/CodeBlock'; Install on Windows Subsystem for Linux (WSL) You can install Pact on Microsoft Windows if you first install and configure the Windows Subsystem for Linux (WSL) on Windows 10, or later, or on Windows Server 2019, or later. After you install and configure the WSL, you can install Pact from the Pact Linux release archive. Prerequisites Before you can install Pact on Microsoft Windows, you must install and configure the Windows Subsystem for Linux (WSL). For complete WSL installation instructions, see Install WSL or Install on Windows Server. To set up WSL: 1. Click Start to select Windows PowerShell, then click Run as Administrator. 2. Run the following command to enable WSL and install the Ubuntu distribution: Code example (powershell): wsl --install --distribution Ubuntu `` 1. Restart the Windows computer to complete the WSL installation. After restarting, click Start to select the Ubuntu virtual machine and follow the instructions displayed to create a new user account and complete the setup process. In addition to setting up WSL, if you are installing Pact 4. x, you should note that this version of Pact requires the z3 theorem prover from Microsoft Research to support formal verification. Starting with Pact 5, . . . [code continues]bash sudo apt update sudo apt install z3 z3 --version Code example (): If z3 is installed properly, you should see output similar to the following: bash Z3 version 4. 13. 3 - 64 bit ` Installation instructions To install Pact on Window Subsystem for Linux (WSL): 1. Navigate to the appropriate Pact Releases page: - Pact 4 Releases to download the latest stable version of Pact 4. x. - Pact 5 Releases to download the latest version of Pact 5. 2. Download the latest pact-<version>-linux-<arch>. tar. gz file for the Linux operating system and architecture you use. 3. Open a terminal and extract the downloaded compressed archive by running the following command: `bash tar -xvzf pact-<version>-linux-<arch>. tar. gz ` 4. Navigate to the extracted directory: `bash cd pact-<version>-linux-<arch> ` 5. Move the pact binary to a directory in your system PATH, or update your PATH variable. For example, to move the pact binary from the current working directory to the /usr/local/bin directory and update the PATH: `bash sudo mv pact /usr/local/bin export PATH=\"/usr/local/bin: $PATH\" ` 6. Reload the shell configuration. For example, reload the configuration for the bash shell by running the following command: `bash source ~/. bashrc ` Replace ~/. bashrc with ~/. zshrc if you use the zsh shell. 7. Verify the installation by checking the Pact version: `bash pact --version ` 8. View usage information for the pact interactive interpreter by running the following command: `bash pact --help ` For more information about the command-line options, see Pact command-line interpreter. For an introduction to Pact programming and language features, see Pact features and conventions. Troubleshooting If you encounter issues, check the following: - Check the Pact version and, if Pact, version 4. x, is installed, verify that you have z3 installed. `bash pact --version ` This command should display output similar to the following: `bash pact version 4. 13 ` If the Pact version is 4. x, check for the z3 package by running the following command: `bash z3 --version ` If z3 is installed correctly, the command should display output similar to the following: `bash Z3 version 4. 8. 12 - 64 bit ` If necessary, install z3 by running the following commands: `bash sudo apt update sudo apt install z3 z3 --version ` - Verify the pact binary can be located and is in a directory included in your PATH environment variable. First check the path to the pact binary by running the following command: `bash which pact ` This command should display the current path to the pact binary. For example: `bash /usr/local/bin/pact ` If the command doesn't display the path to the pact binary, you should try reinstalling pact from the prebuilt release archive or from the source code. If the which pact command displays the path to the pact binary, check the PATH environment variable to verify the path the the binary is include by running the following command: `bash echo $PATH ` This command should display output similar to the following: `bash /home/pistolas/. nix-profile/bin: /usr/local/sbin: /usr/local/bin: /usr/sbin: /usr/bin: /sbin: /bin: /usr/games: /usr/local/games: /snap/bin ` The $PATH output should include the directory where the pact binary is located. If the PATH environment variable doesn't include the directory, open your shell profile—for example, the ~/. bashrc or ~/. zshrc file—in a text editor. Add the following line at the end of the file: `bash export PATH=\"/path/to/pact-directory: $PATH\" `` Save the shell profile file and exit. Open a new terminal or reload the shell profile to complete the update. - Check Pact GitHub Issues for known issues or to report a problem with installing Pact.",
    "source": "smart-contracts/install/on-windows.md",
    "title": "Install on Windows"
  },
  {
    "content": "Install additional tooling for Pact and for smart contract development. import CodeBlock from '@theme/CodeBlock'; Developer tooling Although Pact provides the foundations for developing smart contracts for the Kadena network, there are several other tools and extensions you might want to install and configure to complement Pact and provide a more complete development environment. The additional tools you might want to install locally include the following: - Pact language server - Pact version manager - Pact extension for Visual Studio Code - Kadena command-line interface - Chainweaver wallet and integrated development environment There are also developer tools that are available as web-based applications that you can access through the development lifecycle. Web-based developer tools include the following: - Faucet - Module explorer - Block explorer Pact language server You can install the Pact language server on your local computer to support syntax highlighting and other features in the code editor. Pact version manager The Pact version manager (pactup) is a community-contributed program that enables you to install and manage multiple versions of the Pact programming language and command-line interpreter. For more information about installing and using the pactup version manager, see Pact version manager. Pact extension for Visual Studio Code If you use Visual Studio Code as your integrated development environment (IDE), you can install the Pact extension to streamline your smart contract development experience. Before installing the extension, verify that you have Pact and the Pact Language Server installed. To install the Pact extension: 1. Open Visual Studio Code. 2. Select View, then click Extensions. 3. Type pact in the Search field. 4. Select PactLang, then click Install. If you're prompted to install additional extensions, you should install them to enable the full functionality of the Pact extension. To configure the Pact extension settings: 1. Select Code, Settings, then click Settings and search for pact. 2. Select Pact configuration and configure the settings appropriate for your development environment. 3. Select Enable coverage to enable code coverage reporting for. pact and. repl files. With this option enabled, code coverage is calculated for the. repl file and all of the. pact and. repl files that it loads every time you save a. repl file. Covered lines aree highlighted in green in your editor and uncovered lines aree highlighted in red. To view a code coverage report in HTML format, right-click the. /coverage/html/index. html file relative to the file that was run. Click Show preview to open the report. To run code coverage for all your. repl files at once, create an entry point. repl file that loads all the other. repl files in your project. You can then open the entry point file and save it to run all of your tests. 4. Select Enable Lsp to enable the Pact Language server. With this option enabled, syntax errors are be highlighted in. pact files and problems are reported in the Visual Studio Code status bar and bottom panel. 5. Select Enable trace to enable the output trace for Pact. With this option enabled, the pact command runs with the --trace option every time you save a file. The --trace option provides detailed line by line information about. pact and. repl file execution. 6. Set the path to the Pact executable and the Pact Language server executable. If you added the executables to your PATH, you can use pact and pact-lsp for these settings. ! Configure Pact settings Kadena command-line interface The Kadena command-line interface (kadena-cli) is a node. js package that provides direct access to the Kadena blockchain and to commands that help you create, test, deploy, and manage applications for the Kadena network. You can use the Kadena command-line interface to perform many common tasks interactively. You can also use kadena-cli commands in scripts and automated workflows that don't allow interactive input. To install the kadena-cli package: 1. Open a terminal shell on the computer where you want to install the kadena-cli package. 1. Verify that you have node, version 18 or later, and the npm or pnpm package manager installed. For example, check that you have node and npm installed by running the following commands: ``bash node --version npm --version ` 2. Use the npm or pnpm package manager to install kadena-cli globally. For example, to install globally using npm, run following command: `bash npm install --global @kadena/kadena-cli ` 3. Verify the package is installed and display usage information by typing kadena and pressing Return: `bash kadena ` 4. Prepare a development workspace with initial settings by running the following command: `bash kadena config init ` This command creates the. kadena configuration folder location in your current working directory and adds default network settings to a networks subfolder, then prompts you to create a wallet. For example: `bash Created configuration directory: /Users/pistolas/. kadena Added default networks: - mainnet - testnet - devnet? Would you like to create a wallet? (Use arrow keys) ❯ Yes No `` If you already have keys and an account or an existing wallet that you want to use, you can select No to end the interactive session. However, wallets are an important part of interacting with any blockchain, so you can follow the prompts displayed to create a new local wallet and account as part of your initial configuration. For more information about using the Kadena CLI as your primary interface for development tasks, see Develop with kadena-cli. For command-line reference information, see Kadena CLI. Chainweaver wallet and IDE Chainweaver is a combination wallet and integrated development environment that enables you to manage accounts and keys, sign transactions, and edit, call, and deploy smart contracts. Chainweaver is avaiable as a desktop application or as a browser-based web application. With Chainweaver, you can build, test, and iterate on your smart contracts before deploying them to your local development network, the Kadena test network, or the Kadena main network. As an integrated development environment (IDE), you can also use Chainweaver to: - Explore smart contract modules and functions, including sample applications and default contracts. - Define and manage authorization rules using keysets. - Connect to and deploy smart contracts on your local development network, the Kadena test network, or the Kadena main network. - Edit, update, and execute smart contract code. If you don't already have a Chainweaver account, you should create one using either the After you download and install the desktop application or open Chainweaver in a browser, you can create a wallet and accounts to interact with Kadena networks. For more information about using Chainweaver as your primary interface for development tasks, see Develop with Chainweaver.",
    "source": "smart-contracts/install/tooling.md",
    "title": "Developer tooling"
  },
  {
    "content": "Install the Pact smart contract programming language and set up tooling for your development environment. import CodeBlock from '@theme/CodeBlock'; Installation and setup Setting up a fully-functioning development environment often requires more than the minimal steps covered in the Quick start guide. This section provides more detailed information about installation, tooling, and configuration options so you can create a complete development environment that best meets your needs. At a high level, you complete the following steps to configure a development environment for writing smart contracts that execute transactions on the Kadena blockchain network: - Install Pact: Pact is the core smart contract programming language for Kadena. By installing the appropriate version of Pact for your operating system, you'll be able to write, test, and deploy your smart contracts from your working environment. - Install tooling: Installing additional tooling is optional. However, many toolchain extensions—like the Pact language server plugin (LSP) and the community-contributed pactup package manager—provide essential quality-of-life enhancements that improve the developer experience. You should also consider adding access to common blockchain applications—like faucets, wallets, and block explorers—to ensure you have an end-to-end development environment. - Set up a local node: A properly configured blockchain node is a crucial part of your development environment for testing and debugging of projects during development and simulating public deployment in an isolated network environment. Before you begin To prepare for installation, you should verify your development environment meets the following basic requirements - You have an internet connection and a web browser installed on your local computer. - You have an integrated development environment (IDE) or code editor such as Visual Studio Code. - You have access to an interactive terminal shell as part of the IDE or code editor you use. Pact versions You can choose to download and install either the latest, stable version of Pact, version 4. x, or the Pact core revision, version 5 (beta) for Linux or macOS computers. - Pact 4. 13 is the latest stable release of the Pact smart contract language and interactive interpreter for macOS. - Starting with Pact 5, the Pact core—including the command-line interpreter, built-in functions, and related components—have undergone a major transformation. This reinvention of the Pact language retains functional parity with previous Pact releases, but with significant changes that enhance the scalability, maintainability, and performance of the language. With the release of Pact 5, the Pact core is also positioned for more sustainable growth of Pact features within the Kadena ecosystem. By offering more modular and maintainable internal structures, Pact 5 can now better support community participation and enhancements to the language and components that rely on it. For more information about Pact 5, see the following resources: - Migrating to Pact 5 - Pact 5 repository - Pact 5 Beta: Improving Developer, Miner, and User Experience Installation options You can download and install the Pact programming language and interactive interpreter locally on your local computer from prebuilt platform-specific binaries or build Pact directly from its source code. You can also run Pact in a browser without installing it as a component in the development network Docker image. The installation instructions in this section describe how to install Pact locally using prebuilt binaries for each operating system platform. To build Pact binaries directly from source, see the instructions in the appropriate repository: - Pact 5 - Pact 4. x <! -- To build Pact binaries directly from source, download the source code from Pact Releases, then use Homebrew, Cabal from the Haskell toolchain, or the Nix package manager to build Pact. For more information about the dependencies and tools for building from the source code, see Building from source. -->",
    "source": "smart-contracts/install.md",
    "title": "Installation and setup"
  },
  {
    "content": "Learn the basics of Pact programming language features and coding conventions with an introduction to built-in functions and writing your own simple functions. Pact has a lot in common with other programming languages, but some of its conventions and intentional restrictions are either unique or unlike other programming languages you might be familiar with. This part of the documentation presents an overview of Pact language features and conventions you should be familiar with as you start reading and writing smart contract code. Command-line interpreter In the Quick start, you got a first look at writing Pact smart contract code and using the Pact command-line interpreter, also referred to as the Pact read-eval-print-loop (REPL) environment. The Pact REPL enables you to write and execute Pact code interactively from the command-line. but its real power lies in the ability to execute code in smart contract modules—that is, . pact files—or in test files with the. repl file extension that help you test your code as you go. With test. repl files, you can execute. pact module code and take advantage of features that are only available to use in. repl files run by the Pact REPL interpreter. For example, . repl files can include functions to set up environment data that's required for testing, but that is otherwise difficult to replicate in a test. In most cases, you can use the features provided by the Pact REPL in combination with an integrated development environment (IDE), like Visual Studio Code, to provide an end-to-end development environment. Parenthesis Pact uses parentheses to enclose each statement in the code. The statements enclosed by parentheses are often referred to as symbolic expressions or S-expressions. Parentheses enclose all module declarations, all function declarations, and any related logic. Often, the code requires nested parenthetical statements to resolve the logic. For example, the outermost parentheses in the following code contain the helloWorld module: Code example (pact): (module helloWorld 'admin-keyset (defun hello (name) (format \"Hello {}! \" [name])) ) Within the module helloworld declaration, the next set of parentheses contain a hello function declaration that includes an expression—also enclosed by parentheses—that uses the format built-in function. Comments There are several ways that you can embed comments in Pact programs. The most common convention is to use semicolons (; ) at the start or end of a line to add comments in smart contracts. With this notation, all comments are introduced by a single semi-colon followed by text to the end of the line. Although there's no difference between using a single semi-colon and multiple semi-colons, it's common for code to follow a convention similar to the following for readability: - A single semicolon (; ) for short notes on a single line of code. Code example (pact): ; First Pact module (module greeting GOVERNANCE (defcap GOVERNANCE () true) (defun say-hello(name: string) (format \"Hello, {}! ~ from Kadena\" [name]) ) ) (say-hello \"Pistolas\"); Call the hello function `` - Two semicolons (; ; ) inside or above definitions that describe functions or other top-level forms. `pact; ; In this example, the module defines a table for storing greeting; ; names and two functions: ; ; ; ; - (say-hello-to \"name\"); . . . [code continues]pact @doc \"Initializes a TOKEN with given policies and parameters, \\ \\ and executes the enforce-init function for each listed policy. \" Code example (): The @doc metadata tag is optional. For example, a module definition, function definition, or table definition can include comments in strings without the @doc tag: pact (module helloWorld 'admin-keyset \"A smart contract to greet the world. \" (defun hello (name) \"Do the hello-world dance\" (format \"Hello {}! \" [name])) ). . . (deftable accounts: {account} \"Main table for accounts module. \") Code example (): For more information about metadata, see Pact syntax. Data types Pact, like most programming languages, supports the data types that you would expect. For example, Pact allows you define the following types of data: Data type | Description | Examples: --------- |: ----------- |: ------- Integer | Any whole number value—positive or negative—that doesn't include a decimal. | 1, 2, -19 Decimal | Any number value that includes a decimal. Decimal precision is represen. . . [code continues]bash title=\" \" pact> (format-time \"%Y-%m-%d %H: %M: %S%N\" (time \"2024-07-23T13: 30: 45Z\")) \"2024-07-23 13: 30: 45+00: 00\" Code example (): The time function constructs a time object from a UTC value using the ISO8601 format (%Y-%m-%dT%H: %M: %SZ). The format-time built-in functions takes a format argument and a time argument to produce the specified time in the specified format. The following table provides a summary of time formats used in the previous example: Format | Purpose %Y | Year, no padding. %m | Month of the year, zero-padded to two characters, \"01\"–\"12\" %d | Day of the month, zero-padded to two characters, \"01\"–\". . . [code continues]pact pact> (format-time \"%Y-%b-%d\" (time \"2024-07-24T13: 30: 45Z\")) \"2024-Jul-24\" ` For more information about all of the formats supported, see Time formats. Operators Pact provides operator functions to perform common arithmetic, comparison, and logical operations. The most common of these operator functions are listed in this section. For a complete list with more information about each function, including function signatures and examples, see Operators. Arithmetic operators - +: Addition - -: Subtraction - *: Multiplication - /: Division - ^: Exponentiation Comparison operators - =: Equality -! =: Inequality - <: Less than - <=: Less than or equal to - >: Greater than - >=: Greater than or equal to Logical operators - and: Logical AND - or: Logical OR - not: Logical NOT Bitwise operators - &: Bitwise AND - |: Bitwise OR - ~: Bitwise NOT - xor: Bitwise XOR - shift: Bitwise shift Math-related operators - mod: Modulus - abs: Absolute value - round: Rounding - ceiling: Ceiling - floor: Floor Functions Functions are an important part of any programming language, whether you are working with built-in libraries or writing your own functions. In addition to the operator functions, Pact provides many other built-in functions to handle different types of tasks. The functions are grouped into the following categories: - Capabilities - Database - General - Guards - Keysets - Operators - Repl - Time Click a category to see a complete list of the functions in that category. Within each category, you can click individual function names to see more information, including function signatures and examples. You can also view information about built-in functions using the Pact command-line interpreter and interactive REPL. Defpacts One of the key features of the Pact programming language is support for multi-step transactions using coroutines—called defpacts—that can start, stop, continue, or rollback the execution of specific operations in a transaction. With defpacts, you can define the steps to be executed by different parties as sequential operations on the blockchain. For example, defpacts are used for cross-chain transfers where a burn operation takes place on the first chain and a mint operation takes place on the second chain. Because defpacts enable you to orchestrate a series of transactions in a strict sequence, they have two primary use cases: - For public two-party transactions—similar to an escrow process—with rules for the operations that are required to be performed by each participant to complete the transaction. - For private, confidential transactions that can be serialized and executed in a sequence and recorded in a private log and, predominately, involving the exchange of encrypted messages outside of the blockchain state. Note that private multi-step transactions aren't supported in Pact-5 or later. With defpacts, you can enable each participant to run only a subset of functions—for example, as a buyer who can make an offer or a seller who can start a sale—while preserving the integrity of the transaction as a whole. For more information about defining and using defpacts, see the syntax description for the defpact reserved keyword. For a more detailed example of using defpact in a smart contract, see the Marmalade ledger` contract.",
    "source": "smart-contracts/language-features.md",
    "title": "Pact features and conventions"
  },
  {
    "content": "Modules define the business logic and essential functions for blockchain applications and provide the basic foundation for all Pact smart contracts. The fundamental building blocks for all Pact smart contracts are defined in Pact modules and interfaces. As Pact code, modules and interfaces have some similarities, but they are used differently have different usage rules. A a high level: - Module are typically self-contained logical units with all of the code necessary to create an application or a service—including schemas and tables—and can be upgraded after they are deployed. - Interfaces enable modules to interact by defining constant values and typed function signatures for common operations that can't be changed except by defining a new interface. Module declaration All of the functions and data definitions required to complete business operations are defined within the context of a module. For simple contracts, all of the business logic might be defined in a single module. You can also use modules as composable units that interoperate if iit makes complex logic easier to navigate. Whether you are building a contract as a single, self-contained Pact module or using multiple modules, module declarations typically include the following components: - Capability definitions - Schema definitions - Table definitions - Function definitions - Multi-step defpact definitions - Constant value definitions There are also components that are required by smart contracts that aren't part of the module declaration, but are defined outside of the module code. For example, the code related to the following components is considered to be outside of and separate from the module declaration: - Namespace definition - Keyset definitions - Table creation - Function calls In addition to the module declaration and the components that aren't included in the module declaration, modules often require information passed in as message data, separate from the Pact code, but part of the transaction payload. For example, a module might require keys or environment data that's referenced in Pact code, but provided as part of the JSON object to be executed as a transaction. Modules and smart contracts When you start working with Pact, you typically create single modules that contain the full functionality of your smart contract, much like most of the examples in the coding projects. Using a single module to define a contract keeps your codebase simple and straightforward because there's only one file to keep track of. However, as you begin writing more complex or sophisticated programs, you might find it more convenient to split the smart contract logic into multiple modules that work together to compose the complete application. In a typical smart contract—the full application—each individual module can provide a focused set of functionality with clear organizational logic. Because a smart contract can be defined using one module or many modules and interfaces, the logic in individual Pact file—with the. pact file extension—is always referred to as a module or an interface. Module keyword and owner You can start a module declaration by typing the module keyword, followed by the module name and the keyset or governance capability that owns the module. The following example illustrates a module named example that is governed by the admin-keyset referenced in the first line of the module declaration: Code example (pact): ; ; Define and read keysets (module example \"admin-keyset\"; ; module code goes here; ; function calls ) The entire example module consists of the code within the opening and closing parentheses. Top-level code, like namespace definitions and keyset definitions, are outside of these parentheses. For example, you enter a namespace and define a keyset for a module before starting the module declaration like this: Code example (pact): ; ; Enter a namespace (namespace \"free\"); ; Define and read a keyset (define-keyset \"free. admin-keyset\" (read-keyset \"admin-keyset\")) (module example \"admin-keyset\"; ; module code goes here; ; function calls ) Module governance With keyset governance like the previous example, the admin-keyset is defined outside of the module and checked and enforced at the module level. Any attempt to upgrade the module, write to module tables, or access table functions directly requires the admin-keyset to sign the transaction. As an alternative to strict keyset enforcement, you can specify a governance capability in the module declaration to support a more generalized form of module governance. By using a governance capability that references a defcap declaration in the module body, you can define more flexible models for enforcing access to Pact modules, tables, and functions. For example, you can implement the same governance for the example module using a governance capability named GOVERNANCE like this: Code example (pact): (module example GOVERNANCE. . . (defcap GOVERNANCE () (enforce-guard \"admin-keyset\")). . . ) Note that the capability name has no significance, except to indicate the purpose of the capability. Its placement at the beginning of the module declaration is what identifies this capability as a module governance capability. It's worth noting that, when you initially deploy a module, the module governance capability is not invoked. This behavior is different than when you use a keyset. With a keyset, the keyset must always be defined and evaluated to ensure that the keyset exists before a module can be deployed. The module governance capability is enforces after a module is deployed, when it's accessed or upgraded. Invoking governance Because the module governance capability is defined using the defcap keyword, its elevated administrative function cannot be called directly. The module administrator elevated permissions are only automatically invoked in the following situations: - When a module upgrade is attempted. - When module tables are directly accessed from outside of the module code. Transactions that attempt to upgrade a module or access module tables can only be executed by the module owner specified by the module administrator capability—in this example, the GOVERNANCE capability. If the conditions specified for the GOVERNANCE capability are met, full administrative rights are granted. Module administrator scope The module administrator capability, once automatically invoked, stays in scope for the rest of the calling transaction. This is unlike other capabilities that can only be acquired in a fixed scope specified by the body of a with-capability function call. The reason for this difference in behavior is to ensure that a governance capability doesn't rely on transient information that can change during a single transaction. This is important, for example, in the case of module upgrades. A module upgrade might change the governance capability itself. If the module administrator capability didn't remain in scope through the completion of the transaction, the upgrade might fail because the administrative capability is required to migrate table data as part of the upgrade process. Stakeholder upgrade vote The following example demonstrates how to upgrade a module based on a stakeholder vote. The upgrade is designed as a Pact transaction, and its hash and code are distributed to stakeholders, who vote for or against the upgrade. After the upgrade transaction is distributed, the vote is tallied in the governance capability, and if a simple majority is found, the code is upgraded. Code example (pact): (module govtest count-votes \"Demonstrate programmable governance showing votes \\ \\ for upgrade transaction hashes\" (defschema vote vote-hash: string) (deftable votes: {vote}) (defun vote-for-hash (user hsh) \"Register a vote for a particular transaction hash\" (write votes user { \"vote-hash\": hsh }) ) (defcap count-votes () \"Governance capability to tally votes for the upgrade hash\". (let ((h (tx-hash)) (tally (fold (do-count h). . . [code continues] Module properties and components As you've seen, module declarations start with the module keyword and a name. Module names must be unique within a namespace. You can define custom namespaces for local development. However, you must deploy modules to a registered namespace in the Kadena test or production networks. Module declarations use the following keywords to define module components: - defun to define module functions. - defschema to define schemas for module tables. - deftable to define the tables to create for a module. - defpact to define multi-step transactions in the module. - defconst to define constant value variables in the module. - defcap to define capabilities in the module. - use to import functions from other modules into the module. - implements to implement functions from interfaces exposed in other modules into the module. Modules can also include different types of metadata, such as documentation strings or information for emitted events. When a module is declared, all references to native functions, interfaces, or definitions from other modules are resolved. Resolution failure results in transaction rollback. Module versioning and dependencies Module versioning is not supported, except by including a version identifier in the module name, for example, accounts-v1 or marmalade-v2. However, you can use module hashes to import a specific version of a module with the use keyword. By specifying a module hash when you import the module, you can link your code to a particular release of a module that's identified by the hash. By combining module imports with module hashes, you can ensure that updated module code will fail to import if a dependent module has subsequently changed on the chain. Module table creation Tables are created at the same time as modules and include the module name as a prefix to the table name. With this naming convention, the module acts as a guard to protect access to tables using database functions that are controlled by the module owner. You can create any number of tables in a module. It’s important to note that you define table schemas, the tables that use the schemas, and the functions that insert, read, and modify database records inside of module code, but you create tables outside of module code. That is, tables are defined in modules, but they are created after the module declaration. This separation allows module code to be potentially updated without recreating the table. Interfaces In Pact, interfaces represent an abstract API that modules can implement to make use of the constants and typed function signatures that an interface defines. To make use of the components defined in an interface, module declarations can include one or more implements statements to specify the interface from which the module wants to implement features. A single module can implement multiple interfaces. However, if you implement interfaces with conflicting function names, you must resolve the conflict in your code or by redefining the interfaces to remove the conflict. Interface properties and components You can declare an interface using the interface keyword followed by the name for the interface. Interface names must be unique within a namespace. Interfaces can't be upgraded and aren't governed by keysets or a governance capability. Interfaces can import definitions from other modules with use statements to construct new constant definitions, or make use of types or functions defined in the imported module. Modules can implement interfaces that include the following components: - function signatures - constant values - schema definitions - defpact specifications - capability specifications - imported definitions from other modules The following example illustrates how to declare and implement an interface with one function signature and one constant value: Code example (pact): (interface my-interface (defun hello-number: string (number: integer) @doc \"Return the string \\\"Hello, $number! \\\" when given a string\" ) (defconst SOMECONSTANT 3) ) (module my-module (read-keyset 'my-keyset) (implements my-interface) (defun hello-number: string (number: integer) (format \"Hello, {}! \" [number])) (defun square-three () ( my-interface. SOMECONSTANT my-interface. SOMECONSTANT)) ) As you can see in this example, the my-module module implements the hello-number function signature. The constant declared in the interface is accessed directly by its fully qualified name namespace. interface. const. Implements and use keywords You can create complex and layered relationships between interfaces and modules. One important way you can create this layered relationships is by using combinations of the implements and use keywords. The use keyword enables you to import elements from the specified module into a namespace, interface, or module. For example, you can specify the use keyword in an interface declaration to import table schemas and types from a specified module. You can also include use statements at the top-level of a contract or within a module declaration to make all or parts of a specified module available in the current module context. For example, you can specify a list of functions, constants, and schema names to import from the specified module. If you explicitly define the function, constant, and schema names to import, only those items are available in the module body. You can also specify a hash argument in use statements to check that an imported module's hash matches the hash you expect, and fail if the hashes are not the same. By including the hash argument in a use statement, you can perform a simplified form of version control or dependency checking. The following example is an excerpt from the marmalade-v2. ledger module that illustrates the relationships created by combining implements and use statements. In this example, marmalade-v2 is the primary namespace where the ledger contract is deployed. Code example (pact): (namespace (read-string 'ns)) (module ledger GOVERNANCE (implements marmalade-v2. ledger-v2) (implements kip. poly-fungible-v3) (use kip. poly-fungible-v3 [account-details sender-balance-change receiver-balance-change]) (use kip. token-policy-v2 [token-info]) (use util. fungible-util) (use marmalade-v2. policy-manager). . . ) This module implements the ledger-v2 interface that defines a set of capabilities. Code example (pact): (interface ledger-v2 (defcap INIT-CALL: bool (id: string precision: integer uri: string) @doc \"Capability securing the modref call for enforce-init \" ). . . ) The module also implements the poly-fungible-v3 interface and imports the specified functions. Code example (pact): (interface poly-fungible-v3 (defschema account-details @doc \" Account details: token ID, account name, balance, and guard. \" id: string account: string balance: decimal guard: guard) (defschema sender-balance-change @doc \"For use in RECONCILE events\" account: string previous: decimal current: decimal ) (defschema receiver-balance-change @doc \"For use in RECONCILE events\" account: string previous: decimal current: decimal ). . . ) For more information about the syntax for using these keywords, see the implements and use syntax descriptions. Module references Pact module references enable you to support use-cases that require polymorphism. For example, a Uniswap-like exchange allows users to specify pairs of tokens to allow trading between them. The Pact fungible-v2 interface allows tokens to offer identical operations such as transfer-create. However, without a way to abstract over different fungible-v2 implementations, an exchange smart contract would have to be upgraded for each token pair with custom code for every operation. For example: Code example (pact): ; ; ; simplified DEX example with hardcoded dispatching on token symbols (defun swap ( a-token: string a-amount: decimal a-account: string b-token: string b-amount: decimal b-account: string ) (with-read pair-accounts (format \"{}: {}\" [a-token b-token]) { 'pair-a-account: = pair-a-account, 'pair-b-account: = pair-b-account } (cond ((= \"KDA\" a-token) (coin. transfer a-account pair-a-account a-amount)) ((= \"KBTC\" a-token) (kbtc. ledger. transfer a-account p. . . [code continues] With module references, an exchange-type smart contract can accept pairs of values where each value references a concrete module that implements the fungible-v2 interface, giving it the ability to call fungible-v2 operations using those values. For example: Code example (pact): ; ; ; simplified DEX example with module references in a dynamic dispatch (defun swap ( a-token: module{fungible-v2} a-amount: decimal a-account: string b-token: module{fungible-v2} b-amount: decimal b-account: string ) (with-read pair-accounts (format \"{}: {}\" [a-token b-token]) { 'pair-a-account: = pair-a-account, 'pair-b-account: = pair-b-account } (a-token: : transfer a-account pair-a-account a-amount) (b-token: : transfer pair-b-account b-account b-amount)) ) To invoke the swap function, the module names are directly referenced in code. Code example (pact): (swap coin a-amount a-account kbtc. ledger b-amount b-account) Module reference values are normal Pact values that can be stored in the database, referenced in events, and returned from functions. Code example (pact): ; ; ; simplified DEX example with stored pair module reference values (defun swap ( pair-symbol: string a-amount: decimal a-account: string b-amount: decimal b-account: string ) (with-read pair-accounts pair-symbol { 'pair-a-account: = pair-a-account: string, 'a-token: = a-token: module{fungible-v2}, 'pair-b-account: = pair-b-account: string, 'b-token: = b-token: module{fungible-v2} } (a-token: : transfer a-account pair-a-account a-amount) (b-token: : transfer pair-. . . [code continues] Polymorphism Module reference values provide polymorphism for use cases like the previous example with an emphasis on interoperability. A module reference is specified with one or more interfaces, allowing for values to reference modules that implement those interfaces. In the previous example, the module reference a-token: module{fungible-v2} accepts a reference to the Kadena coin KDA token module, because coin implements fungible-v2. There's nothing special about the fungible-v2 interface. Module references can specify any defined interface and accept any module that implements the specified interface. The Pact module reference polymorphism is similar to generics in Java or traits in Rust, and should not be confused with more object-oriented polymorphism like that found with Java classes or TypeScript types. Modules cannot extend one another. They can only offer operations that match some interface specification, and interfaces themselves cannot extend other interface. You should note that module references introduce indirection and, therefore, can increase the overall complexity of Pact smart contracts, making contract logic harder to understand and reason about. You should only use module references when you need to provide flexible interoperation between smart contracts. If all of the modules are your own code, you should use direct references instead of external module references whenever possible. Reference value binding Module references use the latest upgraded version of the referenced module when you invoke a module operation. For example, consider a module reference to a payments module stored in the database when the payments module is at version 1. Sometime later, the payments module is upgraded to version 2. The module reference in the database will refer to the upgraded version 2 of the payments module when the reference is called. This behavior is different from Pact direct references, which are not late-binding, so you should consider this difference in module reference behavior to prevent returning unexpected results. Referencing untrusted code Because module references allow external modules to interoperate with your code, you should not assume that the external code is safe. Instead, you should treat any module reference call as a call to untrusted code. In particular, you should be aware that invoking module references in the context of acquiring a capability can result in unintended privilege escalation. For example, the following data-market module has a public collect-data function that is intended to allow external modules to provide some data, resulting in the one-time payment of a fee. The external modules implement a data-collector interface with a collect function to get the data and a get-fee-recipient function to identify the receiving account. In this example, the data-market module code acquires the COLLECT capability, and uses this capability to prevent collect and a get-fee-recipient functions from being called directly. However, with the wrong code, this seemingly benign code can be exploited by a malicious module reference implementation: Code example (pact): (module data-market GOVERNANCE. . . (defun collect-data (collector: module{data-collector}) \"Provide data, get paid! \"; ; BAD: capability acquired before modref calls (with-capability (COLLECT); ; BAD: modref invoked with capability in scope! (store-data (collector: : collect)) (pay-fee (collector: : get-fee-recipient))) ) (defun pay-fee (account: string) \"Private function to pay one-time fee for collection\" (require-capability (COLLECT)) (coin. transfe. . . [code continues] The problem with the module code is that the with-capability call happens before the calls to the module reference operations, such that while the external module code is executing, the COLLECT capability is in scope. While the COLLECT capability is in scope, the pay-fee and store-data functions can be called from anywhere. Malicious code could exploit this code with a module reference that calls the data-market. pay-fee function repeatedly in the seemingly innocent calls to the collect or get-fee-recipient functions. Malicious code could also call the data-market. store-data function and wreak havoc that way. The important point in this example is that once a capability is in scope, the protections provided by the require-capability function aren't available. Fortunately, you can avoid this situation by keeping module reference calls outside of the scope of the sensitive capability. For example: Code example (pact): (defun collect-data (collector: module{data-collector}) \"Provide data, get paid! \"; ; GOOD: modref invoked before with-capability call (let ((data (collector: : collect)) (account (collector: : get-fee-recipient))) (with-capability (COLLECT) (store-data data) (pay-fee account)))) In this example, the module reference calls have safely returned before the COLLECT capability is acquired. A malicious implementation has no way to invoke the sensitive code. Coding with module references You can reference modules and interfaces directly by issuing their name in code. For example: Code example (pact): (module foo 'k (defun bar () 0)) (namespace ns) (interface bar (defun quux: string ())) (module zzz 'k (implements bar) (defun quux: string () \"zzz\")) foo; ; module reference to 'foo', of type 'module' ns. bar; ; module reference to bar interface, also of type 'module' ns. zzz; ; module reference to zzz module, of type 'module{ns. bar}' Using a module reference in a function is accomplished by specifying the type of the module reference argument, and using the dereference operator: : to invoke a member function of the interface specified in the type. Code example (pact): (interface baz (defun quux: bool (a: integer b: string)) (defconst ONE 1) ) (module impl 'k (implements baz) (defun quux: bool (a: integer b: string) (> (length b) a)) ). . . (defun foo (bar: module{baz}) (bar: : quux 1 \"hi\"); ; dereferences 'quux' on whatever module is passed in bar: : ONE; ; directly references interface const ). . . (foo impl); ; 'impl' references the module defined above, of type 'module{baz}' You should use module reference calls in use cases that require dynamic evaluation of a function or interface or when an interface requires multiple implementations. For example, decentralized exchanges and liquidity pools typically require module references. You should avoid using use module reference calls where you have a capability that you are using to guard resources could be brought into scope in an external module. For example, if you are using the INTERNALFUNDSCAP to guard account funds in the mymodule module, you shouldn't bring that capability into scope before calling the external module: Code example (pact): (module mymodule GOVERNANCE. . . (defcap INTERNALFUNDSCAP true); my capability for funds owned by this module (defconst MODULEACCOUNTGUARD (create-capability-guard (INTERNALFUNDSCAP)) (defconst MODULEACCOUNT (create-principal MODULEACCOUNTGUARD)) (defun withdraw (person: string amount: decimal mref: module{fungible-v2}) (with-capability (INTERNALFUNDSCAP) (mref: : transfer person MODULEACCOUNT amount) (coin. transfer MODULEACCOUNT person amount)))) In this example, the INTERNALFUNDSCAP capability—which should only be brought into scope for the coin. transfer call—is in scope for both the external mref: : transfer call and the coin. transfer call. With this vulnerability, a malicious user could write a module that satisfies the fungible-v2 interface that drains all of the funds from mymodule because the INTERNALFUNDSCAP is in scope. To fix the issue, you need to change where the call that grants the INTERNALFUNDSCAP capability is brought into scope: Code example (pact): (defun withdraw (person: string amount: decimal mref: module{fungible-v2}) (mref: : transfer person MODULEACCOUNT amount) (with-capability (INTERNALFUNDSCAP) (coin. transfer MODULEACCOUNT person amount)))) Securing module reference calls Pact has always relied on restricting loops and preventing recursion to provide security guarantees. These security measure ensure that your program can never enter into an infinite loop and functions can't call into themselves. However, module references introduced a potential vulnerability that Turing incompleteness alone didn't address. In particular, virtual calls to module code that were not controlled by the module caller have been difficult for module authors to make secure. While functions are not allowed to recurse, module references don't prevent virtual calls from reentering the calling module. If the virtual call then calls a separate credit or debit function, that call isn't considered recursion down the call stack. For applications that rely on module references to provide the function interfaces they use, this behavior— combined with the importance of controlling capability scope—has made it difficult for contract authors to write secure contract code. As a security enhancement, Pact 5. 3 introduces module reference calls that are ready-only by default. With Pact 5. 3, any module reference function call that reenters the originating module is treated as a read-only call to prevent database modification and code reentry attacks. For example, assume you have a my-token module with the module reference fungible: : transfer-create. If the fungible module tries to call back into the my-token module to execute a withdraw-funds or deposit-funds function, the operation isn't allowed because all calls from the fungible module reference are read-only by default. ``pact (module my-token GOVERNANCE. . . (defconst MODULEGUARD (create-capability-guard (SOME-SECURE-CAP))) (defconst MODULEOWNEDACCOUNT: string (create-principal. . . )) (defun withdraw-funds (account: string destination: module{fungible-v2}) (require-capability (SOME-SECURE-CAP)) # Code withdraws funds and transfers them to a particular account ) (defun deposit-funds (account: string amount: decimal fung: module{fungible-v2}) (with-capability (SOME-SECURE-CAP) (fungible: : transfer-create account MODULEOWNEDACCOUNT MODULEGUARD amount))) ) ` If the fungible: : transfer-create function were written to call back into my-token, calls back into my-token from the fungible module reference would be allowed to retrieve information, such as account details, but not modify balances or any database entries that are part of the my-token` module. For projects like decentralized exchanges (DEX) and bridges that require virtual calls, this enhancement enables Pact to provide module-level security guarantees against reentry attacks.",
    "source": "smart-contracts/modules.md",
    "title": "Modules and interfaces"
  },
  {
    "content": "There are two types of transaction in Pact smart contracts: transactions that execute in a single step and transactions that consist of more than one step. Transaction format and lifecycle There are two types of transaction in Pact smart contracts: - Transactions that execute in a single step, identified in Pact code as exec transactions. - Transactions that continue a sequence with more than one step, identified in Pact code as cont transactions. Most transactions execute as a single step with a single message that is sent to a blockchain node to be evaluated by Pact. The execution of the code in the message is atomic and the transaction succeeds as a complete unit, or doesn't succeed at all. For these types of transactions, Pact doesn't allow partial execution or provide any concept for rollback handling. For transactions that consist of more than one step, each step is effectively a single transaction. However, each step must be executed in sequence and if any step in the sequence fails, the entire transaction can be rolled back to its initial state or allowed to continue without rollback handling. For example, a cross-chain transfer is essentially a two-step transaction, with a debit transaction initiated on a source chain and a separate credit transaction occurring on a destination chain. Without rollback handling, if the second step isn't called to complete the transaction, the first step becomes an orphan and the intended transfer operation remains in an incomplete, interrupted state. However, multi-step transactions can include a rollback step so that if a specific condition exists, a previously completed steps can be reversed. For example, if an asset is moved from a seller's account to an escrow account awaiting a buyer to complete the transaction, the transfer can be reversed if the buyer doesn't complete necessary steps within a previously agreed upon time. Single-step transactions are defined in smart contracts as function calls using the defun reserved keyword, as previously introduced in Define a function. Transactions with multiple steps are defined in smart contracts using the defpact, step, and step-with-rollback reserved keywords. Transaction formats Given that there are two types of transactions, there are also two transaction formats. The format for transaction execution requests—that is, the exec transaction type—is the same for single-step transactions and the first step (0) in multi-step defpact transactions. These transactions always contain the Pact code to execute, either as raw embedded code or as a reference to a. pact file. By contrast, continuation requests—cont requests—don't contain Pact code. For a defpact transaction, the first step, step 0, initiates the transaction using the exec transaction format. Subsequent step or step-with-rollback code blocks use the continuation—the cont transaction type—format. Instead of containing Pact code, continuation requests reference the defpact identifier that links the steps together and the continuation step they are attempting to execute. The difference between execution transaction requests and continuation transaction requests is reflected in the different fields required to construct the transactions. For example, if you're constructing a transaction request using the YAML API format, you use the exec payload format for defun and defpact execution requests and the cont payload format for the continuation requests for defpact steps after the first step. Execution request format The following template describes the YAML format for signed execution transaction requests: Code example (yaml): code: Pact code to execute for the transaction codeFile: Pact file that contains the transaction code to execute data: JSON data to include in the transaction dataFile: JSON data file for the transaction keyPairs: [ List of public and secret key pairs for signing - public: Base 16 public key secret: Base 16 secret key caps: [ List of capabilities and arguments (optional) - name: args: ] ] nonce: Request nonce or current time if not provided (optional) networkId: String. . . [code continues] You can generate public and private key pairs that use the Ed25519 signature scheme by running pact --genkey. Both keys are required to submit signed transaction execution requests. If you only want to include the public key in a transaction execution request, you can use the unsigned YAML request format. The YAML format for unsigned requests is similar to the format for signed requests. However, in an unsigned request, a signers attribute replaces the keyPairs attribute: Code example (yaml): code: Pact code to execute for the transaction codeFile: Pact file that contains the transaction code to execute data: JSON data to include in the transaction dataFile: JSON data file for the transaction signers: [ List of public keys for required signers - public: Base 16 public key caps: [ List of capabilities and arguments (optional) - name: args: ] ] nonce: Request nonce or current time if not provided (optional) networkId: String identifier for the blockchain network p. . . [code continues] Continuation request format The following template describes the YAML format for continuation transaction requests: Code example (yaml): pactTxHash: integer transaction identifier for a defpact step: integer next step of a defpact rollback: boolean for rolling back a defpact step proof: string spv proof of continuation (optional, cross-chain only) data: JSON transaction data dataFile: JSON transaction data file keyPairs: list of key pairs for signing (use pact -g to generate): [ public: string base 16 public key secret: string base 16 secret key caps: [ optional capabilities ] ] networkId: string identifier for a bl. . . [code continues] Basic transaction flow After you have a transaction message properly formatted as a JSON object, it can be executed locally for testing purposes or sent to the blockchain for execution on-chain. You submit transactions to the blockchain for on-chain execution by connecting to a node using the Pact /send endpoint. In most cases, the node you connect to is a node that you control—in the local development environment, the public test network, or the production main network. Before moving the transaction into a pending state, Pact performs some initial checks on the message to validate that the transaction doesn't have errors that would prevent it from being executed. These initial checks include verifying the signatures format, metadata, and the availability of funds to pay transaction fees. If there are issues—like an invalid signature or a time-to-live (TTL) that has expired—the transaction fails immediately without further processing. If the initial checks pass, the node receiving the transaction message assigns the message a unique transaction identifier (txid) and inserts the transaction into its holding area for pending transactions, called the mempool. The transactions waiting to be included in a block are synchronized across all of the nodes. Mining nodes, typically Chainweb nodes with specialized application-specific integrated circuit hardware attached, periodically check the transaction pool—the mempool—for new work and select transactions to validate based on their transaction fees. After the mining node computes the solution that validates the transaction, it includes the transaction in its next block. The block that includes the transaction is then sent to all of the nodes in the network, including the node where the transaction originated. The following diagram provides a simplified view of the transaction flow for a single-step exec transaction. ! Transaction lifecycle Throughout its lifecycle, there are several ways you can check the status of the transaction using the transaction identifier or request key. For example, you can use the Pact /listen endpoint to wait for the results from a single transaction or the Pact /poll endpoint to poll the node for one or more transaction results without blocking new requests. You can also check whether transactions are pending in the mempool by calling the peer-to-peer API endpoints, such as the /mempool/member and /mempool/lookup endpoints. If you don't want to use the Pact API or the peer-to-peer API to see results, you can enter the transaction request key in a block explorer, such as explorer. kadena. io/mainnet or explorer. kadena. io/testnet. Multi-step transaction flow At a high level, the workflow for transactions with more than one step is the same as single-step transactions. However, transactions with more than one step require a both an initial transaction request and a continuation message to be sent to a node. Depending on the logic in the smart contract, each part of the transaction might be initiated by the same entity or required to be initiated by different entities. The logic in the smart contract also determines whether each step can be rolled back to a previous state under specific conditions or discontinued as an incomplete operation. Much like single-step transactions, the node receiving the first step in a defpact transaction message assigns the message a unique identifier (pact-id). This identifier is what ties the steps together as parts of the same transaction. The remainder of the workflow for the first step in a defpact transaction is the same as any other execution request. Two-step transactions without rollback In cross-chain transfers, a receiving account is typically responsible for sending the continuation transaction request and paying the transaction fee associated with that request. However, any account—including a dedicated autonomous gas station account—can sign and send the continuation request. If there's a delay in sending the continuation request, the transfer operation remains incomplete. Two-step transactions with rollback Multi-step defpact transactions can also include logic to rollback a step under specified conditions. For example, you can use a defpact transaction to orchestrate operations similar to an escrow service, moving assets into a holding account until contractual obligations are met and the releasing assets only after all parties have completed require actions. A step with rollback logic could specify a time limit for completing required actions and return assets to the original account if all required steps aren't completed within the time allowed.",
    "source": "smart-contracts/transactions.md",
    "title": "Transaction format and flow"
  }
]