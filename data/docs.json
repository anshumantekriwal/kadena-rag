[
  {
    "content": "title: Smart contracts id: smart-contract-dev description: \"The Kadena Smart contract developers content provides a roadmap for learning how to write smart contracts and frontend user interfaces for applications that run on the Kadena blockchain network.\" sidebar_position: 2 tags: [pact, typescript, account, transactions, utils] Smart contract development Kadena Developer documentation is organized into three main content areas: The Smart contracts portion of the documentation is all about learning to write smart contracts and build applications using the Pact smart contract programming language for the Kadena blockchain network. This part of the documentation provides explanations and examples that describe programming language features, introduce Pact-specific concepts and terminology, and expose common programming patterns to help you design and build robust and secure applications. The Reference portion of the documentation provides complete reference information for the Pact programming language—including syntax, keywords, and built-in functions—and the command-line interfaces you can use to interact with Pact smart contracts and the Kadena blockchain in a development, test, or production environment. The Coding projects portion of the documentation provides you with opportunities to apply the information covered in Smart contracts to sample projects with hands-on coding challenges. Get started with Pact In Get started, you'll get an introduction to smart contract development, Pact design principles, and how to navigate the documentation. After the introduction, topics align loosely with the software development life cycle, moving from basic concepts and simple examples to more complex topics as you explore Pact language features and common coding patterns. At a high level, topics are organized to cover the following stages of the software development life cycle: Learn the fundamentals of the programming language. Build programs with common core components like functions and tables. Test and debug your code to verify and improve its functionality. Iterate and update code when changes are required. Integrate user experiences and frontend frameworks. Deploy smart contracts for further testing or into production. Reference The Reference content area is where you'll find the information you most frequently need to look up. For example, the Reference content area contains the descriptions and examples for all of the Pact built-in functions. In general, reference information is organized alphabetically and easiest to find by using Search. Coding projects The Coding projects content area provides instructional material for working with the sample projects located in the repository. The topics that correspond with the sample projects illustrate concepts in action and complement explanation topics with hands-on exercises and coding challenges. The projects themselves highlight common use cases that can be adapted to many scenarios or extended to address new use cases.",
    "source": "smart-contract-dev.md",
    "title": "smart-contract-dev"
  },
  {
    "content": "title: Quick start description: \"Learn how to set up a development environment and write a simple smart contract for the Kadena network.\" slug: quickstart import Link from '@docusaurus/Link'; import CodeBlock from '@theme/CodeBlock'; Quick start for Kadena developers Welcome to the Kadena development Quick start guide. Follow these simplified instructions to set up your development environment with a local blockchain and developer tools, then write your first contract using the Pact smart contract programming language. Before you begin Before you begin, verify your computer meets the following basic requirements and has the following tools installed: Access to the internet, an interactive terminal shell, and a web browser. Git version control program. You can verify that is installed by running on your computer. Node.js, version 18 or higher. You can verify that is installed by running on your computer. npm, the command-line interface for the node package manager. You can verify that is installed by running on your computer. Docker, version x or higher. You can verify that is installed by running on your computer. If you have everything you need, you can set up your development environment and deploy your first contract with a few basic steps. Install Pact The Pact smart contract programming language is specifically designed for writing smart contracts to run safely and efficiently on the Kadena blockchain network. Follow the appropriate instructions for your operating system to Pact. Install Pact on Linux Install Pact on macOS Install Pact on Microsoft Windows Services for Linux (WSL) For more information about installing Pact, see Installation and setup. Set up a local network The Kadena development network allows you to run a standalone local blockchain node to simulate network operations and to test your smart contracts locally before deploying to a test or production network. To set up the local network, open a terminal shell on your computer then run the following commands to get the development network Docker image and start the network in a Docker container: For more information about starting the Kadena development network in a Docker container, see Set up the local network. Install the Kadena command-line interface The Kadena command-line interface () provides direct access to the Kadena blockchain and commands to create, test, deploy, and manage applications for the Kadena network. You can use the Kadena command-line interface interactively or in scripts and automated workflows. To install and configure the program, open a terminal shell on your computer then run the following commands: The command creates the configuration folder location in your current working directory and adds default network settings to a subfolder, then prompts you to create a wallet. Wallets are an important part of interacting with any blockchain, so you can create one now as part of your initial configuration steps. Follow the prompts displayed to continue setting up your local development environment with a development wallet and an account. For more information about getting started with commands, see Develop with kadena-cli. For command-line reference information, see kadena-cli command reference. Write your first smart contract You can now write and execute a simple smart contract using the Pact smart contract programming language and the Pact interactive interpreter. Open a terminal shell on your computer. Start the Pact interpreter that you installed in the first step by running the following command: Copy and paste the following simple module code, then press return: You should see the module loaded with output similar to the following: Call the function with a string similar to the following: The function returns a greeting similar to the following: If you want to deploy this contract on the local development network, copy the module code to a file with the file extension—for example, create a file—then create a transaction to deploy the module as described in Deploy smart contracts. You can exit the Pact interpreter by pressing control-d on the keyboard. Next steps Congratulations! In this Quick start, you learned the basics of how to set up a development environment with the Pact programming language, a local development network, and the Kadena developer command-line interface. You also got a first look at how to write and execute a simple Pact contract in the interactive interpreter. You can learn more about these topics in Smart contracts documentation. Here are some suggested next steps: Start learning the Pact programming language with Get started: Introduction to Pact. Explore hands-on coding projects in Coding projects. Learn how to interact with the blockchain and deployed contracts using Kadena API calls and How-to guides. Join the Kadena Discord community for support and discussions.",
    "source": "quickstart.md",
    "title": "quickstart"
  },
  {
    "content": "title: Transaction format and flow id: transactions sidebar_position: 10 description: \"There are two types of transaction in Pact smart contracts: transactions that execute in a single step and transactions that consist of more than one step.\" Transaction format and lifecycle There are two types of transaction in Pact smart contracts: Transactions that execute in a single step, identified in Pact code as transactions. Transactions that continue a sequence with more than one step, identified in Pact code as transactions. Most transactions execute as a single step with a single message that is sent to a blockchain node to be evaluated by Pact. The execution of the code in the message is atomic and the transaction succeeds as a complete unit, or doesn't succeed at all. For these types of transactions, Pact doesn't allow partial execution or provide any concept for rollback handling. For transactions that consist of more than one step, each step is effectively a single transaction. However, each step must be executed in sequence and if any step in the sequence fails, the entire transaction can be rolled back to its initial state or allowed to continue without rollback handling. For example, a cross-chain transfer is essentially a two-step transaction, with a debit transaction initiated on a source chain and a separate credit transaction occurring on a destination chain. Without rollback handling, if the second step isn't called to complete the transaction, the first step becomes an orphan and the intended transfer operation remains in an incomplete, interrupted state. However, multi-step transactions can include a rollback step so that if a specific condition exists, a previously completed steps can be reversed. For example, if an asset is moved from a seller's account to an escrow account awaiting a buyer to complete the transaction, the transfer can be reversed if the buyer doesn't complete necessary steps within a previously agreed upon time. Single-step transactions are defined in smart contracts as function calls using the reserved keyword, as previously introduced in Define a function. Transactions with multiple steps are defined in smart contracts using the , , and reserved keywords. Transaction formats Given that there are two types of transactions, there are also two transaction formats. The format for transaction execution requests—that is, the transaction type—is the same for single-step transactions and the first step (0) in multi-step transactions. These transactions always contain the Pact code to execute, either as raw embedded code or as a reference to a file. By contrast, continuation requests— requests—don't contain Pact code. For a transaction, the first step, step 0, initiates the transaction using the transaction format. Subsequent or code blocks use the continuation—the transaction type—format. Instead of containing Pact code, continuation requests reference the identifier that links the steps together and the continuation step they are attempting to execute. The difference between execution transaction requests and continuation transaction requests is reflected in the different fields required to construct the transactions. For example, if you're constructing a transaction request using the YAML API format, you use the exec payload format for and execution requests and the cont payload format for the continuation requests for steps after the first step. Execution request format The following template describes the YAML format for signed execution transaction requests: You can generate public and private key pairs that use the Ed25519 signature scheme by running . Both keys are required to submit signed transaction execution requests. If you only want to include the public key in a transaction execution request, you can use the unsigned YAML request format. The YAML format for unsigned requests is similar to the format for signed requests. However, in an unsigned request, a attribute replaces the attribute: Continuation request format The following template describes the YAML format for continuation transaction requests: Basic transaction flow After you have a transaction message properly formatted as a JSON object, it can be executed locally for testing purposes or sent to the blockchain for execution on-chain. You submit transactions to the blockchain for on-chain execution by connecting to a node using the Pact endpoint. In most cases, the node you connect to is a node that you control—in the local development environment, the public test network, or the production main network. Before moving the transaction into a pending state, Pact performs some initial checks on the message to validate that the transaction doesn't have errors that would prevent it from being executed. These initial checks include verifying the signatures format, metadata, and the availability of funds to pay transaction fees. If there are issues—like an invalid signature or a time-to-live (TTL) that has expired—the transaction fails immediately without further processing. If the initial checks pass, the node receiving the transaction message assigns the message a unique transaction identifier (txid) and inserts the transaction into its holding area for pending transactions, called the mempool. The transactions waiting to be included in a block are synchronized across all of the nodes. Mining nodes, typically Chainweb nodes with specialized application-specific integrated circuit hardware attached, periodically check the transaction pool—the mempool—for new work and select transactions to validate based on their transaction fees. After the mining node computes the solution that validates the transaction, it includes the transaction in its next block. The block that includes the transaction is then sent to all of the nodes in the network, including the node where the transaction originated. The following diagram provides a simplified view of the transaction flow for a single-step exec transaction. Throughout its lifecycle, there are several ways you can check the status of the transaction using the transaction identifier or request key. For example, you can use the Pact endpoint to wait for the results from a single transaction or the Pact endpoint to poll the node for one or more transaction results without blocking new requests. You can also check whether transactions are pending in the mempool by calling the peer-to-peer API endpoints, such as the and endpoints. If you don't want to use the Pact API or the peer-to-peer API to see results, you can enter the transaction request key in a block explorer, such as explorer.kadena.io/mainnet or explorer.kadena.io/testnet. Multi-step transaction flow At a high level, the workflow for transactions with more than one step is the same as single-step transactions. However, transactions with more than one step require a both an initial transaction request and a continuation message to be sent to a node. Depending on the logic in the smart contract, each part of the transaction might be initiated by the same entity or required to be initiated by different entities. The logic in the smart contract also determines whether each step can be rolled back to a previous state under specific conditions or discontinued as an incomplete operation. Much like single-step transactions, the node receiving the first step in a transaction message assigns the message a unique identifier (pact-id). This identifier is what ties the steps together as parts of the same transaction. The remainder of the workflow for the first step in a transaction is the same as any other execution request. Two-step transactions without rollback In cross-chain transfers, a receiving account is typically responsible for sending the continuation transaction request and paying the transaction fee associated with that request. However, any account—including a dedicated autonomous gas station account—can sign and send the continuation request. If there's a delay in sending the continuation request, the transfer operation remains incomplete. Two-step transactions with rollback Multi-step transactions can also include logic to rollback a step under specified conditions. For example, you can use a transaction to orchestrate operations similar to an escrow service, moving assets into a holding account until contractual obligations are met and the releasing assets only after all parties have completed require actions. A step with rollback logic could specify a time limit for completing required actions and return assets to the original account if all required steps aren't completed within the time allowed.",
    "source": "smart-contracts/transactions.md",
    "title": "transactions"
  },
  {
    "content": "title: Modules and references description: \"Modules that define the business logic and essential functions for blockchain applications and provide the basic foundation for all Pact smart contracts.\" id: modules sidebar_position: 7 Modules and references The fundamental building blocks for all Pact smart contracts are defined as Pact modules. For simple contracts, a module often acts as a mostly self-contained logical unit with all of the code necessary to create an application or a service. All of the functions and data definitions required to complete business operations are defined within the context of a module. Although you can use modules as composable and callable units that interoperate in a smart contract, modules typically include the following components: Schema definitions Table definitions Functions definitions Multi-step defpact definitions Constant values Some elements of smart contracts are defined in modules but aren't contained withing the module itself. For example, modules don't contain the following elements in the code that's included in the module itself: Namespace definition Keyset definitions Table creation Function calls The code related to these elements is considered to be outside of and separate from the module definition. Modules and smart contracts When you start working with Pact, you typically create single modules that contain the full functionality of your smart contract, much like most of the examples in the coding projects. Using a single module to define a contract keeps your codebase simple and straightforward because there's only one file to keep track of. However, as you begin writing more complex or sophisticated programs, you'll find it more convenient to split the smart contract logic into multiple modules that work together to compose the complete application. In a typical smart contract—the full application—each individual module can provide a focused set of functionality with clear organizational logic. Because a smart contract can be defined using one module or many modules, the logic in individual Pact files () is always referred to as a module. Module declaration You can create a module by typing the keyword, followed by the module name and the keyset or governance capability that owns the module. The following example illustrates a module named example that is governed by the admin-keyset referenced in the first line of the module declaration: The entire example module consists of the code within the opening and closing parentheses. Top-level code, like definitions and definitions, are outside of these parentheses. For example, you enter a namespace and define a keyset for a module before starting the module declaration like this: Module governance With keyset governance like the previous example, the is defined outside of the module and checked and enforced at the module level. Any attempt to upgrade the module, write to module tables, or access table functions directly requires the to sign the transaction. As an alternative to strict keyset enforcement, you can specify a module governance capability in the module declaration to support a more generalized form of module governance. By using a governance capability that references a declaration in the module body, you can define more flexible models for enforcing access to Pact modules, tables, and functions. For example, you can implement the same governance for the example module using a governance capability named GOVERNANCE like this: Note that the capability name has no significance, except to indicate the purpose of the capability. Its placement at the beginning of the module declaration is what identifies this capability as a module governance capability. It's worth noting that, when you initially deploy a module, the module governance capability is not invoked. This behavior is different than when you use use a keyset. With a keyset, the keyset must always be defined and evaluated to ensure that the keyset exists before a module can be deployed. Therefore, you might consider module governance using a capability to be more risky than using a keyset. You should test modules thoroughly when implementing module governance capabilities to ensure that you don't introduce bugs that might prevent a module from being upgraded. Invoking governance Because the module governance capability is defined using the keyword, its administrative function cannot be called directly. It is automatically invoked in the following circumstances: Module upgrade is attempted. Module tables are directly accessed from outside of the module code. Under these circumstances, the transaction is tested for elevated access to the module administrator, defined as the grant of the module administrator capability. This capability cannot be expressed in user code, so it cannot be installed, acquired, required, or composed. However, the capability that implements the module administrator capability—in this example, the capability—can be installed, acquired, required, or composed. If the capability is installed or granted, it's scoped like any other capability over the code that only the module administrator can run. Module administrator scope The module administrator capability, once automatically invoked, stays in scope for the rest of the calling transaction. This is unlike other capabilities that can only be acquired in a fixed scope specified by the body of a function call. The reason for this difference in behavior is to ensure that a governance capability doesn't rely on transient information that can change during a single transaction. This is important, for example, in the case of module upgrades. A module upgrade might change the governance capability itself. If the module administrator capability didn't remain in scope through the completion of the transaction, the upgrade might fail because the administrative capability is required to migrate table data as part of the upgrade process. Stakeholder upgrade vote The following example demonstrates how to upgrade a module based on a stakeholder vote. The upgrade is designed as a Pact transaction, and its hash and code are distributed to stakeholders, who vote for or against the upgrade. After the upgrade transaction is distributed, the vote is tallied in the governance capability, and if a simple majority is found, the code is upgraded. Module properties and components As you've see module declarations start with the keyword and a name. Module names must be unique within a namespace. You can define custom namespaces for local development. However, you must deploy modules to a registered namespace in the Kadena test or production networks. Module declarations use the following keywords to define the following module components: defun to define module functions. defschema to define schemas for module tables. deftable to define the tables to create for a module. defpact to define multi-step transactions in the module. defconst to define constant value variables in the module. defcap to define capabilities in the module. use to import functions from other modules into the module. implements to implement functions from interfaces exposed in other modules into the module. Modules can also include different types of metadata, such as documentation strings or information for emitted events. When a module is declared, all references to native functions, interfaces, or definitions from other modules are resolved. Resolution failure results in transaction rollback. Module versioning and dependencies Module versioning is not supported, except by including a version identifier in the module name, for example, or . However, you can use module hashes to import a specific version of a module with the keyword. By specifying a module hash when you import the module, you can link your code to a particular release of a module that's identified by the hash. By combining module imports with module hashes, you can ensure that updated module code will fail to import if a dependent module has subsequently changed on the chain. Module table creation Tables are created at the same time as modules and include the module name as a prefix to the table name. With this naming convention, the module acts as a guard to protect access to tables using database functions that are controlled by the module owner. You can create any number of tables in a module. It’s important to note that you define table schemas, the tables that use the schemas, and the functions that insert, read, and modify database records inside of module code, but you create tables outside of module code. That is, tables are defined in modules, but they are created after the module declaration. This separation allows module code to be potentially updated without recreating the table. Interfaces In Pact, interfaces represent an abstract API that modules can implement to make use of the constants and typed function signatures that an interface defines. To make use of the components defined in an interface, module declarations can include one or more statements to specify the interface from which the module wants to implement features. A single module can implement multiple interfaces. However, if you implement interfaces with conflicting function names, you must resolve the conflict in your code or by redefining the interfaces to remove the conflict. Interface properties and components You can declare an interface using the keyword followed by the name for the interface. Interface names must be unique within a namespace. Interfaces can't be upgraded and aren't governed by keysets or governance capability. Interfaces can import definitions from other modules with statement to construct new constant definitions, or make use of types or functions defined in the imported module. Modules can implement interfaces that include the following components: function signatures constant values schema definitions defpact specifications capability specifications imported definitions from other modules The following example illustrates how to declare and implement an interface with one function signature and one constant value: As you can see in this example, the module implements the function signature. The constant declared in the interface is accessed directly by its fully qualified name . Implements and use keywords You can create complex and layered relationships between interfaces and modules. One important way you can create this layered relationships is by using combinations of the and keywords. The keyword enables you to import elements from the specified into a namespace, interface, or module. For example, you can specify the keyword in an interface declaration to import table schemas and types from a specified module. You can also include statements at the top-level of a contract or within a module declaration to make all or parts of a specified module available in the current module context. For example, you can specify a list of functions, constants, and schema names to import from the specified . If you explicitly define the function, constant, and schema names to import, only those items are available in the module body. You can also specify a argument in statements to check that an imported module's hash matches the you expect, and fail if the hashes are not the same. By including the argument in a statement, you can perform a simplified form of version control or dependency checking. The following example is an excerpt from the module that illustrates the relationships created by combining and statements. In this example, is the primary namespace where the contract is deployed. This module implements the interface that defines a set of capabilities. The module also implements the interface and imports the specified functions. For more information about the syntax for using these keywords, see the implements and use syntax descriptions. Module references Pact module references enable you to support use-cases that require polymorphism. For example, a Uniswap-like exchange allows users to specify pairs of tokens to allow trading between them. The Pact interface allows tokens to offer identical operations such as . However, without a way to abstract over different implementations, an exchange smart contract would have to be upgraded for each pair with custom code for every operation. For example: With module references, an exchange-type smart contract can accept pairs of values where each value references a concrete module that implements the interface, giving it the ability to call operations using those values. For example: To invoke the above function, the module names are directly referenced in code. Module reference values are normal Pact values that can be stored in the database, referenced in events, and returned from functions. Polymorphism Module reference values provide polymorphism for use cases like the example above with an emphasis on interoperability. A module reference is specified with one or more interfaces, allowing for values to reference modules that implement those interfaces. In the calling example above, the module reference accepts a reference to the Kadena KDA token module, because implements . There's nothing special about the contract. Module references can specify any defined interface and accept any module that implements the specified interface. The Pact module reference polymorphism is similar to generics in Java or traits in Rust, and should not be confused with more object-oriented polymorphism like that found with Java classes or TypeScript types. Modules cannot extend one another. They can only offer operations that match some interface specification, and interfaces themselves cannot extend some other interface. You should note that module references introduce indirection and, therefore, can increase the overall complexity of Pact smart contracts, making contract logic harder to understand and reason about. You should only use module references when you need to provide flexible interoperation with other smart contracts. If all of the modules are your own code, you should use direct references whenever possible. Reference value binding Module references use the latest upgraded version of the referenced module when you invoke a module operation. For example, consider a module reference to a module stored in the database when the module is at version 1. Sometime later, the module is upgraded to version 2. The module reference in the database will refer to the upgraded version 2 of the module when the reference is called. This behavior is different from Pact direct references, which are not late-binding, so you should consider this difference in module reference behavior to prevent returning unexpected results. Referencing untrusted code Because module references allow external modules to interoperate with your code, you should not assume that the external code is safe. Instead, you should treat any module reference call as a call to untrusted code. In particular, you should be aware the invoking module references in the context of acquiring a capability can result in unintended privilege escalation. For example, the following module has a public function that is intended to allow external modules to provide some data, resulting in the one-time payment of a fee. The external modules implement interface with a function to get the data and a function to identify the receiving account. In this example, the module code acquires the capability, and uses this capability to prevent and a functions from being called directly. However, with the wrong code, this seemingly benign code can be exploited by a malicious module reference implementation: The problem with the module code is that the call happens before the calls to the module reference operations, such that while the external module code is executing, the capability is in scope. While the capability is in scope, the and functions can be called from anywhere. A malicious coder could exploit this code with a module reference that calls the function repeatedly in the seemingly innocent calls to the or functions. Malicious code could also call the function and wreak havoc that way. The important point in this example is that once a capability is in scope, the protections provided by the function aren't available. Fortunately, you can avoid this situation by keeping module reference calls outside of the scope of the sensitive capability. For example: In this example, the module reference calls have safely returned before the capability is acquired. A malicious implementation has no way to invoke the sensitive code. Coding with module references Modules and interfaces thus need to be referenced directly, which is simply accomplished by issuing their name in code. Using a module reference in a function is accomplished by specifying the type of the module reference argument, and using the dereference operator to invoke a member function of the interfaces specified in the type.",
    "source": "smart-contracts/modules.md",
    "title": "modules"
  },
  {
    "content": "title: Pact features and conventions id: lang-features sidebar_position: 5 description: \"Learn the basics of Pact programming language features and coding conventions with an introduction to built-in functions and writing your own simple functions.\" Pact features and conventions Pact has a lot in common with other programming languages, but some of its conventions and intentional restrictions are either unique or unlike other programming languages you might be familiar with. This part of the documentation presents an overview of Pact language features and conventions you should be familiar with as you start reading and writing smart contract code. Command-line interpreter In the Quick start, you got a first look at writing Pact smart contract code and using the Pact command-line interpreter, also referred to as the Pact read-eval-print-loop (REPL) environment. The Pact REPL enables you to write and execute Pact code interactively from the command-line. but its real power lies in the ability to execute code in smart contract modules—that is, files—or in test files with the file extension that help you test your code as you go. With test files, you can execute module code and take advantage of features that are only available to use in files run by the Pact REPL interpreter. For example, files can include functions to set up environment data that's required for testing, but that is otherwise difficult to replicate in a test. In most cases, you can use the features provided by the Pact REPL in combination with an integrated development environment (IDE), like Visual Studio Code, to provide an end-to-end development environment. Parenthesis Pact uses parentheses to enclose each statement in the code. The statements enclosed by parentheses are often referred to as symbolic expressions or S-expressions. Parentheses enclose all module declarations, all function declarations, and any related logic. Often, the code requires nested parenthetical statements to resolve the logic. For example, the outermost parentheses in the following code contain the helloWorld module: Within the module declaration, the next set of parentheses contain a function declaration that includes an expression—also enclosed by parentheses—that uses the built-in function. Comments There are several ways that you can embed comments in Pact programs. The most common convention is to use semicolons (;) at the start or end of a line to add comments in smart contracts. With this notation, all comments are introduced by a single semi-colon followed by text to the end of the line. Although there's no difference between using a single semi-colon and multiple semi-colons, it's common for code to follow a convention similar to the following for readability: A single semicolon (;) for short notes on a single line of code. Two semicolons (;;) inside or above definitions that describe functions or other top-level forms. Three semicolons (;;;) or more file-level comments or to separate larger sections of code. Depending on where you want to add a comment, you can also enclose strings using double quotation marks () with or without the metadata tag. The following is an example of a multi-line documentation string that describes the create-token function the : The metadata tag is optional. For example, a module definition, function definition, or table definition can include comments in strings without the tag: For more information about metadata, see Pact syntax. Data types Pact, like most programming languages, supports the data types that you would expect. For example, Pact allows you define the following types of data: Data type Description Examples Integer Any whole number value—positive or negative—that doesn't include a decimal. , , Decimal Any number value that includes a decimal. Decimal precision is represented as in which is unbounded, but has, at most, a value of 255. As a result, decimal values have, at most, 255 decimal places, but the total number can be unbounded with a potentially unlimited precision. , , String Any text within quotes. You can represent strings using double quotes. It's also possible to prepend strings used as function names or table names with a single quotation mark ('). , , Boolean Anything that is represented by true and false literals. , List List literals are created inside square brackets (). List items can be separated with spaces or commas. If all of the items in the list have the same type, then the type is defined by the content of the list. Otherwise, the type is just defined as a “list”. or is an integer list, is a list Object Objects are dictionaries specifying key-value pairs created inside curly braces (). For more information about data types, see Pact syntax. If you aren't sure about the data type when you are working in Pact, you can check its data type by using the Pact built-in function. To try it yourself: Open a terminal shell on your local computer. Start the Pact REPL interpreter you installed in Install Pact by running the following command: Use the built-in function to test different data types. In Pact, functions are enclosed by parenthesis, so to test a list data type, for example: After you run the command, the function returns that this is a list with any type of data items: String operations In most cases, you use double quotation marks (\" \") around strings to support whitespace or multi-line strings. However, you can also represent strings by prepending the string with a single quotation mark ('). Typically, you use a single quotation mark to identify strings that are used as function names or table names. You can't identify a string with a single quotation mark if the string includes whitespace or requires multiple lines, but this can be a helpful way to identify certain type of strings more succinctly. For more information about using a single quotation mark for function or table names, see symbols. To work with strings: Open a terminal shell on your local computer. Start the Pact REPL interpreter you installed in Install Pact by running the following command: Use double quotation marks to identify a string. Use a single quotation mark to identify a string. Concatenate two strings using the built-in function. List and object operations Pact allows you to express lists using square brackets and objects using curly braces. Pact objects are similar to JavaScript objects defined using key-value pairs. To create lists and objects: Open a terminal shell on your local computer. Start the Pact REPL interpreter you installed in Install Pact by running the following command: Use double quotation marks to identify strings in a list using square brackets. Use double quotation marks to identify strings in an object that describes a cat named Scratchy who’s 6 years old. Make a list that that contains two objects that describe a cat named Scratchy and a dog named Fluffy. Time formats Pact supports many different time properties and formats. The following example illustrates using a built-in function to format the time specified using the built-in function: The function constructs a time object from a UTC value using the ISO8601 format (%Y-%m-%dT%H:%M:%SZ). The built-in functions takes a argument and a argument to produce the specified time in the specified format. The following table provides a summary of time formats used in the previous example: Format Purpose %Y Year, no padding. %m Month of the year, zero-padded to two characters, \"01\"–\"12\" %d Day of the month, zero-padded to two characters, \"01\"–\"31\" %H Hour of the day using a 24-hour clock, zero-padded to two characters, \"00\"–\"23\" %M Minute of of the hour, zero0-padded to two characters, \"00\"–\"59\" %S Second of the minute, zero-padded to two characters, \"00\"–\"60\" %N ISO 8601 style numeric time zone (for example, \"-06:00\" or \"+01:00\") There are many other formatting options than included in the previous example. For example, you can replace the numeric representing the month of the year with the short or long name for the month. For more information about all of the formats supported, see Time formats. Operators Pact provides operator functions to perform common arithmetic, comparison, and logical operations. The most common of these operator functions are listed in this section. For a complete list with more information about each function, including function signatures and examples, see Operators. Arithmetic operators +: Addition -: Subtraction *: Multiplication /: Division ^: Exponentiation Comparison operators =: Equality !=: Inequality : Less than : Less than or equal to : Greater than : Greater than or equal to Logical operators and: Logical AND or: Logical OR not: Logical NOT Bitwise operators &: Bitwise AND |: Bitwise OR ~: Bitwise NOT xor: Bitwise XOR shift: Bitwise shift Math-related operators mod: Modulus abs: Absolute value round: Rounding ceiling: Ceiling floor: Floor Functions Functions are an important part of any programming language, whether you are working with built-in libraries or writing your own functions. In addition to the operator functions, Pact provides many other built-in functions to handle different types of tasks. The functions are grouped into the following categories: Capabilities Database General Guards Keysets Operators Repl Time Click a category to see a complete list of the functions in that category. Within each category, you can click individual function names to see more information, including function signatures and examples. You can also view information about built-in functions using the Pact command-line interpreter and interactive REPL. Defpacts One of the key features of the Pact programming language is support for multi-step transactions using coroutines—called defpacts—that can start, stop, continue, or rollback the execution of specific operations in a transaction. With defpacts, you can define the steps to be executed by different parties as sequential operations on the blockchain. For example, defpacts are used for cross-chain transfers where a burn operation takes place on the first chain and a mint operation takes place on the second chain. Because defpacts enable you to orchestrate a series of transactions in a strict sequence, they have two primary use cases: For public two-party transactions—similar to an escrow process—with rules for the operations that are required to be performed by each participant to complete the transaction. For private, confidential transactions that can be serialized and executed in a sequence and recorded in a private log and, predominately, involving the exchange of encrypted messages outside of the blockchain state. Note that private multi-step transactions aren't supported in Pact-5 or later. With defpacts, you can enable each participant to run only a subset of functions—for example, as a buyer who can make an offer or a seller who can start a sale—while preserving the integrity of the transaction as a whole. For more information about defining and using defpacts, see the syntax description for the reserved keyword. For a more detailed example of using in a smart contract, see the Marmalade contract.",
    "source": "smart-contracts/language-features.md",
    "title": "language-features"
  },
  {
    "content": "title: Installation and setup id: install sidebar_position: 2 description: \"Install the Pact smart contract programming language and set up tooling for your development environment.\" import CodeBlock from '@theme/CodeBlock'; Installation and setup Setting up a fully-functioning development environment often requires more than the minimal steps covered in the Quick start guide. This section provides more detailed information about installation, tooling, and configuration options so you can create a complete development environment that best meets your needs. At a high level, you complete the following steps to configure a development environment for writing smart contracts that execute transactions on the Kadena blockchain network: Install Pact: Pact is the core smart contract programming language for Kadena. By installing the appropriate version of Pact for your operating system, you'll be able to write, test, and deploy your smart contracts from your working environment. Install tooling: Installing additional tooling is optional. However, many toolchain extensions—like the Pact language server plugin (LSP) and the community-contributed package manager—provide essential quality-of-life enhancements that improve the developer experience. You should also consider adding access to common blockchain applications—like faucets, wallets, and block explorers—to ensure you have an end-to-end development environment. Set up a local node: A properly configured blockchain node is a crucial part of your development environment for testing and debugging of projects during development and simulating public deployment in an isolated network environment. Before you begin To prepare for installation, you should verify your development environment meets the following basic requirements You have an internet connection and a web browser installed on your local computer. You have an integrated development environment (IDE) or code editor such as Visual Studio Code. You have access to an interactive terminal shell as part of the IDE or code editor you use. Pact versions You can choose to download and install either the latest, stable version of Pact, version 4.x, or the Pact core revision, version 5 (beta) for Linux or macOS computers. Pact 4.13 is the latest stable release of the Pact smart contract language and interactive interpreter for macOS. Starting with Pact 5, the Pact core—including the command-line interpreter, built-in functions, and related components—have undergone a major transformation. This reinvention of the Pact language retains functional parity with previous Pact releases, but with significant changes that enhance the scalability, maintainability, and performance of the language. With the release of Pact 5, the Pact core is also positioned for more sustainable growth of Pact features within the Kadena ecosystem. By offering more modular and maintainable internal structures, Pact 5 can now better support community participation and enhancements to the language and components that rely on it. For more information about Pact 5, see the following resources: Migrating to Pact 5 Pact 5 repository Pact 5 Beta: Improving Developer, Miner, and User Experience Installation options You can download and install the Pact programming language and interactive interpreter locally on your local computer from prebuilt platform-specific binaries or build Pact directly from its source code. You can also run Pact in a browser without installing it as a component in the development network Docker image. The installation instructions in this section describe how to install Pact locally using prebuilt binaries for each operating system platform. To build Pact binaries directly from source, see the instructions in the appropriate repository: Pact 5 Pact 4.x <!-- To build Pact binaries directly from source, download the source code from Pact Releases, then use Homebrew, Cabal from the Haskell toolchain, or the Nix package manager to build Pact. For more information about the dependencies and tools for building from the source code, see Building from source. -->",
    "source": "smart-contracts/install.md",
    "title": "install"
  },
  {
    "content": "title: Guards description: \"Guards are an important concept in Kadena that provide a flexible way for you to enforce authorization rules that grant or restrict access based on specific conditions.\" id: guards sidebar_position: 9 Guards In Pact, guards provide a flexible way for you to enforce authorization rules that grant or restrict access based on specific conditions. Guards generalize the behavior of keysets and capabilities to specify conditions that must be met before granting access to an account, a privileged operation, or any type of information that the guard is there to protect. Although Pact provides several types of guards to handle different scenarios and use cases, a guard is essentially a predicate function that enables you to test whether a condition is present (true) or not (false) with an function. As you've already seen, a keyset is the most common type of guard. It specifies a list of keys and a predicate function to verify how many keys were used to sign the current transaction. The keyset predicate references a function that compares the public keys in the keyset to the key or keys used to sign the blockchain message. The function accepts two arguments— and —where is the number of keys in the keyset and is how many keys in the message signature match a keyset key. The function tests whether the required number of matching keys is true or false, determining whether the transaction succeeds with the required number of matched keys or fails because the required number of matched weren't found in the signing set. The following examples illustrate other use cases for guard predicate functions: Ensure that a user is a member of a privileged group that can execute a certain function. Verify that a user has provided some secret, such as the preimage data for a hash function, as is often done for atomic swaps. Enforce that a module is the only owner that can execute a specific function, for example, to debit a protected account. Guards enable you combine all of these types of checks into a single, enforceable rule. For example: Verify the user Alicia is a member of the Executive Board authorized to access the General Fund AND has provided the preimage data AND the transaction is only executable by the module \". Supported guards Guards can have different properties based on what they are intended to protect access to, but can also interoperate with each other seamlessly. You can include any or all of the following Pact guards in a smart contract: Keyset guard KeysetRef guard User guard Capability guard Module guard (DEPRECATED) Pact guard (DEPRECATED) Note that the module guard and Pact guard are DEPRECATED because they are considered unsafe. You can store guards in the Pact database using the type. Although Pact defines these different guards to handle different use cases, the most important point to consider in selecting a guard is ensuring it enforces the appropriate conditions to allow or deny access to the appropriate entity, whether that entity is an account balance, a privileged operation, or a customizable user function. Guards and capabilities Guards and capabilities provide similar functionality in terms of authorizing access based on specific conditions. However, there are a few fundamental differences between guards and capabilities: Guards allow you to define a rule that must be satisfied for an operation or transaction to proceed. They simply provide a way to declare a pass-fail condition—the predicate function—without granting any type of privilege or authorized activity. The Pact guard system is flexible enough to express any rule you can code. Capabilities allow you to declare how a rule is deployed to grant some authority. In doing so, they enumerate the critical rights that are extended to users of the smart contract, and protect code from being called incorrectly. In addition, you can only grant capabilities inside the module code that declares them. Guards are simply data that can be tested anywhere. For capabilities, this is an important distinction because it ensures an attacker can't elevate privileges from outside of the module code. Keyset guards The guard is the backward-compatible as originally defined in Pact. This guard is also referred to as a concrete keyset that's defined in the environment. Using the type is the one instance where you can restrict a guard subtype. For all other guards, the type obscures the implementation type to discourage you from using guard-specific control flow, which would be against best practices. In general, you should use the type unless you have a specific need to use a keyset. Examples To create a keyset guard with the name : To define a keyset by reading a keyset object: Principal account prefix Each type of principal and guard uses a unique prefix, so they are easy to recognize. If you use the function to a create principal account for a keyset guard, the principal account uses one of the following prefixes: k: for single key keysets w: for multiple keys keysets KeysetRef guard You can install concrete keyset guards in the REPL environment by using the function. However, if you want to store a reference to a defined keyset, you must use a type. To make REPL environment keysets interoperate with concrete keysets and other guards, you can use the KeysetRef guard to indicate that a defined keyset is used instead of a concrete keyset. Examples User guard User guards allow you to design an arbitrary predicate function to enforce the guard, given some initial data. With user guards, you can implement any type custom predicate logic that can't be expressed by other built-in guard types. For example, you might want to customize the guard to allow one of two different keysets to sign: One keyset registers the keys for the members of a board of directors. A second keyset registers the keys for union representatives. You can then design a user guard to require two separate keysets to be enforced: User guards can be very flexible and powerful. They can be stored in the database and passed around like plain data. However, user guards are pure functions that don't allow access to a database during evaluation of the guard. Examples The following example illustrates how to write a custom hash timelock guard to implement atomic swaps. Principal account prefix Each type of principal and guard uses a unique prefix, so they are easy to recognize. If you use the function to create a principal account for a user guard, the principal account uses the following prefix: u: for user guards Capability guard Capabilities are in-module rights that can only be enforced within the declaring module, and offer scoping and the other benefits. Because user guards are required to be pure functions, they can't take database state into account. If you need to access database state, you can define a guard that requires a capability to be brought into scope. With this type of guard, you can retrieve database state when you bring the capability into scope. Principal account prefix Each type of principal and guard uses a unique prefix, so they are easy to recognize. If you use the function to create a principal account for a capability guard, the principal account uses the following prefix: c: for capability guards",
    "source": "smart-contracts/guards.md",
    "title": "guards"
  },
  {
    "content": "title: \"Get started: Introduction to Pact\" id: get-started-intro sidebar_position: 1 slug: get-started-intro description: \"Pact is a human-readable smart contract programming language, designed to enable correct, transactional execution on a high-performance blockchain. Start your builder's journey on Kadena by learning about the Pact smart contract programming language.\" Get started: An Introduction to Pact This part of the Kadena developer documentation is focused on writing smart contracts and developing applications to run on a blockchain. To get started, it's important to know what smart contracts are and the kinds of challenges that you might face in writing them. Smart contracts A smart contract is a program that can automatically execute agreements—in the form of transactions—on the blockchain without any external oversight. The contract ensures that the specific conditions, defined in the code logic to describe the terms of the agreement, are met before executing the transaction programmatically. Smart contracts are deployed and executed on blockchain networks because the blockchain provides a decentralized, immutable, and publicly accessible record of all transactions. This transparency and traceability ensures that the programmatic execution of the contract can been considered trustworthy and verifiable. However, there are several unique challenges involved in writing smart contracts. For example, it's important to ensure that smart contracts can't be accessed by unauthorized parties, that transactions can't be intercepted or manipulated, and that code execution and data storage don't overload blockchain resources. Because a blockchain is a resource-constrained environment, it's particularly important for smart contracts to perform well even when network activity is at its peak. For example, if the code in a smart contract isn't efficient, it can be costly to execute the contract functions. Inefficient code can also delay transaction execution and block validation, affecting the throughput for the entire blockchain network. If a smart contract performs unbounded operations, excessive looping, or recursion, the contract might strain or overload the computational capacity that the blockchain has access to. In worst case scenarios, bugs in a smart contract can result in lost funds for participants or stall the progress of the blockchain. With these challenges and risks in mind, you can see why it's important to avoid common pitfalls and write smart contracts that execute transactions efficiently and securely. Pact smart contracts Pact is an open-source programming language designed specifically for writing smart contracts and developing applications to run on a blockchain. Pact was built to help developers create programs that overcome the challenges associated with writing smart contracts. Pact reflects many of the same approaches to writing smart contracts that are used in other programming languages—such as Solidity or Rust—but with a goal of making contracts less error-prone and less vulnerable to exploits and attacks. Pact is similar to many general purpose languages in its syntax, function declarations, module definitions, and imperative style. However, Pact has several features that make it a safe and performant language for blockchain applications, including the following: Pact supports a straight-forward database model for storing and manipulating state using database schemas and tables. Pact contracts can be written and deployed using composable modules, enabling you to iterate, update, and upgrade contract functionality when needed. Pact limits computational overhead by preventing unbound looping and recursion at the language level. Pact code is designed to provide transparency that can be inspected in plain text as part of the public record. Pact transactions can be executed in a single step or as a sequence of steps guaranteed to be executed in a specific order. These features and constraints reduce the risks of writing faulty smart contract code, limit costly performance bottlenecks, and improve readability and reliability of programs running on the blockchain. You'll learn about these language features and more as you progress through the Smart contracts topics. Writing contracts in other languages It's possible to write contracts in other languages, as long as the transactions conform to the expected message format when submitted to a Chainweb node. For example, it's possible to write programs using JavaScript, TypeScript, or Python to emulate Pact smart contracts. However, Pact provides many built-in features and native functions that make smart contract development more efficient and produce more readable results without requiring external libraries to construct compatible commands. Navigating documentation and resources The Smart contracts documentation is for programmers and non-programmers interested in learning how to write programs using the Pact smart contract programming language. This part of the documentation is focused on language features and examples. How the documentation is organized In addition to the language-focused topics in Smart contracts, Kadena developer documentation includes the following top-level sections: The How-to guides provide examples of the different ways you can perform common tasks. You can use these guides as a quick reference when working with accounts, transactions, or contracts to see instructions for tasks like creating an account, submitting a transaction, or calling a contract function. Under API, you'll find reference information for the Pact, Peer-to-Peer, and Service REST API endpoints, including query parameters, request and response schemas, and call examples. The Reference section provides reference information for the Pact programming language—including syntax, keywords, and built-in functions—and the command-line interfaces you can use to interact with Pact smart contracts and the Kadena blockchain in a development, test, or production environment. In Coding projects, you'll find companion documentation for the sample projects located in the repository. Under Resources, there are links to additional resources, such as the Kadena video library, contributor guidelines, and other tools and projects. Documentation conventions The following conventions are used in the Kadena documentation: is used for inline sample code, program names, program output, file names, and commands that you type at the command line. Bold type is used to highlight menus, commands, buttons, or user interface elements, and to introduce new terms. Italic type is used for titles, to emphasize specific words, or to indicate variables for which you should substitute an appropriate value. Square brackets ([ ]) indicate optional arguments in command reference or list data types in the Pact language reference. Curly braces ({ }) indicate objects with key-value pairs in the Pact language reference. Vertical bars (|) separate alternative values from which you must make a selection. An ellipsis (...) indicates that the preceding element can be repeated. The generic data type is used if an argument represents a type-bound parameter. Contributing to documentation or code As a member of the Kadena community, you are invited and encouraged to contribute to Kadena technical documentation and to the Kadena project code base. There are a lot of ways to get involved. For example, you can contribute by: Submitting issues. Offering suggestions for improvements to existing content. Adding review comments to existing pull requests. Proposing new content. Creating new pull requests to fix issues yourself. Creating pull request for new content other community members might find useful. We value, respect, and appreciate all contributions from the developer community and only ask that you agree to abide by our Code of conduct and Community guidelines. Contribute to documentation Kadena documentation is open source and hosted on GitHub in the kadena-docs repository. To report an issue or make a documentation request, open a New Issue and add the documentation label to it. If you have a GitHub account and want to suggest changes to the documentation, create a branch and open a pull request as described in Contribute to documentation. For details about getting started as a contributor to documentation, see How to contribute to Kadena documentation. For recommendation regarding writing style, documentation conventions, and topic templates, see the Writer's style guide. Contribute to the codebase The Kadena codebase is open source and hosted on GitHub in repositories under two organizations: kadena-io and kadena-community. Repositories in kadena-io are focused on the Kadena network infrastructure and foundational components like chainweb-node and pact. Repositories in kadena-community are focused on tooling and projects to help developers build applications on the Kadena network like the TypeScript libraries in kadena.js. For details about getting started as a contributor, see How to contribute as a developer.",
    "source": "smart-contracts/get-started-intro.md",
    "title": "get-started-intro"
  },
  {
    "content": "title: Functions, variables, and types description: \"Work with common built-in functions and start write your own function declarations that include variables and types.\" id: functions-variables sidebar_position: 6 Functions, variables, and types In Language features and conventions, you were introduced to Pact built-in functions and function categories. In this part of the documentation, you'll begin working with common built-in functions and writing your own function declarations that include variables and types. View built-in functions To view information about Pact built-in functions: Open a terminal shell on your local computer. Display the list of built-in functions by running the following command: You might want to save the output from this command to a file for quick reference. For example: Start the Pact REPL interpreter by running the following command: View usage information for a specific built-in function by typing the function name in the interpreter. For example, to see information about the format function, type at the prompt: After you enter the function name, you'll see information about the function in the interpreter. For example: Use common functions Pact includes many built-in functions that enable you to perform common tasks like manipulating lists, assigning values, and formatting strings with variables. A few of the most common general purpose functions include the following: at bind map format You can use the at built-in function to return a value from a list or an object. The bind built-in function allows you to map a variable to a value from within an object. You can use the map built-in function to apply a specific operation to all elements in a list and return the results. The format built-in function allows you to create messages using strings and variables. Let's try a few simple examples to see how these functions work. To use the common general functions: Open a terminal shell on your local computer. Start the Pact REPL interpreter you installed in Install Pact by running the following command: Select an item from a list using its place—its index location—in the list. The index location starts with position 0, so at index position 1, the result is . As this example illustrates, the list can include different data types. If you change the index to 0, the result is . If you change the index to 2, the result is . Select a value from an object by specifying the object key. In this example, you use the key instead of an index location to return the value—\"Scratchy\"—from that key. Bind a variable from a source object to a value in another object using the symbol. In this example, the value from the key in the source object is assigned to the variable, so the value returned by the variable is 1. A more common use case for binding values using the symbol is when you want to bind the values from a table object to a variable. The following example illustrates how you might bind a value from a table in a function: This example reads a table named payments that includes a user from that is sending a balance. A binding is used in this case to map the balance column in the payments table to the value of from-bal variable that is provided by the user. In this example,the function calls the balance of the user using the balance variable rather than the from-bal variable. Apply a specific operation to each element in a list and return the results using the built-in function. This expression adds the value 1 to each element in the specified list then returns the result in a new list. You can also use the function with other values, including strings, and with any of the operators available in Pact. For example, if you have a list of names, you can map “Hello ” to each of them to returning a friendly message for each list item. Format a message using strings, curly braces () for placeholders and a list of values or variables. The first set of curly braces is the placeholder for the first value in the list. The second set of curly braces is the placeholder for the second value in the list. You can create as many placeholders and list values as you need for your messages. In a more typical use case, you would use the function to create dynamic strings with variables inserted into specific locations in Pact contracts. Close the Pact REPL interpreter session by pressing Control-d. Prepare to write functions Now that you've experimented with several built-in functions in Pact, you’re ready to write some simple functions of your own. In Pact, functions are always defined in the context of a module. As you learned in Pact smart contracts, modules are one of the core components of the Pact programming language. A module definition must include information about who has ownership of the module using either an administrator keyset or by defining a GOVERNANCE capability. So, before you start writing functions, you need to create a module and identify the module owner. To prepare to write your first functions: Open a code editor—such as Visual Studio Code—on your computer. Create a new file named for your new Pact module. Add a module definition and a GOVERNANCE capability to the file with the following lines of code: The function is a reserved keyword that defines a capability that controls the ownership of your contract. It must evaluate to true to allow changes to the module. You'll learn more about the power of capabilities in later tutorials and examples. These lines of code represent the bare minimum required to define a module. Before moving on to writing functions within the module, you can test that the module runs using the Pact REPL interpreter. Start the Pact REPL interpreter by running the following command: Load the file by running a command similar to the following with the path to the file: You should see output similar to the following: Define a function Functions are the core units of logic in a module. They define all of the operations you want your application to offer and all of the features that your users want to access. Although Pact includes many built-in functions for you to use, you typically need to define most of a contract's logic using your own functions. Functions definitions start with the reserved keyword in Pact. After the keyword, you must provide the function name followed by any arguments or other functions that the function uses. The following is a simple example of the syntax to define a function in Pact: The function is a reserved keyword that signals the start of a function declaration. In this example, the function is named and the function accepts inputs with the variable identifiers and . The function includes comments by using two semi-colons (;;) to start each comment. Let's add this function to your module. To define your first function: Open the code editor—such as Visual Studio Code—on your computer. Open the file you created for your new Pact module. Define the function in the module by replacing the comment with the following lines of code: The function can now take any two inputs and return a formatted string value. Start the Pact REPL interpreter by running the following command: Load the file by running the following command: You should see output similar to the following: Call the function by running the following command: You can now change these inputs to any values you’d like. Add calculator functions Now that you have a working module with one function, you can add functions for the math operations that take any two numbers as input, and return the result. To add simple calculator functions: Open the code editor—such as Visual Studio Code—on your computer. Open the file you created for your new Pact module. Define functions for adding, subtracting, multiplying, or dividing any input values: Call the functions with different values to see the results. For example: It's important to note that these simple calculator functions are valid, but could be improved by explicitly specifying the data type expected. For example, in the current form, you could execute the addNumbers function to concatenate two strings: To prevent errors or unintentional behavior, you can explicitly define the type for each function. For example, you might want to explicitly set the data type to or : For more information about specifying types, see Typing in variable declarations. Variables In the previous examples, you used the variable identifiers and to represent input arguments in your function declarations. Variables represent and store any type of data that you want to reference and manipulate in a program. Constant values In Pact, you can define variables for constant values using the reserved keyword. For example, the following statement illustrates defining the constant with eight decimal places followed by an optional comment: The following example illustrates defining the constant with an explicit type of : By convention, constant variables use all uppercase letters. However, this convention isn't required. To use a constant in your module: Open the code editor—such as Visual Studio Code—on your computer. Open the file. Add the constant variable for to your module and save your changes. Load the file. Call the function with the constant. You can experiment with using the constant in other functions. However, you should note that the data type for is a decimal value. Therefore, the other values you pass should also be decimal values—as in this example with 1.0—and not the integer values. Changeable values You can also define variables for values that can be changed using expressions. Within functions, you can use the keyword to bind a variable identifier to a value. For example, you can assign the variable identifier a value of and perform a simple addition by entering the following in the Pact terminal: This expression returns the result of adding to with the value . You can also use the keyword to reference previously-declared variables in the same declaration. The following example illustrates referencing a previously-declared variable in the same declaration: Typing in variable declarations Most of the examples you've seen so far haven't explicitly specified the data type being used. However, in practice, you should explicitly identify the data type for each variable you define in a program. By identifying the data type—for example, integer, decimal, boolean, or string—you can ensure that variables can be set and manipulated correctly and without introducing unexpected behavior by mismatching types. For example, to specify that the variable is an integer, you can add the data type to the declaration like this: You can specify a variable is a value like this: You can specify a variable is a value like this: More built-in functions You've already seen how to use several common built-in Pact functions. However, there are many more built-in functions that you'll use frequently in Pact smart contracts, including the following general functions: Entering a namespace In the Kadena ecosystem, a namespace is conceptually similar to a domain name except that the name is a static prefix that establishes a private boundary for the contracts, keys, and other elements that you control. When you are building, testing, and deploying smart contracts on your local development network, you don't need to define a namespace. Your work is isolated from others because your blockchain—and any smart contracts you deploy—run exclusively on your local computer. However, if you want to deploy a smart contract on the Kadena test network or another public blockchain, the contract must have a unique name that distinguishes your Pact module from all the others. If you try to deploy a Pact module with a name that's already being used on the network where you are trying to deploy, the deployment will fail with an error and you'll pay a transaction fee for the failed attempt. To prevent name collisions on the same network, Kadena allows you to define your own unique namespace on the blockchain. The namespace segregates your work—your smart contracts, keysets, and Pact modules—from applications and modules created and deployed by others. Within your namespace, you can define whatever keysets and modules you need and control who can update the namespace with changes. As long as you choose a unique name for your namespace, everything you define inside of that namespace is automatically unique, too. Pact provides the and built-in functions for you define or enter the namespace you want to use as your current working environment. After you declare the namespace you want to work with, all of the modules and functions you define are contained within that namespace. You can access the modules and functions in a namespace by using their fully qualified name. The fully-qualified name includes the namespace string as a prefix before the module name. For example, if you declare a principal namespace such as for the module , you can call functions in the module using a fully-qualified name similar to the following: To define and enter a namespace: Open a terminal shell on your local computer. Start the Pact command-line interpreter to open the Pact terminal. Add a guard and an guard to your working environment by entering the following lines: The and are required to define a new namespace. In the terminal, you should see this information added to your working environment: Define a new namespace by running the following command: In the terminal, you should see this information added to your working environment: Enter the new namespace by running the following command: In the terminal, you should see this information added to your working environment: If you define a module in this workspace, you would set the first line to specify the namespace before any of the module code. For example: The module is created with the fully-qualified name. Hashing values The function enables you to compute a unique Base64Url-encoded string for a specified using the BLAKE2b 256-bit hashing algorithm. Using a hashing algorithm is a common operation for blockchain networks when you need to create unique values. You can create hashes for any type of data. Strings values are converted directly. Other data type values are converted using their JSON representation. The following example demonstrates how to use the function to create a unique index for the string value: Because is a string value, the function computes the BLAKE2b 256-bit hash of the string \"hello\" and returns the hash value. If you change the string to “hello1”, the hash function returns different value. For example: You can also use the function to compute the hash for lists, objects, and other data types. For example: The following example computes the hash for the JSON representation of an object and returns the hash value: The hash enables you to reference and manipulate the specific data in complex ways. Defining conditions with if statements Because Pact doesn't support recursion or unbounded looping, the function is particularly useful for testing conditions. The basic format for testing conditions with statements looks like this: If the specified is true, evaluate the expression. If the specified is false, evaluate the expression. The following example demonstrates the use of to test a condition—whether (2 + 2 =4)—in the Pact REPL: In this example, the condition evaluates to true, so the expression is returned. In this example, the condition evaluates to false, so the expression is returned. Enforcing conditions Pact provides several functions that enable you to evaluate conditions and allow or block further operations based on the result. One critical function in Pact is . If you hit an enforce block and invalidate it, it will stop you from executing any further. With the function, you can test whether a specified evaluates to true or false. If the specified evaluates to true, the function returns true and operation continues. If the specified evaluates to false, the function halts execution and displays a specified error . The following example tests the expression (1 + 3 != 5): Because the specified expression () is true, the function returns true and the operation continues. The following example demonstrates how to use the function to evaluate the expression : There are many situations where the enforcement functions are useful for testing specific behavior. For example, one of the most common enforcement functions is the function. This function ensures that the logic for a specified or is enforced before protected operations can be executed. You'll learn more about guards and enforcing guard logic in Guards.",
    "source": "smart-contracts/functions-variables-types.md",
    "title": "functions-variables-types"
  },
  {
    "content": "title: Database model description: \"Kadena blockchain nodes store information in two different data stores, with a key-value store that keeps track of information about nodes, chains, and blocks and a SQL-based database that stores information about Pact smart contracts and transactions.\" id: databases order: 7 tags: [ 'pact', 'beginner', 'schemas and tables', 'schemas', 'tables', 'pact tutorials', ] Database model Kadena blockchain nodes store information in two different data stores. On each Chainweb node, there's a RocksDB key-value store that keeps track of information about the peer network, chains, and blocks. Each node also hosts a set of SQLite database files that store information about Pact smart contracts and transaction results with one file for each chain in the network. The following diagram presents a simplified view of this separation of concerns. As a smart contract developer, you're primarily interested in writing to and reading from the Pact state, but it's helpful to know how data is organized and optimized for different execution modes and to perform different tasks. The RocksDb database—sometimes referred to as the chain database—is optimized for efficient network communication and resiliency. Pact database operations are optimized for transaction performance. Working with Pact tables Tables are a core component of Pact smart contracts because they enable you to store, manipulate, and read data using familiar patterns. Interacting with Pact databases is much like interacting with any other type of database, but with constraints that reflect the unique requirements of blockchain execution. For example, working with Pact databases is similar to working with other SQL-based databases, with similar database operations. There are built-in functions to insert, read, and update values stored in tables. Function type Description Insert Insert new rows into a table. Read Read values from a table. Update Update values for a column that contains data in a table. Write Write values for a column in a table, regardless of whether the column contains data or not. Delete Not available in Pact. If you've worked with other databases or programming languages, you should be familiar with similar functions that enable you to create, read, update, and delete (CRUD) information. However, in Pact, you use the function in place of the create functionality to add rows to a table and there isn't a function to delete rows from a table. Although Pact doesn't provide a delete function, you can use an column in tables to mark table rows as active or inactive. For more information about using an active column to indicate active and inactive rows, see Identifying active and inactive rows. Data access model Most smart contracts use one or more tables to store all of the information required for the application or service that the smart contract provides. You access the information stored in Pact tables by using the table's key-row structure. This access model is similar to using a primary key to access table data in other relational databases. With the Pact key-row model, you access a row of column values by using a single key. As a result of this access model, Pact doesn't support joining tables in a way that an online analytical processing database would support if populated from data exported from the Pact database. However, Pact can record transactions using relational techniques. For example, if you have a table with keys used in a table, a Pact smart contract could include code to look up the record before writing to the table. Null values aren't allowed The Pact database model doesn't support NULL values as a safety feature to ensure totality for transactions and to avoid unsafe control-flow for handling null values. The main function for working with database results is the with-read function. This function will return an error if any column value it attempts to read isn't found. To prevent transactions from failing with these errors, you should ensure that there are values in the columns you attempt to read in a transaction. Versioned history The key-row model is augmented by every change to column values being versioned by a transaction identifier. For example, if you have a table with columns for , , and , you might update the column in a transaction with the identifier 100, and later update the and columns in a transaction identified as 102. If you retrieve historical data for the table, only the change to the column is returned for transaction identifier 100 and only the change to and columns are returned for transaction 102. Table creation Tables are defined by schemas in module declarations. The schema defines the table columns, field values, and field types. The module declaration also specifies the table name to associate with each schema you define. There's no restriction on the number of tables you can create. The tables specified in the module declaration are created after the module declaration, and the table name is prepended with the module name, so that the module becomes the table owner. It’s important to note this distinction between when tables are defined and when tables are created. You define table schemas, the table associated with each schema, and the functions that insert, read, and modify database records inside of module code. You create the tables outside of module code. The module acts as a guard to protect access to database functions and database records. This separation also allows module code to be updated without necessarily recreating the table in Pact state. Table schemas Before you create a table in Pact, you must define its schema. The schema describes the structure of the table by specifying the columns and data types for the values to be stored in the table. Schemas are defined within the Pact module declarations by using the defschema keyword and consist of a series of field names and field types. Each field name specifies a column in the table, and each field type specifies the type of data held in that field. In the following example, the accounts table has three columns with the field names balance, amount, and currency: Field name Field type balance decimal amount decimal currency string In this example, the balance and amount columns require as the data type and the currency column requires data to be a value. You can create the schema for this table in Pact like this: All table schemas you create look similar to this example, but with different field names and data types. Field names must start with a valid alphabetic character, but can contain alphabetic, numeric, and special characters. In general, you should use field names that are short but recognizable. For each field, the field type must be one the data types that Pact supports. Types that are declared in code are enforced at runtime when expressions are evaluated. For tables, any write to a table is type-checked against the table schema to ensure the data matches the expected type. Execution fails if type checking fails. For information about the data types that Pact supports, see Data types. Table definition In Pact, tables are defined inside of the module declaration by using the keyword. The table definition accomplishes two goals: It associates a table name with a specific table schema of columns and data types. It defines the table inside of the module namespace. There's no limit to the number of tables you can define in a module. Because the table is defined inside of a module, direct access to the table using database functions is only authorized for the module owner, that is, its administrative keyset or governance capability. However, module functions have unrestricted access to the table by default. With this default behavior, the module acts as the main entry point for all user interaction. You can restrict access to tables inside of the module by using row-level keysets and enforcing the keyset guard for specific functions. The following example illustrates using the deftable keyword to define an accounts-table table that uses the accounts schema: Notice that the table and schema are represented as a pair, separated by a colon (). The curly braces () around the schema name are there because the schema is an object. The schema name and table name must be different from one another. In general, you should use table and schema names that are similar to each other or follow a consistent convention to avoid confusion: For example: Create module tables After you have defined all of the tables for your module inside of the module declaration, you can create those tables outside of the module. Creating the table outside of the module ensures that other parts of the module logic can be redefined or updated without recreating the table. You can created tables after the module declaration by using the create-table function followed by the table name as it's defined in the module declaration. For example: Insert You can use the insert function to add new data to a table. You can use function to add any type of new artifact with a key value. For example, you can use a key value to add a row of data about accounts, customers, loans, or assets. The following example illustrates adding a row to the using the function with the key value \"account-1\". Note that the key must be a string value. This example adds the following row to the : key balance amount currency account-1 12.3 0.0 USD You can also use the function inside of another function to add new data to rows in a table from the input values for the function. For example: In this example, the row inserted into the takes the values entered for the function. Read You can use the read function to read a row of data from a specified table for a specified key value. In the following example, the has two rows of data storing the account balance and currency for account-1 and account-2: key balance currency account-1 4.00 USD account-2 3.00 USD You can use the function to retrieve the information for the key value. For example, you can get the and information for like this: You can also use the function inside of another function like this. In each example, the functions returns the following values: balance currency 4.00 USD Update You can use the update function to update one or more values in an existing row of a table. Updates enable you to change the status of a column or amend the initial dataset to record a new value. With the function, you specify the key for the row you want to update, the field you want to update, and the new value for the field in that that row. In most cases, you use functions in other functions to allow users to input new values. The following example illustrates updating the field for an asset in the . Before updating the , the has the following fields and values. assetID assetName assetPrice status asset-1 My Asset 5.0 todo For this example, the function updates the column, then reads the value of the updated column. Select You can use the select function to select values from one or more rows in a table. The function is similar to the function except that the function retrieves information for a single key-row value. The function enables you to retrieve multiple rows from a table based on the criteria you provide. Because you can specify other criteria and not just a single key-row value, the function provides you with more flexibility in what information you choose to return. The syntax for the Pact function is similar to the syntax for standard SQL statements. In its simplest form, the statement retrieves all values from a specified table. In the following example, the statement is used in a function to return all values from the : This query returns all of the values currently stored in the fields. For example: assetId assetName assetPrice status asset-1 My Asset 5.0 todo asset-2 Asset 2 6.0 in progress asset-3 Asset 3 7.0 done Like standard SQL statements, you can use a clause to refine your results. For example, you can return only the and for a specific asset name like this: This query returns the following values from the sample : assetName assetPrice Asset 2 6.0 You can also specify operators—such as greater than () or less than ()—from within the clause. For example: This query returns the following values from the sample : key assetName assetPrice status asset-3 Asset 3 7.0 done Select queries and performance You should note that when you write queries using the Pact function, the and operations provide a streaming interface that applies filters to the specified table, then operates on the row set as a list data structure using sort and other functions. Because of the computational overhead, you should avoid using statements to work with on-chain data. Although it can be convenient to use select statements to retrieve data, you can often return the same results more efficiently using other functions. For example, the following query selects with salaries >= 90000 and sorts by in descending order: You can write the same query using the function and sorting the resulting list like this: For performance reasons, Pact database interactions are optimized for single-row reads and writes. Queries that use the statement to scan multiple rows in a table can be slow and prohibitively expensive computationally. Therefore, the best practice is to use statements in local, non-transactional operations and to avoid using on large tables in functions that perform transactional operations. Transactional and local execution Pact doesn't distinguish between transactional and local execution. However, transactions typically involve business events that must be executed and recorded in a timely fashion. Queries rarely represent a business event, and can often involve data payloads that could impact performance. The best practice is to query data locally on a node by using the endpoint. You can also query historical data using the endpoint and a transaction identifier as a point of reference. For transactions, you should use the endpoint. For more information about transaction execution, see Transaction lifecycle. For more information about Pact endpoints, see Pact API. Keys You can use the keys function from within a module to return all of the key values in a table. For example, you can return the values for the sample with the following code: You can also use the function within another function. For example: Row-level keysets Keysets can be stored as a column value in a row, allowing for row-level authorization. The following code indicates how this might be achieved: In this example, the function reads the definition from the message payload using , then stores it in the column in the table. The function only allows the to read the balance by first enforcing the keyset using function. Changing a table schema As noted in Create module tables, you can update contract functions without updating or recreating database tables. However, you can't modify the table schema when you update a contract. In general, Pact doesn't support database migration or schema and table upgrades. To update a database, you must declare new tables and define any data migration functions as part of a module load step for the new module that contains the modified table schema. To update a table schema: Create a new module and declare the new table schema. Add functions to read rows from the old table and write them to the new table. Deploy the updated module with the new table schema on the network. The original table and database state remain unchanged on the blockchain, but won't receive any new information after you deploy the new module. Identifying active and inactive rows Pact doesn't provide a delete function because of the potential issues with performance, data integrity, and data migration that row-level delete operations can introduce. In addition, being able to delete rows or tables violates one of the most important properties of a blockchain environment: that it provides an immutable record of state. Because deleting information from tables could also cause problems for replaying transactions or synchronizing nodes and leave the chain in an unhealthy state, Pact doesn't support deleting rows or tables. However, you can use an column in tables to identify active table rows on insert, then later flag rows with obsolete information as inactive. Inactive rows remain in the database, but you can write logic to prevent them from being updated or retrieved. For example, you might define the schema and like this: To add new users to the table, you might define a function similar to the following: You can then define a separate function to identify rows—using the key-row—that are no longer active similar to the following: You can then check whether the column is or for a specific row before allowing the row to be updated with code similar to the following: For example, you can set the column to for the row identified by with a call similar to this: If you then attempt to update the column for the row, you'll see the message that the change isn't allowed:",
    "source": "smart-contracts/databases.md",
    "title": "databases"
  },
  {
    "content": "title: Capabilities description: \"Capabilities are the primary means by which you can grant granular permissions to perform tasks for which you wan to control access.\" id: capabilities sidebar_position: 8 Capabilities At a high level, Pact capabilities are a straightforward access control model for smart contracts. With capabilities, you can define specific conditions to authorize specific actions for specific users. Capabilities provide an explicit and transparent way to protect privileged operations, enforce rules before allowing transactions to execute, and ensure smart contract users authorize actions that are performed on their behalf. Because capabilities are a core feature in the Pact smart contract programming language and powerful in how they enable you to manage permissions and resources, it's important to understand what they are, how they work, and how to define them correctly to achieve intended results. Permissions, resources, and events Before getting into the details of how capabilities are defined, you should consider that there are three distinct—but related—use cases for capabilities. You can define capabilities to do the following: Authorize access to a specific privileged operation. Manage updates for a specific protected resource. Report events from operations executed in a transaction. In the most common use case, you define capabilities to manage permissions by enforcing one or more conditions. In combination with guards, these permission-driven capabilities act as gatekeepers to grant access to smart contract functions if the user or contract that controls the guard allows the operation to continue. In general, capabilities protect privileged operations—such as coin.transfer operations—that users must authorize by signing the transaction with their keys or verify in some other way. However, as a contract author, you can define capabilities verify other conditions—such as the account balance or how long it's been since the last transfer operation—before granting the permission requested. If the permission isn't granted, the code where the capability is called won't be executed. You can think of the capabilities that are used to manage permissions as basic capabilities. For more information about defining, acquiring, and scoping basic capabilities, see Expressing basic capabilities In addition to permissions, you can use capabilities to manage values for specified resources. Capabilities that manage resources are called managed capabilities. Managed capabilities have slightly different properties enable users or other contracts to set and update the value for a specified parameter. As a contract author, you can define managed capabilities to allow contract users to manage a resource value, for example, to set a limit on the amount that can be transferred in a given transaction or to define the maximum supply of a resource. For more information about defining and using managed capabilities, see Managed capabilities. Capabilities can also emit events in transaction results. For more information about using capabilities to emit events, see Events. Expressing basic capabilities Basic capabilities enable you to manage permissions by specifying the conditions that allow access to a particular resource or contract function. Therefore, in most cases, you define capabilities inside of the same module declaration as the functions that should use them. Within the module declaration, you define capabilities by specifying the reserved keyword and providing the following information: A capability name that describes the permission to be acquired or the operation to be protected. Optional parameters that specify input arguments, properties, or conditions for the capability. A capability body with the predicate function that determines whether the capability is granted or rejected. This predicate function is evaluated during capability acquisition. The following example defines a basic capability in a module: In this example, the declaration for the capability consists of the following: is the name of the capability. is a parameter that is passed to the capability body to be evaluated. is the capability body that implements the predicate function. The capability body is evaluated when the function is called with a specific parameter. For example, if the is , the capability body is evaluated when is called. In its simplest form, the capability body evaluates one or more conditions to determine whether the permission is granted. If the conditions are met—without exiting or throwing an error—the capability is granted and operations continue. In general, you should test all of the conditions you want to define in the declaration using statements, so that the permission won't be granted if any condition fails. Evaluating and granting permissions The declaration defines the conditions to evaluate to determine whether a permission should be granted (true) or rejected (false). You use the built-in function whenever you want to check these conditions before allowing a user to perform a privileged operation. For example, the following function calls the function to evaluate the capability before executing two protected operations: As illustrated in this example, the capability applies to the protected operations inside of the code block. If the capability is granted, it remains in scope for all operations contained within the scope of the function. In this example, the capability remains in scope for the and functions. After the code block containing the call to the function exits, the capability is no longer in scope. In this example, the capability is removed from scope before executing the function that's outside of the block. Restricting the capability to the code contained within the block prevents duplicate testing of the predicate. Capabilities that have already been acquired and that are currently in scope are not re-evaluated. Requiring a capability The function enables smart contract users to attempt to acquire a specified capability that allows them to perform an operation within a limited scope. The function requires smart contract users to have already been granted the specified capability before they can execute an operation. The function doesn't evaluate the conditions to grant a capability. If the required capability wasn't acquired in the context of another function, the function calling the function fails. For example, you can require the capability to have been acquired and currently in scope before executing the function like this: By requiring a capability, you can define private or restricted functions than cannot be called directly. In this example, the function can only be called by code inside the module that grants the capability and can only be called for this in particular, restricting the function to that user. However, it's important to note that the function doesn't scope to a body of code. The position at which you insert it affects the semantics of the function call and the operations that happen first, before the capability requirement is applied. If you insert the call at an inappropriate position, you might see unexpected behavior or error messages. In general, you should insert the call at the beginning of a function call. Composing capabilities A declaration can also include other capabilities, for modular factoring of guard code or to compose an outer capability from smaller, inner capabilities. For example, the following capability declaration includes an inner capability—the DB_LOG capability—that's defined its own separate declaration: Composed capabilities must be defined using declarations in the same module as the parent capability and are only in scope when their parent capability is granted. In many cases, you can use the function to improve code logic with clear separation of concerns. The following example illustrates separating the , , and functions—and corresponding capabilities—so that is always called with a corresponding operation with the capability being a \"no-guard\" capability that simply encloses the and calls: In this example: The capability protects the and calls from being used independently. The capability governs the ability to debit, enforcing the guard. The simply creates a restricted capability for the function. Calling basic capabilities To give you better insight into how to call capabilities, it's important to consider the concept of scope in Pact modules. Potentially, there are several layers of scope that can you might need to navigate, including: Top-level scope Module scope Outer capability scope for composing capabilities Inner capability scope for composed capabilities Signature-based scope You've seen an example of outer and inner capability scope in Composing capabilities. However, it's equally important to know the difference between top-level scope and module scope for capabilities. Top-level scope In Pact, the functions and expressions that you execute outside of a module declaration are often referred to as top-level expressions. Functions and expressions that are defined within a module declaration are within the scope of that module. For example, top-level expressions can include direct calls to built-in functions like the following: In addition, there are several top-level expressions that set context for a module that must be defined outside of the module declaration. For example, you use top-level expressions to define and enter a namespace, define keysets, create tables, and read messages from transaction data. Module scope The functions and expressions that are defined in a module declaration are included in the scope of that module. For example, if you define the function in the module declaration, the function is within the scope of the module. Acquire a capability inside of a module In most cases, capabilities are defined within the scope of a module and you can acquire the access token from within the body of any function defined in the module if you meet the conditions specified in the body of the declaration. For example, you can acquire the capability by using the call in any function declaration or step in the module where the capability is declared. These examples demonstrate the most common way you acquire the privileges associated with a capability is by calling the built-in function within a or declaration inside of a module declaration. If the conditions specified in the body of the capability declaration are met, permissions are granted and the operation proceeds. The conditions you specify in the body of the capability declaration can vary, but typically enforce some type of guard or key signature. You should also note that you can't acquire a capability inside of a capability declaration. For example, if you try to acquire a capability in the body of a capability declaration, you'll see an error similar to the following: Acquire a capability outside of a module You can acquire a capability in the top-level—that is, outside of the scope of a module—or within the scope of another module if, and only if, you have the administrative privileges to control the module and satisfy the conditions to acquire the capability. The following example illustrates a module declaration for the module that defines a GOVERNANCE capability and an UMPIRE capability with conditions set to true to always succeed: If you deploy this module or load it into the Pact REPL, the GOVERNANCE capability grants you the administrative privileges for the transactions immediately following the deployment of the module. For example, after you load the module in the Pact REPL, you can acquire the capability to perform an operation: Because deploying a module grants you administrative privileges for the module, you can perform other privileged operations—like upgrading modules and creating tables—in the same deployment transaction. In this example, there are no conditions that must be met to acquire the capability. If there were conditions to enforce in the body of the declaration for the capability, those conditions would need to be satisfied to perform the requested operation. The previous example demonstrates the principle of using module administrator privileges to bring a capability into scope. However, this example doesn't represent a typical use-case. In most cases, you want to carefully control and restrict access to capabilities to prevent unintended privilege elevation. If access to the module administrator privileges is managed in any way—for example, owned by a specific keyset or guard or if a module is not upgradable—you must be able to acquire the module administrator rights to bring a capability into scope. To acquire module administrator rights for testing purposes in the Pact REPL, you can use the and built-in functions. The following example demonstrates using the function to access module administrator rights for to upgrade a module: To limit module administrator privileges for a capability to a specific transaction block, you can use the built-in function. Managed capabilities Most capabilities control permissions to access protected operations. However, Pact also supports managed capabilities. Managed capabilities provide an additional layer of security that requires all parties involved in a transaction to specify the actions they are authorizing with their signature or a guard. By requiring a signature or guard to authorize an action, managed capabilities enable smart contract users to safely interact with otherwise untrusted code. As a smart contract author, you specify that a capability is a managed capability by adding the metadata tag in the declaration body. You can define managed capabilities to manage resources in two different ways: To update a specific resource dynamically through a management function. To automatically update a resource once without using a management function. Managed capabilities that use a management function can be called multiple times. Managed capabilities that don't specify a management function can only be called once. Using management functions One of the most common use cases for managed capabilities with management functions is for transfer operations. The following example illustrates this use case with the managed capability and the management function: In this example, the capability allows the to approve any number of transfer operations to the up to the managed resource specified by the keyword. In this case, the resource is the value and the function checks and updates that resource value each time the capability is called for in the function: If transfer operations exceed the value, the capability can no longer be brought into scope. Smart contract users set the values for the operation and capability and approve the operation by signing for the capability when they send the transaction to the blockchain. Typically, you allow smart contract users to set the transfer values and approve the operation through the frontend of a smart wallet or a similar application. For example, as a smart contract author, you enable smart contract users to construct and submit transactions that set the , , and parameters and sign for the capability when they call the operation. In the Pact REPL, you can emulate setting the keys in the environment data and signing the capability. For example: You should note that managed capabilities always require smart contract users to explicitly approve the operation to be performed. If a transaction includes a managed capability, all capabilities involved in the transaction require a signature. Unrestricted keys aren't allowed if a transaction includes a managed capability. In most cases, managed resources represent decimal or integer values, but you can use managed capabilities and management functions to manage any type of resource. For example, you could specify a list or an object as the resource you want to manage, then write a management function that removes names from the list or updates object properties based on some condition. However, the keyword only allows you to specify a single resource to be managed—that is, updated—by the management function. Single-use managed capabilities Managed capabilities that specify a management function update the managed resource dynamically each time the requested capability is acquired. If a managed capability doesn't specify a management function, the requested capability can only be called once in a transaction. Further attempts will fail after the initial grant goes out of scope. In the following example, the VOTE capability is automatically managed to ensure that a validated member can only vote once: Scoped signatures and verifiers In Pact transaction messages, transaction signers can scope their signature to one or more specific capabilities. By scoping signatures to specific capabilities, smart contract users can restrict guard operations based on that signature. These explicitly-authorized actions are separate from the Pact code that's executed in the transaction. Regardless of the code that runs during the transaction, scoped capabilities ensure that only authorized actions can be performed on the user's behalf. Unlike managed capabilities that require a signature or a guard and a managed resource, most capabilities allow users to sign transactions using an unrestricted signing key. Scoped capabilities provide a transparent way for transaction signers to safely call untrusted code. For example, the of a transaction can explicitly sign for the capability to authorize gas payments in the contract. By scoping the signature to this capability, the account signature can't be used to access any other code that might be called by the transaction. If a user authorizes a specific capability, the capability is attached to the signature list for the transaction. For example, the following transaction excerpt attaches two capabilities—coin.TRANSFER and coin.GAS—to the public key \"fe4b6da332193cce4d3bd1ebdc716a0e4c3954f265c5fddd6574518827f608b7\" signature: The following example illustrates an module with a capability that isn't managed: In the Pact REPL, you can attach the signature for the key to the capability by using the built-in function as follows: If you modify the scoped capability to use a different receiver or amount, the transaction returns a keyset failure. For example: Scoped capabilities can also be installed by verifier plug-ins. Capabilities that are installed by verifier plug-ins are also scoped to the specific capabilities that they install. Verifier plugins are external to Pact. However, they are similar to signature capabilities in that they enable you to specify some type of trusted entity—for example, a signature or a generated proof—that grants the capabilities to perform some type of protected operation. A signature capability can use the function to check that the keyset guard includes the signer's key. A capability granted by a verifier plug-in can use the function to check that is the name of the verifier plug-in. Events In Pact, events are emitted as part of transaction execution and are included in the transaction results. With events, you can monitor transaction results to determine if a specific operation occurred and prove the outcome using a simple payment verification proof. Events are treated as capabilities because they share the following characteristics: Events, like capabilities, allow arbitrary data to be published under a topic or a name. With capabilities, the capability name is the topic, and the arguments are the data. Granting permission to acquire a managed capability is, in itself, an event recorded for transaction. Events complete the managed capability lifecycle, where you might install or approve a capability of some quantity on the way in, but not necessarily see what quantity was used. With events, the output of the acquired capability is present in the transaction results. Capabilities are protected such that they can only be acquired in module code, which is appropriate for events as well. You can emit events for any basic capability by including the metadata tag in the declaration. For example: If you include the metadata tag in the declaration, the event is emitted any time that capability is successfully acquired. Basic capabilities that aren't managed can emit events any number of times. Managed capabilities emit events automatically without specifying the metadata tag. The event for a managed capability is emitted once when the capability is first installed or acquired. Events from managed capabilities include the parameters specified when the capability was installed or acquired. You can use the built-in function to test for emitted events in scripts.",
    "source": "smart-contracts/capabilities.md",
    "title": "capabilities"
  },
  {
    "content": "title: Pact best practices description: \"Recommendations and reminders for patterns to avoid and practices to follow when writing programs using the Pact smart contract programming language.\" id: best-practices Pact best practices As a programming language, Pact has some unique features that make it adaptable to writing sophisticated applications, but that are also flexible enough to allow coding mistakes that can make a contract vulnerable to potential misuse. This topic summarizes common mistakes to avoid and best practices you should follow as you develop programs with Pact. Common issues and mistakes The following list summarizes the most common difficulties that developers who are new to Pact encounter or are most likely to misinterpret. Internal methods are often not guarded by capabilities, allowing any unprivileged user to modify contract state. Capabilities are often granted in cross-module calls by accident, giving the target module more permissions than it should have in the calling module. How namespaces, accounts, and guards are used in Pact can be difficult to adjust to for developers familiar with other blockchain ecosystems or programming languages. For example, Solidity developers are used to accounts being public keys and contracts having addresses, and often write smart contracts that only support single key (k:) accounts or deploy contracts insecurely in the free namespace. Developers often forget to add types to their contracts, causing type errors that result in failed transactions later on. Projects often split contract functionality into too many separate contracts—even if they share the same governance—complicating security and the overall design. Contract operations that require user authorization use the function to require a transaction signature without using a capability. In Pact, capabilities enable users to scope their signature to specific actions—explicitly signaling their consent—so that they know exactly what operations they are authorizing with their signature. However, if you allow unscoped signatures by using without putting it into the body of a capability code block, it's impossible for users for know what actions they are authorizing with their signature. Developers often avoid defining managed capabilities because they seem complex or to introduce friction by requiring users to explicitly authorize the operation they are signing for. However, managed capabilities prevent transactions from replay operations that could allow funds to be drained from accounts or other operations could have unintended consequences. By requiring a signature, capability guard, or user guard to authorize activity, you can safeguard users from transactions that perform unintended operation when executing contract functions. Developers sometimes deploy contracts in the free or user namespace, fail to register a principal namespace, or accidentally deploy contracts in more than one namespace. It's important to note, that functions are defined in module declarations, and modules are deployed in namespaces. A function defined in the module that's deployed in the namespace is not the same as the function defined in the module that's deployed in the namespace. Even if the code is identical, the path to the function uniquely identifies each function. Best practices The following list summarizes patterns, practices, and strategies for writing Pact code and delivering quality projects for the Kadena ecosystem. Explicitly type all function parameters and results. Use objects with schemas and use lists with the list item type resolved. For example, use and avoid . Similarly, use instead of . Run the type checker over the code as you iterate on the implementation. Create unit tests for every function that fully exercise error cases, especially cases of missing authorization to perform actions. Be careful when using module references. In particular, keep in mind that when you call into other modules, those modules will be granted the same set of capabilities as the code making the call into those modules. Use the built-in functions to check for conditions that should terminate transaction execution immediately. The functions ensure that if any invariants are violated, the transaction fails. Use the endpoint when you want to query Pact state in tables or blockchain data. Use events to send information about transaction results to off-chain software. Only use and built-in functions in queries. Consider what data must be on chain and any data or operations that might be better suited to off-chain handling. Plan for longevity and avoid defining functions that grow data structures—like lists—without bounds. In general, gas usage per transaction should not go up over time as your code is used more. Keep functions that share the same governance in the same module. It’s fine to create composable contracts with reusable utility functions. However, it’s generally a better practice to keep the implementation of core functions in the same module unless the functions are governed by different parties. Design and document the capabilities your contract requires and the conditions you'll use to enforce that only authorized users have access to privileged operations. Remember that capabilities can provide explicit and fine-grained access control to functions, but only if you enforce the conditions to guard them correctly. Upfront planning can help to ensure you define and grant capabilities precisely where they are needed to make your contract secure. Be sure you know how calling a capability by using the function differs from calling a capability by using the function. Keep in mind that any code executed in the same transaction as the transaction that deploys a contract is granted full administrative privilege over the module, including the ability to update the module and edit module tables. Create your own principal namespace before deploying contracts on the Kadena test or main production network. You should always use managed capabilities to guard contract operations that require user authorization and that should only be executed once in a transaction. All capabilities allow users to authorize specific actions. Managed capabilities allow contracts to keep track of how a capability that's been granted in a transaction can be used, either by setting a limit on a protected resource or by preventing the capability from being granted more than once in a transaction. For functions involving assets transfers, you should use managed capabilities to prevent replay attacks within a transaction. Enforcing access controls As discussed in Capabilities, basic and managed capabilities are critical components for controlling how permissions are granted to users of smart contracts. In addition, most modules define a governance capability as the module owner. Conceptually, capabilities aren't difficult to comprehend or implement. However, if they aren't used correctly, capabilities can make your contract vulnerable to unexpected behavior or to be exploited. The following examples demonstrate patterns and outcomes for governance and basic capabilities. Governance As discussed in Modules and references, every Pact module has a keyset or capability that has full administrative ownership of the module. In most cases, modules define a governance capability. The governance capability for a module is different from other capabilities in two important ways: The governance capability for a module provides total control over the code defined in the module. With this capability, the module owner can grant capabilities, access tables, modify module functions, and deploy upgraded module code on the blockchain. External code can attempt to take control of a module by acquiring the module's governance capability. Usually, capabilities can only be granted inside the module they are defined in. In example code for modules, the body of the governance capability is often set to for simplicity. For example: If the code associated with a capability—like GOV in this example—is simply set to true, no conditions are being enforced to restrict access and the capability is always granted when requested. Any Pact code can take total control over the module. If you don't enforce any restrictions on the module administrative privileges, anyone can take control of the contract and modify its tables and functions. This vulnerability might seem insignificant while you're testing in a development environment. However, it's important to plan for and implement access controls that prevent unauthorized use of functions that perform any type of sensitive or privileged operation. The following examples demonstrate common patterns to avoid and follow to help you make contract operations more secure. You can find more complex and complete examples in the contract and in the and repositories. As previously noted, the following pattern is often used in sample code for simplicity: However, this pattern makes your contract vulnerable to hijacking with no protections in place to prevent unauthorized access. You should only use this pattern in your local development environment and in the early stages of learning to write Pact code. Another common mistake is to read a keyset or message that doesn't enforce a signing key to grant a capability as illustrated in the following example: In this example, the function reads whatever value is defined under the \"hello-world\" key in the environment data. The function doesn't verify that the value under the \"hello-world\" key represents a valid keyset object, valid values, or a keyset you control. If someone else specifies a valid keyset in the environment data, that keyset would pass the governance check and take control of the module. The following example is similar except that it identifies a specific keyset name to enforce—not just read—and specifies that the keyset exists within the namespace: This example uses the correct syntax, but the keyset could be claimed by someone else if you don't create the keyset in the message payload for the transaction used to deploy the module. The following example illustrates a more secure pattern that defines a keyset, then uses that keyset to control the administrative privileges for a module: In this example, you define a keyset in the principal namespace and must include the keyset definition in the environment data for testing in the Pact REPL or in the message payload for deployment. Basic capabilities The following example illustrates defining a second capability to control access to a specific function: This example requires the contract to be loaded and the specified account to exist on-chain. The function has also been modified to require an string as an argument. For example: With this pattern, the condition for the USER capability checks that the guard matches the specified account. If the account exists and the condition evaluated is true, the account can run the function. The USER capability now enforces that only the specified account can run the function. The following example illustrates using a guard as input to acquire the capability to access a specific function: In this example, the function has been modified to require an string and a as arguments. If the guard is a keyset, you can use the function and keyset name to input the keys and predicate for the account. For example, if the guard is the keyset you defined using as the keyset name, you could call the function with arguments similar to the following: The following example illustrates another common enforcement mistake; With this pattern, any string used for the argument passes the enforcement rule for the USER capability, enabling any user to acquire the capability and use the unprotected function. For example, any value can be used with this function: The following example illustrates using a hard-coded account string instead of reading a keyset or guard from a table or the message payload: If the enforced string is used, the capability is acquired: If any other account or arbitrary string is used, the operation fails:",
    "source": "smart-contracts/best-practices.md",
    "title": "best-practices"
  },
  {
    "content": "title: Basic concepts id: basic-concepts sidebar_position: 3 description: \"Get familiar with important Kadena blockchain and Pact language concepts and terminology.\" Basic concepts The main purpose of a blockchain is to record transactions. Typically, transactions are business events that transfer some form of digital asset from one owner or entity to another. Through the use of modern cryptography, a blockchain can provides guarantees about the authenticity and integrity of the transactions recorded without relying on any central authority or under the control of any government, corporation, or other institution. The decentralized nature of the blockchain depends on having its computational resources distributed across many individual computers. The individual computers in the network—called nodes—run the blockchain software and communicate with each other as a peer-to-peer (P2P) network using the internet and publicly-accessible IP addresses. Nodes provide the bandwidth, processors, memory, and storage capacity to handle incoming transaction requests and validate the transactions results that change the blockchain state. Consensus models The method that a blockchain uses to validate transactions, insert transactions into blocks, and submit blocks to continue the chain is called its consensus model or consensus algorithm. For the Kadena blockchain, the method of adding new blocks to the blockchain is a variation of a proof of work consensus model used by Bitcoin. With the proof-of-work consensus model, the first node to solve a computational problem for a transaction adds the transaction to a block. As new transaction are added to blocks and new blocks are produced, all of the nodes in the network attempt to stay in synch with each other so that there's a consistent view of the blockchain state. The computers used to solve the mathematical problems that validate transactions typically run specialized hardware and are commonly referred to as miners because they earn rewards for the work they do to keep the chain going. The rewards take the form of KDA tokens that are deposited in accounts owned by the node operators. The Kadena proof-of-work consensus model is unique in its use of multiple chains to support horizontal scaling and in the use of degree and diameter network design to identify adjacent peers. Chainweb and parallel chains Networks that rely on a proof-of-work consensus model provide security and decentralization, but are often limited by scalability issues, including: The number of transactions they can process. The speed at which they can process transactions. The energy consumption required to validate transactions. The high cost of transaction fees when the network in busy. These factors have limited the effectiveness of blockchain networks to handle modern economic activity. The Kadena proof-of-work consensus model is designed to address these scalability issues and deliver a blockchain built for business. The core of the Kadena blockchain is defined in its Chainweb architecture. The Chainweb architecture is based on a proof-of-work consensus model, but introduces the concept of parallel blockchains to minimize latency and maximize throughput. The parallel chains are connected through peer nodes in an adjacency graph that makes efficient use of cross-chain hops for transaction execution and validation. The optimized network connections enable the chains to operate simultaneously to increase transaction processing capacity and reduce transaction costs across all of the chains in the network. The nodes that participate in the network run software to communicate as a peer-to-peer network and to execute transactions. Each parallel chain includes block hashes (Merkle roots) from blocks on peer chains into their headers. By referencing block hashes from peer chains, each chain can validate the consistency of its peer chains and provide a trustless oracle for cross-chain transfers of funds. With this mechanism, the chains are braided together into a single canonical chain that offers an effective hash power that is the sum of the hash rate of each individual chain. Each chain in the network mints its own coin, but all of the chains use same cryptocurrency. Because the chains share a common currency, coins can be transferred cross-chain using a trustless, two-step simple payment verification (SPV) at the smart contract level. Applications and smart contracts Applications that run on a blockchain—often referred to as decentralized applications or dApps—are typically web applications that are written using frontend frameworks like React, Angular, Vue, or Next.js but depend on backend smart contracts to capture, store, modify, and read application data. A smart contract is a program that executes specific instructions under specific conditions that can be programmatically-enforced to ensure that the outcome is recorded and immutable. Smart contracts can be written in different languages for different blockchain networks. For the Kadena network, most smart contracts are written using the Pact smart contract programming language. Pact has several key features that make it well-suited to writing business applications that run as smart contracts on the Kadena network and Chainweb nodes. Namespaces and modules Two important concepts in Pact are namespaces and modules. A namespace is a logical ownership boundary for smart contracts that are controlled by a specific entity. Smart contracts include a namespace declaration to provide a unique prefix for everything—including modules, functions, keysets, and interfaces—that are defined within the namespace scope. The root namespace in the Kadena test and main networks is reserved for built-in contracts like the contract. You can't deploy contracts directly in the unpartitioned root namespace. However, Kadena provides the namespace and the namespace as publicly-accessible namespaces for testing and training purposes. For local development, you can deploy contracts directly in the local root namespace or define custom namespaces. For public blockchains like the Kadena test and main networks, you must define and register custom namespaces for your projects. Within a namespace, modules are the fundamental building blocks that provide the logic used in all Pact smart contracts. All of the functions and data definitions that are required to complete a set of related business operations are defined within the context of a module. Individual modules are often self-contained logical units that implement a related set of functions. Keysets, capabilities, and guards Keysets define authorization rules for smart contracts. They often determine who can access specific functions in a program and the keys required to sign specific transactions. Capabilities define specific privileges or permissions that must be granted or acquired to perform specific operations within a section of code. Guards provide to enforce specific conditions, including that required keyset is being used or a specific capability token has been granted. A keyset is itself a type of guard. Cross chain and multi-step transactions Pact supports cross-chain and multi-step transactions by enabling you to define a sequence of steps in a declaration. With a declaration, you can emulate an escrow service or orchestrate a process that must be completed in a specific order. Execution modes Pact is designed to use distinct execution modes to address the performance requirements of rapid linear execution on a blockchain. These execution modes are: Contract deployment. Transaction execution. Queries and local execution. Contract deployment When a contract is deployed, the deployment transaction that's sent to the blockchain is comprised of modules, tables, and authorization data. The transaction can also include code that modifies the database, for example, to initialize information that the contract requires. As a general rule, the transaction that you use to deploy a contract on the blockchain should be sent as a single message, so that any error will rollback the entire smart contract as a unit. When contracts are initialized on the blockchain, they identify a namespace that provides context for the contract code and a unique prefix for modules and interfaces defined in the contract. Modules contain the main business logic for the application or service you want to deploy. Interfaces provide access to constant definitions and typed function signatures that are defined outside of a module to be implemented an used in a module. Deploying a contract also requires you to define one or more authorization keysets that have administrative control over the contract modules and tables. Keysets that are defined as data in the runtime environment are then stored in the global keyset database. After setting the runtime context, Pact executes the module and interface declarations and creates required tables to complete the contract deployment. Transaction execution Most of the transactions executed on the blockchain are intended to record business events. For example, business events often involve the handling of assets, payments, ownership transfers, or the completion of contractual agreements. These types of transactions are typically executed using a single call to a specific module function. However, there is no limit on the number statements you can execute in a transaction and you can define transactions that are executed as a sequence of steps. Note that the difference between transaction execution and contract deployment is simply the kind of code executed. There's no difference in how the code itself is evaluated. Queries and local execution In general, querying data that's stored on the blockchain isn't considered a business event where execution and performance are more critical. In addition, queries can often involve larger data payloads that could introduce overhead, bandwidth, and latency issues. To reduce the impact of queries on network operations, queries are handles as local execution requests on the node receiving the message. Historical queries use a transaction hash as a point of reference to avoid race conditions and to allow asynchronous query execution. Pact code doesn't distinguish between transactional execution and local execution. However, the Pact API provides separate endpoints to execute transactions on the blockchain and submit local execution requests. FOr more information about using the Pact API endpoints, see Pact API.",
    "source": "smart-contracts/basic-concepts.md",
    "title": "basic-concepts"
  },
  {
    "content": "title: Accounts, keys, and principals description: Learn about how public and secret keys are used in accounts and how accounts on Kadena blockchain differ from accounts and addresses on most blockchains. id: accounts sidebar_position: 4 Accounts, keys, and principals With most blockchains, accounts and account addresses that can send and receive funds are based on generating public and secret key pairs then using your public key as your account name. This “one-to-one” model keeps things simple, but runs into problems when you want to use multiple keys for a single account. For example, you might want an account to represent joint-ownership for partners in a relationship or the officers in a board of directors who must approve expenditures by a majority vote. To handle situations where an account must represent more than one owner, Kadena makes a distinction between keys and accounts. This distinction enables multiple keys to be associated with the same account name. In simple terms, an account name is a unique name on the blockchain that can hold funds with one or more public and secret key pairs that grant access to the account. The keys determine ownership of an account. The rules for how many keys are required to act on behalf of the account are defined in a construct called a keyset. Defining a keyset A keyset is a specific type of guard that consists of one or more public keys and a predicate function that specifies how many of the keys are required to perform an operation. In JSON, a keyset object looks similar to the following example: In this keyset, there are three public keys defined as owners associated with this keyset. The predicate function of means that any of the three public keys can sign transactions and act on the behalf of the account associated with this keyset. To make this keyset usable for practical purposes in a smart contract, it's assigned a name. You can then reference the name to check whether an action is valid by verifying at least one (keys-any) of these three public keys has authorized it. In this example, you evaluate the keyset name and, if the result is , allow the action to be performed. Defining accounts Keysets are important because they are one part what it takes to define an account. An account is an entry in the Kadena contract, the ledger that keeps track of all transfers from one account to another. In the contract, an account consists of the following parts: Key: An account name in the form of a string of 3 to 256 LATIN-1 characters (key). Vale: An account object that holds the decimal balance of funds in the account and the keyset that governs the account. As you saw in the previous example, the keyset consists of one or more public keys and the predicate function that specifies the number of keys that must sign a transaction for the account. There are three built-in predicate options: keys-all keys-any keys-2 For most accounts—where there's only one public key with ownership of the account—the default predicate of works as you would expect it to, granting ownership of the account to a single party. However, the predicate function is important to consider when creating accounts that require multiple signatures or have multiple owners. For example, the predicate requires that at least two public keys defined in the keyset for the account must sign a transaction to authorize the execution of that transaction. The following diagram illustrates the relationship between keys, keysets, and accounts: If you would like to learn more about keys and accounts in Kadena, see Beginner's Guide to Kadena: Accounts + Keysets. Accounts on a multi-chain network The Kadena network is a scalable proof-of-work blockchain with a consensus model that weaves the transactions and blocks from multiple parallel chains into a single and consistent view of the blockchain state. For a visual introduction to how the Kadena Chainweb protocol weaves connections from multiple chains into a single view of state, watch the 3-minute video How Chainweb Works: A Simple Animation. Ultimately, this single view of state is one network. However, each of the parallel chains in the network operates independently. When you create and fund an account on any chain, it only exists on that chain. You can create accounts on more than one chain, but they are essentially independent accounts, with separate account balances and potentially different keysets and owners. Because the chains operate independently, you should always pay close attention to the network and chain identifier you have selected when you are signing and submitting transactions. It's also important to remember that the account name—on its own—doesn't determine the ownership of an account. The keyset associated with an account determines ownership. You could own an account named Alice on chain 0, and someone else could own an account named Alice on chain 5. If you want to own a specific account name across all of the chains in the network, you would need to be the first person to create that account with your keys on each chain. To create a one-to-one relationship between a specific account name and a specific keyset, Kadena introduced the concept of principal accounts. Account names and principals As mentioned in Defining accounts, an account name can be any string. Using an arbitrary string as an account name can be convenient. For example, you might want to create an account with a name that identifies it as a personal or primary account, for example, Lola-Pistola, so that it's easy to differentiate it from an account that you own jointly with another party or a group, for example, Las-Pistolas. However, using arbitrary or vanity account names like these examples can make your account vulnerable to certain kinds of attacks. For example, an attacker might try to frontrun a transaction that creates an account or transfers funds by changing the keyset associated with the account name. One way to prevent an an attacker from trying to impersonate you with a frontrunning attack is to create principal account. A principal is a way to enforce a one-to-one relationship between a guard and a resource that the guard is there to protect, like an account name to protect the ownership of an account balance. If an attacker tries to intercept a transaction by changing an account keyset—the most common type of guard—the new keyset won't match the one defined in the underlying ledger, so the transaction would fail. Keysets and principals Keysets represent the most-commonly used type of guard and are the most similar to how most blockchains protect access to accounts using public and secret keys. As you've already seen, a keyset holds a collection of one or more public keys and a predicate function that defines how many of those keys must sign to authorize an action. In Pact, a guard is an assertion of ownership, for example, the ownership of a particular keyset, capability, or user attribute. By calling a function to enforce the guard, Pact produces a Boolean value that must return true for an associated action to take place. By default, when you define a principal account with a single public key and the keys-all predicate, the result is an account name that starts with the prefix, followed by the public key for the account. This naming convention creates a principal account for an individual key. You can use the built-in function to create a principal account name for a specified guard. The function returns a string that represents the principal identified by the specified guard. In the following example, the function creates a principal from the guard with the name : You can also create principal accounts for keysets that have multiple keys and that use either built-in or custom predicate rules. For example, you can define a keyset with two public keys and the built-in predicate . If you create a principal for this account, the keyset information is used to generate a unique hash and the account is created using the prefix, followed by the hash for the guard. In the following example, the function creates a principal from the guard with the name : Other types of guards In addition to keysets, Pact supports several other types of guards that you can implement in smart contracts. These guards give you flexibility for handling different types of authorization scenarios, and in general, you can use any type of guard to create a principal account by generating a unique hash. Each type of principal and guard uses a unique prefix, so they are easy to recognize. If you create principal accounts for the guards, you'll see that the principal accounts use the following set of prefixes: k: for single key keysets w: for multiple keys keysets u: for user guards c: for capability guards To learn more about different types of guards and how to use them, see Guards. Transfers within and between chains There are two main ways to move Kadena tokens (KDA) between accounts: Transfer coins between accounts on the same chain. Transfer coins between accounts on different chains The primary different between these two types of transfers is who pays the transaction fee to have the transaction included in a block. With same-chain transfers, the sender must pay the transaction fee. With cross-chain transfers, the sender and the recipient must both pay a transaction fee. With a cross-chain transfer, you interact with two different blockchains, which requires two separate transactions, one on each chain. If you attempt to send a cross-chain transfer to a recipient with no funds on the destination chain, the transfer operation won't be able to complete. However, anyone with funds on the destination chain can help to pay the required fee, allowing the transfer to finish as intended. Kadena has also set up gas stations cover the cost of transaction fees for cross-chain transfers. If you have an incomplete cross-chain transfer, you can use the Transfer assistant to finish the transaction on the destination chain. To learn more about transfers in Kadena, see Getting started with transfers.",
    "source": "smart-contracts/accounts-keys.md",
    "title": "accounts-keys"
  },
  {
    "content": "title: Writer's style guide description: Provides guidelines, conventions, and recommended practices for contributing to Kadena documentation. id: writing-guide keywords: documentation contributor guidelines conventions community writing style Writer's style guide This guide describes our approach to building effective documentation, the conventions we follow, and the recommended practices for organizing, crafting, and evolving our information architecture with a clear and consistent voice. Many style rules have equally justifiable alternatives. Following a common style guide is intended to prevent debates over style from getting in the way of documenting Kadena. If you don't see an answer to a style question in this guide, follow your best judgement and keep the style you choose consistent within the page or document you're working on. Organizing information into purpose-driven documents For software documentation, you can structure information using the following information model: Tutorials are learning oriented and designed to give a newcomer a positive, successful experience. Tutorials should be tested regularly to ensure they don't get stale and that they always provide a successful result. How-to guides are task oriented with practical steps to achieve a specific goal. These guides assume that readers are know the task they want to complete for a specific scenario but not necessarily how to complete it. References are information oriented technical descriptions of a system or its components. Explanations are the conceptual framework for understanding how or why a system works. Explanation provide the context that surrounds what people learn in a tutorial, do in a how-to guide, or look up in reference material. For more detailed information and examples of how to structure documentation using this information model, see The Grand Unified Theory of Documentation. Structuring content into pages In general, every page of documentation should have a purpose and be self-contained. It's okay for information to be in multiple places and similar content can exist in pages that serve different purposes. For example, you might have conceptual information about secret and public keys in one page and have similar content as context in a how-to topic for generating keys. When possible, you should reuse content rather than duplicate content, but it's perfectly fine to cover the same information in more than one place to serve different purposes. How-to guides A how-to guide describes how to achieve a goal or complete a task. Only the information that is pertinent to achieving that goal or completing the task is included. With how-to guides, readers have enough information to know what they want to do—for example, open a bank account—but not necessarily enough information to know how to do it. For example, the how-to guide for opening a bank account wouldn't explain what a bank account is or why you might want to open one, but would focus on specific steps such as: Select an institution. Fill out an application. Deposit a minimum amount of currency. How-to guides often include links to additional information, but should not include explanations that take the focus away from what the reader wants to accomplish. What's in a how-to guide? In most cases, how-to guides contain the following sections: Frontmatter with a title, description, and other information. The title should be short and identify the subject of the how-to topic in the fewest words possible. The description should be a sentence that summarizes the content of the topic. Additional information might include a list of keywords or the location of the source file. One or more introductory paragraphs that explain what the task-at-hand is, the use case or scenario driving the reader to complete the task, and the expected outcome. A \"Before you begin\" list of prerequisites. Prerequisites can include what you need to do, what you need know, or what you need to have before starting a procedure. For example, if completing a procedure requires the reader to have specific software installed, you should include a description of the software requirement in the \"Before you begin\" section. Task step sections that break down the how-to procedure into manageable chunks or subtasks with clearly-defined goals. If you're documenting a simple task that can be completed in less than ten steps, you can probably skip breaking it down into more atomic task sections. However, most how-to procedures benefit from being split into subtasks with fewer steps in each is subtask. If a procedure is more than ten steps, you should consider using task step sections. Steps in subtask sections should specify the action the reader should take. In most cases, steps should also describe the result the reader should expect after taking action. A \"Next steps\" section can be used to add links to logically related topics, if applicable, or to recommend related topics for further reading, such as reference topics related to the procedure completed. Using links, admonishments, and details in how-to guides You should avoid breaking the reader's focus in how-to guides. For example, avoid adding links to other pages or to other sections in the same topic. Avoid inserting notices, tips, admonishments, or other stylized and potentially distracting components unless absolutely necessary. If you include links to external documentation, explain why the reason to go there or what information the reader should expect to find there. For example, use explicit information like \"For more information about launching an EC2 instance, see Launch your instance in the AWS documentation\" instead of \"Read the AWS documentation for more information\". Tutorials Tutorials are designed to give first-time users or new developers hands-on experience completing a set of explicit instructions. Tutorials should be as simple and straightforward as possible, with one or more clear objectives that are consistently achievable. Tutorials must provide a positive learning experience and a successful outcome with no unexpected behavior or unexplained errors. It's okay for a tutorial to include a red herring to illustrate a common misstep but the author must provide a sufficient explanation of the error and how to correct it. What's in a tutorial? Tutorials provide information that's similar to how-to guides but are focused on achieving learning objectives. Typically, a tutorial includes: Frontmatter with a title, description, and other information. A tutorial might also include a link to a video demonstration that covers the same lesson. Tutorials can also be tagged with a skill level, estimated time to complete, or topic category. For example, tutorials can be assigned a skill level of Beginner, Intermediate, or Advanced or a topic category such as Pact or TypeScript. One or more introductory paragraphs that explain what the tutorial demonstrates. Introductory information can also include a brief summary of the expected outcome. For example, if a tutorial demonstrates how to create a simple calculator application, you can include a brief descriptions of the functions the application is going to support. A \"Before you begin\" list of the tools, knowledge, or skills required to complete the tutorial. Learning objectives that summarize what the reader will accomplish by completing the tutorial. Objectives can be listed under a \"Learning objectives\" heading, but only if this heading is used consistently for all tutorials. Task steps that the reader must follow in sequence to successfully complete the lesson. The same rules for task sections and steps for how-to guide apply for tutorials. A \"Next steps\" section is optional because tutorials are often self-contained standalone topics. However, you can use a \"Next steps\" section to add links to logically related topics or to recommend related topics for further reading, such as reference topics related to the lesson just completed. Conceptual explanation guides Conceptual guides explain core concepts and how Kadena, Chainweb, and other tools work at system, component, and operational levels. Conceptual guides can include information about software architecture, blockchain technology, network concepts and protocols, or cryptography. Conceptual guides explain the \"why\" and \"how\" at the foundational level. What's in a conceptual guide? Conceptual guides typically contain the following sections: Frontmatter with a guide title, description, and other information. Subsections and body paragraphs that explain that explain concepts, components, system operations, and context to help the reader understand what something is, why it's important, and how it works. Diagrams to illustrate component relationships, system architecture, or flow of operations. Links to related topics, where applicable. Reference manuals Reference manuals describe command-line programs with complete command-line option descriptions and examples, language semantics, API methods, and other technical details. Reference information is often organized using alphabetic order and presented in lists or tables. Information should be easy to scan henever possible. What's in a reference manual? Reference manuals typically contain the following sections: Frontmatter with a guide title, description, and other information. One or more introductory paragraphs that explain what information the reference covers. Formatted reference information. The format might resemble a page or API description with a common set of sections (name, description, syntax, options, examples, and so on) or the format might use lists or tables to present information. Links to related topics, where applicable. General guidance for engaging content There are three keys to writing content that engages the audience: Use the second person point of view to directly address the reader. Use an active voice and present tense whenever possible. Use a conversational tone that is not too formal or too chummy. Point of view In most cases, address the reader directly using imperative sentences (Run the following command) or as you (You can run the following command). Because tutorials provide a more guided approach to a topic, using the first person plural—we, us, our, ours—is more commonly accepted than in other types of documentation. Use the first person point of view sparingly and with intention. For example, in a tutorial you might use something like \"Let's try that now\" for a conversational tone. However, if you overuse the first person point of view, it can overwhelm the sense of a shared experience and obscure the reader's journey. Don't use “I” or “me” unless it appears in the text of a user interface element. Avoid using “we” in documenting a recommended setting or practice. Using “We recommend...” is ambiguous (\"we\" being who exactly?) and potentially dangerous if something goes wrong. If there are industry best practices or recommendations, it's okay to indicate that instead of using the royal or editorial \"we\" in documentation. Passive constructions In passive constructions, the object on the receiving end of an action is the subject of the sentence: This value is used for the field in the section of the configuration file. In active constructions, the person or object performing an action is the subject of the sentence: You use this value for the field in the section of the configuration file. When writing about software, it's often tempting to describe what's happening from the code point of view. However, there's almost always a human being with a goal or task to complete who is initiating the activity that the software is executing. If you keep this human presence in mind, your writing will be more dynamic, easier to follow, and more interesting to read. There are situations where a passive sentence structure might be appropriate, but be wary of using it. Contractions and conversational tone Contractions are generally acceptable because they give documentation a more natural conversational tone—at least for English speakers. Be conscious of when and why you use contractions. To keep the tone conversational but concise, adhere to the following guidelines: Use simple English words instead of flowery or literary language. Use “when” to imply eventuality and time. Use \"if” to imply the possibility of something happening. Use “since” to imply a period of time. Use “because” to imply cause and result. Use “once” to imply something that occurs a single time. Use “after” to imply something that occurs each time. Avoid dead language words and phrases even if they are generally accepted as English words in practice. For example: Instead of “i.e.”, use “that is” or rewrite the sentence to make the meaning clear without needing extra qualification. Instead of “e.g.”, use “for example”. Instead of “via”, use an appropriate English substitute such as “by”, “through”, \"from\", or “using”. Instead of “etc.”, use “and so on” or revise the content to make the term unnecessary. For example, revise to use such as or like followed by an example or two. Instead of “caveat”, use an appropriate English substitute such as “notice”, “caution”, or “warning”. Avoid adding unnecessary words or phrases. For example: Instead of “In order to”, just use “to”. Instead of “as well as”, just use “and”. Instead of “and then”, just use “then”. Avoid jargon, colloquialisms, and idiomatic phrases. Avoid adverbs and subjective statements. For example: Experienced developers who truly prefer to skip the tutorial... You can quickly test this code is functioning as expected... You can run the following script to easily deploy a cluster... Headings All heading levels should use the following conventions: Use sentence case. Sentence case means that only the initial word and proper nouns are capitalized. Use active, present tense verbs in headings wherever appropriate, especially in the context of tutorials and how-to guides. Use noun phrases for conceptual and reference topics whenever possible. Minimize the number of words you include in a heading text whenever possible. Avoid generic headings like \"Overview\" and \"Introduction\", if possible. Generic headings can be conceptually useful, but they don't add value to the content or the navigational experience. Include at least two sentences of content. A heading should never be immediately followed by another heading. Avoid using headings strictly for navigation. Limit heading levels As a best practice, avoid building an information hierarchy with more than three heading levels. Most content can be effectively organized using two internal heading levels, making it easier to navigate and scan for relevant topics. Topic titles Avoid using gerunds (verbs ending in \"-ing\") in titles and headings. Procedure titles and headings should answer the question: What are you trying to do? For example, if the answer to What are you trying to do? is I want to create an account, the article heading should be Create an account. In most cases, concept and reference topics that aren't related to tasks are named with a noun phrase, such as Blockchain basics. Lists Introduce lists with a heading, a sentence, or a fragment that ends with a colon. Use bulleted lists for items that don't need to appear in order. Use numbered lists only for processes and procedures that must be completed in sequential order. Bullets Use the same bullet type for all items in unordered lists. The order of items in a bulleted list can imply importance, but generally all list items are peers. Each list item should start with a capital letter and end with a period unless all of the list items are single words or short phrases of no more than four words. Use parallel sentence structure in phrasing the items in a list. For example, start each item in the list using a noun or a phrase that starts with a verb. Numbered steps Only use numbered paragraphs for steps in procedures. If a procedure has more than nine steps, always consider breaking it into subsections with headings. Ideally, each procedure or subtask: Should be three to six steps. Should have minimal embedded paragraphs describing what happens—the result or outcome to expect—in an unnumbered paragraph following the step. Should not have nested sub-steps. Pronouns Use gender-neutral pronouns, like “they” whenever possible. Generally, you can change any noun from singular to plural to have subject-verb-pronoun agreement and avoid the use of gender-specific pronouns like “he”, “him”, “his” or “she”, “her”, “hers”. Using \"they\" or \"their\" with singular nouns is more generally accepted in modern conversational English, but it's rare you to need to use the disagreeing format in documentation. Be wary of impersonal and potentially ambiguous pronouns such as: all, another, any each, either few, many, neither, none, one, other same, several, some, such this, that, them, these, those If you use any of these impersonal pronouns, be sure you answer “of what?”, “of which?”, or “as what?” in the sentence. Be especially cautious if you start a sentence with an indefinite pronoun like \"This\" followed by a verb. In most cases, the pronoun should be followed by an object. Kadena-specific styles Most of the style suggestions in this guide are general writing recommendations for any type of documentation project. The general recommendations aren't specifically focused on documenting Kadena. The topics in this section cover style conventions that are specifically for Kadena and Kadena documentation. Tone The tone of different articles might vary depending on the target audience. However, most topics in documentation should have a neutral conversational tone that delivers technically accurate information. Code, commands, and configuration Use backticks around inline code and commands. For example: You can run the command to check whether Docker is currently running. Use labeled code fence blocks for code snippets so that they render with syntax highlighting and a Copy button. For example: Diagrams Use the Kadena visual library to create diagrams with a consistent design language. Product names and capitalization Full product names are treated as proper nouns and capitalized. For example, Chainweaver and Pact are proper nouns. Don't capitalize terms that are common words and not proper nouns. For example, don't capitalize common terms like server, node, agent, and so on. Overuse of capitalization makes text more difficult to read. Technical concepts and acronyms Avoid using acronyms if possible. If you use acronyms, be consistent and use the same acronym for any given concept, protocol, or process throughout the entire page. For example, don't use a combination of \"multifactor\", \"2-factor,\" \"two-factor\", \"2fa,\" or \"tfa\" within a given page. Always use the full definition followed by the acronym in parentheses before using the acronym thereafter. For example, use \"Network Level Authentication (NLA)\", not \"NLA (Network Level Authentication)\" or \"NLA\" on its own without its full definition. Search engine optimization (SEO) Every page should have a clearly-worded description in the frontmatter. Descriptions should be full sentences and end with a period. Descriptions should include common keywords related to the subject matter if possible. Terminology and usage conventions This section covers common terminology, style, and usage questions. It includes recommended practices for using punctuation, referring to user interface elements, and selecting the right words for the information you're trying to convey. Above and below Don't use above to mean earlier or as an adjective preceding a noun (the above section) or following a noun (the code above). Use a hyperlink, or use previous, preceding, or earlier. Don't use below to mean later or as an adjective preceding a noun (the below section) or following a noun (the code below). Use a hyperlink, or use later or the following. For example: Use the preceding code to display information about the database. Use the following code to display information about the database. Dates and numbers Date formats can depend on context, including the location of a computer and a user's preferences. In most cases, you can use the DD Mon YYYY or DD Month YYYY format for dates. In body text, spell out whole numbers from zero through nine. Use numerals for 10 or greater. Use commas in numbers with four or more digits. Use more than instead of over (over is a spatial term). Emphasis and user interaction Use bold formatting for user interface elements that the user interacts with, including: Menus and menu commands. Field and button labels. Options that can be selected in the user interface. Images Diagrams and illustrations can help readers visualize and internalize complex ideas and processes, so use them liberally but with intention. Images also help to break up long text flows, but they should always reinforce and reflect the text immediately preceding or immediately following the image. If you include screenshots, only include the relevant parts of the screen and use callouts to highlight how what is captured in the image is relevant to the text. Be wary of using diagrams or illustrations that include any information—visual or textual—that is likely to get stale. \"Log in\" and \"sign in\" terminology Most Linux distributions and macOS use log in to describe how a user initiates an interactive session. Windows uses log on. Many modern web-based applications use sign in. Use sign in or log in as two words with no hyphen when describing an action (verb usage). Use sign in and sign out as the preferred terminology for actions involving web-based applications unless it contradicts the user interface. Use login as one word only when it's used as a noun, for example, when using login to mean a user profile or an identity. Use log-in with a hyphen only when modifying a noun, for example, when describing a log-in window (adjective usage). Optional steps Use (Optional) at the beginning of steps that are optional. For example: (Optional) Add a custom field. Punctuation and writing mechanics Use the following guidelines for punctuation marks. Punctuation Usage apostrophe (') Use in contractions for a conversational tone. Avoid using the possessive form. colon (:) Use a colon at the end of the statement that introduces a procedure, bulleted list, or table. comma (,) Use a serial comma to separate three or more items in a series, including the item before the conjunction. For example: She bought apples, oranges, and bananas. em dash (—) Use an em dash (—) to set off a clarifying or parenthetical phrase with more emphasis than parentheses provide. Don't add spaces around an em dash. Don't capitalize the first word after an em dash unless the word is a proper noun. exclamation point (!) Avoid using exclamation points in general and never use more than one. semicolons (;) Don't use semicolons instead of commas to separate items in a list. If you think the content should use semicolons, consider rewriting it into subtopics or an unordered bullet list. slashes (/) and backslashes () Avoid using slashes or backslashes except when documenting paths that require either forward or backward slashes. Never use and/or in documentation. Software versions Use or later or and later to refer to multiple versions of software. For example: Firefox 3.6 or later Rust compiler, version 1.55.0 and later Special notice paragraphs If there's text that requires more attention than the surrounding body, consider isolating it as a standalone note or tip. However, think twice before adding any type of special notice components or tabbed boxes. These elements can be distracting and too many of them can make the text unreadable. Because they are generally disruptive to the reader's experience, ask yourself if it is really necessary to stop the reader's forward progress by adding a special component. In most cases, it's more effective to integrate the information in the main body of the text. If you use any special notice components at all, use them sparingly. Note—Indicates neutral or positive information that emphasizes or supplements important points of the main text. A note supplies information that may apply only in special cases. Examples are memory limitations, equipment configurations, or details that apply to specific versions of a program. Tip—Helps users apply the techniques and procedures described in the text to their specific needs. A tip suggests alternative methods that may not be obvious and helps users understand the benefits and capabilities of the product. A tip is not essential to the basic understanding of the text. Caution—Advises users that failure to take or avoid a specific action could result in loss of data. Tense Use present tense whenever possible. Use past tense only if you must describe something that has already occurred. Use future tense only if you must describe something that has not yet occurred but can be safely assumed. User interface elements In general, you should avoid referring to user interface elements by describing them as menus, buttons, tabs, dropdown lists, and so on. Instead, documentation should always focus on what the audience needs to do or wants to accomplish—that is, the user interaction—and not the widgets displayed on the screen. When referring to interactions in the user interface, you should generally follow the capitalization that is used for the element unless it is rendered as all capital letters. Because using all capitals is typically considered aggressive in text and most user interface elements that use all capital letters are also text that the user interacts with, you can break the follow the UI rule and use an initial capital letter. Element How to use it button Use bold for the button label. Don't include button in the description. For example: Click Submit. checkbox Use checkbox, not box or check box, if you need to refer to a checkbox in the user interface. Use select and clear with checkboxes, not turn on and turn off, check and uncheck, or unselect and deselect. click Use click to describe taking action on a standalone button. Do not use click on. Click and select are not interchangeable. dialog If you need to refer to a dialog box, use dialog. Don't use pop-up window, dialog box, or dialogue box. dropdown Use dropdown as an adjective, not as a noun. For example, use dropdown list. menu Use bold for the menu name and menu item names if the user interacts with them. Verb usage Use the following guidelines for common verbs. Verb How to use it can, may, might Use the verb can when describing ability, capability, or capacity. Avoid using the verb may because it implies permission. Use the past tense might when describing the possibility or eventuality of an outcome. clear Use clear rather than deselect or unselect if you have to describe removing a selection from a checkbox. displays Use the transitive verb displays rather than the intransitive verb appears. Use displays with a direct object. For example, The command displays log messages. ensure Use ensure to mean to make sure or to guarantee. Remember that this is not interchangeable with assure (to make confident) and insure (to provide insurance). enter, type Use enter to instruct the user to input a value by pressing the Enter or Return key. Use type to instruct the user to type a value in a field. select Use select to describe taking action on a menu item, checkbox, or radio button. Note that click and select are not interchangeable. set up, setup Use set up—two words, no hyphen—when used as a verb. Don't hyphenate. Use setup—one word, no hyphen—when used as an adjective or as a noun. want, wish Use want instead of wish or desire when the user has a choice of actions. Word choice Use the following guidelines to select the right word based on context. Word in question How to use it affect, effect Use affect as a verb and use effect as a noun. allow, enable Avoid using software as a point of view and consider rewriting to focus on the human interacting with the software. app, application Use application or applications unless there's a specific reason for using the shorthand term app or apps. back-end, frontend Using the hyphen in these terms is still more common than not using it. Both forms are acceptable, but for consistency use the hyphen. email It hasn't been e-mail for thirty-plus years. Never use emails. Don't use email as a verb. file name Use file name as two words, not filename unless there's a specific reason for using as one word. its, it's Use its as a possessive meaning belonging to or associated with an object or idea previously mentioned. Because it is a vague pronoun, be sure to check that what it refers to can be easily identified. Use it's only as a contraction for it is or it has. multifactor Use multifactor without the hyphen for multifactor authentication. please Avoid using please in documentation unless there's a specific reason for using it. For example, you might use please if quoting the content of a message that asks the user to do something inconvenient. that, which Use that at the beginning of a clause that's necessary for the sentence to make sense. Don't put a comma before that. Don't use that when introducing a clause referring to people. Use who. Use which at the beginning of a clause that adds supporting or parenthetical information to a sentence. If you can omit the clause and the sentence still makes sense, use which, and put a comma before it. user name, username Use user name as two words in most cases. However, username is acceptable to indicate a user identity profile name. Best practices and common mistakes This section highlights best practices and common mistakes to avoid. Make every word count Concise sentences are easier to read, comprehend, and translate. Use simple words with precise meanings. Remove words that don't add substance. Avoid using passive, weak, or vague verb constructions—like “have been” or “is done”—if possible. Choose words that have one clear meaning. If you use words that can be both nouns and verbs—for example, words like file, post, mark, screen, record, and report—use sentence structure and context to eliminate ambiguity. When in doubt, choose the simple word or phrase over a more formal or complex one. Avoid flowery language and unnecessary words whenever possible. For example: Choose this Instead of this use utilize, make use of remove extract, take away, eliminate tell inform, let know to in order to, as a means to also in addition connect establish connectivity Avoid adjectives and adverbs—words that describe how, when, or where. They're tempting, but rarely add value. Unless they're important to the meaning of a statement, leave them out. Be consistent Use one term consistently to represent one concept. For example, avoid using overloaded terms like accounts, keys, and wallets interchangeably or ambiguously. Use the glossary to standardize how terminology should be used. If terminology changes, be prepared to root out old terminology. Dangling prepositions In modern English, it's perfectly acceptable to end a sentence with a preposition. This is something you might be interested in. Cross-reference formats Most cross references should include information that clarifies what the reader can expect to be found in the referenced topic. For cross references to topics in the Kadena documentation, use the following format: For more information about viewing audit logs, see Troubleshooting. For cross references to external resources, use the title of the destination instead of the URL of the destination. Avoid using links to unnamed destinations. For example, don't use links like click <ins>here</ins> or see this <ins>article</ins>>.",
    "source": "resources/writing-guide.md",
    "title": "writing-guide"
  },
  {
    "content": "title: Developer tools and solutions description: Explore a comprehensive list of tools and solutions built for building on Kadena. id: solutions keywords: dev tools developer tools sdk pact chainweb Developer tools and solutions Explore a comprehensive list of tools and solutions built for developers building on Kadena. -- Full list of Tools & Solutions coming soon Chainweb Node Client Is a TypeScript library that simplifies connecting to and interacting with Kadena’s Chainweb nodes. Overall, this client library provides a straightforward way to integrate with the Kadena blockchain network, handle node interactions, and build blockchain applications more efficiently. More Info Chainweb Stream Client Is a TypeScript library designed to provide a live stream of data from Kadena’s Chainweb network. Overall, this library makes it straightforward to build real-time, event-driven applications that react to updates on the Kadena blockchain. More Info ChainwebJS Is a TypeScript library that simplifies working with Kadena’s Chainweb network. In short, chainwebjs helps you interact with and manage the details of Kadena’s multi-chain architecture without having to reinvent lower-level functionality. More Info Client Is a TypeScript library that provides straightforward methods for interacting with the Kadena blockchain. Overall, the client library simplifies building applications that communicate with the Kadena network, helping developers focus on app logic rather than complex network interactions. More Info Client Utils Is a TypeScript library providing convenience methods and helpers for interacting with the Kadena network. By offering these common utilities, client-utils helps developers quickly implement reliable, consistent interactions with the Kadena blockchain. More Info Create Kadena App Is a CLI (Command-Line Interface) utility that jump-starts Kadena-based application development. Overall, create-kadena-app is designed to streamline the initial steps of Kadena dApp development, so you can start coding right away with a well-organized, ready-to-use setup. More Info Cross-Chain Finisher & Tracker Finisher Tracker Cryptography Utils Is a TypeScript library that provides foundational cryptographic functionality for Kadena-based applications. Overall, cryptography-utils helps developers implement secure, standards-based cryptography in their Kadena applications with minimal friction. More Info Faucet Fund New Account Fund Existing Account GraphQL Real-Time Updates: Subscribe to Chainweb events (e.g., blocks or transactions) and receive notifications as soon as they occur. More Info HD Wallet Is a TypeScript library that provides functionality for creating and managing Kadena-compatible HD (Hierarchical Deterministic) wallets. Overall, the hd-wallet library makes it simple to implement secure, recoverable, and scalable key management in your Kadena-powered projects. More Info Kadena CLI Is a command-line interface designed to simplify various tasks related to Kadena development and network interactions. Overall, kadena-cli provides a comprehensive, developer-friendly toolset for interacting with the Kadena ecosystem straight from the command line. More Info Module Explorer Easy Integration: Simple, developer-friendly methods for setting up streams and handling incoming data within your codebase. Visit PactJS Is a TypeScript library designed to streamline interactions with Kadena's Pact smart contracts. By providing a clean abstraction over the low-level details of Pact, the pactjs library empowers developers to rapidly build and deploy smart-contract-enabled dApps on the Kadena blockchain. More Info SpireKey SDK Leverages WebAuthn standards to deliver a secure backend, enabling end users to generate and store keypairs directly on their hardware devices. More Info Wallet SDK Is a TypeScript library focused on simplifying the integration of Kadena wallets into web and dApp environments. Overall, the Wallet SDK makes it straightforward to build robust, user-friendly applications that interact with the Kadena blockchain through secure wallet integrations. More Info",
    "source": "resources/solutions.md",
    "title": "solutions"
  },
  {
    "content": "title: Legacy documentation site description: Access to the old Kadena documentation for reference. id: legacy keywords: legacy docs Missing something? Here is access to the old Kadena documentation for reference. Visit the Kadena legacy documentation site Note that the legacy documentation site includes information and links that are out-of date as well as material that has been intentionally removed from the core documentation. For example, if you're interested in learning about the Kadena token standard defined in Marmalade smart contracts, you should review the Non-fungible tokens documentation in the legacy site.",
    "source": "resources/legacy.md",
    "title": "legacy"
  },
  {
    "content": "title: Glossary description: \"Defines common concepts and terminology that are generally applicable or specific to decentralized computing, blockchain technology, Kadena, or the Kadena ecosystem.\" id: glossary sidebar_position: 1 Glossary This glossary defines and explains common concepts and terminology that are generally applicable or specific to decentralized computing, blockchain technology, Kadena, or the Kadena ecosystem. A account An account is an entry in the Kadena contract ledger—a key-value store—that consists of: An account name in the form of a string of 3 to 256 LATIN-1 characters (the key row in the database table). An account value that holds the decimal balance and a keyset that governs the account. The keyset specifies the signing requirements for the account and consists of one or more public keys and a predicate that indicates the number of keys that must sign a transaction for the account. address On the Ethereum network, an address serves as both an identity and an account. The address is derived from the last 20 bytes of the ECDSA public key that controls the account prepended with 0x before the hashed key. For example, you might have an address similar to 0x71C7656EC7ab88b098defB751B7401B5f6d8976F on Ethereum. You must have an address—sometimes referred to as your wallet address—to send or receive funds and to access the funds, you must have the corresponding private key. Contracts deployed on the Ethereum network also send and receive transactions using an address. The functions in the contract are executed when the contract receives a transaction request. Contract addresses use the same format as wallet addresses. On the Kadena network, a principal account name is roughly equivalent to an Ethereum address because it establishes a unique identity. For Ethereum, the address establishes a one-to-one relationship with a public and private key pair. For Kadena, principal account names consist of a letter followed by a colon (:) and a public key or hash that uniquely identifies the account owner. airdrop Tokens that are distributed to selected groups or all addresses on a blockchain network as a free incentive to encourage participation or adoption of a specific blockchain protocol, application, or service. application-specific integrated circuit (ASIC) Application-specific integrated circuits (ASIC) are engineered to perform one type of computation to optimize performance. In a proof-of-work blockchain like Kadena, computers are often optimized with application-specific integrated circuits to compute hash functions for mining blocks. B Bitcoin Bitcoin is the world’s very first cryptocurrency, postulated by ‘Satoshi Nakamoto’ (which is typically presumed to be a pseudonym) in a now-famous white paper called ‘A Peer-to-Peer Electronic Cash System’ in 2008. blockchain A ‘blockchain’ is a distributed digital ledger that’s used to record transactions. It’s an immutable database, which means that information can’t be tampered with or altered once it’s been recorded. If there’s an error in an entry, then a new, revised entry must be made, and both entries will subsequently be visible on the ledger. The name comes from the fact that a blockchain stores data in ‘blocks,’ individual units that are linked, or ‘chained,’ together. New data is filed into blocks – and blocks are subsequently chained together – in chronological order, so a blockchain becomes longer and longer as more information is added to it. Each new piece of information is also assigned a timestamp, which makes it easy for users to find out exactly when it was linked to the database. The transparency and immutability of the blockchain makes it a very reliable and trustworthy business resource both for individuals and companies. Kadena is an example of a blockchain. bridge A bridge, in a web3 context, is a protocol which links blockchain systems together, allowing users from one system to send assets and information to another. C capability Capabilities provide a way to manage permissions and authorize certain actions based on specific conditions and separate from transaction signing. Capabilities are a core feature in the Pact smart contract programming language. chain identifier The numeric identifier for a specific chain in the Kadena network. Currently, the chain identifiers are zero (0) through nineteen (19). consensus A consensus mechanism is a system that validates transactions and encodes new information on a blockchain. The most common consensus mechanisms are Proof-of-Work (PoW) and Proof-of-Stake (PoS). Kadena uses Proof-of-Work. cryptocurrency Cryptocurrency is a digital currency secured on a blockchain. The blockchain uses cryptographic proof to secure the currency. This prevents the double spending issue for digital currencies where a currency unit is used for multiple payments without being used up. This is where the cryptocurrency name derives from. Anyone can make a cryptocurrency and they are regulated only by their underlying protocol or DAO. KDA is an example of a cryptocurrency. crypto wallet A crypto wallet is a software program or physical device that allows you to store your digital assets and allow for the sending and receiving of crypto transactions. A crypto wallet consists of two key pairs: private keys and public keys. D decentralized application (dApp) A decentralized application, colloquially called a dapp, is an application constructed on the blockchain. Dapps function autonomously, according to the stipulations in smart contracts. Like any other application on your phone, dapps come with a user interface and are designed to provide some kind of practical utility. decentralized finance (DeFi) Financial services and applications that are not, or mostly not, controlled centrally, as in Centralized Finance. For example, Uniswap is a decentralized exchange, versus Coinbase which is a centralized exchange. decentralized network A network architecture in which every computer is a peer that can receive and respond to requests. The individual peer computers—called nodes—use a consensus model to determine the final state of the network after responding to the requests received. Decentralized networks are generally more fault tolerant than networks that depend on centralized servers responding to incoming client requests. distributed autonomous organization (DAO) Generally, refers to a method of management that has rules coded in software and that has decision making which is not centralized or hierarchical. G gas Gas is a unit of measurement that represents the computational effort required to complete a transaction. How much a user spends to complete a transaction is determined by the total amount of gas multiplied by the gas price. gas station A gas station is a type of smart contract that manages an autonomous contract account that can be used to pay transaction fees on behalf of users. Implementing a gas station contract simplifies onboarding for applications and reduces friction for users who are unfamiliar with blockchain technology, digital wallets, managing keys, and signing transactions. On the Kadena network, gas stations enable developers to abstract transaction costs using a secure capability-guarded principal account. F formal verification Formal verification uses mathematical methods to evaluate all possible paths and outcomes produced by the logic in a a program or smart contract. With formal verification, developers can mathematically verify whether their code works as expected or contains bugs that produce unexpected results. Blockchain applications that handle assets with real world value should include formal verification in the software development process. H hardware wallet Hardware wallets are physical devices that are designed to securely store secret keys. Typically, hardware wallets are considered more secure devices than desktop or smartphone wallets because they aren't used to connect to the internet. By not allowing internet access, hardware wallets reduce the attack vectors malicious parties can use to attempt to tamper with the device remotely. I interoperability Interoperability refers to the ability of multiple blockchains to cooperate and exchange information with one another, enabling virtual assets (such as non-fungible tokens [NFTs]), avatars and other pieces of code to move seamlessly from one platform to another. K keys Keys are long strings of numbers used to access the Web3 products stored in your wallet. There are two forms of keys: Your public key is the string you share with others to request transactions and identify yourself in the ecosystem. Your private key is the string that gives you access to your personal crypto assets and to confirm any transactions – a digital signature. This should never be shared with anyone. A public key functions like your bank account number, with the private key being your PIN code. These keys are randomly generated and so can be hard to memorize. Therefore most wallets employ a string of words known as a “seed phrase” to act as a passcode to your keys. keyset A keyset is a Pact construct used to authorize transactions. A keyset consists of one or more public keys and a predicate function that describes the authorization policy for the keys in the keyset. For example, if a keyset has three public keys and the keys-all predicate, then all three keys must sign a transaction for the transaction to be valid. Pact provides three default keyset predicates: keys-all keys-any keys-2 Smart contract module authors can define additional predicates. L layer-1 (L1) blockchains are the foundations of multi-level blockchain frameworks. They can facilitate transactions without support from other blockchain networks. All layer 1 blockchains – including Bitcoin and Ethereum – offer their own native cryptocurrency as a means of accessing their networks. layer 2 (L2) blockchains are built on top of layer 1 blockchains, often enhancing the latter’s performance and expanding its accessibility. Polygon, for example, is a popular layer 2 blockchain that allows users to enjoy the benefits of using the Ethereum network without having to go through that network’s relatively slow transaction speed and costly fees. M mining Mining is the process of validating a transaction in a proof of work blockchain. In mining, a large pool of users compete for tokens to see who can solve a cryptographic puzzle the quickest using computing power. The difficulty of the puzzle scales with the total hash power of the entire network, the hash rate. The costs of mining are well documented, both in the exponential increase in computing power to continue mining and the detrimental environmental impact. module A module is the fundamental logical unit for programs used in Pact smart contracts. All of the functions and data definitions that are required to complete a set of related business operations are defined within the context of a module. For simple contracts, a single module often contains all of the code necessary to create an application or a service. N namespace A namespace is a logical ownership boundary for smart contracts that are controlled by a specific entity. Smart contracts include a namespace declaration to provide a unique prefix for everything—including modules, functions, keysets, and interfaces—defined within the namespace scope. In a local development network, you can define custom namespaces. In public networks, like the Kadena test and main networks, you must use an existing namespace, like \"free\" or \"user\", or register a principal namespace as a static prefix and ownership boundary for the contracts, modules, and keyset definitions that you control. non-fungible token (NFT) Non Fungible Token. Tokens that represent something unique, such as crypto art or collectibles. They cannot be exchanged for something identical. For example, CryptoPunks and Hashmasks. node Nodes are the computers used to secure a blockchain network. These are the engine of the blockchain, supplying the computing power to maintain it, validating transactions, and maintaining the consensus of the blockchain that keeps it secure. The more nodes a blockchain has, the safer it is. However, this increases the computational complexity, amount of energy used, and thus the price for making each transaction. O oracle An oracle is any application that provides data from outside the blockchain or vice-versa. Blockchains can only access data available on their own chains, and so need oracles to add outside or off-chain data. A typical use case is smart contracts that need to incorporate real-world data or bridges that require information from another blockchain to perform an exchange. For example, if a stablecoin needs to keep its value constantly connected to the amount of collateral available to that coin, it would need an oracle to identify how much of that collateral is available. This is because knowledge of the collateral amount is off-chain data that has to be translated to data usable by the blockchain. R Read-eval-print-loop (REPL) Read-eval-print-loop (REPL) is an interactive shell that enables you to run and test code in a terminal. In most cases, a REPL is an interpreter for a specific language or compiler that enables you to write and execute programs from a command-line interface. S smart contracts Smart contracts are self-executing contracts formed using a blockchain. A smart contract is a program that can automatically execute agreements on the blockchain without external oversight, as long as the originally set parameters of the contract are fulfilled. The blockchain ensures that the contract has been considered trustworthy – the validation method and the transparent ledger of previous transactions create the necessary trust. T tokens A token is an electronic proof of asset ownership. These are typically split into two types. Fungible tokens like Kadena are identical, exchangeable tokens; non-fungible tokens (NFTs) are unique and cannot be reproduced. While not every blockchain has a token, most deploy a form of token to take advantage of their utility value. Uses for tokens include: Cryptocurrencies are the most common form of tokens that can be exchanged for goods and services. KDA is an example of a cryptocurrency. Payment or utility tokens can be used to pay for services but only on the blockchain that produces the token. These could for instance be the in-game currency for a blockchain-based video game. Governance tokens can be seen as shares in a blockchain, giving you voting rights on major decisions regarding the future direction of that relevant blockchain. NFTs that prove ownership over a unique digital asset such as art or a venue ticket. time-to-live (TTL) The expiration time—in seconds—for how long a transaction should be considered valid for inclusion in a block after its creation time. In most cases, transactions are processed and included in block in approximately 30 seconds and don't require changes to the default TTL. However, the maximum time a transaction can wait to be included in a block is 48 hours after its initial creation. tokenomics A portmanteau of the words 'token' and 'economics,' tokenomics refers to all the aspects of a cryptocurrency that can impact the price such as total supply, vesting, and utility. trilemma The Trilemma refers to the problem every blockchain has in having to compromise on either security, decentralization, or scalability. Coined by Vitalik Buterin, one of the Ethereum co-founders, the trilemma points to each of the issues being interconnected: Increasing decentralization makes the blockchain more computationally complex, slowing down transaction speed (scalability), and requires more work to keep the network secure Highly secure blockchains cannot handle many transactions efficiently and so compromise on scalability Increasing transaction speed requires reducing the computational load in some way. This compromises decentralization and security. Kadena’s innovative PoW consensus mechanism called Chainweb makes it the only blockchain to have solved the infamous blockchain trilemma.",
    "source": "resources/glossary.md",
    "title": "glossary"
  },
  {
    "content": "title: Contribute to documentation description: \"Get started as a contributor to Kadena documentation.\" id: contribute-doc How to contribute to Kadena documentation Thank you for your interest in contributing to documentation for the Kadena blockchain and the Kadena community. As a member of the community, you are invited and encouraged to contribute to the Kadena technical documentation. There are a lot of ways to get involved. For example, you can contribute by: Submitting issues. Offering suggestions for improvements to existing content. Adding review comments to existing pull requests. Proposing new content. Creating new pull requests to fix issues yourself. Creating pull request for new content other community members might find useful. This guide describes how you can make changes to the documentation website directly by editing source files or indirectly by requesting updates. Before you begin To follow the steps in this guide, verify the following basic requirements: You have a code editor, a GitHub account, and experience using command-line programs, including commands and command-line options. You are familiar with using Markdown to add formatting elements to plain text documents. For information about using Markdown, see the Markdown Guide. You have the package manager installed. You can run to verify that you have installed and the version you are running. Get started You can contribute to documentation by editing existing pages in the GitHub repository or by setting up a local documentation environment. If you want to make a simple fix on an existing page—for example, to fix a typo or make minor changes to a sentence—you can edit documentation pages directly in its GitHub repository. To edit an existing page: Open docs.kadena.io and navigate to the page you want to change. Click Edit this page to open the page in its GitHub repository. Edit the page in GitHub, then click Commit changes. Replace the default commit message with a short description of your change and, optionally, an extended description of the change or why you're proposing the change. Select Create a new branch for this commit and start a pull request, then click Propose changes. Add any additional information to the title or description of the pull request, then click Create pull request. Your pull request will be reviewed by a Kadena team member and merged, if approved. Set up a local development environment The Kadena Developer Documentation website is built using Docusaurus, a modern static website generator. If your contribution is more than a simple change, you'll most likely need to set up a local development environment where you can build and test the documentation that you are proposing to change. The following steps summarize what you need to do. To set up a local development environment for contributing to Kadena documentation: Open a terminal shell on your computer. Clone the repository by running the following command: Change to the root of the repository by running the following command: Install the dependencies for the site by running the following command: Start the local development server and open up a browser window by running the following command: All of the content for the Kadena Developer Documentation website is located in the directory and its subdirectories. To contribute to documentation, you typically only need to work in the folder, its subfolders, and in individual Markdown () pages. Preview documentation changes To preview your documentation changes locally: Navigate to the directory: Start the Docusaurus development server: Open your browser and go to Create working branches and pull requests After you set up a local environment for contributing to documentation, you'll need to create local branches for your pull requests. In most cases, you should strictly limit the changes you include in any single pull request. To create a working branch: Use to create a local branch with a prefix that identifies you as the author and a branch name that describes the content you intend to add or change by running a command similar to the following: For example, if your handle is and you are fixing a typo in the folder, you might create a branch like this: Open the file you want to fix in a code editor and make the appropriate changes for the issue you are trying to address. Add the file you changed to the list of staged commits by running a command similar to the following: Commit the staged changes with a descriptive commit message by running a command similar to the following: Push the changes to the remote repository by running a command similar to the following: Click Create pull request to start a new pull request and provide any additional information about the changes you made. A member of the Kadena team will review your pull request and approve or request changes. If no changes are required, the Kadena team member will merge your pull request. If a Kadena team member requests changes or clarification, update your pull request and request another review. When you see your changes have been merged, celebrate your success! 🥂 What to contribute Most contributions from the community typically involve corrections or updated examples. However, you can also make valuable contributions in the form of how-to guides or tutorials that help other developers solve specific problems, learn specific skills, or demonstrate specific tasks or by translating topics into a new language. If you would like to contribute, you might be wondering “What is the difference between a ‘how-to’ guide and a tutorial?”. How-to guides A how-to guide describes how to achieve a goal or complete a task. Only the information that is pertinent to achieving that goal or completing the task is included. With how-to guides, readers have enough information to know what they want to do—for example, open a bank account—but not necessarily enough information to know how to do it. For example, the how-to guide for opening a bank account wouldn't explain what a bank account is or why you might want to open one, but would focus on specific steps such as: Select an institution. Fill out an application. Deposit a minimum amount of currency. Tutorials A tutorial is a hands-on illustration or lesson that enables the reader to achieve a highly-predictable result. Tutorials assume that readers have no prior knowledge on the subject being covered and that they require explicit guidance to complete each step to reach a well-known outcome. A tutorial is like a guided tour that helps the reader complete one organic task from start to finish. For example, a tutorial for opening a bank account would identify an example institution, explicitly describe what to enter for every field of the application using sample information, and specify exactly how much currency to deposit. The single most important aspect of a tutorial is that it should always result in a successful, expected outcome that inspires confidence and delight in the reader. The single most important distinction between a how-to guide and a tutorial is that, in a tutorial, the author decides what the goal should be and the author eliminates all distractions that would detract from the successful achievement of the goal. Translations To translate Kadena documentation: Copy the folder and rename it to . For example, create a folder named for translating topics into Spanish. Translate the content in the new folder. Update the Docusaurus configuration to include the new language.",
    "source": "resources/contribute-doc.md",
    "title": "contribute-doc"
  },
  {
    "content": "title: Contribute as a developer description: \"Get started as a code contributor to the Kadena project.\" id: contribute-dev How to contribute as a developer We appreciate your interested in contributing to the Kadena project. There are a lot of ways to get involved. For example, you can contribute by: Fixing bugs in existing features, code logic, or code comments. Suggesting design enhancements. Implementing new features. Providing usability testing and feedback. Translating code or documentation. This guide describes how to get started with contributing as a developer. Set up a local development environment To set up a local development environment for contributing to Kadena: Navigate to the appropriate repository on GitHub. Click Fork tfor he repository on GitHub to create your own copy of the repository. Open a terminal shell on your computer. Clone your fork locally by running the following command: Install dependencies by running the following command: Set up pre-commit hooks by running the following command: Find issues to work on Check for open issues in the repository. For example, check the Open issues for the kadena.js Check for issues labeled good first issue. If you have an idea for a new feature, please open a new issue to discuss it before starting work. Branching strategy We use a simplified Git flow: branch for stable releases branch for ongoing development Feature branches should be created from Commit messages Follow the Conventional Commits specification: Pull requests Create a new branch from . Make your changes and commit them. Push to your fork and submit a pull request to the branch. Ensure your PR description clearly describes the problem and solution. Recognizing contributors We use the All Contributors specification to recognize all types of contributions. After your first contribution is merged, you'll be added to the contributors list in the README. <!-- ### Contribution rewards More updates on this will be added shortly To show our appreciation, we offer the following rewards for significant contributions: Contributor of the Month recognition Exclusive project swag for major contributions Opportunities to speak at project-related events --> Review process Automated tests will run on your pull request. A maintainer will review your contribution. Address any feedback or requested changes. Once approved, a maintainer will merge your contribution. Community Join the Kadena Discord server for real-time discussions. Follow Kadena on X or LinkedIn for news and announcements.",
    "source": "resources/contribute-dev.md",
    "title": "contribute-dev"
  },
  {
    "content": "title: Specialized functions description: \"Reference information for Pact built-in functions that are intended for special usee cases.\" id: special-use Specialized functions Pact includes several built-in functions that are intended for very specific use cases, such as integrating with other tools and working with zero knowledge proofs. Commitments hyperlane-decode-token-message Decode a base-64-unpadded encoded Hyperlane Token Message into an object. hyperlane-encode-token-message Encode an object into base-64-unpadded encoded Hyperlane Token Message. hyperlane-message-id Get the message identifier of a Hyperlane Message object. Simple payment verification verify-spv Perform a platform-specific simplified payment verification (SPV) proof. Zero knowledge (ZK) built-in functions pairing-check Perform pairing and final exponentiation on points for a zero knowledge proof. point-add Add two points together for a zero knowledge proof. scalar-mult Multiply a point by an integer value for a zero-knowledge proof.",
    "source": "pact-5/special-use-cases.md",
    "title": "special-use-cases"
  },
  {
    "content": "title: Function quick reference description: \"Quick reference listing of links for Pact built-in functions.\" id: func-quick-ref Function quick reference abs Calculate the absolute value of a number. acquire-module-admin Grant module administrative privileges for a specified module. add-time Add a specified number of seconds to a time. add () Add numbers, concatenation for strings, or merge objects. and? Apply a logical AND operation to a result. and Perform a boolean logic AND operation. at Get a value using an index for a list or a key for an object. base64-decode Decode a base64-encoded string. base64-encode Encode a string as unpadded base64. begin-tx Begin a new transaction with an optional name (REPL only). bind Evaluate an object with bindings. bitwise-and () Compute the bitwise AND operation between arguments. bitwise-or () Computes the bitwise OR operation between two integers. bitwise-reverse () Reverse all bits in the provided integer. ceiling Round up the value of a decimal to the nearest integer or specified precision. chain-data Retrieve public metadata. charset-ascii Use the standard ASCII character set. charset-latin Use the standard Latin1 character set. commit-tx Commit the current transaction (REPL only). compose-capability Request the grant of a capability within a capability. compose Compose functions to operate on value. concat Concatenate a list of strings. constantly Ignore specified arguments. contains Evaluate the contents of a list, object, or string. continue-pact Continue a previously-initiated multi-step transaction (REPL only). continue Continue a previously started step. create-capability-guard Create a guard to enforce a specified capability. create-capability-pact-guard Create a guard to enforces a specified capability in an executing step. create-module-guard Define a guard to enforce the current module administrator predicate. create-pact-guard Define a guard predicate that captures the for a step. create-principal Create a principal that identifies a guard. create-table Create a table. create-user-guard Define a custom guard. days Specify a number of days to add or subtract days from a given time. dec Convert an integer to a decimal value. define-keyset Define an authorization keyset from keyset data set in the environment. define-namespace Create a new namespace or update the guards of an existing namespace. describe-keyset Retrieve metadata for a specified keyset. describe-module Get metadata for a specified module. describe-namespace Describe the specified namespace. describe-table Get metadata for a specified table. diff-time Compute the difference in seconds between two specified times. distinct Return a list with duplicates removed. div () Divide the first argument by the second argument. do Evaluate a sequence of expressions and return the result from the last expression. drop Remove values from a list or string. emit-event Emit a specified capability as an event. enforce-guard Execute a specified guard or keyset to enforce predicate logic. enforce-keyset Execute a keyset to enforce predicate logic. enforce-one Evaluate a series of tests in order. enforce-pact-version Enforce the runtime Pact version to be within a specified range. enforce-verifier Enforce that a verifier with the specified name is in scope. enforce Fail a transaction if an expression evaluates to false. enumerate Return a sequence of numbers as a list. env-chain-data Define chain information for transactions in your testing environment (REPL only). env-data Set transaction data for your testing environment (REPL only). env-enable-repl-natives Control whether REPL native functions are allowed in module code (REPL only). env-events Retrieve any accumulated events and optionally clear the event state (REPL only). env-exec-config Query or set configuration information for transactions in your testing environment (REPL only). env-gas Query the current gas state or set it to a specific value (REPL only). env-gaslimit Set the environment gas limit to a specific value (REPL only). env-gaslog Enable gas logging for a block of code (REPL only). env-gasmodel Query or update the current gas model (REPL only). env-hash Set the current transaction hash (REPL only). env-keys Set the transaction signer keys (REPL only, deprecated). env-milligas Query the current gas state in units of one one thousandth of a gas unit. env-module-admin Acquire the module administrative rights for any module loaded in the REPL. env-namespace-policy Install a managed namespace policy (REPL only). env-set-debug-flag Set the Pact interpreter debug flags. env-set-milligas Set the current gas state to a specific value in units of one one thousandth of a gas unit. env-sigs Set signature keys for signing transactions and granting capabilities (REPL only). env-verifiers Set transaction verifier names and capabilities. equal () Return true if the first argument is equal to the second argument. exp Calculate the exponential function of a value. expect-failure Evaluate an expression and succeed only if the expressions results in an error (REPL only). expect-that Evaluate an expression and succeed if the resulting value passes a predicate function (REPL only). expect Evaluate an expression and verify that the result equals an expected value (REPL only). filter Filter a list by applying a function to each element. floor Round down the value of a decimal to an integer or to a specified precision. fold-db Select rows from a table using a predicate and accumulate the results. fold Reduce a list iteratively by applying a function to each element. format-time Format a time value using a specified format. format Format a message using placeholders and variables. greater-than or equal () Return true if the first argument is greater than or equal to the second argument. greater-thant () Return true if the first argument is greater than the second argument. hash-keccak256 Compute the hash of a list of inputs. hash Compute the BLAKE2b 256-bit hash of a value. hours Add a specific number of hours to a given time. hyperlane-decode-token-message Decode a base-64-unpadded encoded Hyperlane Token Message into an object. hyperlane-encode-token-message Encode an object into base-64-unpadded encoded Hyperlane Token Message. hyperlane-message-id Get the message identifier of a Hyperlane Message object. identity Return the provided value. if Test whether a condition is true to determine the operation to perform. insert Add a new value to a database record in a specified table. install-capability Specify and provision a managed capability. int-to-str Represent an integer value as a string in a specified base. is-charset Check whether a string conforms to a supported character set. is-principal Check whether a principal string conforms to the principal format. keys-2 Determine whether a keyset has at least two required keys. keys-all Determine whether a keyset has all of its required keys. keys Return all of the keys for a specified table in a module. keys Return all of the keys for a specified table in a module. keyset-ref-guard Create a guard for the keyset in the guard database. length Compute the length of a list, string, or object. less-than or equal () Return true if the first argument is less than or equal to the second argument. list-module List modules available for loading. list-modules List all of the modules deployed on a particular chain using the endpoint. ln Compute the natural logarithm of a specified value. load Load and evaluate a specified or file. log Compute the logarithm of the specified value with the specified base. less-than Return true if the first argument is less than the second argument. make-list Create a list by repeating a specified value a certain number of times. map Apply a function (APP) to each element in a list. minutes Add a specific number of minutes to a given time. mod Compute the remainder for the first value divided by the second value. multiply () Multiply the first argument by the second argument. namespace Set the current namespace to a specified value. negate Negate a specified integer or decimal value. not-equal () Return true if the first argument does not equal the second argument. not? Apply a logical NOT to the results of a function. not Perform a boolean logic NOT operation. or? Apply a logical OR to the results a function. or Perform a boolean logic NOT operation. pact-id Return the identifier associated with execution. pact-state Inspect state from most recent execution. pact-version Get the current Pact build version. pairing-check Perform pairing and final exponentiation on points for a zero knowledge proof. parse-time Construct time from a UTC value using a specified format. point-add Add two points together for a zero knowledge proof. poseidon-hash-hack-a-chain Compute a hash using the Poseidon hash function used by Hack-a-Chain. power-of () Raise an argument to the power of the second argument. print Convert a value into a string and print it to the REPL output. read-decimal Read a string or number value from the message data as a decimal. read-integer Read a string or number value from the message data as an integer. read-keyset Read a from the message data as a keyset with a list of keys and a predicate function. read-msg Read a from the message data body. read-string Read a string or number value from the message data as a string. read Retrieve information from a specified based on a given row. remove Remove an entry associated with a specified from an object. require-capability Check whether a specified capability has been granted. resume Bind a yielded object value from a step to the execution of the next step. reverse Reverse the order of elements in a given list. rollback-tx Roll back the current transaction. round Perform Banker's rounding to return an integer or decimal value. scalar-mult Multiply a point by an integer value for a zero-knowledge proof. select Retrieve full rows or specific columns from a table. shift Perform a bitwise shift operation on the specified integer by the specified number of bits. show Convert a specified into a string. sig-keyset Build a keyset guard from keys present in message signatures. sort Sort a list of primitive values or objects. sqrt Compute the square root of the given value. static-redeploy Redeploy a module without any code changes. str-to-int Compute the integer value of the specified string. str-to-list Convert a string into a list where each element is a single-character string. subtract () Negate an argument or subtract the second argument from the first argument. take Retrieve a specified number of values from a list, string, or object. test-capability Acquire or install the specified. time Construct a time object from a UTC value using the format. try Attempt a pure action without input, output, or state-changing operations. tx-hash Get the hash of the current transaction as a string. typecheck Run the Pact static type checker on a module. typeof-principal Return the protocol type of a given principal. typeof Return a description of the data type for a specified value. update Update a value for a database record in the specified table. validate-principal Validate that a principal identifies a specified guard. verify-spv Perform a platform-specific simplified payment verification (SPV) proof. where Define a clause to refine the results from or operations. with-capability Specify the capability that must be granted to perform a privileged operation. with-default-read Read a row from a specified table and use default values for columns if the row isn't found. with-read Read a row from a specified table and bind columns names to variables. write Write or overwrite a value for a database record in the specified table. xor Compute the bitwise exclusive OR operation between two integers. yield Yield an object to use with the function in a step. zip Combine two lists using a specified function to create a new list.",
    "source": "pact-5/quick-reference.md",
    "title": "quick-reference"
  },
  {
    "content": "title: Syntax and keywords description: This reference provide a summary of syntax conventions for the Pact smart contract programming language. id: syntax sidebar_position: 2 tags: ['pact', 'language reference', 'syntax'] Syntax and keywords This reference provide a summary of syntactical conventions and reserved keywords for the Pact smart contract programming language. This section doesn't include explanatory text, use case examples, or general information about the Pact language. Therefore, this section is typically not suitable for readers who are new to programming languages or who are looking for a general introduction to using Pact. Text strings Text string literals are delimited using double quotation marks: In programs, you can specify multiline strings by putting a backslash before and after whitespace within the quotation marks. For example: Multiline strings aren't support when using the Pact command-line interpreter interactively. Symbols Symbols are string literals that represent a unique item in the runtime, like a function identifier or a table name. Internally, symbols are treated as string literals. However, if you want to make use of symbols to distinguish identifiers from other strings, precede the string with a single quotation mark. For example: Symbol notation doesn't support whitespace nor multiline strings. Integers Integer literals are unbounded, and can be positive or negative. Decimals Decimal literals have potentially unlimited precision. Booleans Booleans are represented by and literals. Lists List literals are created with square brackets (). Optionally, list items can be separated with commas. Uniform literal lists are given a type in parsing. Objects Objects are dictionaries, created with curly braces () specifying key-value pairs using a colon (). For certain applications, such as database updates, keys must be strings. Bindings Bindings are dictionary-like forms, also created with curly braces, to bind database results to variables using the operator. Bindings are used in the following functions to assign variables to named columns in a row, or values in an object: with-read with-default-read bind resume Lambdas Lambda expressions are code blocks that create anonymous functions that can be applied in a local scope, rather than at the top level of a program with the keyword. Lambdas are supported in expressions, and can be as inline arguments for built-in function applications. Type specifiers You can specify types for functions, variables, and objects by using the colon () operator followed by one of the following type literal or a user type specification: or to specify the list type , which can be further typed with a schema , which can be further typed with a schema , which must be further typed with required interfaces For example: Function arguments and return types Let variables Schema type literals A schema defined with defschema is referenced by a name enclosed in curly braces (). Tables and objects can only take a schema type literal. Module type literals Module references are specified by the interfaces they demand as a comma-delimited list. Dereference operator The dereference operator allows a member of an interface specified in the type of a module reference to be invoked at runtime. bless Use the keyword to identify a previous version of a module—identified by its value—that you want to continue to support. For more information about using the keyword in a module declaration, see Dependency management. Basic syntax To support a previous version of a module, use the following syntax model: Examples The following example illustrates supporting two previous versions of the module: cond Use the keyword to produce a series of expressions to evaluate one after another. For example, if the first condition evaluated passes, then branch-1 is executed. If the first condition isn't met, the second condition is evaluated and if that condition passes, then branch-2 is executed. The is only evaluated if all other conditions fail. The special form allows you to evaluate a series of expressions in a more concise manner. Syntactically, the form accepts a sequence of conditions: When the conditions are evaluated, the statements are expanded to a series of statements: Basic syntax To evaluate a series of conditions, use the following syntax model: Examples The following example demonstrates how to use to evaluate multiple branching conditional expressions. If you load this module, you can call the function to see the conditions evaluated: defcap Use the keyword to signal the start of a capability definition followed by the capability name, required or optional arguments, optional documentation, and the capability body composed of one or more expressions. A code block defines a capability token you want to store in the environment to grant some type of permission or privilege. The body of the code block can consist of one or more expressions. The body of the capability definition is only called with the and functions when the token—parameterized by its arguments—isn't found in the environment. When the code is executed, the arguments are in scope. Basic syntax To define a capability token that grants a permission or a privilege, use the following syntax model: Examples The following example illustrates defining the capability: The following example illustrates defining the capability: defconst Use the keyword to define a constant name with the specified value and optional documentation or metadata. The value is evaluated when the module is loaded and held in memory for the duration of module execution. Basic syntax To define a constant value, use the following syntax model: Examples The following examples illustrate defining constants with optional documentation: The following example illustrates defining the constant with an explicit type: defun Use the keyword to signal the start of a function definition followed by the function name, required or optional arguments, optional documentation or metadata, and the function body composed of one or more expressions. Arguments are in scope for the function body. Basic syntax To define a function, use the following syntax model: Examples The following examples illustrate defining an function and a function: defpact Use the keyword to define a multi-step transaction with the specified as a pact. The computation for a pact is composed from a sequence of steps that must be executed in a specific order and occur in distinct transactions. The syntax is identical to the [defun](/reference/syntax#defun keyword except that the body must be comprised of steps to be executed in strict sequential order. Basic syntax To define a pact, use the following syntax model: Examples You can nest calls. However, the following restrictions apply: The number of steps in the child must match the number of steps of the parent . If a parent step has the rollback field, so must the child. If a parent step rolls back, so do child steps. You must call the function with the same continuation arguments as the originally dispatched to support multiple nested calls to the same function but with different arguments. The following example shows a well-formed with an equal number of steps, nested rollbacks, and calls: defschema Use the keyword to define a schema of table with the specified . Each field in the schema takes the form of . Basic syntax To define a schema, use the following syntax model: Examples The following example illustrates defining the schema and an table: deftable Use the keyword to define a database table with the specified . The name you specify is used in database functions to identify the table you want to work with. Note the table must still be created with create-table function. Basic syntax To define a table, use the following syntax model: Examples The following example illustrates defining a schema and an table: do Use the keyword to evaluate a sequence of expressions and return the last one as the result. Basic syntax To evaluate a sequence of expressions and return the last result, use the following syntax model: Examples Notice how the return value is the last addition of . The keyword evaluates every expression supplied, so if any expression errors along the way, the subsequent expressions will never be evaluated. For example: implements Use the keyword to specify that a module implements the specified . This keyword requires the module to implement all of the functions, defpacts, and capabilities that are specified in the interface with identical signatures, including the same argument names and declared types. A module that implements an interface can be used as a module reference for the specified interfaces. <!--Note that models declared for the implemented interface and its members will be appended to whatever models are declared within the implementing module. --> Basic syntax To implement an interface in a module, use the following syntax model: interface Use the keyword to define and install an interface with the specified and optional documentation or metadata. The of the interface is composed of definitions that will be scoped in the module. Valid expressions in a module include the following: defun defconst defschema defpact defcap use <!--- models--> Basic syntax To define an interface, use the following syntax model: Examples The following example illustrates defining the interface with documentation: let Use the keyword to bind variables in pairs to over the scope of the code body. In Pact 4, declarations didn't allow variables within bind-pairs to refer to previously-declared variables in the same declaration. In Pact 4, you could use the form to enable variables to reference previously-declared variables in the same declaration. In Pact 5, the keyword is deprecated and you can replace all declarations with declarations. Basic syntax To bind a variable to a value, use the following syntax model: Examples The following example illustrates binding variables to values in a declaration: The following example illustrates referencing a previously-declared variable in the same declaration in Pact 5: let* Use the keyword to bind variables in pairs over the scope of the code . In Pact 4, this form of the keyword enables variables to reference previously-declared variables in the same declaration. In Pact 5, this form is deprecated and you can replace all let* declarations with declarations. Basic syntax To bind a variable to a value, use the following syntax model: Examples The following example illustrates referencing a previously-declared variable in the same declaration: Metadata prefix (@) As several examples demonstrate in this section, you can often embed optional documentation strings in code blocks that use reserved keywords like and like this: You can also add metadata by using the -prefix. Supported metadata fields include: to provide a documentation string. to emit an event. to manage specific data associated with a capability. to specify a property that can be checked for correctness in format verification. Embedded documentation strings like are just a short form of metadata. module Use the keyword to define and install a module with the specified that is governed by the specified , with optional documentation or metadata. If the is a string, the string represents a keyset that has been installed with the function that will be checked whenever module administrative privileges are required. If is an unqualified atom, it represents a capability that will be acquired if module administrative privileges are requested. The body of a module is composed of definitions are scoped to the module. A module can include the following types of declarations: defun defpact defcap deftable defschema defconst implements use bless Basic syntax To define a module, use the following syntax model: Examples The following example illustrates a defining the module with a keyset and two functions: step Use the keyword to define a step within a defpact, such that any prior steps will be executed in prior transactions, and later steps in later transactions. You can include an argument to indicate that a specific step is intended for confidential transactions. With this argument, only the specified would execute the step, and other participants would skip the execution of the step. Basic syntax To define a step in a , use the following syntax model: Examples The following example illustrates a for depositing funds with two transactions: step-with-rollback Use the keyword to define a step within a defpact similar to using the step keyword except that you specify a . If you include an argument, the is only be executed upon failure of a subsequent step, as part of a reverse-sequence \"rollback cascade\" going back from the step that failed to the first step. Without the argument, the acts as a cancel function that is be explicitly executed by a participant. Basic syntax To define a step in a , use the following syntax model: Examples The following example illustrates a for offering a token for sale with one : use Use the keyword to import the specified into a namespace. This keyword is only valid at the top-level of a contract or within a module declaration. The specified can be a string, symbol, or bare atom. You specify the argument to validate that the imported module's hash matches specified and fail if the hashes are not the same. You can use the describe-module function to query for the hash of a loaded module on the chain. You can also specify an optional list of consisting of function, constant, and schema names to import from the specified . If you explicitly define the function, constant, and schema names to import, only the listed items are available for you to use in the module body. If you don't specify an import list, then every name in the imported module is brought into scope. If two modules are defined in the same transaction, all names are in scope for both modules, and the import behavior defaults to the entire module. Basic syntax To import a specified module, use the following syntax models: Examples The following example illustrates importing all of the definitions from the module and using the function: The following example illustrates importing all of the definitions from a specific version of module with the hash and using the function: The following example illustrates importing only the and definitions from the module and using the function: The following example illustrates importing only the and definitions from a specific version of module with the hash and using the function: Expressions Expressions can be literals, atoms, s-expressions, or references. Atoms Atoms are non-reserved barewords that start with a letter or allowed symbol, and contain letters, digits, and allowed symbols. Allowed symbols are . Atoms must resolve to a variable bound by one of the following: defun definition. defpact definition. bindings form. lambda form. Symbols imported into the namespace with use. S-expressions S-expressions are formed with parentheses, with the first atom determining if the expression is a special form with a reserved keyword or a function application. If the expression is a function application, the first atom must refer to a definition. An application with less than the required arguments is in some contexts a valid partial application of the function. However, this is only supported in a limited number of Pact functions, such the , , and functions. With these functions, the list item can be appended to the application arguments to serially execute the function. Using a partial application with most functions results in a runtime error. References References are multiple atoms joined by a dot that directly resolve to definitions found in other modules. References are preferred over for transactions because references resolve faster. However, when defining a module, is preferred for legibility.",
    "source": "reference/syntax.md",
    "title": "syntax"
  },
  {
    "content": "title: Pact command-line interpreter description: The Pact command-line interpreter enables you to run Pact code interactively and test Pact code and modules in an interactive terminal shell. id: pact-cli side_position: 6 tags: ['pact', 'testing', 'language reference', 'REPL', 'API'] Pact command-line interpreter Use the Pact command-line interpreter—also referred to as the Pact read–eval–print-loop (REPL) interactive shell program—to test Pact code and modules in an interactive terminal shell. The Pact command-line program also includes an HTTP server with a built-in REST API that provides commands and options for working with transactions in a simulated production environment. Basic usage Depending on the option you provide, can specify the path to a file to compile or a file to execute. You can specify command-line options before or after the file name. Options You can use the following command-line options with the command-line interpreter: Option Description -h, --help Displays usage information for or for a specific command. -v, --version Displays version information. -b, --builtins Displays the list of Pact built-in native functions. -g, --genkey Generates a random public and secret key pair with the ED25519 signature scheme. -s, --serve config-file Starts a built-in HTTP server with the configuration file you specify. After you start the server, you can submit API requests to Pact API endpoints to simulate submitting API requests to a Chainweb node and to create transactions for testing purposes. -r, --findscript file-name Attempts to execute a file to for the file you specify. -t, --trace file-name Displays trace output for each line of code executed in the specified file. -c, --coverage file-name Generates a coverage report in the file for the file you specify. -a, --apireq api-request-yaml Formats an API request as JSON using the api-request-yaml file you specify. -l, --local Formats a request for the endpoint on the built-in HTTP server or a Chainweb node. -u, --unsigned api-request-yaml Formats an unsigned API request as JSON using the api-request-yamlL file you specify. Commands You can use the following commands with the command-line interpreter: Option Description add-sig Adds a signature to the signature data from standard input (stdin). combine-sigs Combines multiple signature files. sign Signs arbitrary base64url-encoded data from standard input (stdin). Basic examples To display usage information for the command, you can run the following command: To generate a new public and secret key pair, you can run the following command: This command produces output similar to the following snippet: To trace the output for a set of transactions defined in the file, you would run the following command: This command produces output similar to the following snippet: Work with transactions using Pact commands You can use the Pact command-line interpreter, built-in HTTP server, and SQLite backend to sign and submit transactions and to format transactions requests so that they can be executed using commands or Postman API calls. The following examples illustrate how you can use the Pact built-in HTTP server, command-line options, and API calls to work with transactions in a local development environment. Start the built-in server To start the built-in HTTP server: Open a terminal shell on your local computer. Create a configuration file using YAML format with the following properties: For example, create a file with properties similar to the following: Start the built-in server by running a command similar to the following: Create and submit an API request To create an API request and submit a transaction: Open a second terminal window or tab and create an API request for a simple transaction in a YAML file. For example, use a text editor to create a YAML file called with the following content: In this example, the transaction API request executes an addition function (+ 1 2) and identifier the request sender using the public and secret key pair. The request is defined using YAML format because the format is more readable and less error-prone than the required JSON format. However, before you can submit the request, it must be converted to the JSON format that the endpoint receiving the request expects. Format the YAML version of the API request using the Pact command-line option to generate a valid JSON API request. For example, run the following command to display the output before submitting the request to the built-in server: This command displays the formatted API request as standard output: Format the transaction using the command-line option to display the API request that can be submitted to the endpoint of the built-in HTTP server by running the following command: The command displays the transaction to be submitted as standard output: Notice that, in the formatted API request output, there are several fields not defined in the original file. In this example, the request is for a simple transaction that executes in a single step. Therefore, the transaction uses the API request template for transactions. The key fields not defined in the original file are populated as part of the formatting of the request. More complex transactions that require execution of more than one step use the API request template for transactions. For information about the required and optional fields for in the and API request templates, see Formatting API requests in YAML. Send the API request to the Pact built-in HTTP server running on port 8081—as configured in the file for this example—by running the following command: This command returns the transaction result with output similar to the following: Pact HTTP server API endpoints In the previous example, you saw how to submit an API request to the endpoint exposed by the built-in HTTP server. The Pact built-in HTTP server supports the following API endpoints: Endpoint Description Listen for the result of a single transaction. The request body must contain the request key for the transaction. Requests sent to the endpoint block operations waiting for the transaction result. Submit a command to simulate the execution of a transaction. Requests sent to the endpoint don't change the blockchain state. Any database writes or changes to the environment are rolled back. The request body must contain a properly-formatted Pact command. In response to the request, the endpoint returns command result and hash. Poll for the results of one or more transactions. The request body must contain one or more request keys. Requests sent to the endpoint don't block operations waiting for the transaction result. In response to the request, the endpoint returns the poll result for each request key. Send one or more commands to the local HTTP server to be executed. The request body must contain properly-formatted Pact commands. In response to the request, the endpoint returns the request key for each transaction sent. Verify a transaction request is properly formatted. The request body contains the transaction to analyze. In response to the request, the endpoint returns the result from analyzing the transaction. To send a sample transaction to the Pact built-in HTTP server, you can run a command similar to the following: The command returns the request key for the transaction: To poll for the results of a transaction, you can run a command similar to the following: In this example, the transaction is complete and the request returns the following response:",
    "source": "reference/pact-cli.md",
    "title": "pact-cli"
  },
  {
    "content": "title: Chainweb execution and latency description: \"Benchmarks and calculations to help you understand expected execution times.\" id: latency sidebar_position: 5 Chainweb execution and latency There are a number of factors that influence the time it takes to execute transactions, including network topology and the performance of individual nodes. This section provides benchmarks, estimations, and calculations to help you better understand the time it takes to execute transactions on Chainweb nodes under different circumstances. Single chain transactions On average, single chain transactions take approximately 45 seconds. However, transactions can take much longer than 45 seconds, in particular, if there are mining delays. To give you better insight into how transactions are executed, the following example describes the workflow for a single chain transaction. You start a transaction by submitting a formatted request to the endpoint on a node. The code provided by the endpoint performs some simple initial checks that validate the transaction has a reasonably high chance of being executed successfully. These initial checks ensure that you learn if a transaction is invalid as soon as possible. If the transaction passes the initial checks, the process adds the transaction to the mempool for the local node. The transaction is then gossiped to remote nodes, and, eventually, one of the nodes is selected to mine the next block, and the node includes the transaction in that block. After the mined block is added to its target chain, the block with the transaction result is synchronized on the local node, and a request to the endpoint returns the transaction result. Under normal load, the initial checks should take less than a millisecond for a single transaction. However, if a node in under heavy load—for example, because the PactService is contending with a high volume of or calls or because the node is catching up—you might experience delays in sending or polling transactions. It's worth noting that if a node is too busy, it will always prioritize staying caught up over sending transactions. The propagation of transactions in the mempool to other nodes takes, on average, 10 seconds, but it can take longer if there are networking delays, such as increased network traffic or slow network connections between nodes. Block propagation back to the local node is usually a matter of seconds. Cross-chain transfers As discussed in Transaction format and flow, a cross-chain transfer is essentially two separate but related transactions. The time it takes to complete a cross-chain transfer can depend on several factors, including the physical distance between the chain nodes in the network, network congestion, and the synchronization of state between the chains involved. For two distant chains—representing the worst case—a cross-chain transfer is expected to take the following time to complete: The initiating transaction has an average time from submission to completion of 45 seconds. With the current 20-chain graph, two blocks at most must be propagated to the target chain so that the source and target chain share the same view of state, with an average time of 30 seconds per block. The number of blocks that must be propagated will increase as more chains are added, and will depend on the distance between the chains. The continuation step is a second transaction, again with an average time of 45 seconds. Therefore, a cross-chain transfer typically takes 2 minutes and 30 seconds to complete. If either the source or target chain is ahead of the other chain, more blocks might be required to synchronize the chains before the transaction can complete, in which case the transfer might take additional time. Local execution In general, calls to the Chainweb endpoint return results almost immediately. Depending on how long it takes to execute the Pact code in a transaction, you can typically expect to see results from call within seconds, at most. However, it's important to know that calls are executed on a single chain and served in a single-threaded, first-come-first-served basis. If a node is under contention—because it's catching up with state, busy processing multiple calls, or performing mempool checks—execution could take as long as needed for the request to be serviced in the queue. Block production On average, producing a block takes 30 seconds. The actual time it takes to produce any given block depends on the time required to prepare the block for mining, and the time it takes to mine the block. Before a block can be mined on any chain, it must satisfy specific requirements. To give you better insight into how blocks are produced, the following example describes the workflow and requirements for mining a block. For this example, the target chain for the block is chain 1 on a Kadena network with 20 chains. To start block production on chain 1, the new block candidate must provide the following inputs: The block header for a block that exists on chain 1 to serve as the parent of the new block. The block headers for the parent block of the new block on the adjacent chains, which are currently chains 6, 11, and 18 for chain 1. The sequence of transactions in the new block and the output from running the transactions in the new block. The nonce and creation time for the new block, which are set by the miner. Block parents and orphans If the block selected to serve as the parent of the new candidate block is superseded by the arrival of a new block on the target chain, the block production process must start over with the new parent block. If the block production process starts over, the new block candidate that was being processed is no longer valid for the continuity of the chain and is deemed an orphaned block. Block height and payload The next step in the block production process involves two requirements that are satisfied in parallel. The first requirement is to determine whether the chains that are adjacent to the target chain in the chain graph have any blocks at the same height as the parent block. If the adjacent chains have blocks at the same height as the parent block, a new block can be created while satisfying the braiding requirement of the Chainweb protocol. The second requirement is to produce the block payload on the target chain. Producing the payload involves querying the mempool for a set of transactions that can fit in the block, and executing those transactions on the Pact state. Currently, the gas limit for a block is 150000, and each unit of gas can represent up to 2.5 microseconds of execution time, leading to a maximum execution time of 375 milliseconds. However, node contention can increase the maximum execution time up to 600 milliseconds. Mining work After the block production requirements are met—that is, the block payload, parent block, and the adjacent parent blocks have been validated—the new block can be mined and added to the target chain. Miners make a request to the node and can receive a new block on any chain that has a new block ready. Mining time follows an exponential distribution where the mean time is such that the average total block time is 30 seconds. Because other parts of the block production process take some time as well, mining time will actually be less than 30 seconds on average. After mining is successful, the new block candidate is added to the target chain on the mining node, and then sent around the chainweb network for other nodes to see. Mining per block Mining a block takes 16 seconds on average with the current 20-chain graph. With the average block production time of 30 seconds and the current 20-chain graph, mining accounts for roughly half of the time it takes to advance each chain by one block. The average time it takes to mine a block is likely decrease as more chains are added. However, the total block production time is expected to remain about 30 seconds on average because chains might spend more time blocked from creating new blocks. In most cases, this delay is caused by adjacent chains that have not yet advanced to the block height required for the target chain to add a new block.",
    "source": "reference/latency.md",
    "title": "latency"
  },
  {
    "content": "title: Kadena TypeScript client description: The @kadena/client library provides a TypeScript-based API for interacting with Pact smart contracts and Chainweb nodes using frontend frameworks. if: kadena-client order: 3 layout: full tags: ['TypeScript', 'Kadena', 'Kadena client', 'frontend'] Kadena TypeScript client The library provides a TypeScript-based API for interacting with smart contracts and Chainweb nodes on the Kadena network. The library includes modules to help you perform the following types of common tasks: Create commands Sign transactions Submit transactions Query transaction results If you only need to interact with the contract, you can use the functions in the library instead of the library for a simpler API. Get started with Kadena client One of the most important features of the Kadena client library is that helps you create command objects with the correct structure. You can then construct and sign transactions to send the command to the blockchain network. After you submit a transaction for processing, you can use the Kadena client to listen for the transaction results. The following example illustrates the structure of a command object: If your use case is simple enough that you can create the JSON directly, you don't need to use the functions in the Kadena client library. You can also use some parts of the library, without using everything. If you prefer to learn from code, check out the client-examples. Install You can download and install the library with the following command: Import After you install the library, you can import functions into a TypeScript or JavaScript program with the following statement: The library also exports functional programming utilities under for more flexibility when using a functional programming approach. To import functional programming utilities, include the following statement in your TypeScript or JavaScript program. Calling Pact modules Interacting with the Kadena blockchain network and Chainweb nodes is mostly a matter of calling smart contract functions. From the client perspective, you need to write Pact code in a string and pass it to the interface. Without code completion and validation, writing the Pact code string manually is error-prone and vulnerable to code injection. To simplify the process, you can use to help you: Write type-safe functions. Perform Pact type conversion. Avoid code injection. You can skip this part of the client library if your code is just a simple constant string. Basic usage Use with the following format: Parameters Parameter Type Description ...args PactValue[] List of arguments. Examples To create the code for the function: To create the code for the function that converts a list, objects, and date to valid Pact code: Create type definitions You can use @kadena/pactjs-cli to create the type definitions for the Pact module you use. After you generate the type definitions file, the code editor in your development environment should provide code completion for functions and capabilities. To create a type definition file for the contract: Creating commands As illustrated in Get started with Kadena client, a command is a JSON object with three keys: , , and . There are two types of commands: Execution commands Continuation commands You can create the JSON object without using the Kadena client library. However, using the library and to create the command object simplifies the process. Pact.builder.execution You can use to create an execution command object, . Most transactions are execution (exec) commands that complete in a single step. Execution commands are also be used for the first step in transactions that are multi-step transactions. Parameter Type Description ...codes string[] List of input for a function. Examples To use strings for the command code: To use for the command code: Pact.builder.continuation You can use to create a continuation command object, , which is the type of transaction used for additional steps of multi-step transactions. Parameter Type Description contData object Continuation data includes a unique identifier, whether the transactions rolls back a previous transaction, the transaction step that the continuation represents with the first step being step 0, and a simple payment verification proof if one is generated by calling the endpoint. The object consists of the following properties: Example The function is a multi-step transaction that burns tokens in the source chain and mints tokens in the destination chain. After the first step completes successfully, you can call the second step by using the command object. addSigner You can use the method to add public keys and capabilities for a transaction signer to the command. You can call multiple times to add multiple signers to the transaction. Later, the Chainweb node checks whether all required signers have signed the transaction or not. Parameter Type Description signer string or object Public key of the signer or the signer object (this can also be a list of signers if all of the signers sign for the same capabilities). capabilityCallback Allows you to scope what the signer is signing for to a specific list of capabilities. Chainweb supports the following signature schemes for public keys: The default signature scheme is . You can pass just the public key if the signature scheme is . If the scheme is not , you must pass a signer object that includes the pubic key and the signature scheme. Examples To add a signer public key for a contract transfer: To add a signer that uses the scheme: To add a list of signers with no capabilities: To add a list of signers with similar capabilities: addData You can use to add data to the or command. This data is readable in the smart contract later. You can also use this data in the code you set in the command. Parameter Type Description key string The key associated with the data you're sending. value PactValue Data that you want to send. Examples To transfer with parameters in data: To use and send the receiver guard: addKeyset Because keysets are often included as data in commands, you can use the method as an alternative to the method to add a keyset to a command. Parameter Type Description name string The name associated with the keyset. pred \"keys-all\"|\"keys-2\"| \"keys-any\" | string One of the built-in predicate functions or a user-defined predicate function. ...keys ...string[] List of public keys in the keyset. Examples To use and helper functions with transfer-create: To use transfer-create as string code: setMeta You can use to add metadata to a command. Parameter Type Description meta object Add a metadata object to the command. The object consists of the following properties: Property Type Default value Description chainId to Chain identifier for the chain. Valid values are from 0 to 19. senderAccount The account address that you want to pay transaction fees from. gasLimit Maximum units of gas that you want to allow to be deducted when running the transaction. gasPrice Price of each gas unit based on KDA (e.g., 0.0000001). ttl Time-to-live (ttl) for the transaction to be valid in seconds. The default value is 8 hours. creationTime Transaction creation time in seconds. Examples setNonce You can use function to set to a custom nonce for the transaction. Otherwise, the nonce is set using the function. Parameter Type Description nonce string Custom nonce for the transaction. Examples setNetworkId You can use to set to specify the network for the transaction. Parameter Type Description networkId string Network identifier, for example, \"mainnet01\" or \"testnet04\". Examples Creating transactions After you set all parts of the command, you can create the transaction object by calling the method. This method adds all of the default values to the command, converts to a string, and adds the hash. You must add signatures to the transaction object using a wallet to submit the transaction to the blockchain. For information about adding signatures from a wallet, see Signing transactions. Examples getCommand If you prefer to have the non-stringified version of the command, you can use . Examples initialPactCommand If you find yourself repeating certain parts of methods for different commands, you can create your own command builder by using the function. This function allows you to set all of the default values once and then reuse them in . Parameter Type Description initial The initial Pact command values that you want to reuse. Examples To create a transaction builder with network and chain already set: Signing transactions After creating the command, you need to sign it using the appropriate private keys. The signing process is usually managed with a wallet. Kadena has two protocols for signing transactions, each serving different purposes: Sign API: This API allows users to send their sign requests to the wallet. The wallet is then responsible for creating and signing the transaction simultaneously. With this approach, the wallet has more freedom, making it more suitable for simple transactions. Quicksign: This API is designed to give dApps full control over the command, with the wallet only responsible for adding signatures. This is the recommended method if you are using the command builder from this library. Wallets typically have their own API for communicating with applications. You can use the API provided by the wallet, or, depending on the wallet, use one of the wallet-specific wrapper functions for convenience. Sign function interface The function can be used two ways: If you pass a single transaction to the function, it returns the single signed (or partially signed) transaction. If you pass a list of transactions to the function, it returns the list of signed (or partially signed) transactions. Single transaction Parameter Type Description tx IUnsignedCommand The transaction to be signed. List of transactions Parameter Type Description tsList IUnsignedCommand[] List of the transactions to be signed. Chainweaver You can use to sign a transaction using Chainweaver. It's a factory function that returns the actual sign function. This function uses the protocol. Parameter Type Description option object option including host URL default Examples To sign one transaction using Chainweaver: To sign two transactions using Chainweaver: WalletConnect The WalletConnect protocol and helper functions are based on KIP-017. You must use the WalletConnect protocol to create a walletConnect client and session before you can use the helper functions to sign transactions. Wallet Connect sign method The function returns the function using the protocol. The return object might contain different data than what you would pass from the transaction builder because the protocol lets the wallet create the transaction. Parameter Type Description client Client The client object. session SessionTypes.Struct The wallet-connect session object. networkId string The network identifier, for example, or . The identifier can include the prefix, for example, . Examples Wallet Connect quicksign method The function returns the function using the protocol. Parameter Type Description client Client The client object. session SessionTypes.Struct The wallet-connect session object. networkId string The network identifier, for example, or . The identifier can include the prefix, for example, . Examples EckoWallet The following functions provide the and protocols for EckoWallet to return a function and other properties: isInstalled You can use to check if the EckoWallet extension is installed in the browser. isConnected You can use to check if the application is already connected to EckoWallet. connect You can use to send a connection request to EckoWallet. createEckoWalletSign The function uses the protocol to communicate with EckoWallet. The return object might contain different data than what you would pass from the transaction builder because the protocol lets the wallet create the transaction. Examples To sign a transaction using EckoWallet: createEckoWalletQuicksign The function uses the protocol to communicate with EckoWallet. Examples To sign one transaction using the protocol and EckoWallet: To sign two transactions using the protocol and EckoWallet: Sign with a public and secret key pair If you have a secret key in a safe environment—for example, a server environment or CI test pipeline—you can sign transactions with the function to returns the function. The interface is defined as followis: Examples To sign with one key pair: To sign with several key pairs: addSignatures If you already have the signature for a transaction, you can use the function to add the signature to the transaction. All signatures you add should either include a public key, or none of them should. If the signatures don't include the public keys, then the number of signatures must match the number of signers, and the signatures are matched based on their order. Parameter Type Description transaction IUnsignedCommand The partially signed or unsigned transaction. ...signatures Array of objects or strings or List of signatures to be added to the transaction. Examples To add a signature manually with a public key: To add a signature based on the signer order: Communicating with the network Kadena exposes endpoints for communicating with Chainweb nodes through the [Pact REST API}(https://api.chainweb.com/openapi/pact.html). You can use any REST client to call these endpoints. However, the Kadena client library also provides functions to make these call more convenient for frontend frameworks. createClient To use the helper functions for communicating with Chainweb nodes, you must first use the function to return the interface. You can use object destructuring to extract specific functions. Parameter Type Description host string | The Pact service URL as a string or the function that returns the URL. options Additional options for the client. It has only one property now: , which can be used in the poll endpoint. Default value is . Both and are optional. The default value of is a function that returns the Chainweb node URLs for mainnet and testnet. If you want to use different URLs, you must specify the parameter. The and parameters are read from the command object and passed to the URL generator function. Examples To create a client for the development network and a specific chain identifier (1): To create a client for the development network that covers multi-chain and uses the URL generator function for more flexibility: To create a client that uses but not Kadena main network nodes: To create a client with a of that waits for five new blocks to be added to the chain before reading the result of a transaction: Submitting transactions You can use the or functions to submit data to the blockchain. These functions use the Pact endpoint. The client function is a deprecated alias for the function with the same interface. To submit one transaction using the function: Parameter Type Description tx ICommand The command object ready to submit. To submit a list of transactions using the function: Parameter Type Description txList ICommand[] List of command objects ready to submit. In most cases, you should store the result of this function so you can fetch the result of the request. The function is the same as submitting one transaction using the function. For example: Parameter Type Description tx ICommand The command object ready to submit. Getting transaction results After you submit a transaction, you need to query for the result using a request key. You can query transaction results by calling the or endpoint. The endpoint is a blocking request. It only accepts one request key and returns the results when the transaction result is ready. If you use this endpoint, the HTTP request remains open for a while. The endpoint accepts a list of request keys and responds immediately with the current status of the request key. The Kadena client library exposes the following functions to use the /listen or /poll endpoint in different scenarios: These functions all return the result of a transaction with the following interface: getStatus This function calls and returns the result of requests. Parameter Type Description transactionDescriptor TransactionDescriptor[list] One or more request keys to be queried pollStatus This function calls in intervals and returns the result of all requests when all are ready. Parameter Type Description transactionDescriptor TransactionDescriptor[list] One or more request keys to be queried. pollOptions object Optional poll configuration settings. onPoll string Identifier for the callback that is called each time the node is polled for the status of a request key. This callback might be called several times if the request is not ready yet. timeout time Specifies a timeout in milliseconds to stop polling if the result is not ready. The default is milliseconds (3 minutes). interval time Specifies the delay between retry attempts. The default is milliseconds (5 seconds). confirmationDepth number Sets the confirmationDepth for getting the response. This setting overrides the one you set in the function. Return value The return value is a special type of promise that enables you to listen for each individual request through the property. Alternatively, you can the result without using the property to handle most use cases. Examples Poll the status of a request: Poll the status of several requests and get the result for each one immediately: listen is another function for fetching the result of one request. It uses the endpoint, which is a blocking endpoint. Note: If your network or firewall configuration doesn't allow keeping HTTP connections open for a long time, then it's better to use which has the same interface but uses under the hood. Parameter Type Description transactionDescriptor TransactionDescriptor The request object including , , and . pollOne The function fetches the result of only one request using the endpoint. Parameter Type Description transactionDescriptor TransactionDescriptor The request object including , , and . Reading data Apart from transactions, you can also send read requests to the node. This mainly utilizes the endpoint. These kinds of requests return the result immediately since you don't need to submit data. You can also use these functions to validate your transaction before calling the endpoint to avoid transaction failure, as in some scenarios you need to pay gas even for failed transactions. The following functions all use the endpoint: local The function is the most generic function that utilizes the endpoint. The return type is with when it is set to true. Parameter Type Description transaction ICommand or IUnsignedCommand The signed or unsigned command object. options object Optional configuration settings. preflight boolean Runs the code in the mode to simulate submitting the transaction. You can also use this option to preview the estimated gas that the transaction would consume. The default is . signatureVerification boolean Runs the signature verification in the node for the transaction. The default is . Examples Use a local call to avoid submitting an incorrect transaction: Use local call for gas estimation: dirtyRead Alias for local where both preflight and signatureVerification are false. This function is useful when your code only needs to read data from the node. Parameter Type Description transaction ICommand or IUnsignedCommand The signed or unsigned command object Examples Get account balance preflight Alias for local where preflight is true but signatureVerification is false. Parameter Type Description transaction ICommand or IUnsignedCommand The signed or unsigned command object signatureVerification Alias for local where preflight is false but signatureVerification is true. Parameter Type Description transaction ICommand or IUnsignedCommand The signed or unsigned command object runPact If you just want to see the result of a pact code and don't want to create a command object, you can use the function. This function creates a command object internally. Parameter Type Description code string Pact code data Record, string, or unknown Data to be sent with the transaction options object chainId string Specifies the chain identifier that you want to send the transaction to. The valid values are \"0\" to \"19\". networkId string Specifies the network identifier that you want to send the transaction to. Examples Requesting simple payment verification (spv) You need SPV proof mainly for cross-chain transactions - but it's not limited to this, and you can request SPV proof for all kinds of transactions. There are two functions for this purpose, both of which use the endpoint: createSPV Request SPV proof if it's ready. Parameter Type Description transactionDescriptor object Specifies the request key, network identifier, and chain identifier for the transaction that you want to create a simple payment verification (spv) proof for. targetChainId string Specifies the chain identifier that consumes this proof. pollCreateSPV Poll for the SPV proof and await until it's ready. Parameter Type Description transactionDescriptor object Specifies the request key, network identifier, and chain identifier for the transaction that you want to create a simple payment verification (spv) proof for. targetChainId string Specifies the chain identifier that consumes this proof. pollOptions object Optional poll configuration settings. onPoll string Identifier for the callback that is called each time the node is polled for the status of a request key. This callback might be called several times if the request is not ready yet. timeout time Specifies a timeout in milliseconds to stop polling if the result is not ready. The default is milliseconds (3 minutes). interval time Specifies the delay between retry attempts. The default is milliseconds (5 seconds). Examples Functional programming to compose Pact commands For additional flexibility, you can use the functional programming (FP) API to create Pact commands. The functional programming (FP) API supports the same functions as the command builder API. In fact, the command builder API uses the functional programming (FP) API under the hood. To reduce redundancy, this section lists the common functions with examples for using the function rather than repeating the full function descriptions and parameter tables. Importing functions To use the functional programming (FP) API, import functions from the package. For example: composePactCommand The function let you compose parts of the Pact command and create the final command objects. The function accepts pure JSON as well as reducer functions. This function eventfully returns the interface that is converted to a string for the key in the JSON command object. The return value is also a function that you can pass to another call. Eventually, when you call the function, it also adds the default values. Parameter Type Description ...reducersOrPartialCommands Array List of command reducers or partial Pact commands. Examples execution To create : For example, using strings: For example, using : continuation To create : For example: addSigner To add : For example, add a signer: Add a signer with scheme: Add a list of signers with no capabilities: Add a list of signers with similar capabilities: addData To add data to or : For example, to transfer with parameters in data: Send the receiver guard: addKeyset To add a keyset: For example, to add a keyset using the helper function: setMeta To add metadata properties to a command: For example: etNonce To manually set : For example: setNetworkId To set : For example: createTransaction To create the transaction object: For example:",
    "source": "reference/kadena-client.md",
    "title": "kadena-client"
  },
  {
    "content": "title: kadena-cli command reference description: The library provides a complete set of commands for creating applications and interacting with the Kadena network interactively or by using scripts from the command-line. id: kadena-cli-ref sidebar_position: 7 tags: ['TypeScript', 'Kadena client', 'frontend'] Kadena-cli commands The Kadena command-line interface () provides direct access to the Kadena blockchain and to commands that help you create, test, deploy, and manage applications for the Kadena network. You can use the Kadena command-line interface to perform tasks interactively or in scripts and automated workflows that don't allow interactive input. The Kadena CLI has one primary entry point—the parent command. By providing a single entry point for performing a wide range of tasks, the Kadena CLI integrates naturally into the typical development workflow. With commands designed specifically for building, testing, and managing Kadena-based applications, you can focus on building innovative applications using familiar tools and processes. Prerequisites Before you use the Kadena command-line interface, verify the following basic requirements: You have , version 18 or later, installed. You have the package manager installed. Depending on your development environment, you can install pnpm using a standalone script or using a package manager. For example, you can run the command or to install pnpm on your local computer. For more information about installing pnpm on different operating systems, see Installation. Run to verify that you have pnpm installed and the version you are running. Installation The Kadena CLI is packaged in a TypeScript library. You can install the Kadena CLI () using the or package manager. To install globally using , run the following command: To install globally using , run the following command: To verify the package is installed and display usage information, type and press Return: Command overview You can use the parent command with different flags and subcommands to perform different types of operations. The basic syntax for running commands is: The following diagram provides an overview of the kadena command-line interface: Command subjects and syntax Commands in the Kadena CLI are organized into categories that describe the subject of the action you want to perform. The commands are structured using the following basic format: For example, you can create and manage all wallet-related information by specifying as the command subject. Available subjects Use the following command subjects to select the category of information for the operation you want to perform. Use this command subject To do this Create, fund, and manage accounts that contain fungibles assets. Configure the initial context and properties for working with the command-line interface. Create and manage an application project using a frontend framework template. Generate and manage public and secret keys. Create and manage network information. Create and manage transactions. Generate keys and manage wallets. Global flags Flag Description Display usage information. Use JSON format to display relevant result data in standard output (stdout) stream. Eliminate interactive prompts and confirmations. Display version information. Use YAML format to display relevant result data in standard output (stdout) stream. Command-specific help To get help on a specific subject, use the flag: Interactive execution You can run all commands without any arguments by responding to prompts interactively from the command line. You can skip prompting for any argument by passing your response as part of the command you want to run. Interactive prompting is designed to make command execution more intuitive and easy to follow with a guided user experience. If you run a command in the Kadena CLI without specifying all of the required options, the CLI automatically prompts you to provide the missing information. This guided approach ensures that you provide all necessary information to successfully execute every command. To run commands with interactive prompting, type the entry point, the command subject, and the action you want to take without any arguments. For example, if you want to add a new wallet but aren't sure of all the required flags and arguments, you can run the following command: The CLI then guides you through the necessary steps, asking for the information required to add the new wallet. Interactive prompting is especially useful for new users or for users who are less familiar with using command-line tools. It also helps you learn about the arguments required to run different commands, so over time you can reduce or skip interactive prompting by entering arguments directly on the command line. By allowing you to run commands interactively, the Kadena CLI provides the following key benefits: Ease of use: Reduces the need to remember all command arguments and options upfront. Guided execution: Ensures that all required inputs are collected before executing a command. Flexibility: Allows for a more conversational and less rigid interaction with the CLI. If you want to disable all interactive prompts and confirmation messages, you can use the flag. The flag enables you to automate tasks in environments where interactive input is impractical, such as continuous integration (CI) pipelines. If you include the flag in a command, the command suppresses all interactive prompts and skips confirmations, so that the command executes uninterrupted. This mode ensures that automated processes can run smoothly and efficiently, without the need for manual intervention. JSON or YAML output You can use the or flag to format output from the results of a command in JSON or YAML format. The results are displayed in the selected format on standard output (stdout). You can then pipe the output into a file or to other programs. For example, to format network information using JSON format, you can run the following command: The command then displays the results in JSON format: The and options don't affect logging of informational messages, warnings, or errors. Log messages are sent to standard error (stderr) instead of standard output (stdout). You can disable the logging of informational messages by setting the environment variable. Legacy mode The flag ensures that the output format for commands related to wallets, keys, and transactions aligns with earlier cryptographic standards and with existing workflows and tools, such as Chainweaver. This flag is especially useful if you need to interact with tools that rely on a legacy format for processing transactions or if you need to maintain backwards compatibility for a wallet or other application. Legacy mode is available for the following commands:",
    "source": "reference/kadena-cli-ref.md",
    "title": "kadena-cli-ref"
  },
  {
    "content": "title: Guard JSON representation description: \"This technical specification describes the JSON representation for different guards returned by the chain.\" id: guard-json sidebar_position: 5 Guard JSON representation In the technical specification for the guard types, the following types all correspond to JSON types: String Number Array[*] Bool Objects () Keyset guards The guard is the backward-compatible as originally defined in Pact. This guard is also referred to as a concrete keyset that's defined in the environment. Using the type is the one instance where you can restrict a guard subtype. For all other guards, the type obscures the implementation type to discourage you from using guard-specific control flow, which would be against best practices. In general, you should use the type unless you have a specific need to use a keyset. Type definition Examples Principal account prefix Each type of principal and guard uses a unique prefix, so they are easy to recognize. If you use the function to a create principal account for a keyset guard, the principal account uses one of the following prefixes: k: for single key keysets w: for multiple keys keysets KeysetRef guard You can install concrete keyset guards in the REPL environment by using the function. However, if you want to store a reference to a defined keyset, you must use a type. To make REPL environment keysets interoperate with concrete keysets and other guards, you can use the KeysetRef guard to indicate that a defined keyset is used instead of a concrete keyset. Type definition Examples User guard User guards allow you to design an arbitrary predicate function to enforce the guard, given some initial data. With user guards, you can implement any type custom predicate logic that can't be expressed by other built-in guard types. For example, you might want to customize the guard to allow one of two different keysets to sign: One keyset registers the keys for the members of a board of directors. A second keyset registers the keys for union representatives. You can then design a user guard to require two separate keysets to be enforced: User guards can be very flexible and powerful. They can be stored in the database and passed around like plain data. However, user guards are pure functions that don't allow access to a database during evaluation of the guard. Type definition Examples The following example illustrates how to write a custom hash timelock guard to implement atomic swaps. Principal account prefix Each type of principal and guard uses a unique prefix, so they are easy to recognize. If you use the function to create a principal account for a user guard, the principal account uses the following prefix: u: for user guards Capability guard Capabilities are in-module rights that can only be enforced within the declaring module, and offer scoping and the other benefits. Because user guards are required to be pure functions, they can't take database state into account. If you need to access database state, you can define a guard that requires a capability to be brought into scope. With this type of guard, you can retrieve database state when you bring the capability into scope. Type definition For information about PactValue types, see Pact values. Principal account prefix Each type of principal and guard uses a unique prefix, so they are easy to recognize. If you use the function to create a principal account for a capability guard, the principal account uses the following prefix: c: for capability guards Module guard (DEPRECATED) Modules always guard access to the tables and functions that are defined within the module. For example, when you create a table, you must specify a module name. This requirement ensures that tables are fully encapsulated or guarded by the module and that direct access to the table through data-access functions can only be authorized by the administrative owner of the module. However, within module functions, table access is unconstrained. This behavior gives you flexibility in designing data access, and ensures that the module is the main point of entry for all data-related interactions. Within a module, only the module code or a transaction having module administrative privileges can write directly to a module table or upgrade the module. Module guards aren't required to protect these in-module operations. Instead, module guards are intended to allow a Pact module or smart contract to autonomously own or manage an asset outside of the module, for example, to own coins in an external ledger or manage assets in an internal ledger alongside other non-module owners. If a module guard is enforced: The function must called from within the module. or Module governance must be granted to the current transaction. For more information about module management, see Governance. Type definition Examples The function takes a argument to allow you to name the guard with text that indicates the purpose or role of the guard. Pact guard (DEPRECATED) Pact guards are a special guard that only pass if called in the specific execution in which the guard was created. Pact guards turn executions into autonomous processes that can own assets, and is a powerful technique for trustless asset management within a multi-step operation. Type definition Examples The following example illustrates the use of a guard for an escrow transaction modeled as a two-step declaration. In this example, the funds go into a account named after the identifier, guarded by a guard. This means that only code in a subsequent step of that particular pact execution—that is, having the same as the previous—can satisfy the guard. Union Pact value literals The following pseudo code provides type information for decoding Pact values returned by guards: Pact value union types The following pseudo code provides type information for decoding Pact values returned by recursive guards:",
    "source": "reference/guard-json.md",
    "title": "guard-json"
  },
  {
    "content": "title: chainweb-node command-line description: \"Command-line options and usage information for running the chainweb-node binary.\" id: chainweb-cli sidebar_position: 6 chainweb-node command-line You can configure many aspects of Chainweb node operations using configuration settings in one or more configuration files or by specifying command-line options and arguments. Configuration settings are loaded in order first from one or more configuration file locations that you specify using options then from the command-line options in the order you specify them. Configuration settings that are loaded later overwrite settings that were previously loaded. You can specify configuration file locations by providing local file system paths or remote HTTP or HTTPS URLs. Remote URLs must start with either \"http://\" or \"https://\". Basic usage The basic syntax for setting chainweb-node command-line options is: Node information options Use this option To do this --config-file filename Specify the local path or the URL of a file that contains configuration settings in YAML or JSON format. If you specify more than one option, the files are loaded in the order that they are specified on the command line. You can specify configuration file locations by providing local file system paths or remote HTTP or HTTPS URLs. Remote URLs must start with either \"http://\" or \"https://\". -?, -h, --help Display usage information as standard output, then exit. --info Display a brief summary that describes the Chainweb version number and revision (commit) hash as standard output, then exit. --license Display the license agreement for the software as standard output, then exit. --long-info Display a complete list of packages and dependencies as standard output, then exit. --print-config Display the current configuration of the node as standard output. This option is an alias for the option. --print-config-as full minimal -v, --version Display the Chainweb version number and revision (commit) hash as standard output, then exit. General blockchain options Use this option To do this -v, --chainweb-version networkId Specify the Chainweb network identifier for the node. Valid values are , , , and . The default is . --database-directory path Specify the path to the database root folder. --header-stream Enable the endpoint for streaming block updates. For information about streaming block updates, see Stream block header event updates. --no-header-stream Unset the option and disable streaming block updates. --enable-tx-reintro Enable transactions from losing forks of the chain to be resubmitted. --disable-tx-reintro Unset the option and prevent transactions from losing forks to be resubmitted. --enable-reset-chain-databases Reset chain databases when the node starts. --disable-reset-chain-databases Disable resetting of chain databases when the node starts. --reorg-limit max Specify the maximum allowed reorganization depth. For more information, see Recovering from deep forks. --pre-insert-check-timeout microseconds Specify the maximum number of microseconds allowed for the transactions validation in the PreInsertCheck command. --allowReadsInLocal Enable direct database reads of smart contract tables in local queries. --no-allowReadsInLocal Disable direct database reads of smart contract tables in local queries. Development mode options Use this option To do this --fork-upper-bound upperBound Specify the latest fork for the node to enable (development mode only). --block-delay delay Specify the block delay in seconds per block (development mode only). --disable-pow Disable the proof-of-work check (development mode only). Peer-to-peer options Use this option To do this --p2p-hostname hostname Set the hostname or IP address for the local peer to enable peer-to-peer communication. --p2p-port portNumber Set the port number for the local peer to enable peer-to-peer communication. --p2p-interface interface Set the interface for the peer-to-peer REST API endpoints to bind to. For more information, see the HostPreference documentation. --p2p-certificate-chain certificate Specify the PEM-encoded X509 certificate or certificate chain used by the local peer for peer-to-peer communication. --p2p-certificate-chain-file file Specify a file with the PEM-encoded certificate chain. Providing the as a text string takes precedence over using a file for peer-to-peer communication. --p2p-key key Specify the PEM-encoded X509 certificate key used by the local peer for peer-to-peer communication. The default is . --p2p-certificate-key-file file Specify a file with the PEM-encoded certificate key. A textually provided certificate has precedence over using a file for peer-to-peer communication. --p2p-max-session-count count Specify the maximum number of sessions that can be active at any time. --p2p-max-peer-count count Specify the maximum number of entries allowed in the peer database. --p2p-session-timeout seconds Specify the maximum number of seconds to allow for a session to try to connect before timing out the connection. --known-peer-info [ peerId@ ]hostaddress Specify the peer information that is added to the list of known peers. You can specify this option multiple times on the command-line. --enable-ignore-bootstrap-nodes Specify that you want to ignore the hard-coded bootstrap nodes for the network. --disable-ignore-bootstrap-nodes Unsets the option to ignore bootstrap nodes to restore communication with the hard-coded bootstrap nodes for the network. --enable-private Specify that you want this node to be private and only communicate only with its initially configured known peer nodes. --disable-private Unsets the make the node private to enable the node to communicate with other nodes in the network. --bootstrap-reachability [0,1] Specify the number of bootstrap nodes that must be reachable when the node starts up as a fraction of the bootstrap nodes available. The default value of 0.5 indicates that half of the bootstrap nodes must be reachable for the node to connect to the network. Memory pool options Use this option To do this --enable-mempool-p2p Enables the memory pool peer-to-peer network for the local node. --disable-mempool-p2p Unsets the --enable-mempool-p2p option to disable the memory pool peer-to-peer network for the local node. --mempool-p2p-max-session-count count Specify the maximum number of memory pool peer-to-peer sessions that are active at any time. --mempool-p2p-session-timeout seconds Specify the maximum number of seconds to allow for a memory pool peer-to-peer session to try to connect before timing out the connection. --mempool-p2p-poll-interval seconds Specify the poll interval for synchronizing memory pool sessions. Gas options Use this option To do this --block-gas-limit max Specify the upper bound for the sum of all transaction fees allowed in a block. The total fees for all transaction must not exceed the value you set for the max argument. --log-gas Logs the gas fees consumed by Pact commands. --no-log-gas Disables the option to stopping logging the gas consumed by Pact commands. --min-gas-price price Specify the minimum gas price allowed for an individual transaction in a block. The gas fee for any individual transaction in a block cannot be below the value you set for the price argument. Pact options Use this option To do this --pact-queue-size max Specify the maximum size of the Pact internal queue. --full-historic-pact-state Keep the full historic Pact state n the database. You should only only set this option for custodial or archive nodes. --no-full-historic-pact-state Reset the option from true to false. --module-cache-limit bytes Set the maximum size of the per-chain module cache in bytes. --enable-local-timeout seconds Enable timeout support for endpoint calls. Cut options Use this option To do this --fast-forward-block-height-limit height Set the limit for fast-forwarding block height (null means no limit). If you set the option, chain synchronization uses this block height. If you haven't set the option, this option is ignored. --cut-fetch-timeout microseconds Set a timeout for fetching cuts in microseconds. --initial-block-height-limit height Reset the initial cut to this block height (null means no limit). --prune-chain-database none headers Service API options Use this option To do this --service-port port Specify the port number for exposing the service API. --service-interface interface Set the interface for the service REST API endpoints to bind to. For more information, see the HostPreference documentation. --service-payload-batch-limit max Set the upper limit for the number of payload batches that can be returned in response to a service API request. Note that increasing this upper limit can make payload requests a potential attack vector for Denial of Service (DoD) attacks. Mining options Use this option To do this --enable-mining-coordination Enable the mining coordination API for the node. | --disable-mining-coordination | Reset the option from true to false to disables the mining coordination API for the node. | | --mining-public-key key | Set the public key for a miner account in hexadecimal encoding. Account names typically use the prefix followed by the account public key. You can specify this option multiple times. | | --mining-request-limit max | Specify the maximum number of mining work requests that can be made within a 5 minute period.| | --mining-update-stream-limit max | Specify the maximum number of concurrent update streams that the node can support. | | --mining-update-stream-timeout seconds | Set the maximum number of seconds to keep an update stream open. | | --mining-payload-refresh-delay seconds | Specify the frequency with which the mining payload is refreshed. | | --enable-node-mining | Enable in-node mining. Only use this option for internal network testing.| | --disable-node-mining | Unset the option.| | --node-mining-public-key key | Set the public key for a miner account in hexadecimal encoding. Account names typically use the prefix followed by the account public key. You can specify this option multiple times.| Synchronization and replay options Use this option To do this --only-sync-pact Synchronize the Pact databases to the latest cut, then terminate the node process. --no-only-sync-pact Unset the option. --read-only-replay Replay the block history non-destructively. --no-read-only-replay Unset the option. --sync-pact-chains JSON list of chain ids Specify a list of chain identifiers to synchronize in JSON format. If the list is empty or this option is unset, all chains are synchronized. Backup options Use this option To do this --enable-backup-api Enable the backup API. --disable-backup-api Disable the backup API. --backup-directory directory Specify the directory where database backups are located when you use the endpoint to start backup jobs. Logging options Use this option To do this --log-level quiet error --log-policy block raise --exception-limit max Set the maximum number of backend failures before the node should raise an exception. --exception-wait seconds Set the time to wait in seconds after an backend failure has occurred. --exit-timeout seconds Set the timeout for flushing the log message queue on exit. -c, --color color Specify whether to use ANSI terminal colors in the log output. --log-format format Specify the format to use for writing logs to the specified log output location. The log format can be or . --log-handle location Specify where the logs are written. Valid location are , , , or . --enable-telemetry-logger Enable the telemetry logger. --disable-telemetry-logger Disable the telemetry logger. -c, --telemetry-color color Specify whether to use ANSI terminal colors in the output. --telemetry-log-format format Specify the format to use for writing telemetry logs to the specified log output location. The log format can be or . --telemetry-log-handle location Specify where the logs are written. Valid location are , , , or . --cluster-id label Specify a label to add to all log messages from this node. --log-filter-rule KEY:VALUE:LOGLEVEL[:RATE] Define a log filter rule. Log messages that match the filter rule are discarded if they don't meet the log level threshold you specify. --log-filter-default LOGLEVEL:RATE Define a default log filter. This filter is applied to all messages that don't match any other log filter rule. --queue-size max Set the maximum size of the internal logger queue.",
    "source": "reference/chainweb-cli.md",
    "title": "chainweb-cli"
  },
  {
    "content": "title: Chainweb bootstrap nodes id: bootstrap description: \"Kadena test and production networks rely on bootstrap nodes to establish peer-to-peer communication.\" sidebar_position: 16 Chainweb bootstrap nodes When you start on a computer, the program attempts to connect to one or more bootstrap nodes to discover other nodes in the peer-to-peer network. For the connection to succeed, at least one of the bootstrap nodes must be trusted. You can configure Chainweb to connect to specific bootstrap nodes by using the command-line option or specifying the peer information in a Chainweb configuration file. You can also configure Chainweb to ignore the built-in bootstrap nodes by using the command-line option or by setting the configuration option. If you're a node operator and would like to have your Chainweb node included as a bootstrap node, keep in mind the following requirements: Bootstrap nodes must have a public DNS name and a corresponding TLS certificate that is issued by a widely-accepted Certificate Authority. At a minimum, the certificate must be accepted by the OpenSSL library. Bootstrap node operators are expected to guarantee reasonable uptime and long-term availability of the nodes. Bootstrap node operators are expected to monitor node and network health, maintain node operations, and perform timely software updates. To become a bootstrap node operator: Fork the chainweb-node repository. Add your node information to the chainweb-node/src/P2P/BootstrapNodes module. Create a pull request to have your change reviewed and approved. Testnet bootstrap nodes Currently, Kadena has the following bootstrap nodes running on port 443: us1.testnet.chainweb.com us2.testnet.chainweb.com eu1.testnet.chainweb.com eu2.testnet.chainweb.com ap1.testnet.chainweb.com ap2.testnet.chainweb.com Mainnet bootstrap nodes Currently, Kadena has the following bootstrap nodes running on port 443: us-e1.chainweb.com us-e2.chainweb.com us-e3.chainweb.com us-w1.chainweb.com us-w2.chainweb.com us-w3.chainweb.com jp1.chainweb.com jp2.chainweb.com jp3.chainweb.com fr1.chainweb.com fr2.chainweb.com fr3.chainweb.com",
    "source": "reference/bootstrap.md",
    "title": "bootstrap"
  },
  {
    "content": "title: Troubleshooting tips description: \"Tips for troubleshooting common issues when connecting to Chainweb nodes or calling Kadena API endpoints.\" id: troubleshooting toc_min_heading_level: 2 toc_max_heading_level: 3 Troubleshooting tips If you encounter errors, warnings, or Bad Request failures when you attempt to connect to a Chainweb nodes or call Kadena API endpoints, you should check for the following common issues and potential solutions. Common API issues It can be challenging to call REST API endpoints manually from the command-line because of all of the information you must include in the URL to reach a node that can respond to your request. The following are the most common causes of potential issues when you have problems calling Kadena API endpoints. Network and chain identifiers You should verify that you are using the correct network identifier and chain in the call. Most API endpoints require you to specify the network identifier, such as or , and a specific chain identifier in the request. If you specify testnet or mainnet or the wrong chain identifier, you'll receive a Bad Request or empty response instead of the information you expect. If you're submitting or checking the status of a transaction, be sure you've specified the correct chain identifier, and, if applicable, that there are sufficient funds to pay transaction fees on the network and chain you specify. Transaction formatting If you are using YAML files to format your transaction requests and encounter errors, check the YAML file for formatting or field name errors. There are slight differences in the fields expected and how they are defined in the YAML file depending on whether you are sending a signed transaction request with a public and secret key, an unsigned transaction request with a public key, or using a transaction template and the Kadena CLI to submit the transaction. For more information about transaction formatting, see the following topics: Transaction format and flow Construct transactions Sign and submit transactions Gas management Although default values for the gas limit and gas price might be appropriate for most situations, you should always check the settings and adjust them when necessary. For example, if you're deploying a complex contract, you might need to set a higher gas limit or gas price to ensure your transaction is processed. Nonce handling The nonce setting is optional in YAML request files and defaults to the transaction creation time, if not set. However, it's a best practice to include a unique nonce to prevent duplicate transactions. Error handling If you don't get the results you expect from an API request, you should always check the response for any additional information about the errors encountered. Security If an API request fails, you should check the keys you used to sign the transaction request and verify you are using the correct keys and accounts for the network and chain you connect to. Most Chainweb service API requests don't require a secure (HTTPS) connection. However, private keys are used to sign requests, so in most cases you should use a secure connection when calling API endpoints. For more information about calling specific endpoints and their parameters, see the API documentation. Common Pact contract issues In most cases, Pact error messages provide the information you need to resolve coding issues such as invalid syntax or formatting errors. However, there a few common errors that can be more difficult to diagnose and resolve. The following are the most common errors that you might encounter when executing functions defined in Pact contracts. Contract-specific errors If you see an error message that isn't a Pact interpreter error, you should copy the message and search in the smart contract you are executing for a matching message. It's likely that the function definition includes an statement that contains the message and the error indicates that you haven't met all of the conditions that the statement defines. Not enough input parsing error One of the most common Pact parsing errors you might see is a signing error that's similar to the following: This error typically indicates that you've forgotten to add the namespace of a capability that you tried to sign for. Even contracts that are deployed in the root namespace must include at least the module name before the capability name. For example, the capabilities defined in the contract require you to specify the module name before the capability name, such that to acquire the capability, you must sign for the capability. For most contracts, you must sign for capabilities using a registered namespace, like or or a principal namespace like , and the module name before the capability name. For example, if you define the capability in a module and deploy the module in the namespace, you would sign for the capability. Error: Keyset failure ... If you see a keyset failure, you should check for the following issues: Check whether you have signed the transaction using the required keyset. Check that you've met the conditions that are specified inb the keyset predicate. For example, if a keyset requires more that one key to sign the message, be sure you have signed with the required number of keys. Check that you have signed for all required capabilities. For example, if you have signed to a acquire a capability, check whether the function requires you to sign for additional capabilities by reviewing the statements to be sure that all capabilities are in scope. Capability not in scope If you attempt to access an account or row that is guarded by a capability defined outside of the scope of a function, executing the function might fail because the capability is not in scope. In this case, you might need to execute a different function that brings the capability into scope for the function you intended to execute. Common Chainweb node issues The most common issues you might encounter if you're a node operator or attempting to connect to a remote node are problems with peer synchronization, network interruptions, or node unavailability. The following are the most common causes of potential issues when you have problems connecting to Chainweb nodes. Out of date binaries Peer synchronization failures are often caused by nodes with out of date binaries or dependencies. For example, if a node attempts to synchronize with an outdate version of the library, peer synchronization will fail. To address this issue, you should make that any node you control is up to date with the most recent official release of the binary. Timeout exceptions If a synchronizing node fails to provide timely feedback to the network, other nodes will receive a timeout exception warning. Generally, the warning can be ignored and nodes can synch to alternative nodes. These exceptions can be fixed by issuing a statement. Something went wrong exceptions A \"Something went wrong\" error signals an internal server error due to misconfiguration. If you see this error, you should regenerate your current configuration file and post a message on the Kadena Discord server #infrastructure channel to make sure your node is configured correctly. To regenerate the configuration: Network communication issues Every Chainweb node maintains a list of peers. You can connect to the endpoint on any node to discover its list of peers. For example, to see a list of peers for a bootstrap node, you can run a command similar to the following: The command returns information about peer nodes similar to the following: Network configuration issues If you do not have incoming and outgoing ports configured correctly on your router, network traffic might be blocked, preventing access to the node, or the node might be offline. To see is a node is accessible, you can try pinging the node with a command similar to the following: You can also try sending a request to the /health-check endpoint for a node: A healthy node should return the following: If a node is down, try connecting to a different node.",
    "source": "guides/troubleshooting-tips.md",
    "title": "troubleshooting-tips"
  },
  {
    "content": "title: Develop with kadena-cli description: The library provides a complete set of commands for creating applications and interacting with the Kadena network interactively or by using scripts from the command-line. id: dev-kadena-cli Develop with kadena-cli The Kadena command-line interface () provides direct access to the Kadena blockchain and to commands that help you create, test, deploy, and manage applications for the Kadena network. You can use the Kadena command-line interface to perform tasks interactively or in scripts and automated workflows that don't allow interactive input. The Kadena CLI has one primary entry point—the parent command. By providing a single entry point for performing a wide range of tasks, the Kadena CLI integrates naturally into the typical development workflow. With commands designed specifically for building, testing, and managing Kadena-based applications, you can focus on building innovative applications using familiar tools. Before you begin Before you use the Kadena command-line interface, verify the following basic requirements: You have , version 18 or later, installed. Run to verify the version you are running. You have the package manager installed. Depending on your development environment, you can install pnpm using a standalone script or using a package manager. For example, you can run the command or to install pnpm on your local computer. For more information about installing pnpm on different operating systems, see Installation. Run to verify that you have pnpm installed and the version you are running. Install The Kadena CLI is packaged in a TypeScript library that you can install using a package manager such as or . To install globally using package manager, run the following command: To install globally using package manager, run the following command: To verify the package is installed and display usage information, type and press Return: To see the version of the package you have installed, run the following command: Get started The package is designed to streamline the development workflow with commands that provide direct access to everything you need to build on and interact with Kadena networks. Whether you're doing local development, deploying an application on the test network, or managing your accounts and keys on the Kadena main network, you can use the commands to complete tasks without leaving your development environment. The following diagram provides an overview of the command-line interface: Prepare a development workspace You can use the entry point to run commands that help you set up a complete local development environment. You can use the command-line interface to generate random keys, create local wallets, add accounts, customize network connections, and construct and send transactions. After you prepare a development workspace, you can use CLI commands in combination with other tools—like Pact and Kadena client—to create, test, deploy, and manage decentralized applications for the Kadena network. Start with interactive prompting The package is designed to simplify setting up a development environment. Its intuitive commands prompt you for all of the information required to complete tasks, like creating accounts or managing keys. Responding to prompts interactively is typically the best approach when getting started, eliminating the need to look up or remember the arguments required for the action you want to perform. To start using the CLI in interactive Mode, you simply type kadena followed by a subject that describes the type of information you want to work with and a verb to describe what you want to do. You don't need to specify any additional arguments or options. For example, if you want to add a new wallet but aren't sure of all the required flags and arguments, you can start by entering the following command: The CLI then displays interactive prompts, asking for the information required to successfully complete the task at hand—in this example, adding the wallet to your local development environment. As you gain experience, you can reduce interactive prompting by specifying some or all of the arguments as part of the command. If you run any command without specifying all of its required parameters, the CLI prompts you to provide the missing information. Configure initial settings After installing the package, the first step for working with the Kadena command-line interface is to use to create a configuration folder to store information about your development environment and connecting to Kadena networks. Depending on where you want the configuration settings available for your projects to use, you can create the configuration folder in a working directory or in your home directory. By default, a Kadena configuration folder named is created in your current working directory. The settings in the folder are then available to projects within that directory. For example, if you run with as your current working folder, you can access the configuration settings from anywhere inside the project folder. Creating the configuration folder in a working directory enables you to have different configuration settings for different projects. If you want to use the same configuration settings from any folder on your computer, you can create a global configuration folder in your home directory by running the command. The command-line option adds the configuration folder to the folder in your home directory so that the settings are available globally on your computer. Configuration settings that are defined in a local working directory take precedence over configuration settings defined in the home directory. If you add more than one configuration folder to your development environment, you can use to see details about the development environment you have configured in your working or global directory. To configure initial settings: Open a terminal shell on the computer where you've installed the package. Enter on the command line to create the configuration folder interactively: This command creates the configuration folder location in your current working directory and adds default network settings to a subfolder, then prompts you to create a wallet. For example: If you already have keys and an account or an existing wallet that you want to use, you can select No to end the interactive session. However, wallets are an important part of interacting with any blockchain, so you can create one now as part of your initial configuration steps. Select Yes and press Return to continue setting up your local development environment. Enter a wallet name and press Return. For example: Enter and confirm a password for the wallet to generate a public and secret key pair. For example: After entering the password, you are prompted to create an account using the wallet key generated for your first wallet. For example: Select Yes to continue setting up your local development environment with a local account. Enter an alias for the local account and press Return. For example: The command automatically creates a local Kadena principal account and displays information about your account and wallet. For example: Be sure to copy and store the mnemonic phrase in a safe place. This 12-word secret phrase is required if you ever need to recover your wallet. You now have a public key that you can use to sign transactions and authorize certain activity. In this example, the public key for the wallet is 61cf22aa8f209b1a5549242601b4a217f034e3d931b6522ccb7743bf6c355546. You also have the principal account associated with the key. In this example, the principal account name is k:61cf22aa8f209b1a5549242601b4a217f034e3d931b6522ccb7743bf6c355546. For more information about accounts names, keys, and principal accounts, see Accounts, keys, and principals. View wallet and account information At this point, you have one public and secret key pair, a local wallet, and a local account. However, this information isn't associated with a specific network—devnet, testnet, or mainnet—or with any chain identifier (0-19). Before you add the account to a specific network and chain, you might want to verify the information you have defined so far to understand the current state of your development environment. View wallet information To view information about the wallet: Open a terminal shell on the computer where you've installed the package. Enter on the command line to list wallet information interactively: This command prompts you to select a wallet. For example: Select All Wallets, then press Return. If you have only one wallet, you should see output similar to the following: View account information To view information about the account: Open a terminal shell on the computer where you've installed the package. Enter on the command line to list account information interactively: This command prompts you to select an account. For example: Select All accounts, then press Return. If you have only one account, you should see output similar to the following: Note that the account name k:61cf22aa8f209b1a5549242601b4a217f034e3d931b6522ccb7743bf6c355546, shortened to k:61cf22aa8f20....7743bf6c355546, uses the default keys-all predicate and the fungible for the account is coin. The keys-all predicate is a guard. Guards define the condition that must be satisfied for an operation to proceed. In this case, all public keys associated with the k:61cf22aa8f209b1a5549242601b4a217f034e3d931b6522ccb7743bf6c355546 account must sign transactions. The first wallet and default account information provide you with the basics for signing transactions: a public key, an account name, and a predicate. However, there aren't many practical applications that involve signing transactions using a local account. Before you can use an account to send and receive funds and sign the most common types of transactions, it must exist on a network and have funds on one or more chains. Fund your first onchain account To create an account on the Kadena main network, you need to either have KDA already or know someone who can transfer funds to your account for you. However, for local development or development on the Kadena test network, you can fund your account using commands, a faucet application, or publicly available private keys. If you created a local wallet and an account using the wallet key, you can use that information to add your account to the development or test network on one or more chains. To fund an onchain account: Open a terminal shell on the computer where you've installed the package. Enter on the command line to fund an account interactively: Select the account alias you used for your first account. For example: Enter an amount, then press Return. For example: You can request up to 20 coins per network. If you select more than one chain in the request, the coins are distributed equally over the chain identifiers you specify. For example, if you request 20 coins for the development network and chains 0-3, each chain receives five coins. Select a network, then press Return. For example, enter devnet to make this account available on the local development network: Select one or more chain identifiers, then press Return. For example, enter all: If prompted to deploy the faucet module on the network, select Yes. For example: If you selected all chains and are deploying the faucet module, you should see output similar to the following: Verify account information for the account for a subset of by chains. For example, to see account details for chains 1, 2, and 3 formatted as JSON output, you can specify command-line options similar to the following: This command displays output similar to the following: You now have one account on the development network with the same account name and public key on twenty development chains. The account on each chain has a balance of two KDA coins. To make this development environment more interesting—and learn about additional CLI commands—you can create additional accounts on the development network or the test network. Add another account There are several ways you can create additional accounts for testing in your local development environment. For example, you can: Add another wallet with a completely new public and secret key pair (kadena wallet add). Generate new random keys for a completely independent account (kadena key generate). Import keys from a wallet you've previously created for a new account (kadena wallet import). Add new keys from your first wallet to create a new account (kadena account add). The following example illustrates how to use to create a new local account. To add a new local account: Open a terminal shell on the computer where you've installed the package. Enter on the command line to fund an account interactively: You are prompted to select the method for providing the public keys for the new account. Because you already have a wallet, you can add a new account based on the public key and secret key pair generated for that wallet. If you have other keys you want to use, you can also add accounts by manually providing them. However, to keep things simple, use your first wallet. Use the arrow keys to select Wallet, then press Return. For example: Select the wallet alias you set for the first wallet, then press Return. For example: Enter a new alias for this account, then press Return. Because you're adding a new account for this wallet, you must give it a new alias. For example: Enter the name of a fungible for the account, then press Return. You can specify coin or nft as the fungible for an account. For most accounts, the default—coin—is appropriate. You can press Return to accept the default. Select the public keys that should be used for the account. You can select Generate new public key to generate a new random public key from the original wallet key pair. This key can be recovered using the same 12-word secret phrase you saved for your first wallet. For example: Enter the wallet password, then press Return. Select a keyset predicate for the account, then press Return. If this account is only going to have one owner and one public key, select the default keys-all predicate. If an account has more than one owner and public key, select an appropriate predicate. After you select the predicate and press Return, the account information is displayed in a confirmation message similar to the following: You now have one onchain account and one local account. View updated account information After you've added a second account, you might want to check your updated information with a simple command-line option instead of interactive prompting. To verify your updated account information: Open a terminal shell in your working or home directory. Verify the information for all accounts by running the following command: The command now displays information for two account similar to the following: Format command output In some cases, you might want to format the output from a command, so it can be used as input to another command or easier to parse. You can use the or flag to convert the output from virtually any CLI command to JSON or YAML format. To format the output using JSON: Open a terminal shell in your working or home directory. Add the flag to the command line. For example: With the flag, the command displays account information in JSON format similar to the following: Add a simple transaction You must have an onchain account to sign and submit transactions that transfer funds. However, you can use local accounts for transactions that read information from the blockchain or that execute commands with local calls. The following example illustrates how to create and execute a simple transaction using a transaction template and a local account. Create a transaction template To create a transaction template: Open a terminal shell in your working or home directory.. Create a YAML API request file to execute a simple command similar to the following: This transaction uses template variables to construct a transaction. You can learn more about transaction templates and variables in Construct a transaction. For more information about using YAML request files for transactions, see Formatting API requests in YAML. Save the file as a transaction template by giving it a name with the file extension and moving the file to the folder. For example, save the file as in your working directory. Create the transaction To create a transaction from the template: Create a transaction from the template by running the following command: Select the transaction template you created, then press Return. For example: Press Return to skip using a data file. Specify any chain identifier, then press Return. Select your local account alias as the transaction sender, then press Return. For example: Select the network for the transaction, then press Return. Type a name for the transaction request JSON file, then press Return. In this example, the transaction request is named . After you press Return the command displays the JSON object, the location of the file, and the command executed to create the transaction. For example: Test the transaction To test the transaction: Submit the transaction on the local endpoint by running the following command: Select the transaction you created from the template, then press Return. For example: After you press Return, you should see output similar to the following: Set a default network Many commands require you to specify the network you want to work with. You can streamline command execution by setting a default network. For example, if you are just getting started, you might want to set the default network to to save time as you iterate on your application. Later, you might want to unset the default, so you can specify the network to use on a command-by-command basis. As your application matures, you might want change the default network from to so you can deploy updates for broader testing. To set the default network: Open a terminal shell on the computer where you've installed the package. Enter on the command line to set the default network interactively: Because you're running the command interactively, you are prompted to select a network. For example: Use the up and down arrow keys to select the network you want to use as your default network, then press Return. For example, select devnet, then press Return. Select Yes to confirm your default network, then press Return. The command displays confirmation of your default network. For example: After settings default network, you won't be prompting to select a network when running other commands. If you want to remove the default network from your configuration, run the following command: The command displays confirmation of your change. For example: Run commands in automated scripts For most commands, responding to interactive prompts and confirmation messages helps to ensure that you provide all of the information necessary to successfully execute each command. However, if you want to disable all interactive prompts and confirmation messages, you can use the flag. The flag enables you to run commands in environments where interactive input is impractical, such as automated test suites and continuous integration (CI) pipelines. If you include the flag in a command, the command suppresses all interactive prompts and skips all confirmation messages, so that each command can run uninterrupted without human intervention. Running commands using the flag ensures that automated processes can run smoothly and efficiently, without manual input. If you use the flag for a command, you must include all required arguments in the command line. Create a project You can use the command to create a new project directory for the decentralized application you want to build. This command allows you to create an empty project directory or to create a new project from one of the frontend framework templates that are currently supported. You can create the new project using templates for the following frontend frameworks: Angular Nextjs Vuejs To create a new project from a template: Open a terminal shell on the computer where you've installed the package. Enter on the command line to create a new project directory with the name you specify. For example, to create a project names my-to-do: Because you're running the command interactively, you are prompted to select a template. For example: Use the up and down arrow keys to select the template to use for your project, then press Return. If you are missing required dependencies for the template you select, you are prompted to install them. Confirm that you want to install missing dependencies. Change to your project directory by running a command similar to the following: If you explore the project directory, you'll see it contains the appropriate template files and folders for the framework you selected plus a folder with some starter code for a Pact module () and for testing the Pact module in the Pact REPL (). Next steps Learn more about the Kadena command-line interface and the actions you can perform using CLI commands in the Command-line reference section. To get started with building a smart contract backend for your application, see the sample modules in Coding projects. For information about using the Kadena client libraries and packages, see Kadena client.",
    "source": "guides/dev-with-cli.md",
    "title": "dev-with-cli"
  },
  {
    "content": "title: Common task quick reference description: \"Quick reference for common tasks\" id: howto-quick-ref import Tabs from '@theme/Tabs'; import TabItem from '@theme/TabItem'; import CodeBlock from '@theme/CodeBlock'; Common task quick reference This guide provides a quick reference for the most common API calls: Check account balances Transfer coins Deploy smart contracts Regardless of the method you choose, each task requires you to connect to an appropriate network endpoint with a payload in the expected format. The payload contains all of the information required to complete the task. The difference between using the API directly or the abstraction provided by the Kadena CLI or Kadena.js libraries is simply in how you deliver the request. Check account balances <Tabs> <TabItem value=\"api\" label=\"API\" default> Call the function with the account name string as an argument using and a JSON object. For principal accounts, the account name starts with a prefix. For example, the prefix for single key accounts or the prefix for accounts with multiple keys. </TabItem> <TabItem value=\"cli\" label=\"Kadena CLI\"> The package provides commands to perform many common operations like viewing balances. You can also use to construct transactions using YAML request files. kadena account details --account=\"k-bbccc9\" --network=\"devnet\" --chain-ids=\"all\" ``` </TabItem> <TabItem value=\"js\" label=\"Kadena.js\"> Use the package to create Pact transactions and client connections. </TabItem> </Tabs> Transfer coins <Tabs> <TabItem value=\"api\" label=\"API\" default> Call the function with the sender, receiver, and amount as arguments using and a JSON object. Create an unsigned transaction using the template and the data file, and save the transaction to a file: Sign the transaction created with a wallet or key pair: Send the signed transaction file to the blockchain: </TabItem> <TabItem value=\"js\" label=\"Kadena.js\"> You can use the package to create Pact transactions and client connections. </TabItem> </Tabs> Deploy smart contracts <Tabs> <TabItem value=\"api\" label=\"API\" default> Connect to the Pact API endpoint to submit a transaction that deploys a smart contract. </TabItem> <TabItem value=\"cli\" label=\"Kadena CLI\"> You can use and YAML configuration files or templates to deploy contracts with commands. Create a YAML configuration for deploying a smart contract. Create a new unsigned transaction: Sign the unsigned transaction: Send the signed transaction to the network: </TabItem> <TabItem value=\"js\" label=\"Kadena.js\"> You can use the package to create Pact transactions and client connections to deploy a contract. </TabItem> </Tabs>",
    "source": "guides/common-tasks-tabs.md",
    "title": "common-tasks-tabs"
  },
  {
    "content": "title: Develop with Chainweaver id: chainweaver sidebar_position: 4 description: \"Install the Pact smart contract programming language and set up tooling for your development environment.\" Develop with Chainweaver Chainweaver integrates the management of wallets, accounts, and keys with signing and editing features that you can use as you develop smart contracts using the Pact programming language. With Chainweaver, you can build, test, and iterate on your smart contracts before deploying them to your local development network, the Kadena test network, or the Kadena main network. Chainweaver includes a built-in read-eval-print-loop (REPL) interactive interpreter that enables you to write and execute Pact code in the desktop or web-based application. You can also use Chainweaver to: Explore smart contract modules and functions. Define and manage authorization rules in keysets. Deploy smart contracts on a network. Update previously-deployed contracts. If you don't already have a Chainweaver account, you should create one using either the Chainweaver desktop application or the Chainweaver web application. After you download and install the desktop application or open Chainweaver in a browser, you can create a wallet and accounts to interact with Kadena networks. When you open and unlock Chainweaver, the navigation panel on the left is collapsed to only display icons by default. The navigation panel provides access to the tools for managing your accounts, keys, and development environment. Icon Section What you can do here Accounts View and manage your accounts, add account names to your watch list, transfer funds between accounts and across chains, and view transaction status. Keys Generate, view, and manage public keys associated with your secret key. Signature Builder Construct the signatures needed to sign transactions. Contracts Access a code editor and development tools for writing, testing, and deploying Pact modules and smart contracts. Resources Explore documentation and Chainweaver resources. Settings Configure your network and account settings. Log out Log out of the current session. For more information about using Chainweaver as your primary interface for development tasks, see Develop with Chainweaver. Connect to the development network By default, Chainweaver lets you connect to the Kadena test network and the Kadena main network. However, as you start writing Pact modules, you'll want to test and deploy them on your local development network. Before you can do that, you need to configure Chainweaver to connect to the local host and port number running the development network. To connect to the development network: Click Settings in the Chainweaver navigation panel. Click Network. In Edit Networks, type a network name, then click Create. Expand the new network, then add the localhost as a node for this network by typing . If the local computer is still running the development network Docker container, you should see the dot next to the node turn green. Click Ok to close the network settings. Navigate smart contracts After you connect Chainweaver to the development network, you can use Chainweaver to deploy and manage the smart contracts you develop. You can access the Chainweaver development environment by clicking Contracts in the navigation panel. After you click Contracts, Chainweaver displays common tasks and two working areas: The left side displays a sample contract in a code editor that you can use to view and edit contract code. The right side provides controls that enable you to navigate between contracts, view contract details, manage keys, and test operations for contracts you have deployed. The common tasks enable you to: Browse to an open a file from the file system. Load your contract into the Pact interactive REPL where you can run Pact commands. Deploy the selected contract on the active blockchain network. You'll use Load into REPL and Deploy frequently as you start writing Pact modules and deploy modules on the local development network. Code editor Within the Contracts development environment, the code editor enables you to view and modify contract code using a familiar editing interface. It's similar to other code editors with support for copying and pasting text, syntax highlighting, and inline error reporting. You can hover the cursor over lines that indicate errors to view information about the problem to help you determine how to fix it. The Chainweaver code editor also supports formal verification. Formal verification is a process that enables you to automatically test the correctness of your code for potential errors and security vulnerabilities. With this process, you can mathematically prove that your contract has no security vulnerabilities, ensuring you can create secure code quickly and effectively. For more information about how formal verification helps you develop safer smart contracts, see Pact Formal Verification: Making Blockchain Smart Contracts Safer. Contract navigation and developer tools The right side of the Contracts development environment provides many useful features and tools for developing smart contracts. For example, there are features to help you set up your environment, run commands in the interactive REPL, read messages, and explore other modules that exist on the network. Env Select Env to view and fix errors or manage authorization data in keysets. If the error and warning detected can be fixed automatically, you'll see the Fix option. In this example, the error is a missing keyset and you can click Fix to automatically create the keyset and add it to the Data section. If you delete the keyset created for you, you can use the Data section to create a keyset by typing a keyset name, then clicking Create. By default, keysets require all of the keys associated with an account to sign transactions, so you'll see keys-all selected for the new keyset. You can also create keysets manually using the JSON format by clicking Raw, then defining the keyset name, keys, and pred values. You can see the JSON format for keysets you have created by clicking Result. The field specifies a function to use for the keyset. The function returns a boolean value evaluating to true or false. In this case, the predicate option evaluated is keys-all and it returns true if all of the keys listed in the keyset—in this example, only one key—sign the transaction. REPL A great way to get started with Pact is by writing some simple code for yourself. The REPL enables you to run Pact commands directly in the browser. Select REPL to open the Pact interactive interpreter, then try running the following commands to start learning Pact syntax conventions. Numbers Pact uses prefix notation for math operators. With prefix notation, the operator precedes the values it’s operating on. For example, you can add two numbers with the following command: To subtract two numbers: To multiply two numbers: Strings You can concatenate strings using a plus (+) as a prefix. For example, you can concatenate the strings \"Hello\" and \"REPL\" with the following command: Lists You can specify lists using square brackets () with or without commas. For example, you can specify the elements in a list without using commas: To specify the elements in a list using commas: Objects You can create objects using curly braces () with key-value pairs separated by a colon (). For example: You can view more commands to try in Syntax and keywords and Pact functions. Run commands in the code editor You can also run commands in the code editor. To run commands in the code editor, delete existing code from the code editor type a command, then click Load into REPL. Messages Code editors often provide messages to help you identify errors and log outputs. These messages are useful for debugging programs and fixing potential issues with your contract. Select Messages to view messages from the code editor in Chainweaver. Module Explorer Select Module Explorer to open and view sample smart contracts, search for and view deployed contracts, and call functions from any contract that exists on the active network. Under Examples, you can click Open next to an example contract name to load the contract into the code editor. You can modify the code in the editor and reload the original contract code at any time, if needed. Click View to explore the Pact modules in a contract. For example, if you select the Simple Payment contract, then click View for the payments modules, you'll see the functions and capabilities defined in the payments module. Under Deployed Contracts, you san search for any contract that has been deployed to the network using the Module Explorer by name, by chain, or by navigating the pages using the arrow buttons. After you select a deployed contract, you can click View to see details about what's defined in the contract, including implemented interfaces, functions, capabilities, and pact included in the contract. You can click Open to see the full contract code in the code editor. You can also call individual functions from within the Module Explorer. You'll learn more about navigating modules and calling functions in coding projects.",
    "source": "guides/chainweaver.md",
    "title": "chainweaver"
  },
  {
    "content": "title: Simple payments description: \"Build a simple contract that transfers value between two accounts, one of the most common and most important operations that smart contracts are use to perform.\" id: transfers sidebar_position: 3 Simple payments The Simple payments project is designed to help you build a simple contract that transfers value between two accounts. Because a blockchain acts as a digital ledger, transferring value between accounts is one of the most common blockchain operations. Knowing how to create a smart contract that can securely transfer assets is one of the most important building blocks that will enable you to create more complex applications. For this project, you'll create one Pact module smart contract that consists of three functions: These functions store information in a database table. The manages payments between two test accounts named and . Before you begin Before starting this project, verify your environment meets the following basic requirements: You have a GitHub account and can run commands. You have installed the Pact programming language and command-line interpreter. You have installed the package and have a working directory with initial configuration settings. You have a local development node that you can connect to that runs the program, either in a Docker container or on a physical or virtual computer. You should be familiar with defining modules and using keysets. Get the starter code To get started: Open a terminal shell on your computer. Clone the repository by running the following command: Change to the directory by running the following command: If you list the contents of this directory, you'll see the following files: provides a starting point with the framework for the project code and comments for every challenge. contains the final solution code that can be deployed. provides a simplified example of a test file that illustrates using REPL-only functions for testing contracts locally. provides a complete test file for testing the final contract. Open and review the file. This file describes all of the tasks that you need to complete for the Simple payments coding project. You can follow the instructions embedded in the file to try to tackle this coding project on your own without looking at the solutions to each step, or follow the instructions in the next sections if you need additional guidance. Define a module and module owner The module declaration is a core part of any Pact smart contract. To define a module, you must also specify the administrative keyset or governance capability that owns the module. For this coding project, you need to define one module—the module—and the administrative keyset for the module. To start the module declaration: Open the file in your code editor and save it as . Define and read an administrative keyset with the name to own the module. In essence, this line creates an administrative keyset using the keyset name of that will have one or more public keys and a predicate function read from a message or as environment data. The data that needs to be passed into the environment looks similar to the following: Note that you can use the standard string notation with double quotation marks or symbol notation with a single quotation mark ('admin-keyset) for identifiers. For more information about string literals used as identifiers, see Symbols. Create a module named that is governed by the . Save your changes. Now that you have a module, you need to add the code for this module inside of the declaration—that is, before the closing parenthesis that marks the end of the module declaration. For more information about defining modules, see Modules and references and the description of the module keyword. Define a schema and table The modules stores information about accounts and balances in the database table. This table keeps track of the balance of the accounts that are associated with the and account keysets. The schema for the looks like this: Field name Field type balance decimal keyset guard To define the schema and table: Open the modified file in your code editor. Define a schema for a table with the columns as type decimal and as type guard. It's worth noting that the row key for the table isn't defined in the schema for the table. Define the to use the schema you created in the previous step. Move the closing parenthesis that marks the end of the module declaration after the table definition to include the schema and table definitions inside of the module. Without comments, your code should look similar to the following: Save your changes. You now have a schema and table definition inside of the declaration. For more information about defining schemas and tables, see Database model. Define functions For this coding project, the module provides three functions: to allow the module administrator to create accounts. to allow the module administrator and account owner to view account balances. to allow one account to pay another account. Define the create-account function The function allows the module administrator—identified by the keyset—to create any number of accounts. To define the function: Open the modified file in your code editor. Start the function definition with the keyword and add the parameters , , and . Within the function, use to ensure that all accounts are created by the administrator. Within the function, use to ensure the is greater than or equal to zero and include an optional documentation string. Within the function, insert the and into the using the parameter to set the key-row value. Check that the closing parenthesis for the function is after the last expression and move the closing parenthesis for the module declaration after the function. Without comments, your code should look similar to the following: Define the get-balance function Now that you can create accounts, it is helpful to be able to view the balance of these accounts. The function allows account owners and the module administrator to view account balances. To define the function: Start the function definition with the keyword and the required argument to be the key-row value. Within the function, use to view the from the . Within the function, use to check that the keyset calling the function is either the or the keyset. Within the function, return the for the specified keyset. Check that the closing parenthesis for the function is after the last expression and move the closing parenthesis for the module declaration after the function. Without comments, your code should look similar to the following: Define the pay function The function allows one account to transfer assets to another account defined in the . To define the function: Start the function definition with the keyword and specify the parameters as , , and . Within the function, use to view the for the account and bind the and of this account to the and variables. Within the function, enforce that the is the keyset of the account. Within the function, use to get the balance of the account, and bind this balance to the variable. Within the function, enforce that the amount being transferred is greater than zero or return an error message. Within the function, enforce that for the account is greater than what is being transferred or return an error message. Within the function, update the to reflect the new balance for the account. Within the function, update the to reflect the new balance for the account. Within the function, return a formatted string to say that the account has paid the account and the paid. Check that the closing parenthesis for the function is after the last expression and move the closing parenthesis for the module declaration after the function. Without comments, your code should look similar to the following: Save your changes. The function is the last code that you need to include within the module. Create the table Although you defined a schema and a table inside of the module, tables are created outside of the module code. This distinction between what you define inside of the module and outside of the module is important because the module acts as a guard to protect access to database functions and records. This separation also allows module code to be potentially updated without replacing the table in Pact state. To create the table: Open the modified file in your code editor. Locate the closing parenthesis for the module. Create the table using the keyword. Create a file for local testing At this point, you have completed all of the essential code for the contract. However, you can't test or deploy the code in its current state. Because keysets are defined outside of contract code, the most common way to test a module locally is to create a test file that makes use of REPL-only built-in functions to simulate data that must be provided by the environment, like keysets and signatures. In this part of the project, you'll see how to create a test file—the file—to call REPL-only functions and test the functions you've defined in the module. To create the test file: Copy the file and rename the file as . Open the file in your code editor. Add the built-in function to set environment data to simulate keyset information. Add a transaction using the and functions to define a namespace for your module. Namespaces are required to define a context for modules when they are deployed on a network. For local testing, you must define a namespace before you can define a keyset. Keysets must be defined inside of a namespace. Add a signature using the function for signing transactions to your environment. Add a transaction to define a keyset inside of the namespace. This example uses the built-in function to test the assertion that the keyset can be defined. Add the function before the module declaration and modify the governing entity to be the defined in this namespace. Scroll to the bottom of the file and add the closing function. Save your changes. Open a terminal shell on your computer and test execution by running the following command: You should see output similar to the following: This sample test file only covers the most minimal steps for testing your module locally. For a more complete set of tests for the contract, including function calls, see the file. Deploy the contract After testing the contract using the Pact interpreter and the REPL file, you can deploy the contract on your local development network or the Kadena test network. Note that you can only define namespaces in the local development environment. You must deploy to an existing namespace—such as the namespace—or register a principal namespace to deploy on the Kadena test network or on a public production network. To deploy in an existing namespace, you must also ensure that your module name and keyset name are unique across all of the modules that exist in that namespace. For this coding project, you can deploy the contract using the Chainweaver desktop or web-based application and its integrated development environment. Prepare to deploy Because you're going to deploy the contract on the Kadena test network, you can update the contract code to use the namespace, a unique keyset name, and a unique module name before you deploy the contract. To prepare to deploy on the Kadena test network: Open the contract you want to deploy in your code editor. For example, open the file in your code editor. Add the namespace before the module definition, define an administrative keyset inside of the namespace, and update the module name and governing keyset. For example: Update the other references to the to use the keyset you are defining for the namespace. For example, update the lines in the and functions: Save the changes in the code editor. Load the module using Chainweaver Because you must define the keyset keys and predicate function for your contract in the environment outside of the contract code, the Chainweaver integrated development environment provides the most convenient way to add the required keysets. To load the contract using Chainweaver: Open and unlock the Chainweaver desktop and web-based application, then select the testnet network. Click Accounts in the Chainweaver navigation pane and verify that you have at least one account with funds on at least one chain in the test network. If you don't have keys and at least one account on any chain on the test network, you need to generate keys, create an account, and fund the account on at least one chain before continuing. You'll use the public key for this account and the chain where you have funds in the account to deploy the contract and identify the contract owner. Click Contracts in the Chainweaver navigation pane, then click Open File to select the contract that you want to deploy. After you select the contract and click Open, the contract is displayed in the editor panel on the left with contract navigation on the right. You'll also notice that the line where you define the keyset indicates an error, and the error message is because your administrative keyset doesn't exist in the environment. Under Data on the Keysets tab, type the name of your administrative keyset, click Create, then select the public key and predicate function for the administrative keyset. You'll see that adding the keyset dismisses the error message. Click Load into REPL to load the contract into the interactive Pact interpreter for testing its functions. You should see the following message: Click the ENV tab to add keysets for the test accounts Sarah and James. Type , click Create, then select a public key and predicate function for the Sarah account keyset. Type , click Create, then select a public key and predicate function for the James account keyset. Click the REPL tab to return to the loaded module to test its functions: Call the function to create test accounts in your uniquely-named module in the namespace. For example, to create the accounts for Sarah and James: Call the function to pay 25.0 from Sarah to James: Call the function as Sarah and James: Deploy using Chainweaver Now that you've tested that the contract functions work as expected, you can use Chainweaver to deploy the contract on the test network in the namespace. To deploy the contract using Chainweaver: Click Deploy to display the Configuration tab. On the Configuration tab, update General and Advanced settings like this: Select the Chain identifier for the chain where you want to deploy the contract. Select a Transaction Sender. Click Advanced and add the namespace keyset to the environment. Because this transaction includes multiple keysets for the administrative and test accounts, select the administrative public key and the predicate function. Click Next. On the Sign tab, select the public key for the administrative keyset as an Unrestricted Signing Key, then click Next. On the Preview tab, scroll to see the Raw Response is \"TableCreated\", then click Submit to deploy the contract. View the deployed module After you deploy a contract, you can view its details and call its functions using Chainweaver. To view and call your contract: Click Contracts in the Chainweaver navigation pane, then click Module Explorer. Under Deployed Contracts, search for your module name in the free namespace and chain where you deployed, then click Refresh to update the list of deployed contracts to display only your just-deployed contract. In this example, the unique module name is free.pistolas-simple-payment and the contract was deployed on the testnet chain 1. Click View to display the functions and capabilities defined in your contract. Click Call for the create-account function to display the function parameters. On the Parameters tab, set the parameters like this, then click Next: For id, type \"ben\" in quotes. For initial-balance, type 4.0. For keyset, type (read-keyset \"ben-keyset\"). On the Configuration tab, review and update the General settings, then click Advanced. Under Data and Keysets, type , then click Create. Select a public key and predicate, then click Next. On the Sign tab, select the public key for the contract owner you used to deploy the contract as an Unrestricted Signing Key , then click Next. On the Preview tab, scroll to see the Raw Response is \"Write succeeded\" for function. You can click Submit if you want to submit the transaction to the blockchain or close the function call without submitting the transaction. Next steps Congratulations, you've just completed the Simple payments coding project. You'll see similar patterns in other coding projects, with each project introducing new features, Pact syntax, or alternative coding models. The coding projects are also intended to complement and reinforce concepts and examples presented in other parts of the documentation. Follow the links embedded in each project to learn more.",
    "source": "coding-projects/simple-payments.md",
    "title": "simple-payments"
  },
  {
    "content": "title: Rotate authorized keys description: \"Develop a smart contract that allows users to change their account name and rotate authorized keys.\" id: rotate-auth sidebar_position: 5 Rotate authorized keys The Rotate authorized keys coding project demonstrates how to create a smart contract with rotatable authorization keys and how to enforce row level permissions. This project continues to build on concepts and challenges presented in other coding projects and covered in Smart contracts topics. Specifically, this project demonstrates the following: How you can use keysets as row level guards for assets. How to allow users to update information in tables based on their keyset. How to change ownership by rotating keyset values to authorize a new owner. To implement these features, you'll create an module with four functions, one table, and two keysets: Before you begin Before starting this project, verify your environment meets the following basic requirements: You have a GitHub account and can run commands. You have installed the Pact programming language and command-line interpreter. You have installed the package and have a working directory with initial configuration settings. You have a local development node that you can connect to that runs the program, either in a Docker container or on a physical or virtual computer. You should be familiar with defining modules and using keysets. Get the starter code To get started: Open a terminal shell on your computer. Clone the repository by running the following command: Change to the directory by running the following command: If you list the contents of this directory, you'll see the following files: provides a starting point with the framework for the project code and comments for every challenge. contains the final solution code that can be deployed. provides a complete test file for testing the final contract. Open and review the file. This file describes all of the tasks that you need to complete for the Rotate wallet keys coding project. You can follow the instructions embedded in the file to try to tackle this coding project on your own without looking at the solutions to each step, or follow the instructions in the next sections if you need additional guidance. Define the module keysets As you might have seen in other coding projects, modules are defined in a namespace and are governed by either an administrative keyset or a governance capability. Like namespaces, keysets are also defined outside of module code and passed into the module through the namespace from message data that is outside of the module code. This coding project requires two keysets: The module-admin keyset allows authorized users to define and update modules. The operate-admin keyset allows authorized users to create user accounts. To define the module keysets: Open the file in your code editor and save it as . Enter the namespace as the workspace for the keysets and module. You can define custom namespaces in the local development environment. The namespace is a public namespace that you can use to deploy smart contracts on the Kadena test network. Define and read the module administrative keyset with the name to own the module. Define and read the operator keyset with the name to control who can create new user accounts. Save your changes. For more information about defining and reading keysets, see define-keyset Define the module The next step is to create the module that will contain the logic for your smart contract. Create a module named that is governed by the keyset. Define the schema and table The modules stores information about user accounts in the database table. The schema for this table is named user with two columns: Field name Field type nickname string keyset guard To define the schema and table: Open the modified file in your code editor. Define a schema for a table with the columns with the type of and with the type of . Define the to use the schema you created in the previous step. Move the closing parenthesis that marks the end of the module declaration after the table definition to include the schema and table inside of the module. Without comments, your code should look similar to the following: For more information about creating schemas and tables, see the descriptions for the defschema and deftable keywords. Define functions For this coding project, the module provides the following functions: to allow users with the keyset to add rows to the user table. to restrict access permissions to users with a given id. to allow users with a specific keyset to update their nickname. to allow the owner of a keyset to change the keyset being used. These functions give users the ability to create and manage their own accounts. Define the create-user function The function specifies that only users with the keyset can add rows to the user table. To define the function: Open the modified file in your code editor. Start the function definition with the keyword and add the parameters , , and . Within the function, use to restrict access to this function, so that new users can only be created by the keyset. Within the function, insert a row into the with the specified and . Without comments, your code should look similar to the following: For more information, see the descriptions for the enforce-keyset and insert functions. Define the enforce-user-auth function It’s sometimes useful to restrict access to specific data for specific users. For example, you might want to prevent users from seeing account balances or other sensitive information that should be private. In Pact, you can restrict access to specific rows in a table by using row-level keysets. To define a row-level keyset, you must first be able to view the keyset associated with a specific key-row. The following example demonstrates reading a keyset for a specified key-row: The purpose of this function is only to identify the keyset associated with the specified key-row. This function doesn’t provide access to any of the data in the row. However, other functions can call this function if they want to act on the information, for example, to place row-level restrictions on the data. To define the function: Open the modified file in your code editor. Start the function definition that takes the parameter . Within the function, use to read the to find the specified , and bind the column for the to the variable, then return the value with the variable. Without comments, your code should look similar to the following: For more information, see the descriptions for the enforce-keyset and with-read functions. Define the change-nickname function After you define a function to restrict access to data, you can allow users to take specific actions based on the data they have access to. For example, users might want to update their profile name, or make changes to sensitive information that other users should not be able to access. To do that, you can write a function that calls the function to only allow users to update their own data. For example, the following function allows users to update existing information in the by leveraging the function: By calling the function, this function allows users with a specific keyset to make updates to restricted information. To define the function: Open the modified file in your code editor. Start the function definition that takes the parameters and . (defun change-nickname (id:string new-name:string) ) Within the function, call the function to update the column for the specified . Within the function, return a message to the user formatted as \"Updated name for user [id] to [name]\". Without comments, your code should look similar to the following: For more information, see the descriptions for the update and format functions. Define the rotate-keyset function Now that users can update their name, you can apply this same functionality to other information. For this coding project, you can allow users to update their authorized keyset. Being able to rotate the keyset is similar to being able to update your password. For single key keysets, this feature enables a user to replace a potentially compromised key. For keysets with multiple keys, this feature enables the set of owners or authorized signers to change when needed. To define the function: Open the modified file in your code editor. Start the function definition that takes the parameters and . (defun rotate-keyset (id:string new-keyset:string) ) Within the function, call the function to update the column to the for the specified . Within the function, return a message describing the update in the format \"Updated keyset for user [id]\". Without comments, your code should look similar to the following: For more information about updating a table, see Update. Create table Although you defined a schema and a tables inside of the module, tables are created outside of the module code. This distinction between what you define inside of the module and outside of the module is important because the module acts as a guard to protect access to database functions and records. This separation also allows module code to be potentially updated without replacing the table in Pact state. To create the table: Open the modified file in your code editor. Locate the closing parenthesis for the module. Create the table using the reserved keyword. The code for the Rotate authorized keys smart contract is now complete. From here, the next steps involve testing module functions, adding features, and deploying the contract in your local development environment or the Kadena public test network. Test the module using Chainweaver Because you must define the keyset keys and predicate for your contract in the environment outside of the contract code, the Chainweaver integrated development environment provides the most convenient way to add the required keysets and test contract functions in the public namespace on the Kadena test network. To load the contract using Chainweaver: Open and unlock the Chainweaver desktop and web-based application, then select the testnet network. Click Accounts in the Chainweaver navigation pane and verify that you have at least one account with funds on at least one chain in the test network. If you don't have keys and at least one account on any chain on the test network, you need to generate keys, create an account, and fund the account on at least one chain before continuing. You'll use the public key for this account and the chain where you have funds in the account to deploy the contract and identify the contract owner. Click Contracts in the Chainweaver navigation pane, then click Open File to select the contract that you want to deploy. After you select the contract and click Open, the contract is displayed in the editor panel on the left with contract navigation on the right. You'll also notice that the line where you define the keyset indicates an error, and the Env tab indicates that the error message is because your doesn't exist in the environment yet. In the Chainweaver integrated development environment, you can add keysets on the Env tab, under the Data section. Under Keysets, type the name of your administrative keyset—in this example, type as the keyset name—click Create, then select the public key and predicate function for the administrative keyset. You'll see that adding the keyset replaces the first error message with a second error message for the missing keyset. Add the name, key, and predicate function to the environment to dismiss the second error message. Click Load into REPL to load the contract into the interactive Pact interpreter for testing its functions. You should see the following message: Click the ENV tab to add a keyset for the test user account. Type , click Create, then select a public key and predicate function for the Sarah account keyset. Remove the keyset from the environment to test that the keyset can add users. Click the REPL tab to return to the loaded module to test its functions: Call the function to create the test user in the namespace. For example, to create the user: Remove the keyset from the environment to test that the keyset can change the user field. Call the function to change the field for the key-row, for example, to \"S. R. Fitzpatrick-Perez\": Read information from the for the key-row: Call the function for the key-row, then read the information from the : Deploy using Chainweaver After testing that the contract functions work as expected in the interactive REPL, you can use Chainweaver to deploy the contract on the test network in the namespace. To deploy in an existing namespace, you must also ensure that your module name and keyset name are unique across all of the modules that exist in that namespace. To deploy the contract using Chainweaver: Update the module name and keysets to make them unique in the namespace. For example: Click Deploy to display the Configuration tab. On the Configuration tab, update General and Advanced settings like this: Select the Chain identifier for the chain where you want to deploy the contract. Select the Transaction Sender. Click Advanced and add the updated keyset to the environment. Click Next. On the Sign tab, select the public key for the administrative keyset as an Unrestricted Signing Key, then click Next. On the Preview tab, scroll to see the Raw Response is \"TableCreated\", then click Submit to deploy the contract.",
    "source": "coding-projects/rotate-auth.md",
    "title": "rotate-auth"
  },
  {
    "content": "title: Pact built-in server description: \"This coding project demonstrates how to use the Pact built-in REST API endpoints for testing transactions on a local server.\" id: pact-server-api sidebar_position: 8 Pact built-in server The Pact built-in server coding project demonstrates how to use the Pact built-in REST API endpoints for testing transactions on a local server. This coding project focuses on how to: Create a YAML configuration file for the Pact built-in local server. Create YAML execution API requests to submit transactions. Format YAML execution requests as JSON objects. Submit YAML requests using the Pact REST API endpoints. By becoming familiar with how to perform these tasks, you'll be better prepared to develop a full stack application that combines a Pact smart contract backend with a Javascript-based frontend. Before you begin Before starting this project, verify your environment meets the following basic requirements: You have a GitHub account and can run commands. You have installed the Pact programming language and command-line interpreter. You have installed the package and have a working directory with initial configuration settings. You have a local development node that you can connect to that runs the program, either in a Docker container or on a physical or virtual computer. You should be familiar with defining modules and using keysets. Create a local working environment For this coding project, there's no starter code. Instead, you'll create a local working environment that includes the following: A local project directory. A local server configuration file. A sample transaction execution request using the YAML API request format. A directory for storing log files. Create a project folder To create a project folder: Open a terminal shell on your computer. Create a new directory named to hold the project files. Change the directory to make the folder your current working directory: Create a configuration file To create a server configuration file: Create a new file for the local server configuration settings: Open the file in your code editor and define the following configuration settings: You can also find the standard format for the Pact server configuration file in the Pact repository. The file provides the following fields to configure settings for the Pact built-in server: Use this field To do this Specify the port number for the local Pact HTTP server to use. In this example, the port number is specified and is used as the port in all of the examples in this project. You can change this setting if you want to use a different. If this port is available in your local environment, you can leave this setting as it is. Specify the directory for HTTP logs should be stored. This setting specifies a folder location relative to the current directory. Specify the directory for persistence data to be stored. This setting specifies a folder location relative to the current directory. Specify the SQLite pragmas commands to control environmental variables or state flags within the Pact SQLite database. Specify whether you want the Pact server to log output. You can set this field to to produce log files or false if don't want to produce log files. Save your changes and close the configuration file. Create a sample transaction file To create a sample transaction file: Create a new file for the local server configuration settings: Open the file in your code editor and define a sample execution request using the YAML API request format: In this example, the transaction includes one line of Pact code , two data fields for the name and the language , and a public and secret key pair that was generate by running the command. Transaction requests must always include either the setting to specify the Pact code to execute or the setting to specify the path to a file that contains the Pact code to execute. The setting is most commonly uses to specify keyset information. For example: Alternatively, you can use a setting to specify the path to a file that contains the data for the transaction. The setting lists key pairs to use for signing transaction. The key pairs are expected to be generated using the Ed25519 signature scheme that produces a base-16 public key and base-16 secret key. For more information about formatting API requests in YAML, see Transaction formats. Save your changes and close the file. Create a directory for logging To create a directory for logging: Open a terminal shell on your computer and navigate to the folder, if necessary. Create a new directory named to hold the log files. Check the contents of the directory to verify you have the log directory and YAML files. The command should display output similar to the following: Start the local server Now that you have a working environment, you are ready to start the Pact server and use the local Pact REST API endpoints to test transactions. To start the local server: Open a terminal shell on your computer and navigate to the folder, if necessary. Start the local server using the settings you defined in the pact-config.yaml file. After running this command, you should see the Pact server initialized and running on port 8080 with output similar to the following: You can now call Pact REST API endpoints using the local server. Call REST API endpoints You can use the local Pact server to call the following Pact REST API endpoints: Use this endpoint To do this Submit a transaction that contains a object in JSON format and return a transaction hash. This transaction hash is the same string as the request key you can use to look up transaction results. Specify a single transaction hash and return the transaction result. Specify multiple transaction hashes in a single request and return multiple transaction results. Submit a transaction that contains a object that queries the blockchain but only runs in the local server and return the transaction result. Send Now that the Pact server is running, you can use the terminal to call the endpoint locally. To call the endpoint, you must: Convert the YAML request in the transaction.yaml file into a JSON object. Include the object in the request body in the API request. To call the endpoint: Open a new terminal shell on your computer. Navigate to the folder. Convert the YAML request in the transaction.yaml file into a JSON cmd object. This command formats the sample transaction file and displays the JSON output similar to the following in the terminal: Call the endpoint using a command similar to the following: This command formats that YAML transaction, specifies the request header for the to be , then specifies the destination for the API call. In this case, the API call is sent to the on port . This command returns the request key for the transaction in the response: Each request generates a unique transaction hash, so your request key will be different from the example. Listen You can use the endpoint to request the transaction result for a single transaction hash. The format for calling the endpoint looks similar to the following: This command returns the result of the request with output similar to the following: Poll You can use the endpoint to request the transaction results for multiple transactions with a single call. The endpoint is similar to the endpoint except that the connection is intended to run at an interval instead of remain open and accepts multiple request key hashes in the request and returns multiple transaction results. The format for calling the endpoint looks similar to the following with a list of the request keys you received in response from calling the endpoint: This command returns the result of the request with output similar to the following: The difference between the and endpoints is subtle, but important. You only use the endpoint if you are working with a single hash to return the result. You use the endpoint if you want to request the results for multiple transactions. Local You can use the endpoint to submit queries to the blockchain without affecting the blockchain state. The endpoint is similar to the /send endpoint in that it includes a object with code in the request and returns the transaction result. However, the transaction you submit using the /local endpoint only runs in local server and does not update any nodes in the blockchain network. The format for calling the endpoint looks similar to the following: This command returns output that's similar to the output from the /send endpoint: The endpoint is particularly useful if you want to execute a function that doesn’t need to change the state of the blockchain. In general, you should use the endpoint if you want to call functions that retrieve information from tha blockchain. Yoi should use the endpoint if you want to update information stored in the blockchain or to deploy smart contracts on the blockchain. Write and execute YAML requests At this point, you have learned how to start a local Pact server and how to use the REST API endpoints to update or retrieve information from the blockchain. The next step is to apply what you've learned to write your own YAML request files, convert the requests to JSON, and execute the transactions using the REST API endpoints. To finish this coding project, write and execute YAML request files for the following transactions: Deploy the contract. Call the function. For this exercise, add the following smart contract to create a file in your folder: If you list the contents of the folder, you should see the following files and folder: To write and execute YAML requests: Generate a public and secret key pair to sign transactions using a command similar to the following: This command create a file with a public and secret key. For example: Note that, in this example, you’re submitting requests to the built-in Pact server endpoints. If you were deploying contracts or calling functions on the Kadena development, test, or production network, your YAML request file would need to include additional information such as the network identifier and chain identifier. You can find examples of more complete YAML request files in the How to guides. Write a minimal file that deploys the file. Deploy the contract by calling the endpoint. The command returns the request key. For example: Listen for the transaction result by calling the endpoint. The command returns the transaction result. For example: Write a file that calls the function. Submit a transaction that calls the function by using the endpoint. The command returns the request key. For example: Listen for the transaction result by calling the endpoint with the request key returned. The command returns the transaction result. For example: Review In this coding project, you created a project directory with a local server configuration file and a sample transaction YAML request file. You also created a http-log folder for SQLite data from the Pact server and started the Pact server locally on port number 8080. After starting the server, you used the command to convert the sample YAML request file into a JSON object and used commands to send the object to the Pact server. Now that you know how to write and submit transaction requests and how to look up transaction results and submit local queries, you can begin developing more sophisticated applications to run on the Kadena blockchain.",
    "source": "coding-projects/pact-server-api.md",
    "title": "pact-server-api"
  },
  {
    "content": "title: Local testing description: \"This coding project demonstrates how to use built-in functions for testing smart contracts using the Pact command-line interpreter REPL.\" id: local-testing sidebar_position: 7 Local testing The Local testing coding project demonstrates how to use built-in functions for testing smart contracts using the Pact command-line interpreter REPL. If you've explored other coding projects, you might be familiar with some of the most basic functions, such as the and built-in functions. This coding project introduces a more complete set of common functions for testing smart contracts in your local development environment. For this project, you'll use the module as the sample smart contract to test. The module defines three tables and ten functions, making it a good candidate for learning about writing test cases. In this coding project, you'll learn about: Using the Pact read-evaluate-print-loop (REPL) for interactive testing. Using Pact REPL-only built-in functions. Loading and resetting environment data. Defining transaction blocks Loading and using Pact modules. Testing success and failure cases. Before you begin Before starting this project, verify your environment meets the following basic requirements: You have a GitHub account and can run commands. You have installed the Pact programming language and command-line interpreter. You have installed the package and have a working directory with initial configuration settings. You have a local development node that you can connect to that runs the program, either in a Docker container or on a physical or virtual computer. You should be familiar with defining modules and using keysets. Get the starter code To get started: Open a terminal shell on your computer. Clone the repository by running the following command: Change to the directory by running the following command: If you list the contents of this directory, you'll see the following files: provides a starting point with the framework for building the module. provides test cases for completing each part of the coding project. provides the final version of the test cases for verifying the module. Open and review the file. This file outlines the tasks you need to complete for the Local testing project. Follow the embedded instructions to work through the coding challenges on your own or use the detailed instructions and code provided in the next sections. Using the Pact REPL The Pact command-line interpreter provides a read-evaluate-print-loop (REPL) terminal for interactive Pact modules. With this terminal, you can use built-in REPL functions to load and run Pact files to test the functions defined in them. The REPL file is responsible for reading, evaluating, printing, and looping through the Pact code and returning the results to the terminal. By using REPL files, you can test and iterate on the smart contracts code efficiently. To use the Pact REPL: Create a REPL () file that loads the Pact module (.pact) that you want to test. Open a new terminal shell on your computer. Start the command-line interpreter and specify the file that loads the that you want to test. The file loads the file. The interpreter executes the code in the file, returns data to the file which, in turn, sends the output to your terminal. Using built-in functions Pact includes many built-in functions for testing module code using files and the Pact command-line interpreter. Most of these functions are REPL-only functions. They can only be used in files and can't be called directly in files. The following functions are some of the most commonly used REPL-only functions: Function Purpose begin-tx Begin a transaction. commit-tx Commit a transaction. env-chain-data Define the chain information to use for transactions in your testing environment. env-data Set transaction data. env-sigs Set transaction signature keys. expect Evaluate expression and verify that it equals what is expected. expect-failure Evaluate an expression and succeed only if the expression results in an error. load Load and evaluate a file. Load environment data Most smart contracts require some information to be available in the environment so that it can be used by the functions defined in the module. For example, keyset information must be available to authorize access to some operations. In a file, you can use use the built in functions env-data and env-sigs to specify keysets and keys to use for testing. One of the unique features of using these REPL-only functions in a file is that you can simulate keys and accounts without having to generate and use actual keys and signatures to authorize operations or sign transactions. For example, you can use the function to simulate the keyset named like this: Similarly, you can use the function simulate a signing key and capabilities. Defining transaction blocks In files, you define tests within transaction blocks that start with the function and end with the function. Within a transaction block that starts with the function and ends with the function, you can make as many calls to the Pact code as you like. Any command sent to the blockchain is a transaction, but a command can have multiple function calls. For example, a single transaction block is treated as one command, but it can include the code used to define a module with and create module tables with with one or more calls. Transaction blocks enable you to group function calls into smaller logical units, making it easier to identify errors and resolve test failures. Although it's possible to place all of the function calls in a single transaction, in practice, it's better to break test files up to make function calls into several smaller transactions. For example, you can make each function call a separate transaction similar to the following: Transactions can be grouped together however is most convenient for your testing. However, you should try to maintain a logical order in your transactions for maintenance and readability. Load a module from a Pact file Pact files are not run by your computer directly. Instead, they’re loaded into the file and run from there. After you have defined environment data, such as the namespace and keyset for a module, you must load the file into the file using a load statement. For example, type then specify the file path as a string: Typically, and .repl file are located in the same folder, so you only need to specify the name of the file. However, if you place the files in different file locations, you must provide an absolute or relative path to the file you want to load. Call module functions After the file is loaded in the file, you are ready to start calling module functions. Depending on how you define your transaction blocks, there are a few possible ways to call the functions. The most common approach is to import the module with a use statement, then call the functions that are defined in the imported module. For example: For this coding project, edit the file to call the following functions defined in the module: Function Purpose create-a-loan Accepts parameters to add the appropriate information to each table assign-a-loan Assigns a loan to an entity. sell-a-loan Sell a loan and log details in the loan history table. After calling the functions used to create, assign, and sell a loan, add tests to read some of the data that you created. For example, edit the file to call the following functions defined in the module: Function Purpose read-loan-inventory Reads all loans in the loan inventory table. read-loans-with-status Reads all loans with a specific status. Execute the tests At this point, you have a completed file that tests code defined in the module. The final step is to execute the tests by running the file from a terminal shell to view the output. To execute the .repl file tests: Open a terminal shell and navigate to the directory that contains the and files. Start the Pact command-line interpreter: Load the file You should see output for the tests you defined in the .repl file displayed in the terminal. For example, you should see output similar to the following excerpt: Testing success and failure use cases Pact also provides built-in functions to test for expected results, including code that you expect to succeed, code that you expect to fail, and code that returns an expected result from an evaluated expression. Function Purpose expect Evaluates an expression and returns a specified string is the result from the evaluation is what is expected. expect-failure Evaluates an expression and returns a specified string only if the expression evaluated returns an error. expect-that Evaluates an expression and returns true if the expression evaluated returns the expected result or false if the expression evaluated doesn't return the expected result. The following example demonstrates how to use the function to evaluate whether an expression returns an expected result: The following example demonstrates how to use the function to evaluate whether an expression fails as expected result: The following example demonstrates how to use the function to evaluate whether an expression returns the expected result: You can find additional examples of and test files in the pact-examples repository. Both the and functions enable you to test whether the outcome of an expression is what you expect it to be. For example, the keysets.repl demonstrates using the function and function to test use cases that are expected to fail. Review In this coding project, you learned the basics of testing by creating transaction blocks in files. Defining tests in files is the most common approach to testing smart contracts locally. From these basic building blocks, you can experiment with adding and modifying tests and function calls in or files to learn more.",
    "source": "coding-projects/local-testing.md",
    "title": "local-testing"
  },
  {
    "content": "title: Loans in multiple tables description: \"Learn how to build smart contracts that allow users to create, distribute, and manage loan information.\" id: loans sidebar_position: 5 Loans in multiple tables The Loans and database management project is designed to demonstrate working with multiple tables and writing more complex functions to build more complete applications. For this project, you'll build a smart contract with tables for adding and manipulating loan information with secure interactions for module administrators. For this project, you'll create three tables in the module: A table for storing loan holder information. A table for tracking loan history. A table for holding the loan inventory balance. Before you begin Before starting this project, verify your environment meets the following basic requirements: You have a GitHub account and can run commands. You have installed the Pact programming language and command-line interpreter. You have installed the package and have a working directory with initial configuration settings. You have a local development node that you can connect to that runs the program, either in a Docker container or on a physical or virtual computer. You should be familiar with defining modules and using keysets. Get the starter code To get started: Open a terminal shell on your computer. Clone the repository by running the following command: Change to the directory by running the following command: If you list the contents of this directory, you'll see the following files: provides a starting point with the framework for building the module. provides solutions and test cases for completing each part of the coding project. provides the final code for the module and the final test cases for verifying module functions. Open and review the file. This file outlines the tasks you need to complete for the Loans project. Follow the embedded instructions to work through the coding challenges on your own or use the detailed instructions and code provided in the next sections. Define the module and keyset As you might have seen in other coding projects, the first step in creating a new module requires defining or identifying a namespace and an administrative owner for the module. To start the module declaration: Open the file in your code editor and save it as . Specify the namespace and a define a keyset for the module to use. Define the module governed by the capability and enforced to use the keyset: Create a file in you code editor to prepare the environment for testing the module. For example, add test keys and data to define the namespace in your working environment and to load the module: Define the schemas and tables To define the schemas and tables: Open the file in your code editor. Define the schema and the table that uses the schema. Define the schema and the table that uses the schema. Define the schema and the table that uses the schema. Define constants To define the constants for loan status: Define an constant that contains the status description for loans that have been initiated using the \"initiated\" comment. Define an constant that contains the status description for loans that have been assigned using the \"assigned\" comment. Define functions For this coding project, the module provides nine functions to provide comprehensive features for loan management. You can define them in any order. takes and to create a composite key of . takes , , , and to create a loan entry. takes , , , and to assign a loan. takes , , , , and to sell a loan. takes to read values from the table for a given . select all values from the table with set to true. takes to set and for the provided . maps the value of to the keys of the . takes to select all values from the where equals the provided . Define the inventory-key function To define the function: Open the file in your code editor. Start the function definition with the keyword and add the parameters . Create a composite key from the and in the format . Define the create-a-loan function To define the function: Open the file in your code editor. Start the function with the parameters , , , and . Insert the values for the new loan into the table. Insert the values for a new loan into the table. Define the assign-a-loan function To define the function: Open the file in your code editor. Start the function with the parameters , , , and . Read from the table using and bind variables to the column values. Insert values into using the value of the parameter. Insert values into the with the parameters , , and . Update the for the row matching the parameters , , and with the new balance of the issuer. Update the in the table for the specified . If you want to test the functions that you've defined so far, you can update the file to create the tables and the file with transactions that call the functions. If you aren't sure how to make these changes, continue defining the functions, then follow the steps in Test functions in the REPL. Define the sell-a-loan function To define the function: Open the file in your code editor. Start the function with the parameters , , , , and . Read from the table using the parameters , , and and bind to value of . Read from the using the parameters , , and , assign balance to 0, and bind to value of . Insert values into the at the given . Update the with the parameters , , and , and set the to the minus the . Write to the with the parameters , , and , set the to the plus the . Define the read-a-loan function To define the function: Open the file in your code editor. Start the function with the parameter . Read all of the values from the table at the given . Define the read-all-loans function To define the function: Open the file in your code editor. Start the function with no parameters. Select all values from the table that have set to true. Define the read-inventory-pair function To define the function: Open the file in your code editor. Start the function with the parameter . Set the to the provided . Set the value of the balance in the to the value of the . Define the read-loan-inventory function To define the function: Open the file in your code editor. Start the function with no parameters. Map the value of the to the in the . Define the read-loans-with-status function To define the function: Open the file in your code editor. Start the function that takes the parameter . Select all values from the table where the status equals the parameter. Complete the module declaration Complete the module by closing the module declaration and create the tables. To complete the module: Finish the module declaration with a closing parenthesis, if you haven't already done so. Create the tables defined for the module declaration, if you haven't already done so. Test functions in the REPL To test the loans module, you need to add transactions to the file. To test the functions in the file: Open the file. Add a transaction that loads the file and then calls the functions that update the loan tables similar to the following: Because you're loading the module and calling the functions in the same transaction, you don't need to include the namespace and module name to call the functions. Add a transaction that calls the functions that read loan information from the loan tables similar to the following: In this example, you first specify that you want to use the module where the functions are defined using its namespace and module name. Similar to loading the module, you can then call individual function without including the namespace and module name. Add transactions that call the individual functions similar to the following: In this example, you must specify the module where the functions are defined using the namespace and module name. Open a terminal shell on your computer and test execution by running the following command: You should see that the transactions are successful with output similar to the following: Ensure that the REPL output aligns with expected results. Review You have now built and tested a smart contract that manipulates loan information in three tables with a robust set of functions.",
    "source": "coding-projects/loans.md",
    "title": "loans"
  },
  {
    "content": "title: Hello world, revisited description: \"Start coding with the Pact smart contract programming language by creating a 'Hello, World!' project.\" id: hello-world sidebar_position: 2 layout: full tags: [ 'pact', 'hello world', 'tutorials', 'hello world tutorial', 'pact hello world', 'smart contract deployment', ] Hello, World! revisited In the Quick start, you were introduced to a simple module. Modules provide the basic foundation for all Pact smart contracts. In fact, the term is a reserved keyword that you use to define and install a module with a specified name, The module defined a single function—one very much like the traditional Hello, World! program you see when learning any new programming language. In the project folder, you'll take a closer look at the module, extend its functionality, and deploy it on the local development network. Before you begin Before starting this project, verify your environment meets the following basic requirements: You have a GitHub account and can run commands. You have installed the Pact programming language and command-line interpreter. You have installed the package and have a working directory with initial configuration settings. You have a local development node that you can connect to that runs the program, either in a Docker container or on a physical or virtual computer. If you have these basics covered, you're ready to go. Get the starter code To get started: Open a terminal shell on your computer. Clone the repository by running the following command: Change to the directory by running the following command: Open the file in your code editor. A few things you should note about this starter code: The being defined is named . Every module is governed by either a keyset or a capability. In this example, the GOVERNANCE capability is used to control access to the module. This capability must evaluate to true to grant access. The reserved keyword signals the start of a function definition. In this example, the function being defined is named and the function takes one variable, , with a data type of . The function uses the built-in function that allows you to format messages using a placeholder and a variable or a specified value. The curly braces () indicate the location of the value to be inserted and the [name] is the variable to be inserted in place of the curly braces (). To learn more, see the following topics: Syntax and keywords Built-in functions Load and test the module The Pact command-line interpreter provides a read-evaluate-print-loop (REPL) for interactive testing of Pact commands and for executing tests defined in files. To load and test the module interactively: Add a call to the function at the bottom of the file in your code editor. Open a terminal shell on your computer. Start the Pact interpreter by running the following command: After running this command, the terminal displays the prompt: Copy and paste the module code into the terminal with the prompt, then press Return on the keyboard to load the module. You should see that the module loads and the call to the function is executed with output similar to the following: Exit the Pact interpreter by pressing control-d on the keyboard. Create a hello-world.repl file The Pact REPL environment accepts many built-in functions that are specifically for testing and debugging your Pact code. You can use these built-in functions in files that are similar to files, like the file you've been working with so far. However, the files you create for testing Pact functionality use the file extension. To create a basic file: Create a new file named file in your code editor. Use the built-in and functions to define a transaction that loads the file: Open a terminal shell and execute the file by running the following command: Notice that you are executing the file in a terminal shell and not in the Pact command-line interpreter. This command executes the functions defined in the file and displays output in the terminal similar to the following: To learn more, see the following topics: Testing Pact programs REPL-only functions Modify the module to store names One way to make the module a more interesting sample project is to enable the contract to store greetings in a table. To modify the module: Copy the file to create a new file named file in your code editor. Modify the module code to create a schema and table for storing greeting recipient values and add functions to write and read the value from the table. For example: Create a new file named file in your code editor. Use the built-in and functions to define a transaction that executes the module: Open a terminal shell and execute the file by running the following command: Deploy the contract After testing the contract using the Pact interpreter and the REPL file, you can deploy the contract on your development network or the Kadena test network. If you wanted to deploy this contract on the Kadena test network or a production network, you would first need to identify a namespace for deploying the contract and ensure that the module name is unique across all of the modules that exist in that namespace. For simplicity, you can deploy this project locally on your development network without selecting a namespace or updating the module name. However, even on the local development network, you must have an account with funds and a key to sign the transaction that deploys the contract. You can use commands to configure and fund accounts for the local development network. You can also use commands to create transactions to deploy contracts. However, one of the simplest ways to generate keys, manage accounts, and deploy contracts is by using the Chainweaver desktop or web-based application and its integrated development environment. To complete the 00-hello-world project, you can use Chainweaver to deploy the hello-world contract on the Kadena test network. To deploy the contract on the Kadena test network using Chainweaver: Open the contract you want to deploy in your code editor. For example, open the file in your code editor. Add the namespace before the module definition in the file and update the module name to be unique. For example: Save the changes in the code editor. Open Chainweaver and select the testnet network. Click Accounts in the Chainweaver navigation pane and verify that you have at least one account with funds on at least one chain in the test network. For example: If you don't have keys and at least one account on any chain on the test network,you need to generate keys, create an account, and fund the account on at least one chain before continuing. Click Contracts in the Chainweaver navigation pane, then click Open File to select the contract you want to deploy. Click Deploy to display the Configuration tab: Select the Chain identifier for the chain where you want to deploy the contract. Select a Transaction Sender. Click Next. On the Sign tab, select an Unrestricted Signing Key, then click Next. On the Preview tab, scroll to see the Raw Response is \"Hello, world!\", then click Submit. After you click Submit, the transaction is sent to the blockchain. You can use the block explorer and the transaction request key to view the transaction results or wait for the transaction to be included in a block before closing the transaction submission dialog by clicking Done. When the transaction is mined into a block, you will have deployed your Hello World smart contract on the Kadena test network. Call the deployed contract After you deploy a contract, you can view its details and call its functions using Chainweaver. To view and call your contract: Click Contracts in the Chainweaver navigation pane, if necessary, then click Module Explorer. Under Deployed Contracts, search for your module name in the free namespace and chain where you deployed, then click Refresh to update the list of deployed contracts to display only your just-deployed contract. In this example, the unique module name is free.helloWorld-mod-pistolas and the contract was deployed on the testnet chain 1. Click View to display the functions and capabilities defined in your contract. Click Call to call the contract functions. Click Call for the hello function to specify a new string in quotes, then click Next. Click Next, select an Unrestricted Signing Key for this call, then click Next. Click Submit to submit the transaction and commit the change. After the transaction is included in a block: Click Call for the greet function, then click Next. Select an Unrestricted Signing Key for this call, then click Next. Scroll to see the Raw Response uses the string you specified for the hello function. Click Submit if you want to submit the transaction to the blockchain or close the function call without submitting the transaction.",
    "source": "coding-projects/hello-world.md",
    "title": "hello-world"
  },
  {
    "content": "title: 'Gas station accounts' description: \"Create and configure a gas station account to pay for transactions submitted by application users.\" id: gas-station sidebar_position: 9 Gas station accounts In the Gas station account coding project, you'll learn how to create a smart contract that allows application users to complete a transaction on the blockchain without having an account or any tokens to pay the transaction fee. With this smart contract, an autonomous account is used to pay transaction fees on behalf of users. The autonomous account—often referred to as a gas station—simplifies the user experience and eliminates the friction associated with onboarding users who are new to blockchain technology, digital wallets, transaction signing, and managing public and secret keys. Gas station accounts make it easier for new users to interact with applications, but require some extra work by the application developer. For example, you'll most likely want to set limits on how and when the funds in the gas station account can be used to prevent the account balance from being drained too quickly or funding transactions that require a lot of computational overhead. In this coding project, you'll see a simple example of how to create a contract account that pays transaction fees—that is, the gas fees—on behalf of users. This coding project explores how to: Create a gas station principal account with a capability guard. Implement the interface required to allow the account to pay transaction fees for any type of transaction. Scope the gas station account to only pay transaction fees for transactions that meet specific criteria. By completing this project, you'll have a basic understanding of the functions used to create a secure gas station account and how to set limits to protect the account from misuse. Principal accounts and guards A gas station account is similar to any other contract account. It must have an account name, guard, and balance, so that it can be uniquely identified, sign transactions securely, and hold funds for paying fees. However, it's important for you to restrict access to the gas station account to ensure it's only used as intended. The primary way to secure access to the gas station account is by creating it as a principal account with a unique guard. For an introduction to principal accounts, see Accounts, keys, and principals. For information about the different types of guards, see Guards. The following example illustrates how to use the and functions to create a account with a user guard for the function: The function creates a new principal account with a user guard in the with a default balance of 0.0. You can use similar code to create a new account that makes use of a capability guard. For example: A capability guard is an essential part of the code that makes creating a gas station principal account possible. In the next step, you'll implement the interface to add a capability and guard to your module. Before you begin Before starting this project, verify your environment meets the following basic requirements: You have a GitHub account and can run commands. You have installed the Pact programming language and command-line interpreter. You have installed the package and have a working directory with initial configuration settings. You have a local development node that you can connect to that runs the program, either in a Docker container or on a physical or virtual computer. You should be familiar with defining modules and using keysets. Get the starter code To get started: Open a terminal shell on your computer. Clone the repository by running the following command: Change to the directory by running the following command: If you list the contents of this directory, you'll see the following files: provides a framework for the project code in comments. contains the final module code for the sample gas account. provides the complete test file for testing the final file. Open and review the file. This file describes all of the tasks that you need to complete for the Gas station accounts coding project. You can follow the instructions embedded in the file to try to tackle this coding project on your own without looking at the solutions to each step, or follow the instructions in the next sections if you need additional guidance. Implement the gas payer interface Because paying gas fees is a common operation, the interface is defined in a module that's deployed by default on the Kadena development, test, and main networks. For this coding project, you'll implement this interface in a new Pact module—the module—in a file. To create the gas station module: Open the code editor on your computer. Create a new file. Add the minimal Pact code required to define a module. Remember that a module definition requires the following information: namespace governing keyset or capability at least one function The function in this case is an implementation of the interface as defined in the file. For example: To deploy the gas station module, you must use an existing namespace such as the namespace. For local testing, you can create the module in a custom namespace that you define for the local development network. After you issue the statement, you must implement the capabilities, types, and functions that are defined in the file in the module. The interface definition looks like this: Implement the capability as defined in the file and compose an inner capability called to use as a guard for the account used to pay transaction fees: With this code, an account granted the capability can pay gas fees for any transaction. In addition, the function uses the built-in function to return a guard for the capability. Test the gas payer implementation At this point, you have a basic implementation of the interface that can be used to pay transaction fees but without any other scoping or restrictions. Before deploying the new module or updating it to be more restrictive, you should prepare a script for testing operations locally. To test the module locally, you'll need to add the contracts that the gas station module depends on to your local environment. To prepare a test file: Open the code editor on your computer. Copy the following required files to your working directory: Copying these files to your local environment is required because the contracts aren't deployed in the Pact REPL by default. Create a new file to provide all of the environment data required for the module, including the namespace, keys, signatures, and contracts. For example, the initial environment information for the might look similar to the following: Add a call to load the file: Execute the file using the command-line interpreter and the option: You should see that the operations are successful with output similar to the following: Create the capability-guarded account To make the gas station account more secure, you can create it using a principal account name and guard access to it by using the capability. Because the gas station account is a capability-guarded account, the Pact function creates the principal account name with a prefix. You can then define the gas station account name as a constant in the file. To create a capability-guarded account: Open the file in the code editor. Add a constant to store the gas station principal account in the module declaration: Add an function that uses the function to create the gas station account in the module declaration: In this code: The first argument of the function is the account name you defined using the constant. The second argument is the guard for the account. Add an expression after the module declaration that calls the function if the module is deployed with in the environment data: Save your changes to the file. Open the file in the code editor. Update the file to set to by adding the following lines of code before loading the file: Update the load transaction to display the capability-guarded gas station account name when you execute the file: Execute the file: You should see that the transaction completes with output similar to the following: Verify the gas station account In the previous output, the \"Write succeeded\" message indicates that you have successfully created the principal account for the gas station to use. You can verify the account information by adding another transaction to the file that calls the function with the account name for the capability-guarded gas station account. To verify the gas account: Open the file in your code editor. Add a transaction similar to the following after loading the file: Execute the file: You should see that the transaction completes with output similar to the following: Scope to specific transactions Now that you have a capability-guarded gas station account that can be used to pay transaction fees, you can further scope it to only pay for specific transactions or only when specific conditions are met. For example, you might want enforce an upper limit for transaction fees to help ensure that funds in a gas station account aren't drained too quickly. The following example illustrates how to enforce specific conditions for the use the gas station account. In this example, the gas station administrator can use the gas station account for any transaction. Other users can only use the gas station account to pay transaction fees if the gas price is less than a specified price. To enforce specific conditions for transactions using the gas station account: Open the file in the code editor. Add the function to the capability to specify two conditions: In this example, the function allows the owner of the keyset to the use the gas station account to pay for any transaction. For all other transactions and users, the gas price must be less the specified 0.00000001. You can use a similar approach to limit access to gas station funds based on other conditions. For example, you can set a limit for transaction fees using a function to get the current gas price instead of using a hard-coded value. You can also create conditions that prevent the gas station account from being used to submit continuation requests, that exclude specific module or function calls, or that set time boundaries for paying transaction fees. Display account details Before deploying the gas station smart contract, add a function to display the account details when the contract is deployed. You'll need this information to transfer funds to the new account on the network and chain where you deploy the contract. To add a function that displays the account information: Open the file in the code editor. Add the function to call the function for the : Add a call to the function to the end of the smart contract: Open the file in the code editor and add a test for the display function. Execute the file: You should see that the transaction completes with output similar to the following: Deploy the contract After you've updated and tested the module, you can deploy it on a chain in the development network using Chainweaver. For this example, the administrative account has funds on chain 3 in the development network. Prepare to deploy To prepare to deploy the gas station module on the development network: Verify the development network is currently running on your local computer. Open and unlock the Chainweaver desktop or web application. Verify that you're connected to development network (devnet) from the network list. Verify that your administrative account name with the k: prefix exists on the target chain. Verify that your administrative account name is funded with coins on the target chain. Load the module using Chainweaver Because you must define the keyset keys and predicate for your contract in the environment outside of the contract code, the Chainweaver integrated development environment provides the most convenient way to add the required keysets. To load the contract using Chainweaver: Click Contracts in the Chainweaver navigation pane. Click Open File to select the contract that you want to deploy. After you select the contract and click Open, the contract is displayed in the editor panel on the left with contract navigation on the right. You'll also notice that the line where you define the keyset indicates an error, and the error message is because your administrative keyset doesn't exist in the environment. Under Data on the Keysets tab, type the name of your administrative keyset, click Create, then select the public key and predicate function for the administrative keyset. Deploy using Chainweaver To deploy the contract using Chainweaver: Click Deploy to display the Configuration tab. On the Configuration tab, update General and Advanced settings like this: Select the Chain identifier for the chain where you want to deploy the contract. Select a Transaction Sender. Click Advanced and add the administrative account keyset to the environment. Click Next. On the Sign tab, select the public key for the administrative keyset for the coin.GAS capability, then click Next. On the Preview tab, scroll to see the Raw Response displays the account details for the gas station account, then click Submit to deploy the contract. After you deploy the contract, you can use the request key to view the transaction results in the block explorer. Fund the gas station account Now that you have created and deployed the gas station account, you're ready to fund the account to pay transaction fees. You can use the commands to create, sign, and send a transfer transaction to the development network. To fund the gas station account: Verify the development network is currently running on your local computer. Create a new unsigned transaction using the command and the template and follow the prompts displayed to select the sender, receiver, and amount to transfer. For the template value, specify the administrative account that is providing funds to the gas station account. In this example, it's the Chainweaver wallet account . For the template value, specify the gas station principal account that you created with the capability guard. In this example, it's the principal account . For the decimal:amount template value, specify the number of coins to transfer as a decimal value. In this example, the transfer amount is . For example, the prompts and output for creating the transaction look similar to the following: Sign the unsigned transaction using the command and the transaction file name generated by the command. For example, the prompts and output for the transaction look similar to the following: Send the signed transaction using the command and the signed transaction file name generated by the command. For example, the prompts and output for the transaction look similar to the following: After the transaction is completed, you can check the results in the block explorer using the request key. For example, you can open the local block explorer for the development network to view recent transactions: You can click the link matching the transaction request key to see the details about the funding transaction: Review This project demonstrated how to create a capability-guarded principal account to hold funds. This account can be used to pay for transactions on behalf of other users. The project also provided a simple example for restricting the use of the gas station account based on a specific condition. In this example project, the gas station module was deployed on the development network and chain 3 with funds from a Chainweaver wallet account.",
    "source": "coding-projects/gas-station.md",
    "title": "gas-station"
  },
  {
    "content": "title: Estimate gas description: \"Calculate the approximate cost to execute a specific transaction.\" id: estimate-gas Estimate gas Because transaction fees vary depending on the resources required to execute specific operations, it can use useful to calculate potential fees by testing contract functions using the Pact REPL and files. This coding project demonstrates the basic steps for calculating the gas required to execute any method in a file. This coding project assumes you're familiar with the basic built-in functions for testing smart contracts in your local development environment using files. As an extension of the Local testing, the project demonstrates how to gas-related built-in functions with the module as the sample smart contract to test. In this coding project, you'll learn about: Using the built-in environment configuration functions. Setting and updating gas limits. Testing the gas consumed for individual functions. Combining functions in transaction blocks. Before you begin Before starting this project, verify your environment meets the following basic requirements: You have a GitHub account and can run commands. You have installed the Pact programming language and command-line interpreter. You have installed the package and have a working directory with initial configuration settings. You have a local development node that you can connect to that runs the program, either in a Docker container or on a physical or virtual computer. You should be familiar with defining modules and using keysets. Get the starter code To get started: Open a terminal shell on your computer. Clone the repository by running the following command: Change to the directory by running the following command: If you list the contents of this directory, you'll see the following files: provides a starting point testing the module. provides the final code for the module with the functions that you'll estimate gas consumption for. provides the final version of the test cases for estimating the gas consumed by functions defined in the module. Open and review the file. This file outlines the tasks you need to complete for the Estimate gas project. Follow the embedded instructions to work through the coding challenges on your own or use the detailed instructions and code provided in the next sections. (Optional) Copy the file or create a new file in your code editor to use for this coding project. Set environment data As you learned in Local testing, most smart contracts require some information to be defined in the testing environment so that it's available for module functions to use. To prepare environment data for testing: Open the file in your code editor. Add the built-in function to enable the to sign transactions and have unrestricted capabilities. Add the built-in function to define the key and predicate function. Add a transaction to define the namespace for the module. Add a transaction to initialize gas modeling by setting the built-in function to and the built-in function to or a similar value. Load the module and call functions After you initialize gas modeling, you are ready to begin calling the built-in function to report the gas consumed by individual function calls or by transactions that call multiple functions. This coding project demonstrates both how to calculate the gas consumption for specific function calls and how to combine multiple function calls into a single transaction and estimate the gas required to complete the transaction. To load the module and call functions: Begin a transaction. Load the file into the REPL. Call the function with the and parameters. Retrieve the gas consumed using the built-in function. Commit the transaction. Reset the gas retrieved to zero before calling the next function. At this point, you have a loans-estimate.repl file that looks similar to the following to estimate gas consumption of one function: Test that the gas consumed is returned by running the following command: You should see output similar to the following: In this example, the gas consumed by the function is 6031. Call each function separately You can add similar transactions to retrieve the gas consumed for each function defined in a module. In the following example, each transaction imports the module and calculates the gas consumed for a specific function: As before, you can test that the gas consumed is returned for each function by running the following command: In this example, the functions from the module returned the following results: Combine multiple functions In some cases, you might want to estimate the gas required to execute a set of functions instead of individual functions. You can do so by combining the functions into a single transaction. The following example demonstrates combining several function into a single transaction then retrieving the gas consumed. Note that you might need to increase the value you set for the built-in function when you are returning the gas for multiple functions in a single transaction. The following example demonstrates combining multiple functions into a single transaction, increasing the gas limit value, and returning the gas consumed for all of the functions executed: Review This project introduced several of the built-in REPL-only functions for calculating gas. The project included examples of the following use-cases: Calculating the gas required to execute individual functions. Calculating the gas required to execute a transaction that combined multiple functions. Through these examples, you learned how to: Initiate table-based gas modeling. Set an initial gas limit. Report the gas consumed. Reset the gas to zero. You also learned that you can update the gas limit, if needed.",
    "source": "coding-projects/estimate-gas.md",
    "title": "estimate-gas"
  },
  {
    "content": "title: Contract interactions description: \"Learn how to build smart contracts that allow users to authorize and make payments using multiple Pact modules.\" id: contract-interactions sidebar_position: 4 Contract interactions The Contract interactions project is designed to demonstrate how you can import and use functions defined in one module in another module. For this project, you'll build a smart contract with separate modules to handle user authorization and payments with secure interactions between the modules. Secure contract interaction is a fundamental requirement for setting up more complex smart contracts. For this project, you'll create two Pact modules: An module for handling user authentication A module for managing account balances and transactions The module manages user authorization, while the module handles transferring value between two accounts— and . <img src=\"/img/docs-contract-interactions.png\" alt=\"Contract interactions project overview\" height=\"550\" width=\"900\"/> In this tutorial, you'll learn the following: Understanding contract interactions in Pact Setting up multiple modules for authorization and payments Testing interactions in the REPL environment Before you begin Before starting this project, verify your environment meets the following basic requirements: You have a GitHub account and can run commands. You have installed the Pact programming language and command-line interpreter. You have installed the package and have a working directory with initial configuration settings. You have a local development node that you can connect to that runs the program, either in a Docker container or on a physical or virtual computer. You should be familiar with defining modules and using keysets. Get the starter code To get started: Open a terminal shell on your computer. Clone the repository by running the following command: Change to the directory by running the following command: If you list the contents of this directory, you'll see the following files: provides the framework for building the module. provides the framework for building the module. includes test cases for verifying module interactions. Open and review the and files. These files outline the tasks you need to complete for the Contract Interactions project. Follow the embedded instructions to work through the coding challenges or use the detailed instructions provided in the next sections. Key concepts for contract interaction In Pact, modules can call functions from other modules, enabling more complex contract setups. You’ll be using the following key Pact features: load: Load and evaluate a module. use: Import an existing module into a namespace. function calls: Invoke functions defined within other modules. Getting started You’ll work with three main files: auth.pact - Responsible for authorizing users. payments.pact - Manages payments between users. payments.repl - Coordinates interactions between the modules. Define the auth module Define two keysets in the file to identify the keysets that have access to module operations. These keysets will help manage access control throughout the contract. Create the module to handle user authentication and management. Define the schema and table for managing user data. Define the function that keyset owners can execute to add new users to the module. Define the function that ensures a user is authorized for a specific operation. Complete the module by closing the module declaration and create the table. Define the payments module Define a keyset in the file that will manage this module. Start the module declaration and use the module. Define the schema and table for account management. Define the function to set up a new account, ensuring the user is authorized. Define the function to retrieve the balance for an account from the database for an authorized user. Define the function to allow for transferring funds between accounts. Complete the module by closing the module declaration and create the table. Test interactions with the REPL File Create a transaction in the file that loads the module. Create a transaction that loads the module. Create a transaction that uses the module to create user accounts. Create a transaction that uses the module to test transactions. Execute the file with the following command: Ensure that the REPL output aligns with expected results. Review You have now built and tested a contract interaction setup using two modules, following a step-by-step approach. This tutorial covered user authentication and payment transactions across modules.",
    "source": "coding-projects/contract-interactions.md",
    "title": "contract-interactions"
  },
  {
    "content": "title: Binary encoding description: Provides reference information for the chainweb-node block header binary encoding. menu: Chainweb API id: binary-encoding order: 2 layout: full tags: ['chainweb', 'node api', 'chainweb api', 'api reference'] Block header binary encoding The binary format for chain graphs of degree three is defined in . Size Bytes Value 8 0-7 flags 8 8-15 time 32 16-47 parent 110 48-157 adjacents 32 158-189 target 32 190-221 payload 4 222-225 chain 32 226-257 weight 8 258-265 height 4 266-269 version 8 270-277 epoch start 8 278-285 nonce 32 286-317 hash total: 318 bytes Adjacent parents record The binary format for adjacent parents (length 3): Bytes Value 0-1 length 2-109 adjacents total: 110 bytes Adjacent parent Bytes Value 0-3 chain 4-35 hash total: 36 bytes Proof of work and field values Arithmetic operations and comparisons on , , , and interpret the value as unsigned 256-bit integral numbers in little endian encoding. All operations are performed using rational arithmetic of unlimited precision and the final result is rounded. For details about how the result is rounded, consult the source code directly. Time stamps The and values are a little endian twos complement encoded integral numbers that count SI microseconds since the start of the POSIX/UNIX epoch (leap seconds are ignored). These numbers are always positive (highest bit is 0). Numbers The is a little endian encoded unsigned integral 64 bit number. The is a little endian encoded unsigned integral 16 bit number. Version The field identifies the Chainweb version. It is a 32 bit value in little endian encoding. Values up to 0x0000FFFF are reserved for production versions, including includes development and testnets. Value Version 0x00000005 mainnet01 0x00000001 development 0x00000007 testnet04 Other The is any sequence of 8 bytes that is only compared for equality. The is any sequence of 4 bytes that identifies a chain and can be compared for equality. The is any sequence of 32 bytes that is a cryptographic hash of the payload associated with the block and can be compared for equality. flags are eight bytes of value 0x0 that are reserved for future use. Work header binary encoding The work bytes received from the endpoint is slightly different than the above header format. These headers do not include the block hash, instead prefixing the header above (without hash) with chain id and hash target bytes. The first 36 bytes are informational. Only the bytes from position 36 to the end are the subject of the proof of work hash computation. The final 8 bytes are the nonce. The creation time is encoded in bytes 44-52 (see above for details of the encoding). Miners are allowed, but not required, to update the time to reflect the solve time for the block more closely. A larger value for the creation time increases the accuracy of the difficulty adjustment which is in the interest of miners. The high difficulty guarantees that the outcome of the race of winning blocks is determined by actual hash power. However, blocks that are predated (that is, have a creation time that is in the future) are rejected during block header validation. Leaving the time unchanged is a valid choice. Miners must not change or make any assumptions about the content of the \"reserved\" bytes. Defined in : Size Bytes Work bytes Value 4 0-3 NA chain 32 4-35 NA hash-target 8 36-43 0-7 reserved 8 44-51 8-15 time 298 52-313 16-277 reserved 8 314-321 278-285 nonce total: 322 bytes For arithmetic comparisons the is interpreted as unsigned 256 bit integral number in little endian encoding. The is a little endian twos complement encoded integral number that counts SI microseconds since the start of the POSIX/UNIX epoch (leap seconds are ignored). The value is always positive (highest bit is 0).",
    "source": "api/chainweb-encoding.md",
    "title": "chainweb-encoding"
  },
  {
    "content": "title: Data models description: Summarizes the data models used for different elements and attributes in Chainweb nodes. id: data-models order: 2 layout: full tags: ['chainweb', 'node api', 'chainweb api', 'api reference'] Data models Data models summarize the parameters that define important Chainweb node elements. The information in the data models is the same as the information covered in the endpoint documentation. It's duplicated here as a quick reference. Cut model Parameter Type Description origin object Defines a peer information object that consists of an string and an object. The parameter is required to use the endpoint. For more information, see the Peer information data model. height (required) integer >= 0 Defines the cut height. The cut height is the sum of the height of all blocks of the cut. You should avoid using this value in any applications or tools because its semantics might change. weight (required) string Defines the cut weight. The cut weight is the sum of the weights from all of the blocks included in the cut. The weight string consists of 43 characters from the character set. hashes (required) object Defines an object that maps chain identifiers to their respective block and block . The block property is a required string value with characters from the character set. The block property is a required integer value >= 0. The object includes the and properties for each chain, as illustrated for chains 0 and 1 in the truncated JSON example. instance string Defines the network identifier for the cut. id string Defines a cut identifier. Block header model Parameter Type Description creationTime (required) integer >= 0 Records the time the block was created. This timestamp is in microseconds since the start of the UNIX epoch. parent (required) string Records the parent block hash. The block hash is a Base64Url-encoded string—without padding—that consists of 43 characters from the character set. height (required) integer >= 0 Identifies the block height for the block. The height of a block is the number of its predecessors in the block chain. hash (required) string Block hash is a Base64Url-encoded string—without padding—that consists of 43 characters from the character set. chainId (required) integer >= 0 Specifies the Chainweb chain identifier. In Kadena, Chainweb chains are named by numbers starting from 0. Valid values depend on the current graph at the respective block height of the Chainweb version. weight (required) string Specifies the block weight for the block. Block weight is a Base64Url-encoded string—without padding—that consists of 43 characters from the character set. The weight of a block is the sum of the difficulties of the block and of all of its ancestors. The difficulty of a block is the maximum difficulty divided by the target. The string is a 256-bit little endian encoding of the numerical value. featureFlags (required) integer Specifies a reserved value that must be 0. epochStart (required) integer >= 0 Specifies a timestamp in microseconds since the start of the UNIX epoch. adjacents (required) object Records the block hashes of the adjacent parents of the block. This is represented as an associative array that maps the adjacent chain ids to the respective block hash. Each block hash is a Base64Url-encoded string—without padding—that consists of 43 characters from the character set. payloadHash (required) string Specifies the block payload hash. The payload hash is a Base64Url-encoded string—without padding—that consists of 43 characters from the character set. chainwebVersion (required) enum Specifies the Chainweb network version identifier for the Kadena network. The valid values are \"test-singleton\", \"development\", \"mainnet01\", and \"testnet04\". target (required) string Specifies the proof-of-work target for the block. The proof-of-work target for a block is a Base64Url-encoded string—without padding—that consists of 43 characters from the character set. The string is a 256-bit little endian encoding of the numerical value. nonce (required) string Specifies the proof-of-work nonce for the block. This value is computed by the miner such that the block hash is smaller than the target. Payload model Parameter Type Description transactions (required) Array of strings Array of Base64Url encoded strings without padding that represent signed Pact transactions in JSON format. minerData (required) string Miner information is a Base64Url-encoded string—without padding—that consists of 43 characters from the character set. This information is included as part of the payload in the JSON object. transactionsHash (required) string The transaction hash is a SHA256 hash. The hash is a Base64Url-encoded string—without padding—that consists of 43 characters from the character set. outputsHash (required) string The output hash is a SHA256 hash. The hash is a Base64Url-encoded string—without padding—that consists of 43 characters from the character set. payloadHash (required) string The block payload hash is a Base64Url-encoded string—without padding—that consists of 43 characters from the character set. Payload with outputs model Parameter Type Description transactions (required) Array of strings Array with pairs of strings that represent transactions and their outputs. Signed Pact transactions and their outputs are both Base64Url-encoded strings—without padding—that represent signed Pact transactions in JSON format. minerData (required) string Miner information is a Base64Url-encoded string—without padding—that consists of characters from the character set. This information is included as part of the payload JSON object. transactionsHash (required) string The transaction hash is a SHA256 hash. The hash is a Base64Url-encoded string—without padding—that consists of 43 characters from the character set. outputsHash (required) string The output hash is a SHA256 hash. The hash is a Base64Url-encoded string—without padding—that consists of 43 characters from the character set. payloadHash (required) string The block payload hash is a Base64Url-encoded string—without padding—that consists of 43 characters from the character set. coinbase (required) string Coinbase output is a Base64Url-encoded string—without padding—that consists of characters from the character set. This information is included as part of the payload output JSON object. Peer information model Parameter Type Description id (required) string or null The is a Base64Url-encoded string—without padding—that consists of characters from the character set. This string represents the SHA256 fingerprint of the SSL certificate of the node. The field can be null only if the node uses an official CA-signed certificate. address (required) object The contains a and number. The is a required string value in the form of a domain name, IPv4 IP address, or IPv6 IP address. The hostname must be a domain name only if the node uses a valid CA-signed SSL certificate. The is a required integer value [1 .. 65535] that hosts the peer node. Note that it is generally easier to query the peer information for a node using a GET query for the peer database. To get the Base64Url-encoded SHA256 fingerprint peer for peers with self-signed certificates, run a command like this for the specified chainweb-node NODE: For example, to get the peer id for a testnet bootstrap server: The output from running this command is the peer id: Chainweb node information model Parameter Type Description nodeNumberOfChains (required) integer >= 10 Number of chains in the network the node is part of. nodeApiVersion (required) string Chainweb API version information for the node. nodeChains (required) Array of strings Chain identifiers for the chains in the network the node is part of. nodeVersion (required) string Network identifier for the network the node is part of. The valid values are \"test-singleton\", \"development\", \"mainnet01\", and \"testnet04\". nodeGraphHistory (required) Array of integers Array of all chain graphs indexed by the height of the first block with the respective graph. Graphs are encoded as adjacency lists. Collection page model Parameter Type Description limit (required) integer >= 0 The maximum number of items in the page. This number can be smaller but never be larger than the number of requested items. next (required) string or null A cursor that can be used to query the next page. It should be used literally as the value for the parameter in a follow-up request. items (required) any The items in the page. Miner information model Parameter Type Description account string Account name is the miner account name. In most cases, the account name is the public key with the prefix. predicate enum The key predicate guard for the account. For accounts with a single key, this is usually . public‑keys Array of strings Miner public key. Mining update event stream model The update event stream model describes the server-sent events that notify miners when new mining work becomes available. The stream is terminated by the server in regular intervals and it is up to the client to request a new stream. Each event consists of a single line. Events are separated by empty lines. Parameter Type Description events Array Each event consists of the string value \"event:New Cut\".",
    "source": "api/chainweb-data-models.md",
    "title": "chainweb-data-models"
  },
  {
    "content": "title: Developer tooling id: tooling sidebar_position: 4 description: \"Install additional tooling for Pact and for smart contract development.\" import CodeBlock from '@theme/CodeBlock'; Developer tooling Although Pact provides the foundations for developing smart contracts for the Kadena network, there are several other tools and extensions you might want to install and configure to complement Pact and provide a more complete development environment. The additional tools you might want to install locally include the following: Pact language server Pact version manager Pact extension for Visual Studio Code Kadena command-line interface Chainweaver wallet and integrated development environment There are also developer tools that are available as web-based applications that you can access through the development lifecycle. Web-based developer tools include the following: Faucet Module explorer Block explorer Pact language server You can install the Pact language server on your local computer to support syntax highlighting and other features in the code editor. Pact version manager The Pact version manager (pactup) is a community-contributed program that enables you to install and manage multiple versions of the Pact programming language and command-line interpreter. For more information about installing and using the version manager, see Pact version manager. Pact extension for Visual Studio Code If you use Visual Studio Code as your integrated development environment (IDE), you can install the Pact extension to streamline your smart contract development experience. Before installing the extension, verify that you have Pact and the Pact Language Server installed. To install the Pact extension: Open Visual Studio Code. Select View, then click Extensions. Type pact in the Search field. Select PactLang, then click Install. If you're prompted to install additional extensions, you should install them to enable the full functionality of the Pact extension. To configure the Pact extension settings: Select Code, Settings, then click Settings and search for pact. Select Pact configuration and configure the settings appropriate for your development environment. Select Enable coverage to enable code coverage reporting for and files. With this option enabled, code coverage is calculated for the file and all of the and files that it loads every time you save a file. Covered lines aree highlighted in green in your editor and uncovered lines aree highlighted in red. To view a code coverage report in HTML format, right-click the file relative to the file that was run. Click Show preview to open the report. To run code coverage for all your files at once, create an entry point file that loads all the other files in your project. You can then open the entry point file and save it to run all of your tests. Select Enable Lsp to enable the Pact Language server. With this option enabled, syntax errors are be highlighted in files and problems are reported in the Visual Studio Code status bar and bottom panel. Select Enable trace to enable the output trace for Pact. With this option enabled, the command runs with the option every time you save a file. The option provides detailed line by line information about and file execution. Set the path to the Pact executable and the Pact Language server executable. If you added the executables to your , you can use and for these settings. Kadena command-line interface The Kadena command-line interface () is a node.js package that provides direct access to the Kadena blockchain and to commands that help you create, test, deploy, and manage applications for the Kadena network. You can use the Kadena command-line interface to perform many common tasks interactively. You can also use commands in scripts and automated workflows that don't allow interactive input. To install the package: Open a terminal shell on the computer where you want to install the package. Verify that you have , version 18 or later, and the or package manager installed. For example, check that you have node and npm installed by running the following commands: Use the or package manager to install globally. For example, to install globally using npm, run following command: Verify the package is installed and display usage information by typing and pressing Return: Prepare a development workspace with initial settings by running the following command: This command creates the configuration folder location in your current working directory and adds default network settings to a subfolder, then prompts you to create a wallet. For example: If you already have keys and an account or an existing wallet that you want to use, you can select No to end the interactive session. However, wallets are an important part of interacting with any blockchain, so you can follow the prompts displayed to create a new local wallet and account as part of your initial configuration. For more information about using the Kadena CLI as your primary interface for development tasks, see Develop with kadena-cli. For command-line reference information, see Kadena CLI. Chainweaver wallet and IDE Chainweaver is a combination wallet and integrated development environment that enables you to manage accounts and keys, sign transactions, and edit, call, and deploy smart contracts. Chainweaver is avaiable as a desktop application or as a browser-based web application. With Chainweaver, you can build, test, and iterate on your smart contracts before deploying them to your local development network, the Kadena test network, or the Kadena main network. As an integrated development environment (IDE), you can also use Chainweaver to: Explore smart contract modules and functions, including sample applications and default contracts. Define and manage authorization rules using keysets. Connect to and deploy smart contracts on your local development network, the Kadena test network, or the Kadena main network. Edit, update, and execute smart contract code. If you don't already have a Chainweaver account, you should create one using either the After you download and install the desktop application or open Chainweaver in a browser, you can create a wallet and accounts to interact with Kadena networks. For more information about using Chainweaver as your primary interface for development tasks, see Develop with Chainweaver.",
    "source": "smart-contracts/install/tooling.md",
    "title": "tooling"
  },
  {
    "content": "title: Install on Windows id: windows sidebar_position: 2 description: \"Install the Pact smart contract programming language on the Windows Subsystem for Linux.\" import CodeBlock from '@theme/CodeBlock'; Install on Windows Subsystem for Linux (WSL) You can install Pact on Microsoft Windows if you first install and configure the Windows Subsystem for Linux (WSL) on Windows 10, or later, or on Windows Server 2019, or later. After you install and configure the WSL, you can install Pact from the Pact Linux release archive. Prerequisites Before you can install Pact on Microsoft Windows, you must install and configure the Windows Subsystem for Linux (WSL). For complete WSL installation instructions, see Install WSL or Install on Windows Server. To set up WSL: Click Start to select Windows PowerShell, then click Run as Administrator. Run the following command to enable WSL and install the Ubuntu distribution: Restart the Windows computer to complete the WSL installation. After restarting, click Start to select the Ubuntu virtual machine and follow the instructions displayed to create a new user account and complete the setup process. In addition to setting up WSL, if you are installing Pact 4.x, you should note that this version of Pact requires the theorem prover from Microsoft Research to support formal verification. Starting with Pact 5, Pact no longer supports formal verification using the theorem prover. If you are installing Pact 5, or later, you can continue to the Installation instructions. If you are installing Pact 4.x, you can install and verify the installation of the package on Linux by running the following commands: If is installed properly, you should see output similar to the following: Installation instructions To install Pact on Window Subsystem for Linux (WSL): Navigate to the appropriate Pact Releases page: Pact 4 Releases to download the latest stable version of Pact 4.x. Pact 5 Releases to download the latest version of Pact 5. Download the latest file for the Linux operating system and architecture you use. Open a terminal and extract the downloaded compressed archive by running the following command: Navigate to the extracted directory: Move the binary to a directory in your system , or update your variable. For example, to move the binary from the current working directory to the directory and update the : Reload the shell configuration. For example, reload the configuration for the shell by running the following command: Replace with if you use the shell. Verify the installation by checking the Pact version: View usage information for the pact interactive interpreter by running the following command: For more information about the command-line options, see Pact command-line interpreter. For an introduction to Pact programming and language features, see Pact features and conventions. Troubleshooting If you encounter issues, check the following: Check the Pact version and, if Pact, version 4.x, is installed, verify that you have installed. This command should display output similar to the following: If the Pact version is 4.x, check for the z3 package by running the following command: If is installed correctly, the command should display output similar to the following: If necessary, install z3 by running the following commands: Verify the binary can be located and is in a directory included in your environment variable. First check the path to the binary by running the following command: This command should display the current path to the binary. For example: If the command doesn't display the path to the binary, you should try reinstalling from the prebuilt release archive or from the source code. If the command displays the path to the binary, check the environment variable to verify the path the the binary is include by running the following command: This command should display output similar to the following: The output should include the directory where the binary is located. If the PATH environment variable doesn't include the directory, open your shell profile—for example, the or file—in a text editor. Add the following line at the end of the file: Save the shell profile file and exit. Open a new terminal or reload the shell profile to complete the update. Check Pact GitHub Issues for known issues or to report a problem with installing Pact.",
    "source": "smart-contracts/install/on-windows.md",
    "title": "on-windows"
  },
  {
    "content": "title: Install on macOS id: macos sidebar_position: 2 description: \"Install the Pact smart contract programming language on macOS computers.\" import CodeBlock from '@theme/CodeBlock'; Install on macOS You can install Pact on macOS by using the Homebrew package manager or by downloading and installing the appropriate binary for the local system architecture. Prerequisites If you want to install Pact on macOS using the Homebrew package manager (recommended), you should verify that you have Homebrew installed by running the following command: This command should display output similar to the following: If you don't have Homebrew installed, see Homebrew for installation instructions and additional information about using the package manager. In addition to Homebrew, if you are installing Pact 4.x, you should note that this version of Pact requires the theorem prover from Microsoft Research to support formal verification. Starting with Pact 5, Pact no longer supports formal verification using the theorem prover. If you are installing Pact 5, or later, you can continue to the Installation instructions. If you are installing Pact 4.x, you can install and verify the installation of the package on Linux by running the following commands: If is installed properly, you should see output similar to the following: Installation instructions To install Pact on macOS using Homebrew: Open a terminal shell on your local computer. Update the package manager by running the following command: Install the binary and related dependencies by running the following command: Verify the installation by checking the Pact version: View usage information for the pact interactive interpreter by running the following command: For more information about the command-line options, see Pact command-line interpreter. For an introduction to Pact programming and language features, see Pact features and conventions. To install Pact on macOS from a compressed archive: Navigate to the appropriate Pact Releases page: Pact 4 Releases to download the latest stable version of Pact 4.x. Pact 5 Releases to download the latest version of Pact 5. Download the latest file for the macOS operating system and architecture you use. Double-click the downloaded file to extract the contents. Use the Finder to navigate to the binary in the extracted directory, select the binary, right-click, then click Open. Click Open to override system setting settings: Troubleshooting If you encounter issues, check the following: Check the Pact version and, if Pact, version 4.x, is installed, verify that you have installed. This command should display output similar to the following: If the Pact version is 4.x, check for the z3 package by running the following command: If is installed correctly, the command should display output similar to the following: If necessary, install by running the following command: Verify the binary can be located and is in a directory included in your environment variable. First check the path to the binary by running the following command: This command should display the current path to the binary. For example: If the command doesn't display the path to the binary, you should try reinstalling using , from the prebuilt release archive, or from the source code. If the command displays the path to the binary, check the environment variable to verify the path the the binary is include by running the following command: This command should display output similar to the following: The output should include the directory where the binary is located. If the PATH environment variable doesn't include the directory, open your shell profile—for example, the or file—in a text editor. Add the following line at the end of the file: Save the shell profile file and exit. Open a new terminal or reload the shell profile to complete the update. Check Pact GitHub Issues for known issues or to report a problem with installing Pact.",
    "source": "smart-contracts/install/on-macos.md",
    "title": "on-macos"
  },
  {
    "content": "title: Install on Linux id: linux sidebar_position: 1 description: \"Install the Pact smart contract programming language on Linux computers.\" import CodeBlock from '@theme/CodeBlock'; Install Pact on Linux You can download and install the Pact programming language and interactive interpreter locally on your local computer as prebuilt binary file from a release archive or build Pact directly from its source code. Prerequisites If you are installing Pact 4.x, you should note that this version of Pact requires the theorem prover from Microsoft Research to support formal verification. Starting with Pact 5, Pact no longer supports formal verification using the theorem prover. If you are installing Pact 5, or later, you can continue to the Installation instructions. If you are installing Pact 4.x, you can install and verify the installation of the package on Linux by running the following commands: If is installed properly, you should see output similar to the following: Installation instructions To install Pact on Linux: Navigate to the appropriate Pact Releases page: Pact Releases to download the latest stable version of Pact 4.x. Pact 5 Releases to download the latest version of Pact 5. Download the latest file for the Linux operating system and architecture you use. Open a terminal and extract the downloaded compressed archive by running the following command: Navigate to the extracted directory: Move the binary to a directory in your system , or update your variable. For example, to move the binary from the current working directory to the directory and update the : Reload the shell configuration. For example, reload the configuration for the shell by running the following command: Replace with if you use the shell. Verify the installation by checking the Pact version: View usage information for the pact interactive interpreter by running the following command: For more information about the command-line options, see Pact command-line interpreter. For an introduction to Pact programming and language features, see Pact features and conventions. Troubleshooting If you encounter issues, check the following: Check the Pact version and, if Pact, version 4.x, is installed, verify that you have installed. This command should display output similar to the following: If the Pact version is 4.x, check for the z3 package by running the following command: If is installed correctly, the command should display output similar to the following: If necessary, install z3 by running the following commands: Verify the binary can be located and is in a directory included in your environment variable. First check the path to the binary by running the following command: This command should display the current path to the binary. For example: If the command doesn't display the path to the binary, you should try reinstalling from the prebuilt release archive or from the source code. If the command displays the path to the binary, check the environment variable to verify the path the the binary is include by running the following command: This command should display output similar to the following: The output should include the directory where the binary is located. If the PATH environment variable doesn't include the directory, open your shell profile—for example, the or file—in a text editor. Add the following line at the end of the file: Save the shell profile file and exit. Open a new terminal or reload the shell profile to complete the update. Check Pact GitHub Issues for known issues or to report a problem with installing Pact.",
    "source": "smart-contracts/install/on-linux.md",
    "title": "on-linux"
  },
  {
    "content": "title: Migrating to Pact 5 id: migrating-to-pact5 sidebar_position: 4 description: \"Update your development environment and smart contracts to use the Pact 5 smart contract language and command-line interpreter.\" Migrating to Pact 5 The Pact programming language was designed to optimize the transactional logic in smart contracts executed in a resource-constrained blockchain environment. Pact 5 represents a comprehensive refactoring of the Pact language and command-line interpreter that offers improvements in efficiency, performance, and ergonomics. The improvements in Pact 5 ensure lower transaction costs, faster module loading, and enhanced testing and debugging capabilities. To take advantage of these improvements, you need to update your development environment and smart contracts to use Pact 5. This article covers the basics of upgrading to Pact 5 and details some of the breaking changes that might require you to update and redeploy existing contracts or fix potential coding errors. The timeline for migrating to Pact 5 looks like this: Chainweb nodes will be upgraded to Pact 5 with the 2.27 release on 29 January 2025. The Kadena main production network () will be upgraded to use Pact 5 on 10 February 2025. The Kadena test network () will be upgraded to use Pact 5 on 6 February 2025. An interim test network () is currently available for testing with Pact 5. The network will be decommissioned and removed from service on 7 February 2025 after the network is upgraded to use Pact 5. Preparing to migrate Ideally, you should test any smart contracts you've written by installing Pact 5 locally before Pact 5 is released on the Kadena main production network. If you install Pact 5 locally in your development environment, you can run all of your existing contract tests that you've defined in REPL files using the Pact 5 binary to verify that they work as expected. For information about installing the Pact 5 binary locally, see Installation and setup. You can also test that existing smart contracts work with Pact 5 by deploying them on the Kadena network. You can connect to the network by using the API node available at . For examples of how to deploy contracts, see the Deploy smart contracts guide. Pact 5 will also be deployed by default on the network that you can run locally beginning with the 2.27 release. After 2.27 is released, you can start a local development node to build and test contracts using Pact 5 by default. After upgrading to Pact 5 Most smart contracts written in Pact 4, or earlier, should be compatible with Pact 5 and continue to operate as expected without any issues. However, some of the bugs that were found in earlier versions of Pact and corrected in the Pact 5 implementation might cause unexpected behavior in your contracts or require some type of modification to the contract code. You can find details about new features and the types of issues you might encounter in the remainder of this document. You don't need to redeploy any existing contracts to use Pact 5. However, redeploying will reduce the gas required to execute contract functions, because the newly-deployed version will use the Pact 5 on-disk format. Pact 5 includes a new built-in function for redeploying contracts, so you can take advantage of reduced transaction costs without modifying any contract code or module hashes. Semantic changes Pact 5 includes some changes to correct previously allowed but unintended behavior. These changes might require you to modify your smart contract to conform to Pact 5 that enforces expected behavior. Code examples illustrate the old behavior and how to modify your contract, if necessary. Duplicate capabilities cannot be installed In Pact 4, you could install a managed capability with identical parameters multiple times and specify a different value for the managed parameter in each expression. This behavior was not the way the was intended to be used. Using the function in this way didn't introduce any security issues because you can't install a capability to override a managed parameter specified in a signature. However, the code did result in unexpected behavior as illustrated in the following code sample: As illustrated in this example, Pact 4 allows you to install the capability twice, but it selects the lexicographically smallest managed parameter. In this case, because comes before , so the capability is selected instead of the capability, leading to the following output: Pact 5 does not allow installing duplicate capabilities, as shown below: In most cases, you can correct this issue by simply deleting the invocation of in your smart contracts because most managed capabilities are signed for, and thus implicitly installed. Using install-capability is only supported for managed capabilities In Pact 4, you can use the function with any capability, regardless of whether it is a managed capability. However, the sole purpose of this function is to track the value of a managed parameter. Using this function with a capability that isn't a managed capability has no effect. The following code is a minimal reproduction: If you execute this code in Pact 4, the output doesn't report this behavior as an error: To prevent mistakes, Pact 5 is more strict, disallowing this behavior: Acquiring module administrator privileges for operations Pact requires module administrator privileges to be acquired before performing the following operations: Upgrading a module. Accessing or modifying a table. Acquiring capabilities using the function. Pact 4 automatically attempts to acquire the module administrator privileges when executing these operations. To prevent contracts from accidentally executing privileged actions, Pact 5 no longer automatically acquires the module administrator privileges except in the case of upgrading a module. To acquire module administrator privileges explicitly, you can use the new built-in function, This change makes security boundaries between modules much clearer. For example, in the following contract code, the user Bob acquires module administrator privileges by writing directly to the table and gives himself a balance of using Pact 4: In this example, the administrator privileges are granted implicitly for the transaction that contains the function, and the result that gives Bob a balance of 10000000000000 coins might be difficult to spot. In Pact 5, Bob must explicitly acquire the administrative rights for the module. For example: By acquiring the administrative rights before sending the transaction, it's clearer that the code is performing an administrative operation. Note that this change doesn't affect module deployment or upgrade transactions. Module administrator privileges are requested automatically to redeploy a module. Module hashing In Pact 4, the same contract code would always yield the same module hash. In Pact 5, a module’s hash is computed from both the module itself and the modules it depends on, increasing reliability and integrity. The following REPL script illustrates this: The output for this code in Pact 4 looks like this: Notice that despite the change in the hash of , the hash for the module doesn't change. This is no longer the case in Pact 5. In Pact 5, the output for this code looks like this: In the Pact 5 output, the hash for the module reflects the change in the dependencies. This change is required for integrity, because otherwise, modules with the same hash can behave differently. Function names and variable identifiers In Pact 4, it was possible to use variable identifiers with the same name as built-in functions. For example, in Pact 4, you can write a function like the following that uses as a variable identifier: However, is a reserved keyword for a built-in function. In Pact 4, you are allowed to override or shadow the function name. Pact 5 doesn't allow this behavior, and variables that use the same name as a built-in function resolve as the built-in function. If you use any variable identifiers with the same name as a built-in function name, you should modify the variable identifier to use a different name if you want to redeploy the contract as a Pact 5 contract. For a list of the reserved built-in function names, see Function quick reference. For a list of reserved keywords, see Syntax and keywords. Integers returned as objects In Pact 5, functions that return integer values return an object with as the key field and a number as a string or a JSON number. For example, you might see a return value similar to the following: According to the Pact specification for encoding and decoding values, if you return a raw JSON number without the field, the value is a double. If a function returns an object with the field and a number, the value is an integer. In Pact 4, integer values that were returned as objects were silently converted to doubles in results. The silent conversion of integers to doubles caused tests that were written to expect integer values to fail. In Pact 5, values are returned as described by the Pact codec. Integer values are always returned as objects and raw JSON numbers are always interpreted as doubles. Changed or removed built-in functions was usable in the REPL and with the endpoint to determine the current Pact version. It was removed in Pact 5 due to time constraints. was usable in the REPL and with the endpoint to assert on the current Pact version. It was removed in Pact 5 due to time constraints. was removed in Pact 5 after it was deprecated with a warning and increased gas costs in Pact 4. is equivalent to . and have been removed in Pact 5 due to time constraints and lack of users. has changed in Pact 5. It now accepts exactly two arguments, and behaves as if it were . was removed in Pact 5 due to time constraints and lack of users. New built-in functions The following functions are new in Pact 5. is a new special form that you can use to sequence statements. For example: is a new function that you can use to explicitly acquire module administrator privileges as described in Acquiring module administrator privileges for operations. is a new function that you can use to redeploy existing modules into their Pact 5 format, making them cheaper and faster to load, without changing the contract code or updating the contract dependencies. Note that the use of this function is not a privileged operation. Anyone can do it to any module, and the module hash remains the same. Request and result interface In general, Pact 4 and Pact 5 command requests and command results can be parsed successfully by the Pact 5 parser as follows: Existing Pact 4 command requests can be parsed as Pact 5 commands, and Pact 5 command requests can be parsed as Pact 4 commands. Pact 4 command results can be parsed as Pact 5 command results. Successful Pact 5 command results can be parsed as Pact 4 command results. Pact 5 command results with errors are not valid Pact 4 command results because the error format has changed. Errors in Pact 5 include both a textual description of the error, and a hexadecimal error code to distinguish the exact error case. The executable in Pact 5 can explain these error codes using the option, but they can lack some more specific information from the textual error message. For example: Gas changes Because the Pact interpreter has been structurally changed, Pact 5 has different gas costs than Pact 4. Pact 5 also uses more precise methods to determine the gas costs for certain built-in functions. In practice, most functions require less gas when executed with Pact 5. However, the only way to be sure your transactions don't exceed gas limits is to test them using Pact 5, either by running smart contracts on , or by executing functions locally in a Pact 5 REPL. In addition to lower gas costs, Pact 5 is stricter in checking the signature used to buy gas. In Pact 4, you could successfully sign for the capability even if you included extra arguments, such as or . In Pact 5, you can only sign for the capability with . Formal verification The Pact 4 formal verification system is tightly coupled to the internal implementation of Pact 4. Because Pact 5 is a complete re-implementation of the Pact language and command-line interpreter, Pact 5 doesn't support the Pact 4 formal verification system. A new formal verification system compatible with Pact 5 isn't available at this time. However, plans for improving or simplifying formal verification for Pact 5 contracts have been discussed and remain under consideration. Parser fixes In Pact 4, parser bugs allowed some syntactically invalid code to be parsed. Executing this invalid code often caused unexpected behavior. This section describes the most common syntactic errors that were found on-chain that are now disallowed by Pact 5, and how to fix them. Let-expressions binding multiple expressions to the same variable This is syntactically incorrect, as each let-bound variable can only bind one expression. In Pact 4, this code is parsed successfully, with the result that is never evaluated. Invalid object types The correct syntax for object types is where is a user-defined schema, not . In Pact 4, this will lead to errors at runtime when invoking . Binding lists missing commas In the following module, the expression is missing a comma between the bindings of the and variables: To fix this issue, add the comma to the expression. For example: Schemas are no longer allowed in terms In Pact, a schema is essentially a type definition for an object type. The schema type itself is not a value. The following example is thus invalid: In this example, the user intended to read the location at from the table , but instead wrote , which is the schema. It’s not uncommon for a user to name a schema in a similar fashion as the table that holds object of that schema. In Pact 4, this code can be deployed, and leads to a hard-to-debug issue with a strange error message. In Pact 5, this code cannot be deployed at all. Running the above code with Pact 4 results in the following output: In Pact 5, the code output looks like this:",
    "source": "smart-contracts/install/migrate-pact5.md",
    "title": "migrate-pact5"
  },
  {
    "content": "title: Local development network id: local-dev-node sidebar_position: 5 description: \"Start a local development network with a standalone blockchain node.\" Set up a development network Computers that run the Chainweb network software—the program—are a crucial component of the Kadena blockchain. Nodes provide the compute, storage, and network resources that enable the Kadena blockchain to be secure and decentralized. Nodes also provide the engine for transaction processing, data verification, and executing smart contract functions. Because of the role they play in receiving and processing transactions, it's important to include at least one standalone node as part of your development environment. In most cases, you can run a single node to establish a local development network that you can then use to test smart contract operations in an isolated and controlled environment before deploying to a public test or production network. There are two primary ways you can set up a local development network that includes the program: You can download a complete local development network that includes the program, a local block explorer, the Pact interpreter that runs in a browser, and other tools. With this option, you can use a default set of tools and configuration settings from a Docker image to run the development network inside of a Docker container. For instructions, see Start the development network. You can download and run the program as a standalone release binary from its GitHub repository. With this option, you can manually select the tools and configuration settings you want the node to use. For instructions, see Install a standalone node or chainweb-node. Start the development network If you have Docker installed, the simplest way to get a local node running is to download the latest Docker image for the Kadena development network. The development network in the Docker image includes access to additional tools and installs the most commonly-used contracts by default. To run a instance in a Docker container: Open a terminal shell on your computer. Start the Docker service if it isn't configured to start automatically in your local environment. You can run the command to check whether Docker is currently running. Create a new Docker volume by running the following command: Pull the volume image and start the container by running the following command: Wait for the image to be downloaded to your local environment. Start the local development network by running the following command: After you start the development network, you'll see information about the network processes displayed in a terminal console. Open Kadena Devnet to see more information about the configuration of the local development network and how to access other tools. You can stop the network at any time—and reset the blockchain state—by pressing Ctrl-c in the terminal. Start-up options You can customize the operation of the development network using different command-line settings. For example, if you don't want to create a persistent volume, you can start the network by running the following command: You can stop the network at any time—and reset the blockchain state—by pressing Ctrl-c in the terminal. After you stop the network, restart it using the previous command or one of the commands that follow. If you want to automatically remove the container when you stop it, add the command-line option. For example: If you encounter an error where the version of Chainweb is invalid after a certain date (typically after a service update), run the following command to pull the latest version: If you can't run the Pact executable on your local computer, you can mount the folder for the election project in the Docker container by running the following command: Connect Chainweaver to the development network By default, the Chainweaver wallet and IDE lets you connect to the Kadena test network and the Kadena main network. However, as you start writing Pact modules, you'll want to test and deploy them on your local development network. Before you can do that, you need to configure Chainweaver to connect to the local host and port number running the development network. To add the development network to Chainweaver: Open or unlock Chainweaver. Click Settings in the Chainweaver navigation panel. Click Network. Under Edit Networks, type the network name development, then click Create. Expand the development network, then add the localhost as a node for this network by typing 127.0.0.1:8080. If the local computer is still running the development network Docker container, you should see the dot next to the node turn green. Click Ok to close the network settings. After you click Ok, you can see development selected as your current network. All actions you perform in Chainweaver are now executed on the local development network. Install a standalone node If you want full control over node operations, you might want to install and manage as a standalone local node for development or as a node participating in the Kadena test or production public network. There are several options for setting up a Chainweb node in a physical or virtual environment. For example, you can install and run node binaries: Directly on a physical Linux or macOS computer. On an Linux or macOS instance with infrastructure from a cloud services provider. From a Linux image in a Docker container. You can also build the binaries directly from the source code. Minimum system requirements Before installing Chainweb, you should verify that your computer meets the following minimum recommended hardware requirements for running a node: CPU: Minimum of two (2) CPU cores. RAM: Minimum of four (4) GB of RAM. Storage: Minimum 250 GB using a solid state drive (SSD) or fast hard disk drive (HDD). Network: Publicly-accessible IP address. Operating system: Linux AMD64 architecture. If you also plan to use the node for mining, to submit transactions, or to query blockchain data, you should verify that your computer meets the following minimum recommended hardware requirements: Four (4) CPU cores. Eight (8) GB of RAM. Operating system architecture Most software runs on Linux with AMD64 architectures. If you want to run a Chainweb node on Linux or macOS with ARM64 architecture, you'll need to build the binaries yourself from the source code. You might experience some unexpected behavior when running a node on ARM64 architecture. Note that you should not configure mining for nodes on ARM64 architecture. Running a mining node on ARM64 architecture could cause your node to fork from the network. If you want to run a Chainweb node on Microsoft Windows, you should note that this isn't a supported configuration and requires you to install the latest Windows Services for Linux (WSL) software. If you choose to proceed after installing WSL, you can install the software in the WSL virtual environment rather than using the native Windows operating system. Incoming and outgoing network rules In addition to a publicly-accessible IP address, nodes must be able to communicate with peers and accept incoming messages from other computers in the network. If your computer is behind a firewall or is a virtual guest connecting to the internet through a host computer, you should review your network configuration and open required ports to allow inbound and outbound traffic. For example, you might need to configure port forwarding for port 1789 on your router or host computer to allow inbound connections from remote nodes. Install from release binaries You can download compressed archive files with release binaries for Ubuntu Linux directly from the Releases page in the chainweb-node repository. If you have Ubuntu 20.04 or Ubuntu 22.04 on a physical or virtual machine, downloading the binary is the most straightforward installation path. To install from a release archive: Open a terminal shell on the physical or virtual host with the Ubuntu Linux operating system. Update the system with the latest software by running the following command: Install the required packages by running the following command: If your computer uses the Ubuntu 20.04 operating system, install the package instead of the package. Download the archive file from the Releases page. Note that the archive file naming convention includes the version, compiler version, Ubuntu version, and a commit hash identifier using the following format: For example, the archive file for Ubuntu 22.04 looks like this: Change to the directory that contains the downloaded file—typically, the Downloads folder—or move the file to a new location. Unzip and extract the compressed archive by running a command similar to the following: Verify the binary is ready to use and review command-line configuration options by running the following command: You should see usage information about the configuration settings you can specify as command-line options similar to the following truncated output: From the usage information, you can see that there are a large number of configuration options that you can use to control and operation and behavior of the Chainweb node. Before you start the node, you should review the configuration options and the default values to determine whether you want to make any changes to the configuration of the node. Extract the default configuration settings to create a configuration file for the node by running the following command: If you want to modify any of the default settings or add features that are disabled by default, you can: Edit settings in one or more configuration files. Use corresponding command-line options to control node operations. <!--For more information about editing configuration settings in the configuration file, see Edit the configuration settings.--> <!--For information about using command-line options to control node operations, see the chainweb-node command-line reference.--> Start the node from the release binary by running a command similar to the following:",
    "source": "smart-contracts/install/local-dev-node.md",
    "title": "local-dev-node"
  },
  {
    "content": "scalar-mult Use to multiply a point that lies on the BN254 by a specified integer value. Basic syntax To multiply a point by a specified integer value, use the following syntax: Arguments Use the following arguments to specify the , , and value for multiplication using the Pact function. Argument Type Description string Specifies the type of point to multiply. The valid values are \"g1\" and \"g2\". point Specifies the point on the BN254 curve to be multiplied. integer Specifies the integer value to multiply the point by. Return value The function returns the result of multiplying the specified point by the value. Examples The following example demonstrates how to use the function to multiply the point on curve by the scalar value :",
    "source": "pact-5/zk/scalar-mult.md",
    "title": "scalar-mult"
  },
  {
    "content": "point-add Use to add two points together that lie on the in the Barreto-Naehrig (BN254) elliptic curve. The BN254 curve is a pairing-friendly curve tht can be used for verifying on-chain zero knowledge proof schemes such as Groth16 and PlonK. You can use this function to add point either in Fq or in Fq2. Basic syntax To add two points together that lie on the Barreto-Naehrig (BN254) elliptic curve, use the following syntax: Arguments Use the following arguments to specify the type of addition and the points to be added using the Pact function. Argument Type Description string Specifies the type of point addition to perform. The valid values are \"g1\" and \"g2\". any Specifies the first point to be added. any Specifies the second point to be added. Return value The function returns the result of adding the specified points together. Examples The following example demonstrates how to use the function to add the two specified points together on the BN256 curve in the Pact REPL: In this example, the of addition is and the points are provided as objects with and coordinates.",
    "source": "pact-5/zk/point-add.md",
    "title": "point-add"
  },
  {
    "content": "pairing-check Use to perform pairing and final exponentiation on points in and in the Barreto-Naehrig (BN254) elliptic curve, and check if the result is 1. Basic syntax To perform pairing and final exponentiation on points in and , and check if the result is 1, use the following syntax: Arguments Use the following arguments to specify the lists of points in G1 and G2 for which you want to perform the pairing check using the Pact function. Argument Type Description [any] Specifies the list of points in G1. [any] Specifies the list of points in G2. Return value The function returns a boolean value indicating whether the result of the pairing and final exponentiation is 1. Examples The following example demonstrates how to use the function in the Pact REPL:",
    "source": "pact-5/zk/pairing-check.md",
    "title": "pairing-check"
  },
  {
    "content": "verify-spv Use to perform a platform-specific simplified payment verification (SPV) proof of a specified type for the specified payload. The format of the payload object and the returned object depends on the type of proof you specify. For information about payload types and return values, see platform-specific documentation. For Chainweb nodes, see the Chainweb API specification. Basic syntax To perform an SPV proof of a specified on a specified , use the following syntax: Arguments Use the following arguments to specify the type of SPV proof and the payload for verification using the Pact function. Argument Type Description string Specifies the type of SPV proof to be performed. object Specifies the payload object to be used for verification. Return value The function returns an object whose format depends on the specific platform and the type of SPV proof being performed. Examples The following example demonstrates how to use the function to verify an SPV proof of type using the payload obtained from reading a message:",
    "source": "pact-5/spv/verify-spv.md",
    "title": "verify-spv"
  },
  {
    "content": "xor Use to compute the bitwise exclusive OR (xor) operation between two integer arguments. Basic syntax To compute the bitwise XOR operation between two integers, use the following syntax: Arguments Use the following arguments to specify the integers for the bitwise XOR operation using the Pact function. Argument Type Description integer Specifies the first integer for the XOR operation. integer Specifies the second integer for the XOR operation. Return value The function returns the result of the bitwise XOR operation as an integer. Examples The following examples demonstrate how to use the function to compute the bitwise XOR operation between two integers:",
    "source": "pact-5/operators/xor.md",
    "title": "xor"
  },
  {
    "content": "subtract (-) Use to negate a or to subtract from . Basic syntax To negate , use the following syntax: To subtract from , use the following syntax: Arguments Use the following arguments to specify the values for negation or subtraction using the Pact function. Argument Type Description integer or decimal Specifies the value to be negated. integer or decimal Specifies the value to be subtracted from. integer or decimal Specifies the value to subtract from . Return value The function returns the negation of the specified , or the result of subtracting from . Examples The following example demonstrates how to use the function to negate a value in a Pact REPL: The following example demonstrates how to use the function to subtract integer values in a Pact REPL:",
    "source": "pact-5/operators/sub.md",
    "title": "sub"
  },
  {
    "content": "sqrt Use to compute the square root of the given . Basic syntax To calculate the square root of a value, use the following syntax: Arguments Use the following argument to specify the value for which to compute the square root using the Pact function. Argument Type Description integer or decimal Specifies the value that you want to compute the square root for. Return value The function returns the square root of the specified value. The return type depends on the type of the input value and whether the square root for the input value is a whole number. Examples The following example demonstrates how to use the function to calculate the square root of the integer value 25 that returns an integer value: The following example calculates the square root of the decimal value 144.0 that returns a decimal value: The following example calculates the square root for 48 and rounds the result to four decimal places: This example illustrates how to use the function to compute the square root of a value in Pact, producing either an or a result.",
    "source": "pact-5/operators/sqrt.md",
    "title": "sqrt"
  },
  {
    "content": "shift Use to perform a bitwise shift operation on the integer by bits. If is positive, this function shifts to the left. If is negative, the function shifts to the right. Right shifts perform sign extension on signed number types, filling the top bits with 1 if is negative and with 0 otherwise. Basic syntax To shift the integer by bits, use the following syntax: Arguments Use the following arguments to specify the integer values to be shifted using the Pact function. Argument Type Description integer Specifies the integer value to be shifted. integer Specifies the number of bits to shift by. Return value The function returns the result of shifting by bits. Examples The following example demonstrates how to use the function to shift the integer 255 to the left by 8 bits: The following example demonstrates how to use the function to shift the integer 255 to the right by 1 bit: The following example demonstrates how to use the function to shift the negative integer -255 to the left by 8 bits: The following example demonstrates how to use the function to shift the negative integer -255 to the right by 1 bit: These examples illustrate how to use the function to perform bitwise shift operations on integers in Pact, either to the left or to the right, with sign extension for right shifts on signed numbers.",
    "source": "pact-5/operators/shift.md",
    "title": "shift"
  },
  {
    "content": "power-of (^) Use the exponentiation operator to raise the argument to the power of the argument. You can use this operator with both integer or decimal values. When the operands are integers, the result is an integer if the exponent is not negative. When the operands are decimals or you use a negative exponent, the result is always a decimal. Basic syntax To raise to the power of , use the following syntax: Arguments Use the following arguments to specify the base and exponent for raising to a power using the Pact function. Argument Type Description integer or decimal Specifies the base value. integer or decimal Specifies the exponent value. Return value The function returns the result of raising to the power of . Examples The following example demonstrates how to use the function with integer values to raise to the power of in a Pact REPL: The following example demonstrates how to use the function with decimal values to raise to the power of in a Pact REPL: The following example demonstrates using the function with a negative exponent value:",
    "source": "pact-5/operators/pow.md",
    "title": "pow"
  },
  {
    "content": "or Use to apply a logical OR operation with short-circuit evaluation. Basic syntax To perform a logical OR operation with short-circuit evaluation, use the following syntax: Arguments Use the following arguments to specify the boolean values for which you want to perform the logical OR operation using the Pact function. Argument Type Description bool Specifies the first expression to evaluate that returns the boolean value to perform the logical OR operation on. bool Specifies the second expression to evaluate that returns the boolean value to perform the logical OR operation on. Return value The function returns a boolean value based on the logical OR operation of the input values. Examples The following example demonstrates how to use the function in the Pact REPL: In this example, the function evaluates the expressions and . The boolean value returns for the first expression is because is true. Because the function performs short-circuit evaluation on the results, the function returns because the first expression is true.",
    "source": "pact-5/operators/or.md",
    "title": "or"
  },
  {
    "content": "or? Use to apply a logical OR operation to the results of applying a specified to application functions and , with short-circuit evaluation. You can use any data type for the argument as long as the two functions take that same data type and return the resulting boolean value for the logical OR operation performed by the function. By convention, the data type is used if an argument represents a type-bound parameter like the argument in this function. Basic syntax To apply a logical OR operation to the results of applying a value to two application functions, use the following syntax: Arguments Use the following arguments to specify the functions and the to be applied using the Pact function. Argument Type Description function x: Specifies the first function to apply the specified to. The result of applying the specified value returns a boolean value. function x: Specifies the second function to apply the specified to. The result of applying the specified value returns a boolean value. Specifies the value to apply to both and functions. Return value The function returns a boolean value representing the logical OR operation after evaluating the results from applying the specified value to the two application functions. Examples The following example demonstrates how to use the function in the Pact REPL: In this example, the function applies the value 15 to the function , with the result being because is true. Because the function performs short-circuit evaluation on the results, the function returns because the first condition is true.",
    "source": "pact-5/operators/or-q.md",
    "title": "or-q"
  },
  {
    "content": "not Use to compute the boolean negation of a specified . Basic syntax To compute the boolean negation of the specified , use the following syntax: Arguments Use the following argument to specify the boolean value for which you want to compute the negation using the Pact function. Argument Type Description bool Specifies the expression to evaluate that returns the boolean value to be negated. Return value The function returns the boolean negation of the input value. Examples The following example demonstrates how to use of the function in the Pact REPL: In this example, the expression evaluates to , and the function negates this value, resulting in .",
    "source": "pact-5/operators/not.md",
    "title": "not"
  },
  {
    "content": "not? Use to apply a logical NOT operation to the results of applying a specified to an application function. You can use any data type for the argument as long as the function takes that same data type and returns the resulting boolean value for the logical NOT operation performed by the function. By convention, the data type is used if an argument represents a type-bound parameter like the argument in this function: Basic syntax To apply a logical NOT operation to the results of applying a specified to an application function , use the following syntax: Arguments Use the following arguments to specify the application function and the value to be applied using the Pact function. Argument Type Description function x: Specifies the application function to apply the specified to. The result of applying the specified value returns a boolean value. Specifies the value to be applied to the application function. Return value The function returns a boolean value representing the logical negation of the result of applying the value to the application function. Examples The following example demonstrates how to use the function in the Pact REPL: In this example, the application function is and the value is . Because the expression evaluates to , and negates this value, the function returns .",
    "source": "pact-5/operators/not-q.md",
    "title": "not-q"
  },
  {
    "content": "not-equal (!=) Use to return true if the first argument does not equal the second argument. This function allows you to write conditional logic based on whether two values are not equal. Basic syntax To check if does not equal , use the following syntax: Arguments Use the following arguments to specify the values for comparison using the Pact function. Argument Type Description integer, string, time, decimal, bool, list, object, keyset, guard, or module Specifies the first value for comparison. integer, string, time, decimal, bool, list, object, keyset, guard, or module Specifies the second value for comparison. Return value The function returns true if does not equal , otherwise false. Examples The following example demonstrates how to use the function to check whether two strings are not equal: In the following example, the function ensures that the and accounts are not equal to prevent the sender initiating a transfer from also being the receiver of the transfer:",
    "source": "pact-5/operators/neq.md",
    "title": "neq"
  },
  {
    "content": "multiply (*) Use to multiply the first argument by the second argument. Note that you can use this function to multiply integer values or decimal values. However, you should use the same type for both and values. Basic syntax To multiply by , use the following syntax: Arguments Use the following arguments to specify the values for multiplication using the Pact function. Argument Type Description integer or decimal Specifies the first multiplier. integer or decimal Specifies the second multiplier. Return value The function returns the result of multiplying by . Examples The following example demonstrates how to use the function to multiply two decimal values: The following example demonstrates how to use the function to multiply two integer values: These examples illustrate how to use the function to perform multiplication operations in Pact, facilitating arithmetic calculations with both integer and decimal values.",
    "source": "pact-5/operators/mult.md",
    "title": "mult"
  },
  {
    "content": "mod Use to compute the remainder of divided by . Basic syntax To compute the remainder of divided by , use the following syntax: Arguments Use the following arguments to specify the integers for which you want to compute the remainder using the Pact function. Argument Type Description integer Specifies the dividend. integer Specifies the divisor. Return value The function returns the remainder of the division of by . Examples The following example demonstrates how to use the function to compute the remainder when 13 is divided by 8:",
    "source": "pact-5/operators/mod.md",
    "title": "mod"
  },
  {
    "content": "less-than () Use to return true if the first argument is less than the second argument. Basic syntax To check if is less than , use the following syntax: Arguments Use the following arguments to specify the values for comparison using the Pact function. Argument Type Description integer, decimal, string, or time Specifies the first value for comparison. integer, decimal, string, time Specifies the second value for comparison. Return value The function returns a boolean value indicating whether is less than . Examples The following example demonstrates how to use the function to compare two integer values to check if the first value () is less than the second value ():: The following example demonstrates how to use the function to compare two decimal values to check if the first value () is less than the second value (): The following example demonstrates how to use the function to compare two string values to check if the first value () is less than the second value ():",
    "source": "pact-5/operators/lt.md",
    "title": "lt"
  },
  {
    "content": "log Use to compute the logarithm of the specified with the specified . Basic syntax To compute the logarithm of a specified with the specified , use the following syntax: Arguments Use the following arguments to specify the and for which you want to compute the logarithm using the Pact function. Argument Type Description integer or decimal Specifies the base of the logarithm. integer or decimal Specifies the value for which you want to compute the logarithm. Return value The function returns the logarithm of with base . Examples The following example demonstrates how to use the function to computer the logarithm of 256 with base 2:",
    "source": "pact-5/operators/log.md",
    "title": "log"
  },
  {
    "content": "ln Use to compute the natural logarithm of a specified . Basic syntax To compute the natural logarithm of a value, use the following syntax: Arguments Use the following argument to specify the value for which you want to compute the natural logarithm using the Pact function. Argument Type Description integer or decimal Specifies the value for which you want to compute the natural logarithm. Return value The function returns the natural logarithm of the specified value. Examples The following example demonstrates how to use the function to computer the natural logarithm for the value of 60 and round the result to 6 decimal places:",
    "source": "pact-5/operators/ln.md",
    "title": "ln"
  },
  {
    "content": "less-than-equal () Use to return true if the first argument is less than or equal to the second argument. Basic syntax To check if is less than or equal to , use the following syntax: Arguments Use the following arguments to specify the values for comparison using the Pact function. Argument Type Description Specifies the first value for comparison. Specifies the second value for comparison. Return value The function returns a boolean value indicating whether is less than or equal to . Examples The following example demonstrates how to use the function to compare two integer values to check if the first value () is less than or equal to the second value (): The following example demonstrates how to use the function to compare two decimal values to check if the first value () is less than or equal to the second value (): The following example demonstrates how to use the function to compare two string values to check if the first value () is less than or equal to the second value ():",
    "source": "pact-5/operators/leq.md",
    "title": "leq"
  },
  {
    "content": "greater-than (>) Use to return true if the first argument is greater than the second argument . Basic syntax To check if is greater than , use the following syntax: Arguments Use the following arguments to specify the values for comparison using the Pact function. Argument Type Description integer, decimal, string, or time Specifies the first value for comparison. integer, decimal, string, time Specifies the second value for comparison. Return value The function returns a boolean value indicating whether is greater than . Examples The following example demonstrate how to use the function to compare two integer values to check if the first value () is greater than the second value (): The following example demonstrates how to use the function to compare two decimal values to check if the first value () is greater than the second value (): The following example demonstrates how to use the function to compare two string values to check if the first value () is greater than the second value ():",
    "source": "pact-5/operators/gt.md",
    "title": "gt"
  },
  {
    "content": "greater-than-equal (>=) Use to returns true if the first argument is greater than or equal to the second argument . Basic syntax To check if is greater than or equal to , use the following syntax: Arguments Use the following arguments to specify the values for comparison using the Pact function. Argument Type Description integer, decimal, string, or time Specifies the first value for comparison. integer, decimal, string, or time Specifies the second value for comparison. Return value The function returns a boolean value indicating whether is greater than or equal to . Examples The following example demonstrates how to use the function to compare two integer values to check if the first value () is greater than or equal to the second value (): The following example demonstrates how to use the function to compare two decimal values to check if the first value () is greater than or equal to the second value (): The following example demonstrates how to use the function to compare two string values to check if the first value () is greater than or equal to the second value ():",
    "source": "pact-5/operators/geq.md",
    "title": "geq"
  },
  {
    "content": "floor Use to round down the value of a decimal to an integer, or to a specified number of decimal places. The function is useful for situations where you need to round down decimal values in Pact contracts. Basic syntax To round down a decimal value to an integer, use the following syntax: To round down a decimal value to a specified precision, use the following syntax: Arguments Use the following arguments to specify the decimal value and precision for the Pact function: Argument Type Description decimal Specifies the decimal value to round down. integer Specifies the precision to round down to for the resulting decimal value (optional). Return value The function returns the rounded-down value of the specified decimal: If only is provided, it returns an integer. If is provided, it returns a decimal with the specified precision. Examples The following example demonstrates how to use the function to round down the decimal value to the nearest integer: The following example demonstrates how to use the function to round down the decimal value to a decimal value with a precision of two decimal places: The following example uses the floor function in an expression for calculating a royalty payout:",
    "source": "pact-5/operators/floor.md",
    "title": "floor"
  },
  {
    "content": "exp Use to calculate the exponential function of the specified . Basic syntax To calculate the exponential function of a value, use the following syntax: Arguments Use the following argument to specify the value for the Pact function: Argument Type Description integer or decimal Specifies the value for which to calculate the exponential function. Return value The function returns the exponential function of the specified value. Examples The following example demonstrates how to use the function to calculate the exponential value for three and round the result of this calculation to precision of six decimal places:",
    "source": "pact-5/operators/exp.md",
    "title": "exp"
  },
  {
    "content": "equal (=) Use to return true if the first argument is equal to the second argument . Basic syntax To check if is equal to , use the following syntax: Arguments Use the following arguments to specify the values for comparison using the Pact function. Argument Type Description integer, decimal, string, time, bool, object, list, modref, guard Specifies the first value for comparison. integer, decimal, string, time, bool, object, list, modref, guard Specifies the second value for comparison. Return value The function returns a boolean value indicating whether is equal to . Examples The following example demonstrates how to use the function to compare two integer values to check if the first value is equal to the second value: The following example demonstrates how to use the function to compare two decimal values to check if the first value is equal to the second value: The following example demonstrates how to use the function to compare two string values to check if the first string is equal to the second string: The following example demonstrates how to use the function to compare two time values to check if the first time is equal to the second time: The following example demonstrates how to use the function to compare two object values to check if the first object is equal to the second object: The following example demonstrates how to use the function to compare two list values to check if the first list is equal to the second list: You can also the function to evaluate variables and expressions. For example:",
    "source": "pact-5/operators/eq.md",
    "title": "eq"
  },
  {
    "content": "divide (/) Use to divide the first argument by the second argument . Note that you can use this function to divide integer values or decimal values. However, you should use the same type for both and values. Basic syntax To divide by , use the following syntax: Arguments Use the following arguments to specify the values for division using the Pact function. Argument Type Description integer or decimal Specifies the value of the dividend. integer or decimal Specifies the divisor. Return value The function returns the result of dividing by . Examples The following examples demonstrate how to use the function to divide two values in a Pact REPL:",
    "source": "pact-5/operators/div.md",
    "title": "div"
  },
  {
    "content": "dec Use to convert a specified integer to a decimal value. This function can be useful if you need to work with decimal values in Pact but have integer inputs. Basic syntax To convert a specified integer to a decimal value, use the following syntax: Arguments Use the following argument to specify the integer for the Pact function. Argument Type Description integer Specifies the integer to cast to a decimal value. Return value The function returns the specified integer as a decimal value. Example The following example demonstrates how to use the function:",
    "source": "pact-5/operators/dec.md",
    "title": "dec"
  },
  {
    "content": "ceiling Use to round up the value of a specified decimal to the nearest integer or to a specified precision as a decimal. Basic syntax To round up the value of a decimal to the nearest integer, use the following syntax: To round up the value of a decimal to a specified as a decimal, use the following syntax: Arguments Use the following arguments to specify the decimal and optional for the Pact function. Argument Type Description decimal Specifies the decimal value to round up. integer Specifies the precision to round the specified to (optional). Return value The function returns the rounded-up value as an integer or as a decimal based on the input and precision. Examples The following example rounds up a decimal value to the nearest integer in the Pact REPL: The following example rounds up a decimal value to a precision of 2 decimal places: In this example, rounds up the decimal value to a precision of 2 decimal places, resulting in .",
    "source": "pact-5/operators/ceiling.md",
    "title": "ceiling"
  },
  {
    "content": "bitwise-reverse (~) Use to reverse all bits in the provided integer. Basic syntax To reverse all bits in an integer , use the following syntax: Arguments Use the following argument to specify the integer for bit reversal using the Pact function. Argument Type Description integer Specifies the integer for which to reverse all bits. Return value The function returns the result of reversing all bits in the provided integer. Examples The following example demonstrates how to use the function to reverse all bits in the integer :",
    "source": "pact-5/operators/bitwise-reverse.md",
    "title": "bitwise-reverse"
  },
  {
    "content": "bitwise-or (|) Use to compute the bitwise OR operation between the first integer value and the second integer value. Basic syntax To compute the bitwise OR operation between the and integer values, use the following syntax: Arguments Use the following arguments to specify the integers for the bitwise OR operation using the Pact function. Argument Type Description integer Specifies the first integer for the OR operation. integer Specifies the second integer for the OR operation. Return value The function returns the result of the bitwise OR operation as an integer. Examples The following examples demonstrate how to use the function to perform bitwise OR manipulation between two integers in a Pact REPL:",
    "source": "pact-5/operators/bitwise-or.md",
    "title": "bitwise-or"
  },
  {
    "content": "bitwise-and (&) Use to compute the bitwise AND operation between the first integer value and the second integer value. Basic syntax To compute the bitwise AND operation between and , use the following syntax: Arguments Use the following arguments to specify the values for bitwise AND operation using the Pact function. Argument Type Description integer Specifies the first operand. integer Specifies the second operand. Return value The function returns the result of the bitwise AND operation between and . Examples The following examples demonstrate how to use the function to perform bitwise AND manipulation of integer values in a Pact REPL:",
    "source": "pact-5/operators/bitwise-and.md",
    "title": "bitwise-and"
  },
  {
    "content": "and Use to perform a boolean logic AND operation with short-circuiting. Basic syntax To perform a boolean logic AND operation between two boolean values and , use the following syntax: Arguments Use the following arguments to specify the boolean values for the operation. Argument Type Description bool Specifies the first boolean value for the AND operation. bool Specifies the second boolean value for the AND operation. Return value The function returns a boolean value based on the result of the AND operation between the input boolean values. Examples The following example demonstrates how to use the function to perform a boolean AND operation between the values and in the Pact REPL: The following example illustrates using the function to evaluate two expressions to determine whether an account string is valid: In this example, both expressions must evaluate to true for an account string to be valid.",
    "source": "pact-5/operators/and.md",
    "title": "and"
  },
  {
    "content": "and? Use to apply a logical AND operation to the results of applying a specified to application functions and , with short-circuit evaluation. You can use any data type for the argument as long as the two functions take that same data type and return the resulting boolean value for the logical AND operation performed by the function. By convention, the data type is used if an argument represents a type-bound parameter like the argument in this function: Basic syntax To apply a logical AND operation to the results of applying a specified to the functions and , use the following syntax: Arguments Use the following arguments to specify the functions and for the operation. Argument Type Description function x: Specifies the first function to apply the specified to. The result of applying the specified value of type returns a boolean value. function x: Specifies the second function to apply the specified to. The result of applying the specified value of type returns a boolean value. Specifies the value to apply to both and functions. Return value The function returns a boolean value based on the result of applying to and with the logical AND operation. Examples The following example demonstrates how to use the function in the Pact REPL: In this example, the function applies the value 15 to the function , with the result being because is true. The function then applies the value of 15 to the function, with the result being false because is false. The result from the function, therefore, is because the second condition is false.",
    "source": "pact-5/operators/and-q.md",
    "title": "and-q"
  },
  {
    "content": "add (+) Use to add numbers, concatenate strings and lists, or merge objects. Basic syntax To add numbers, concatenate strings and lists, or merge objects, use the following syntax: Arguments Use the following arguments to specify the values for addition, concatenation, or merging using the Pact function. Argument Type Description integer, decimal, string, [list], or object Specifies the first operand for addition, concatenation, or merging. integer, decimal, string, [list], or object Specifies the second operand for addition, concatenation, or merging. Return value The function returns the result of addition for numbers, the concatenated string or list for strings and lists, or the resulting of merging for objects. Examples The following examples demonstrate how to use the function to add two numbers in the Pact REPL: The following examples demonstrate how to use the function to concatenate strings and lists in the Pact REPL: The following example demonstrates how to use the function to merge objects in the Pact REPL: In this example, merging the object fields using the function results in the first operand value replacing the corresponding field in the second operand.",
    "source": "pact-5/operators/add.md",
    "title": "add"
  },
  {
    "content": "abs Use to calculate the absolute value of a given . Basic syntax To calculate the absolute value of a , use the following syntax: Arguments Use the following argument to specify the for which you want to calculate the absolute value using the Pact function. Argument Type Description decimal or integer Specifies the number for which to calculate the absolute value. Return value The function returns the absolute value of the as a or , depending on the input type. Examples The following example calculates the absolute value of a decimal number in the Pact REPL: The following example calculates the absolute value of an integer:",
    "source": "pact-5/operators/abs.md",
    "title": "abs"
  },
  {
    "content": "typecheck Use to run the Pact static type checker on a specified name. Basic syntax To run the static type checker on a specified name, use the following syntax: Arguments Use the following argument when calling the function: Argument Type Description string Specifies the name of the module to run the static type checker on. Return value If type checking for the module is successful, the function returns the unit value . If type checking fails, the function returns an error. Examples The following example demonstrates a simple file with the module declaration for a module that then calls the static type checker to check the module: If you execute the code in the file by running , you see the results of type checking for the module. For example: If you specify a namespace before the module declaration, you must include the namespace when you call the function. For example, if the module declaration comes after entering the namespace, you would call the function like this:",
    "source": "pact-5/repl/typecheck.md",
    "title": "typecheck"
  },
  {
    "content": "test-capability Use to acquire or install the specified. You can use this function to acquire any capability that's not managed or to install any managed capability. The specified capability and any composed capabilities it encompasses are in scope for the rest of the transaction. Basic syntax To acquire or install the specified, use the following syntax: Arguments Use the following argument when using the Pact function. Argument Type Description capability-token Specifies the capability and scope to test. Return value The function returns a string that indicates whether the capability has been installed or acquired. Example The following example demonstrates how to use to acquire a capability for the scope of a REPL transaction: In this example, the capability isn't a managed capability and doesn't require any arguments. Managed capabilities define a resource that the capability controls access to and a management function that modifies the resource. For example, you might define a managed capability and management function similar to the following: For this example, the managed capability requires the , , and arguments:",
    "source": "pact-5/repl/test-capability.md",
    "title": "test-capability"
  },
  {
    "content": "sig-keyset Use as a convenience to build a keyset from keys present in message signatures, using 'keys-all' as the predicate. Basic syntax To build a keyset from keys present in message signatures, use the following syntax: Arguments The function does not take any arguments. Return value The function returns a keyset constructed from all of the signatures specified in the transaction environment data. In most cases, signatures are defined in files or when using the REPL interactively using the function. Example The following example demonstrates how to use to construct a keyset guard from the signatures defined for a transaction:",
    "source": "pact-5/repl/sig-keyset.md",
    "title": "sig-keyset"
  },
  {
    "content": "rollback-tx Use to roll back the current transaction. In most cases, you include this function in files that test specific application features and failure scenarios. Within the context of a transaction started using the function, you can set environment data, load modules, and execute functions. You use the function to signal the end of a transaction block that needs to be rolled back and can be followed by additional and blocks. Basic syntax To roll back a transaction, use the following syntax: Arguments The function does not take any arguments. Return value The function returns a string indicating the transaction identifier that has been rolled back. Examples The following example demonstrates how to use the function within a Pact REPL: In this example, a new transaction—Tx0—is started using , and then is called to roll back the changes from the transaction. The function returns a string indicating that \"Tx 0\" has been rolled back. Note that you should only call the function after performing the necessary operations within a transaction. The function finalizes the transaction, and any changes made during the transaction are rolled back. It's important that you always call the function after and after any other transaction-related operations to properly roll back the transaction. If is not called, the transaction remains open and might result in unexpected behavior or inconsistencies if you are expecting changes to be undone.",
    "source": "pact-5/repl/rollback-tx.md",
    "title": "rollback-tx"
  },
  {
    "content": "print Use to convert a into a string and print it to the REPL logger (usually standard out). Basic syntax To convert a into a string and print it as REPL output, use the following syntax: Arguments Use the following argument to specify the value to be converted into a string and printed using the Pact function. Argument Type Description any Specifies the value to be converted into a string and printed. Return value The function returns the unit value . Examples The following example demonstrates how to use the function to convert a value to a string in the Pact REPL and print it:",
    "source": "pact-5/repl/print.md",
    "title": "print"
  },
  {
    "content": "pact-state Use to inspect state from most the recent defpact step execution. This function returns an object with the following fields: : defpact identifier. : yield result or false if the step didn't produce a yield. : executed step number. : indicates if step was skipped because entity did not match. You can clear the defpact state from the REPL by including the optional argument set to . Basic syntax To query the current state of the latest defpact execution, use the following syntax: To query and clear the defpact state from the REPL, use the following syntax: Arguments Use the following argument to clear the most recent defpact step executed from the REPL state: Argument Type Description bool Clear the latest executed defpact from the REPL state (optional). Return value This function returns an object with the following fields: : defpact identifier : yield result or false, if the step didn't produce a yield : executed step : indicates if step was skipped because entity did not match Examples The following example demonstrates creating a module with a defpact, executing the first step, then querying the execution context using the function: The following example clears the defpact execution context from the REPL:",
    "source": "pact-5/repl/pact-state.md",
    "title": "pact-state"
  },
  {
    "content": "load Use to load and evaluate a specified or file. You can reset the REPL state before loading the file by including the optional reset argument set to . Basic syntax To load a specific .pact or .repl filename, use the following syntax: Arguments Use the following arguments when using the Pact function. Argument Type Description filename string Specifies the .pact or .repl file you want to load into the Pact REPL. reset bool Resets the REPL state before loading if set to true (optional). Return value The function returns the unit value . Example The following example demonstrates how to use the function to load the file to interact with its function in the Pact REPL without resetting the current Pact REPL state. In this example, the file consists of one expression that is evaluated and returned in the Pact REPL: If you want to clear the REPL state before loading the file, set the optional argument to . For example, to clear previous votes from the Pact REPL before loading the file, add for the argument:",
    "source": "pact-5/repl/load.md",
    "title": "load"
  },
  {
    "content": "expect Use to evaluate an expression and verify that the result equals an expected value. Basic syntax To evaluate an expression that returns an expected result, use the following syntax: Arguments Use the following arguments when using the Pact function. Argument Type Description string Specifies the documentation string describing the expectation. any Specifies the expected value to compare against the result of . any Specifies the expression to evaluate. The expression can be of any Pact type. Return value The function returns a string indicating the success or failure of the expectation. Examples The following example demonstrates how to use the function to evaluate an expression that returns an expected result in a Pact REPL: The following example illustrates using the function to verify that the information expected to be inserted into a table is the same as the result of the function:",
    "source": "pact-5/repl/expect.md",
    "title": "expect"
  },
  {
    "content": "expect-that Use to evaluate an expression and succeed if the resulting value passes a predicate function. You can use any data type for the argument as long as the function can take that same data type and return the resulting boolean value . By convention, the data type is used to represent type-bound parameters that serve as input for functions and expressions or for generic arguments. Basic syntax To evaluate an expression that returns a predicate function, use the following syntax: Arguments Use the following arguments when using the Pact function. Argument Type Description string Specifies the documentation string describing the expectation. value: Specifies the predicate function that takes the result of and returns a boolean. Specifies the expression to evaluate. The expression can be of any Pact type. Return value The function returns a string indicating the success or failure of the expectation. Examples The following example demonstrates how to use the function to evaluate an expression that returns the expected result: The following example demonstrates how to use the function to evaluate an expression that returns fails to return the expected result:",
    "source": "pact-5/repl/expect-that.md",
    "title": "expect-that"
  },
  {
    "content": "expect-failure Use to evaluate an expression and succeed only if the expressions results in an error. This function enables you to verify that use cases that should failbehave as expected. Basic syntax To expect a failure without specifying the error message, use the following syntax: To expect a failure with a specific error message, use the following syntax: Arguments Use the following arguments when using the Pact function. Argument Type Description string Specifies the documentation string describing the expected failure. string Specifies the expected error message (optional). any Specifies the expression to evaluate. The expression can be of any Pact type. Return value The function returns a string indicating the success or failure of the expected failure. If the expression throws an error, the function returns a string indicating the success of the expected failure, for example, . If the expression does not throw an error, the function itself throws an error, indicating that the expected failure did not occur. Examples The following example demonstrates how to use the function without specifying the expected error message: The following example illustrates using the function with a specific expected error message: In this example, the argument describes the test being performed. The argument specifies the error message that is returned when the expression is evaluated.",
    "source": "pact-5/repl/expect-failure.md",
    "title": "expect-failure"
  },
  {
    "content": "env-verifiers Use to set transaction verifier names and capabilities. This function enables you to define a list of objects with the \"name\" key specifying the verifier name, and the \"caps\" key specifying a list of associated capabilities. Basic syntax To set the signature keys for transaction verifiers, use the following syntax: Each verifier is an object that consists of a verifier name and a list of capabilities in the following format: For each object, the is the verifier signature to add to scope, and is the list of capabilities that the is scoped to. Arguments Use the following argument to set verifier information using the Pact function. Argument Type Description [object] Specifies the list verifier objects where each object represents a verifier to add to scope and a list of associated capabilities that the verifier is scoped to. Return value The function returns a string indicating that the transaction verifiers have been set. Examples The following example illustrates using the function to grant the and verifiers.",
    "source": "pact-5/repl/env-verifiers.md",
    "title": "env-verifiers"
  },
  {
    "content": "env-sigs Use to set signature keys for signing transactions and granting capabilities. Basic syntax To set the signature keys to use for signing transactionL and granting capabilities, use the following syntax: Arguments Use the following argument when using the Pact function. Argument Type Description [object] Specifies the list of signature objects. Each object represents a signer and its associated capabilities. Return value The function returns a string indicating that the transaction signature keys and capabilities have been set. Examples The following example demonstrates how to use the function to set two transaction signature keys—\"my-key\" and \"admin-key\"—and capabilities: The following example illustrates using the function to grant \"any\" key the MINT capability:",
    "source": "pact-5/repl/env-sigs.md",
    "title": "env-sigs"
  },
  {
    "content": "env-set-milligas Use to set the current gas state to a specific value in units of one one thousandth of a gas unit. This function is similar to the function, except that one (1) unit of gas is equal to one thousand units of milligas. Basic syntax To set the current milligas state, use the following syntax: Arguments Use the following argument to set the gas state when using the Pact function. Argument Type Description integer Specifies the value to set the milligas state to. Return value When called with the argument, the function returns a string indicating that the gas state has been set to the specified value. Examples In the following example, the function resets the current gas state to 0.01 gas:",
    "source": "pact-5/repl/env-set-milligas.md",
    "title": "env-set-milligas"
  },
  {
    "content": "env-set-debug-flag Use to display the result of the internal tree transformations that the Pact interpreter performs during program execution. This function lets you inspect Pact trees from modules and terms in the way the CEK machine understands them. This function is primarily suitable for advanced debugging. Basic syntax To set the Pact REPL debug flags, use the following syntax: Arguments Use the following argument when using the Pact function. Argument Type Description string Specifies the debug flag to set. The valid values are \"lexer\", \"parser\", and \"desugar\". Return value The function returns debugging details from the Pact interpreter. Examples The following example demonstrates how to use the function to display debugging output from the Pact lexer: The following example illustrates using the function to display lexer, parser, and desugar debugging output from the Pact interpreter:",
    "source": "pact-5/repl/env-set-debug-flag.md",
    "title": "env-set-debug-flag"
  },
  {
    "content": "env-namespace-policy Use to install a managed namespace policy. Basic syntax To install a managed namespace policy, use the following syntax: Arguments Use the following arguments when using the Pact function. Argument Type Description bool Specifies whether to allow root-level namespace creation. If set to , root-level namespaces can be created. If set to , root-level namespace creation is restricted. function Specifies the namespace policy function. This function takes two arguments: the namespace string () and the namespace admin guard (), and returns a boolean value indicating whether the namespace is allowed based on the policy. The function should return if the namespace is allowed, and if it is not. Return value The function returns a string indicating that the namespace policy has been installed. Example The following example demonstrates how to use the function to install a namespace policy in a Pact REPL:",
    "source": "pact-5/repl/env-namespace-policy.md",
    "title": "env-namespace-policy"
  },
  {
    "content": "env-module-admin Use to acquire the module administrative rights for any module loaded in the REPL, bypassing any checks. This function is particularly useful for writing tests that require administrative rights such as the ability to write to non-upgradeable module tables in the REPL. Basic syntax To acquire module administrative rights for the specified, use the following syntax: Note that the must be passed in as a module reference. Arguments Use the following argument when using the Pact function. Argument Type Description modref Specifies the module for which you want to acquire module administrative rights. Return value On success, the function returns a string that indicates the module administrative rights have been acquired. Example The following example demonstrates how to use the function to acquire the module administrative rights for a non upgradeable module.",
    "source": "pact-5/repl/env-module-admin.md",
    "title": "env-module-admin"
  },
  {
    "content": "env-milligas Use to query the current gas state in units of one one thousandth of a gas unit. This function is similar to the function, except that one (1) unit of gas is equal to one thousand units of milligas. This function is useful when writing smart contracts with minimal resource consumption to measure gas costs in smaller units than gas. Basic syntax To query the current gas state in units equal to one thousandth of a single unit of gas, use the following syntax: Arguments The function takes no arguments. Return value When called, the function returns an integer representing the current gas state, in units equal to one thousandth of a single unit of gas (milligas). Examples The following example demonstrates how to use the function to query the current gas state:",
    "source": "pact-5/repl/env-milligas.md",
    "title": "env-milligas"
  },
  {
    "content": "env-keys (DEPRECATED) Use to set the transaction signer keys in older version of the Pact REPL. The function is deprecated in favor of . You should use for setting transaction signer keys with associated capabilities. Basic syntax To set transaction signer keys in older version of the Pact REPL, use the following syntax: Arguments Use the following argument when using the Pact function. Argument Type Description keys [string] Specifies the list of keys to set as transaction signer keys. Return value The function returns a string indicating that the transaction keys have been set. Example The following example demonstrates how to use the function to set \"my-key\" and \"admin-key\" as the current transaction signing keys in a Pact REPL:",
    "source": "pact-5/repl/env-keys.md",
    "title": "env-keys"
  },
  {
    "content": "env-hash Use to set the current transaction hash. Basic syntax To set the current transaction hash, use the following syntax: Arguments Use the following argument when using the Pact function. Argument Type Description string Specifies the hash value to set as the current transaction hash. The hash must be an unpadded base64-url encoded BLAKE2b 256-bit hash. Return value The function returns a string indicating that the transaction hash has been set to the specified value. Example The following example demonstrates how to use the function to set the transaction hash using the base64-url encoded string for the string: The following example illustrates using the function to create a transaction hash for the test transaction that creates a token:",
    "source": "pact-5/repl/env-hash.md",
    "title": "env-hash"
  },
  {
    "content": "env-gasmodel Use to query or update the current gas model. Basic syntax To query the current gas model, use the following syntax: To update the gas model to a table-based cost model, use the following syntax: To update the gas model to a fixed-rate model with a specific rate, use the following syntax: Arguments Use the following arguments when using the Pact function. Argument Type Description string Specifies the gas model to set. The supported gas models are to use a table-based gas model and to use a fixed rate gas model. integer Specifies the fixed rate or every operation. This argument is required if you set the argument to use the gas model. Return value When called with the argument, returns a string indicating the updated gas model. When called without arguments, returns a string describing the current gas model. Examples The following example demonstrates how to use the function to query the current gas model: The following example demonstrates how to use the function to update the current gas model to use a table-based cost model: In the following example, the env-gasmodel function updates the gas model to use a fixed rate of two:",
    "source": "pact-5/repl/env-gasmodel.md",
    "title": "env-gasmodel"
  },
  {
    "content": "env-gaslog Use to enable gas logging for a block of code. You can use this function to check the gas required to execute a specific block of code. Basic syntax To enable gas logging for a specific block of , use the following syntax: Arguments The function does not take any arguments. Return value The function returns the log messages in strings that describe the gas consumed by each operation in the code block. Examples The following example demonstrates how to use the function to report the gas consumed for the specified function: In this example, the message signals the beginning of gas logging for the function. The messages after provide details about how the gas was calculated.",
    "source": "pact-5/repl/env-gaslog.md",
    "title": "env-gaslog"
  },
  {
    "content": "env-gaslimit Use to set the environment gas limit to a specific value. Basic syntax To set the environment gas limit to a specific value, use the following syntax: Arguments Use the following argument to set the gas limit when using the Pact function. Argument Type Description integer Specifies the gas limit to set for the environment. Return value The function returns a string indicating that the gas limit has been set to the specified value. Examples The following example demonstrates how to use the function to set a gas limit for the environment:",
    "source": "pact-5/repl/env-gaslimit.md",
    "title": "env-gaslimit"
  },
  {
    "content": "env-gas Use to query the current gas state or set it to a specific value. Basic syntax To query the current gas state, use the following syntax: To set the gas state to a specific value, use the following syntax: Arguments Use the following argument to set the gas state when using the Pact function. Argument Type Description integer Specifies the value to set the gas state to (optional). Return value When called without arguments, the function returns an integer representing the current gas state. When called with the argument, the function returns a string indicating that the gas state has been set to the specified value. Examples The following example demonstrates how to use the function to query the current gas state: In the following example, the function resets the current gas state to zero:",
    "source": "pact-5/repl/env-gas.md",
    "title": "env-gas"
  },
  {
    "content": "env-exec-config (DEPRECATED) Use to query or set execution configuration information for executing transactions in your testing environment. You can use this function to set one or more of the following configuration flags: \"AllowReadInLocal\" \"DisableHistoryInTransactionalMode\" \"DisableInlineMemCheck\" \"DisableModuleInstall\" \"DisableNewTrans\" \"DisablePact40\" \"DisablePact410\" \"DisablePact42\" \"DisablePact43\" \"DisablePact431\" \"DisablePact44\" \"DisablePact45\" \"DisablePact46\" \"DisablePact47\" \"DisablePact48\" \"DisablePact49\" \"DisablePactEvents\" \"DisableRuntimeReturnTypeChecking\" \"EnforceKeyFormats\" \"OldReadOnlyBehavior\" \"PreserveModuleIfacesBug\" \"PreserveModuleNameBug\" \"PreserveNsModuleInstallBug\" \"PreserveShowDefs\" Basic syntax To look up the current configuration settings, use the following syntax: To set one or more configuration flags, use the following syntax: Arguments Use the following argument to specify the configuration data you want to set using the Pact function. Argument Type Description [string] Specifies the configuration flags you want to be set for the execution environment. Return value The function returns the list of configuration flags that have been set for the execution environment. Examples The following example demonstrates how to use the function to enforce key formats and disable Pact events: The following example demonstrates how to unset previously-set configuration flags using the function: The following example demonstrates how to check the current configuration settings:",
    "source": "pact-5/repl/env-exec-config.md",
    "title": "env-exec-config"
  },
  {
    "content": "env-events Use to retrieve any accumulated events and optionally clear the event state. Basic syntax To retrieve events and clear the event state, use the following syntax: Arguments Use the following argument to specify whether to clear the event state after retrieving the events. Argument Type Description bool Specifies whether to clear the event state after retrieving the events. Note that this argument is required. Set it to to retrieve events, then clear the event state. Set it to retrieve events and keep the event state. Return value The function returns an array of objects representing the accumulated events. Each object in the array has the following fields: : The fully-qualified name of the event. : The parameters associated with the event. : The hash of the module that emitted the event. Examples The following example demonstrates how to retrieve events, then clear the event state: In this example, there were no events to retrieve, so an empty list is returned. The following example retrieves three events—TOKEN, MINT, and ACCOUNT-GUARD—without clearing the event state:",
    "source": "pact-5/repl/env-events.md",
    "title": "env-events"
  },
  {
    "content": "env-enable-repl-natives Use to control whether REPL native functions are allowed in module code. If you set this function to to enable REPL native functions in module code, other environment configuration functions like are allowed in module code, and you can use these functions in your module definitions. If you set this function to to disable REPL native functions in module code, other environment configuration functions are not allowed in module code, and attempting to use them will result in an error. Basic syntax To allow REPL native functions to be used in module code, use the following syntax: Arguments Use the following argument to specify whether to enable or disable REPL native functions in module code. Argument Type Description bool Specifies whether to enable or disable REPL native functions in module code. Note that this argument is required. Set it to to enable REPL native function calls. Set it to to prevent REPL native functions from being called. Return value The function returns a string indicating the status of REPL natives. Examples The following example demonstrates how to enable REPL native functions: After enabling REPL natives, you can use environment configuration functions like in your module code. It's important to note that you should only enable REPL native functions in module code—that is, executable files—if absolutely necessary. Most REPL native functions are intended to be used exclusively in the REPL environment. If you enable access to the REPL native functions in module code, ensure that access to the functions is properly controlled and validated. The following example demonstrates how to disable access to REPL native functions:",
    "source": "pact-5/repl/env-enable-repl-natives.md",
    "title": "env-enable-repl-natives"
  },
  {
    "content": "env-data Use to set transaction data for your testing environment either as an encoded string or as Pact types coerced to JSON format. Basic syntax To set transaction data, use the following syntax: Arguments Use the following argument to specify the JSON data when using the Pact function. Argument Type Description object Specifies the JSON data to be set for the transaction. The data can be provided as an encoded string or as Pact types that will be coerced to JSON. Return value The function returns a string indicating that the transaction data is being set. Examples The following example demonstrates the usage of the function within a Pact REPL: In the following example, the function is used to set up a mock token identifier and account information for testing Marmalade functions:",
    "source": "pact-5/repl/env-data.md",
    "title": "env-data"
  },
  {
    "content": "env-chain-data Use to define chain information for transactions in your testing environment. You can this function to create an object with one or more of the following fields: : The chain identifier (0-19) for the blockchain where the transaction is executed. : The height of the block that includes the transaction. : The timestamp of the block that includes the transaction. : The hash of the previous block. : The sender of the transaction. : The gas limit for the transaction. : The gas price for the transaction. : The gas fee for the transaction. Basic syntax To set one or more chain data fields, use the following syntax: Arguments Use the following argument to specify the chain data you want to set using the Pact function. Argument Type Description object Specifies the chain data you want to be set for the transaction. Return value The function returns an object with the chain data you specify. Examples The following example demonstrates how to use the function to set a chain identifier and block time for a transaction:",
    "source": "pact-5/repl/env-chain-data.md",
    "title": "env-chain-data"
  },
  {
    "content": "continue-pact Use to continue a previously-initiated multi-step transaction defined using a declaration. You must specify the at which to continue. You can also specify optional parameters for rollback, pact ID, and yielded value. Basic syntax To continue a pact with the specified step, use the following syntax: To continue a pact with the specified step and rollback option, use the following syntax: To continue a pact with the specified step, rollback option, and pact ID, use the following syntax: To continue a pact with the specified step, rollback option, pact ID, and yielded value, use the following syntax: Arguments Use the following arguments to customize the behavior of the Pact function. Argument Type Description integer Specifies the step of the pact to continue. bool Specifies whether to perform a rollback (optional). The default is . string Specifies the identifier of the pact to continue (optional). The default is the pact identifier initiated in the current transaction, if one is present. object Specifies the yielded value to be read with the function (optional). If not specified, the function uses the yield from the most recent pact execution, if any. The schema of the yielded object is . Return value The function returns a string indicating the result of continuing the pact. Examples The following example demonstrates how to use the function to continue a pact with step 1: The following example demonstrates how to use the function to continue a pact with step 1 and perform a rollback: The following example demonstrates how to use the function to continue a pact with step 1, without rollback, and specify the pact ID: The following example demonstrates how to use the function to continue a pact with step 2, without rollback, specify the pact ID, and provide a yielded value:",
    "source": "pact-5/repl/continue-pact.md",
    "title": "continue-pact"
  },
  {
    "content": "commit-tx Use to commit the current transaction. In most cases, you include this function in files that test specific application features and failure scenarios. Within the context of a transaction started using the function, you can set environment data, load modules, and execute functions. You use the function to signal the end of a transaction block and can be followed by additional and blocks. Basic syntax To commit a transaction, use the following syntax: Arguments The function does not take any arguments. Return value The function returns a string indicating the transaction identifier that has been committed. Examples The following example demonstrates how to use the function within a Pact REPL: In this example, a new transaction—Tx0—is started using , and then is called to commit the transaction. The function returns a string indicating that \"Tx 0\" has been committed. Note that you should only call the function after performing the necessary operations within a transaction. The function finalizes the transaction, and any changes made during the transaction are persisted. It's important that you always call the function after and after any other transaction-related operations to properly commit the transaction. If is not called, the transaction remains open and may lead to unexpected behavior or inconsistencies in the system.",
    "source": "pact-5/repl/commit-tx.md",
    "title": "commit-tx"
  },
  {
    "content": "begin-tx Use to begin a new transaction with an optional name. This function is used to create tests that you want to execute using the Pact REPL. In most cases, you include this function in files that test specific application features and failure scenarios. Within the context of a transaction, you can set environment data, load modules, and execute functions. To complete the transaction, use the function. The function signals the end of a transaction block and can be followed by additional and blocks. Basic syntax To begin a transaction without a name, use the following syntax: To begin a transaction with a specific name, use the following syntax: Arguments Use the following argument to specify an optional name for the transaction when using the Pact function. Argument Type Description string Specifies the name of the transaction (optional). Return value The function returns a string indicating the transaction identifier and the optional name (if provided). Examples The following example demonstrates how to use the function to begin a new transaction without a name: The following example demonstrates how to use the function to begin a new transaction with a specific name: You can write an empty transaction as a placeholder for the logic to test specific function or failure scenarios. For example, to create a placeholder for the logic that defines a namespace:",
    "source": "pact-5/repl/begin-tx.md",
    "title": "begin-tx"
  },
  {
    "content": "keys Use to return all keys present in a specified table. Basic syntax To retrieve all keys present in a , use the following syntax: Arguments Use the following argument to specify the table from which you want to retrieve keys using the Pact function. Argument Type Description Specifies the table from which keys will be retrieved. Return value The function returns a list of strings containing all keys present in the specified table. Examples The following example demonstrates how to use the function to retrieve all of the keys present in the \"accounts\" table: In this example, all keys present in the \"accounts\" table are returned as a list of strings.",
    "source": "pact-5/keysets/keys.md",
    "title": "keys"
  },
  {
    "content": "keys-all Use as a keyset predicate function to determine if all of the keys defined in the keyset are matched. Basic syntax To check whether all of the keys defined in a keyset are matched, use the following syntax: Arguments Use the following arguments to specify the count of keys in the keyset and the number of matched keys using the Pact function. Argument Type Description integer Specifies the total count of keys defined in the keyset. integer Specifies the number of matched keys. Return value The function returns a boolean value indicating whether all keys in the keyset are matched. Examples The following example demonstrates how to use the function to check whether all of the keys are matched in a keyset where the total number of keys defined is three: The function returns true because all keys in the keyset are matched.",
    "source": "pact-5/keysets/keys-all.md",
    "title": "keys-all"
  },
  {
    "content": "keys-2 Use as a keyset predicate function to determine if there are at least two keys that match the keys defined in a keyset. Basic syntax To check whether there are at least two keys that match the keys defined in a keyset, use the following syntax: Arguments Use the following arguments to specify the count of keys in the keyset and the number of matched keys using the Pact function. Argument Type Description integer Specifies the total count of keys defined in the keyset. integer Specifies the number of matched keys. Return value The function returns a boolean value indicating whether there are at least two keys that match the keys defined in the keyset. Examples The following example demonstrates how to use the to check if at least two keys are matched in a keyset where the total number of keys defined in a keyset is three and only one key is matched: The function returns false because the condition of having at least two keys matched is not met.",
    "source": "pact-5/keysets/keys-2.md",
    "title": "keys-2"
  },
  {
    "content": "enforce-keyset Use to execute a specified or a defined keyset named to enforce the desired predicate logic. Basic syntax To execute a to enforce desired predicate logic, use the following syntax: To require a specified keyset to enforce desired predicate logic, use the following syntax: Arguments Use the following arguments to specify the or for the Pact function: Argument Type Description guard Specifies the guard to execute. string Specifies the name of the defined keyset to enforce. Return value The function returns a boolean value indicating whether the specified guard or keyset predicate logic was enforced. Examples The following example demonstrates how to use the function to enforce logic defined in the \"admin-keyset\" predicate function: If the condition specified by the predicate function is satisfied, the function returns a boolean value of true. The following example enforces the logic defined in the predicate logic: If the condition specified by the predicate function is satisfied, the function returns a boolean value of true.",
    "source": "pact-5/keysets/enforce-keyset.md",
    "title": "enforce-keyset"
  },
  {
    "content": "define-keyset Use to define a keyset with the specified and guard. I you don't specify a keyset guard, the functions reads the specified keyset from the message payload to define its keyset guard, which is similar to using the function. If the keyset already exists, the existing keyset is enforced before updating to the new value. Basic syntax To define a keyset as with , use the following syntax: To read keyset information from the transaction message payload, use the following syntax: Arguments Use the following arguments to specify the inputs for the Pact function: Argument Type Description string Specifies the name of the keyset to define or read. string Specifies the keyset to associate with the . Return value The function returns a string representing the result of defining the keyset. Examples The following example demonstrates how to use the function to define a keyset named \"admin-keyset\" to use the keys and predicate function from the specified \"my-keyset\" object: The following example demonstrates how to read the keyset from the message payload and associate it with : The following example illustrates how to define a keyset by reading an existing keyset:",
    "source": "pact-5/keysets/define-keyset.md",
    "title": "define-keyset"
  },
  {
    "content": "time Use the function to construct a time object from a UTC value using the ISO 8601 standard Universal Time Coordinated (UTC) date time format: The UTC format is the default time format in Pact for all time-related functions. Internally, the time object supports up to microsecond resolution. However, the values returned from the Pact interpreter as JSON are serialized using the default format. If you need higher resolution, you can explicitly format times with the template and related codes. Basic syntax To construct a time object from a UTC value, use the following syntax: Arguments Use the following argument to specify the UTC value for constructing the time object using the Pact function. Argument Type Description string Specifies the UTC value in ISO 8601 format . Return value The function returns a time object constructed from the provided UTC value. Examples The following example demonstrates how to use the function in the Pact REPL. This example constructs a time object from the UTC value : This example illustrates how to use the function to create a time object from a UTC value using the ISO 8601 format in Pact.",
    "source": "pact-5/time/time.md",
    "title": "time"
  },
  {
    "content": "parse-time Use to construct a UTC formatted time string from an input time that uses the specified format. The function accepts format codes that are derived from the formatting time function time templates. For information about all of the time formats and specifiers, see Time formats. The following table provides a summary of the most common time formatting codes: Format Purpose %Y Year with no padding. %m Month of the year, zero-padded to two characters, \"01\"–\"12\" %d Day of the month, zero-padded to two characters, \"01\"–\"31\" %H Hour of the day using a 24-hour clock, zero-padded to two characters, \"00\"–\"23\" %M Minute of of the hour, zero-padded to two characters, \"00\"–\"59\" %S Second of the minute, zero-padded to two characters, \"00\"–\"60\" Note that two percentage characters () are interpreted as a literal percentage sign (), not a time formatting template. Basic syntax To construct a UTC time string from a input time that uses a specified format, use the following syntax: Arguments Use the following arguments to specify the format and input time value for constructing time using the Pact function. Argument Type Description string Specifies the format for parsing the input time to construct the time as a UTC string. string Specifies the input time to be parsed. Return value The function returns a UTC formatted time constructed from the provided input value that uses the specified format. Examples The following example demonstrates the use of in the Pact REPL: In this example, the function constructs a UTC-formatted time value from the input value \"2024-11-06\". The input string uses the format specified in the ISO 8601 standard and identified with the \"%F\" format argument. In the following example, the input string uses the %D and %T format specifiers for date and time: The following example parses an input string that uses the abbreviated month name (%b), the day of the month as a zero-padded string (%d), and the full year (%Y) to a UTC time:",
    "source": "pact-5/time/parse-time.md",
    "title": "parse-time"
  },
  {
    "content": "minutes Use to represent a duration of a specified number of minutes. You can use this function in combination with the function to add a specific number of minutes to a given time. Basic syntax To represent a duration of N minutes, use the following syntax: Arguments Use the following argument to specify the number of minutes for the duration using the Pact function. Argument Type Description or Specifies the number of minutes for the duration. Return value The function returns the duration in decimal format. Examples The following example demonstrates the use of in combination with in the Pact REPL:",
    "source": "pact-5/time/minutes.md",
    "title": "minutes"
  },
  {
    "content": "hours Use the function to calculate a time duration in hours. You can use this function in combination with the function to add a specific number of hours to a given time. Basic syntax The syntax for the function is as follows: Arguments Use the following argument to specify the number of hours for the duration using the Pact function. Argument Type Description integer or decimal Specifies the number of hours as either a decimal or an integer. Return value The function returns a decimal value representing the specified number of hours. Examples The following example illustrates how to use the function with the function to add three hours to the time represented by the string . You can also use the function to convert hours specified as a integer or decimal to return the equivalent time in seconds. For example, you can specify hours as an integer to return the number of seconds: In the following example, the function converts the decimal value 2.5 hours to the equivalent time in seconds. The function is useful for performing time calculations in Pact contracts, such as adding or subtracting specific durations from timestamps.",
    "source": "pact-5/time/hours.md",
    "title": "hours"
  },
  {
    "content": "format-time Use to format a value using a specified . The function is useful for converting time values to human-readable formats in Pact contracts. The function accepts format codes that are derived from the formatting time function time templates. For information about all of the time formats and specifiers, see Time formats. The following table provides a summary of the most common time formatting codes: Format Purpose %Y Year with no padding. %m Month of the year, zero-padded to two characters, \"01\"–\"12\" %d Day of the month, zero-padded to two characters, \"01\"–\"31\" %H Hour of the day using a 24-hour clock, zero-padded to two characters, \"00\"–\"23\" %M Minute of of the hour, zero-padded to two characters, \"00\"–\"59\" %S Second of the minute, zero-padded to two characters, \"00\"–\"60\" Note that two percentage characters () are interpreted as a literal percentage sign (), not a time formatting template. Basic syntax To format a time value using a specified format, use the following syntax: Arguments Use the following arguments to specify the format and time for the Pact function: Argument Type Description string Specifies the format string for the time. time Specifies the time value to format. Return value The function returns a new string with the formatted time value. Examples The following example demonstrates how to use the function to format the time value using the specified format: In this example, is the format string specifying the format of the output. The result of this operation is a formatted string representing the date in the format . The following example demonstrates how to replace the numeric representing the month of the year with the short name for the month:",
    "source": "pact-5/time/format-time.md",
    "title": "format-time"
  },
  {
    "content": "diff-time Use to compute the difference between and in seconds. Basic syntax To compute the difference between and in seconds, use the following syntax: Arguments Use the following arguments to specify the times for the Pact function: Argument Type Description time Specifies the first time for the calculation. time Specifies the second time for the calculation. Return value The function returns the difference between and in seconds as a decimal. Examples The following example demonstrates how to use the function to compute the difference between the times \"16:00:00\" and \"09:30:00\" in seconds: In this example, the function returns the result of this computation as a decimal, representing the time difference between the two specified times.",
    "source": "pact-5/time/diff-time.md",
    "title": "diff-time"
  },
  {
    "content": "days Use to specify a number of days. You can use this function in conjunction with the function to add a specified number of days to a specified time. Basic syntax To specify a number of days, use the following syntax: Arguments Use the following argument to specify the number of days for the Pact function. Argument Type Description decimal or integer Specifies the number of days to add. Return value The function returns the number of seconds in the given number of days as a decimal value. Example The following example demonstrates how to use the function to return the number of seconds in one day as a decimal value: The following example demonstrates how to use the function in combination with : In this example, adds one day to the specified time \"2024-07-22T12:00:00Z\" using the function, enabling straightforward manipulation of time-based information in smart contracts.",
    "source": "pact-5/time/days.md",
    "title": "days"
  },
  {
    "content": "add-time Use to add a specified number of to a given . Basic syntax To add to a , use the following syntax: Arguments Use the following arguments to specify the to which you want to add using the Pact function. Argument Type Description time Specifies the time to which you want to add . decimal or integer Specifies the number of seconds to add to the . Return value The function returns the resulting time after adding the specified number of to the specified . Examples The following example adds 120 seconds to the specified time \"2024-06-22T12:00:00Z\" in the Pact REPL: In most cases, you use the function in combination with other functions such or as follows:",
    "source": "pact-5/time/add-time.md",
    "title": "add-time"
  },
  {
    "content": "write Use to write the specified object in the specified for a given row. The function is similar to the and functions, except that: The function fails if data already exists for the specified row. The function fails if data does not exist for the specified row. In both of these cases, the function can succeed and update the table without failing. Basic syntax To write an entry in a specified for a specific with the provided , use the following syntax: Arguments Use the following arguments to specify the table, key, and object data for writing using the Pact function. Argument Type Description Specifies the table in which to write the entry. string Specifies the key for the entry to be written. object Specifies the object column data to be written for the key. Return value The function returns a indicating the success of the write operation. Examples The following example demonstrates how to use the function to write an entry in the table for the specified key with the provided object column data: This example illustrates inserting data into the balance column in the table using the as the row key.",
    "source": "pact-5/database/write.md",
    "title": "write"
  },
  {
    "content": "with-read Use to read a row from a specified table for a given key and bind columns according to provided bindings over subsequent body statements. Basic syntax To read a row from a and bind columns according to provided , use the following syntax: Arguments Use the following arguments to specify the table, key, bindings, and body for execution using the Pact special form. Argument Type Description Specifies the table from which to read the row. string Specifies the key for which to read the row. Specifies the bindings for columns to be bound. any Specifies the subsequent body statements to be executed. Return value The is a special form returns the result of executing the provided body statements. Examples The following example demonstrates how to use the function to read a row from the table for the specified key and bind the and columns for further processing:",
    "source": "pact-5/database/with-read.md",
    "title": "with-read"
  },
  {
    "content": "with-default-read Use to read a row from a specified table for a given key and bind columns according to provided bindings. If the row is not found, the function reads columns from a default object with matching key names. Basic syntax To read a row from a with values and bind columns according to the provided , use the following syntax: Arguments Use the following arguments to specify the table, key, defaults, bindings, and body for execution using the Pact special form. Argument Type Description Specifies the table from which to read the row. string Specifies the key for which to read the row. object Specifies a default object containing values for missing columns. Specifies the bindings for columns to be bound. any Specifies the subsequent body statements to be executed. Return value The is a special form that returns the result of executing the provided body statements. Examples The following example demonstrates how to use the function to read a row from the table for the specified key, using default values if the row is not found, and binds the and columns for further processing: This example illustrates reading the table with the row key of and setting default values of and for the and columns if the row isn't found to format a default message using the function.",
    "source": "pact-5/database/with-default-read.md",
    "title": "with-default-read"
  },
  {
    "content": "update Use to write an entry in the specified table for a given key with the data provided in the object column. It fails if data does not exist for the specified key. Basic syntax To update an entry in the specified for a specific with the provided column data, use the following syntax: Arguments Use the following arguments to specify the table, key, and object data for updating a table using the Pact function. Argument Type Description Specifies the table in which to update the entry. string Specifies the key for the entry to be updated. object Specifies the object column data to be written for the key. Return value The function returns a string indicating the success of the update operation. Examples The following example demonstrates how to use the function to update an entry in the table for the specified key with the provided object column data: This example illustrates how to use the function to modify an entry in a table with new data in Pact, ensuring that the operation fails if data does not exist for the specified key.",
    "source": "pact-5/database/update.md",
    "title": "update"
  },
  {
    "content": "select Use to retrieve full rows or specified columns from a table by applying a clause to each row to determine whether to include the row or column in the selection. Basic syntax To select full rows from a table based on a clause, use the following syntax: To select specific columns from a table based on a clause, use the following syntax: Arguments Use the following arguments to specify the table, columns, and clause for selecting rows using the Pact function. Argument Type Description Specifies the table from which to select rows matching the where clause. [string] Specifies the list of columns to select from the table matching the where clause (optional). Specifies the clause to apply to each row to determine inclusion. Return value The function returns a list of objects representing the selected rows from the table that satisfy the condition. Examples The following example demonstrates how to use the function to select the columns and from the table where the is equal to \"Fatima\": The following example demonstrates how to select all columns from the table where the is less than 30:",
    "source": "pact-5/database/select.md",
    "title": "select"
  },
  {
    "content": "read Use to retrieve a row from a specified table by its key. You can optionally specify a subset of columns to return. Basic syntax To read an entire row from a table, use the following syntax: To read specific columns from a row in a table, use the following syntax: Arguments Use the following arguments to specify the table, key, and optional columns when using the Pact function. Argument Type Description Specifies the table from which to read the row. In the table schema, a represents the structure of each row in the table. string Specifies the key of the row to read from the table. [string] Specifies one or more column names to return from the row. If not provided, the entire row is returned (optional). Return value The function returns an object representing the requested row or columns from the specified table. If you don't specify one or more as parameters, the function returns an object with the structure of the entire row. If you specify one or more as parameters, the function returns an object containing only the specified columns from the row. Examples he following example demonstrates defining a table schema for an table that stores information about bank accounts, including the balance, currency, and owner of each account: You can then use the function to read a row from the table by its key and retrieve only the and columns:",
    "source": "pact-5/database/read.md",
    "title": "read"
  },
  {
    "content": "list-modules Use to get all of the modules deployed on a particular chain. Note: This function is only allowed in in chainweb. Basic syntax To list all modules in , use Arguments None Return value The function returns a list of all module names (including their namespace) stored on-chain Examples The following example deploys a simple module in the repl, then calls .",
    "source": "pact-5/database/list-modules.md",
    "title": "list-modules"
  },
  {
    "content": "keys Use to retrieve all the keys in a specified table. Basic syntax To retrieve all of the keys for a specified , use the following syntax: Arguments Use the following argument to specify the table from which to retrieve keys using the Pact function. Argument Type Description Specifies the table from which to retrieve keys. In the table schema, a represents the structure of each row in the table. Return value The function returns an array of strings, where each string represents a key in the specified table. Examples The following example demonstrates defining a table schema for an table that stores information about bank accounts, including the balance and owner of each account: You can then retrieve all of the the keys from the table using the function:",
    "source": "pact-5/database/keys.md",
    "title": "keys"
  },
  {
    "content": "insert Use to write an entry in a specified for a given of data. This operation fails if data already exists for the specified key. Basic syntax To insert data into a table for a specified key, use the following syntax: Arguments Use the following arguments to specify the table, key, and object data you want to insert using the Pact function. Argument Type Description Specifies the table where the entry will be written. string Specifies the key for which the data will be inserted. object Specifies the object data to be inserted for the specified key. Return value The function returns a string indicating the success or an exception on failure of the operation. Examples The following example demonstrates how to use the function to insert information into the table for the account specified using the for the account: The following example illustrates a more complete flow from defining the table schema to inserting values into the table:",
    "source": "pact-5/database/insert.md",
    "title": "insert"
  },
  {
    "content": "fold-db Use to select rows from a specified using a predicate with both a key and a value, and then accumulate the results of the query using a function. The output is sorted by the ordering of keys. Basic syntax To select rows from a table, apply a predicate, and accumulate the results using a consumer function, use the following syntax: Arguments Use the following arguments to specify the table, predicate, and consumer function for the Pact function: Argument Type Description Specifies the table from which to select rows. Specifies the predicate function to apply to each row and return a boolean value. function with and Specifies the consumer function used to accumulate results from each row and return the final result from all accumulated results. Return value The function returns a list of accumulated results based on the predicate and the function. Examples The following example demonstrates how to use the function: In this example: is a predicate that selects all rows. is a consumer function that selects the \"firstName\" and \"b\" fields from each row. The function is then used to select rows from the table using the predicate and accumulate the results using the consumer function . The result is a list of accumulated results based on the selected rows and the specified consumer function. The function is useful for iterating over rows in a table and performing operations in Pact contracts.",
    "source": "pact-5/database/fold-db.md",
    "title": "fold-db"
  },
  {
    "content": "describe-table Use to get metadata for a specified . This function returns an object with fields including , , and . Basic syntax To get metadata for a specified , use the following syntax: Arguments Use the following argument to specify the for the Pact function. Argument Type Description Specifies the table to describe. Return value The function returns an object with metadata for the specified . Examples The following example demonstrates use to use the function in the Pact REPL by loading a module that has a table definition: The Pact REPL loads the module and displays the has with output similar to the following:",
    "source": "pact-5/database/describe-table.md",
    "title": "describe-table"
  },
  {
    "content": "describe-module Use to get metadata for a specified . This function returns an object with fields including , , , , and . Note: This function is only allowed in in chainweb. Basic syntax To get metadata for a , use the following syntax: Arguments Use the following argument to specify the for the Pact function. Argument Type Description string Specifies the name of the module to describe. Return value The function returns an object with metadata for the specified . Examples The following example demonstrates how to use function to describe a loaded module: In this example, is used to get metadata for the module named 'm'. The function returns an object providing detailed information about the module.",
    "source": "pact-5/database/describe-module.md",
    "title": "describe-module"
  },
  {
    "content": "describe-keyset Use to retrieve metadata for a specified keyset. Note: You can only use this function at the top level of your code. The function fails if used within module code. Basic syntax To get metadata for the specified name, use the following syntax: Arguments Use the following argument to specify the keyset for which to retrieve metadata using the Pact function. Argument Type Description string Specifies the name of the keyset that you want to retrieve metadata for. Return value The function returns a guard. The returned object includes the following properties: : The predicate function associated with the keyset. : An array of public keys associated with the keyset. Examples The following example retrieves metadata for a keyset named in the Pact REPL:",
    "source": "pact-5/database/describe-keyset.md",
    "title": "describe-keyset"
  },
  {
    "content": "create-table Use to create a table identified by the specified name. Basic syntax To create a table identified by the specified name, use the following syntax: Prerequisites Before using this function in a Pact module, you must define the table fields using the declaration and the table identifier using the declaration. Creating the table is a separate step that is outside of the Pact module where the schema and identifier are defined. Arguments Use the following argument to specify the name you want to create using the Pact function. Argument Type Description Specifies the table to create. Return value The function returns a string representing the identifier of the created . Example The following example demonstrates how to use the function to create a table identified by that can be used for storing account information: The following example illustrates using the function after defining the table schema and table identifier:",
    "source": "pact-5/database/create-table.md",
    "title": "create-table"
  },
  {
    "content": "with-capability Use to apply the access to a specific capability to execute a body of code. This function ensures that an elevated privilege—defined as a capability using a code block—is present during the execution of the provided body of code. You can only call the function in the same module that contains the corresponding declaration. If the token that grants permission to use the specified capability isn't found, the evaluates the capability definition to install or grant the permission token. The permission token is automatically revoked after executing the code body. Nested calls for the same permission token detect the presence of the token and execute the body without reapplying the capability. By convention, capabilities are defined using all uppercase letters. Basic syntax To request the grant of an acquired , use the following syntax: Arguments Use the following arguments to specify the name of the capability and the body of expressions to be executed using the Pact function. Argument Type Description capability Specifies the name of the capability to grant access to. any Specifies the body of expressions to be executed using the granted capability. Return value The function returns the result of executing the provided body of code using the granted capability. Examples The following example demonstrates how to use the function to request access to the capability to execute the code that updates user information: In this example, the function ensures that a sensitive operation can only be executed with an elevated permission granted using the capability.",
    "source": "pact-5/capabilities/with-capability.md",
    "title": "with-capability"
  },
  {
    "content": "require-capability Use to require a specific to be granted before allowing the current body of code to be executed. If the required capability isn't found in the environment, the code fails to execute. By convention, capabilities are defined using all uppercase letters. Basic syntax To test whether a specific has been granted before executing a portion of code in a contract, use the following syntax: Arguments Use the following argument to specify the to be tested for using the Pact function. Argument Type Description Specifies the capability that must be granted before executing a certain portion of code. Return value The function returns a boolean value indicating whether the specified exists in the environment. Examples The following example demonstrates how to use the function to check whether the capability to transfer funds from one source to another has been granted: If the capability isn't found, the function fails. The following example uses the function to create a guard that ensure both the GAS and ALLOW_GAS capabilities have been granted:",
    "source": "pact-5/capabilities/require-capability.md",
    "title": "require-capability"
  },
  {
    "content": "install-capability Use to specify and provision a managed capability. Managed capabilities are defined in declarations that include the keyword. The keyword designates a single parameter to be managed by a specified management function. After a capability is installed, it must still be brought into scope using the function. When the capability is brought into scope, its management function is invoked to validate the request. The management function takes the type of the managed parameter, executes the logic required to validate the requested capability or perform the managed operation, and returns the new managed value that results from the request. The type signature for the management function is , where indicates the type of the managed parameter. For example, assume you define a managed capability as: The management function for this capability would be: Any capability that has static unmanaged parameters will invoke the management function with the current managed value and that of the requested capability. The function should perform whatever logic, presumably linear, to validate the request, and return the new managed value representing the of the request. Note that signatures scoped to a managed capability cause the capability to be automatically provisioned in a manner similar to how capabilities are installed with this function. By convention, capabilities are defined using all uppercase letters. Basic syntax To specify and provision a managed capability, use the following syntax: Arguments Use the following argument to specify the capability you want to install using the Pact function. Argument Type Description any Specifies the capability to be installed. Return value The function returns a boolean value indicating the success or failure of the installation, along with a string message providing additional information. Examples The following example demonstrates how to use the to install a capability named with specified parameters: The following example illustrates the definition for a capability with a management function and a managed parameter. The following example demonstrates the use of in the Pact REPL to install a capability named with specified parameters: If the capability is installed successfully, the function returns a boolean value indicating success. If the capability isn't installed, the function returns an error message indicating the reason for failure.",
    "source": "pact-5/capabilities/install-capability.md",
    "title": "install-capability"
  },
  {
    "content": "emit-event Use to emit a specified as an event without evaluating the body of the capability. This function fails if the specified doesn't include the or keyword in its declaration. By convention, capabilities are defined using all uppercase letters. Basic syntax To emit a as an event without evaluating its body, use the following syntax: Arguments Use the following argument to specify the for the Pact function. Argument Type Description capability Specifies the capability to emit as an event. Return value The function returns a boolean value indicating success or failure of emitting the event. Examples The following example demonstrates how to use the function to emit an event for the capability with the parameters , , and : The function returns a boolean value indicating the success or failure of emitting the event.",
    "source": "pact-5/capabilities/emit-event.md",
    "title": "emit-event"
  },
  {
    "content": "compose-capability Use to compose and grant capabilities in a nested structure to control the scope of how the capabilities are applied. By convention, capabilities are defined using all uppercase letters. With this function, you can define the specified within the context of an outer declaration. The function is only valid within the distinct body of its outer capability, such that the you specify for the function is included when you call the function for its outer capability. For example, if you call and the declaration includes the function, the capability is granted in the scope of the logic. Basic syntax To compose and grant a specified within an outer capability body, use the following syntax: Arguments Use the following argument to specify the for the Pact function. Argument Type Description capability Specifies the capability to include in the scope of an outer capability. Return value The function returns a boolean value to indicate success or failure in requesting the grant of the specified . Examples The following example demonstrates how to use the function within the body of the capability and include the DEBIT and CREDIT capabilities when the function is called:",
    "source": "pact-5/capabilities/compose-capability.md",
    "title": "compose-capability"
  },
  {
    "content": "validate-principal Use to validate that a principal unambiguously identifies a specified guard. Basic syntax To validate a against , use the following syntax: Arguments Use the following arguments to specify the guard and the principal that you want to validate using the Pact function. Argument Type Description guard Specifies the guard to validate against. string Specifies the principal to be validated. Return value The function returns a boolean value indicating whether the provided principal unambiguously identifies the specified guard. Examples The following example demonstrates how to use the function to ensure that the principal obtained from reading a keyset matches the specified principal account: The following example uses in a function to ensure the merchant and buyer accounts are guarded principal account:",
    "source": "pact-5/guards/validate-principal.md",
    "title": "validate-principal"
  },
  {
    "content": "typeof-principal Use to return the protocol type of the specified value. If the specified value is not a principal type, then an empty string is returned. Basic syntax To determine the protocol type of a specified value, use the following syntax: Arguments Use the following argument to specify the value that you want to determine the protocol type for using the Pact function. Argument Type Description string Specifies the principal value to determine the protocol type for. Return value The function returns the protocol type of the specified value as a string. If the input value is not a principal type, an empty string is returned. Examples The following example demonstrates how to use the function to determine the protocol type of a principal value: The following example uses the function to create a namespace using the guard associated with the principal account name:",
    "source": "pact-5/guards/typeof-principal.md",
    "title": "typeof-principal"
  },
  {
    "content": "keyset-ref-guard Use to create a guard for the keyset registered as using the function. Concrete keysets are themselves guard types. This function is specifically to store references alongside other guards in the database. Basic syntax To create a guard for a keyset registered with the function, use the following syntax: Arguments Use the following argument to specify the keyset reference for which you want to create a guard using the Pact function. Argument Type Description string Specifies the reference to the keyset registered with the function. Return value The function returns a type corresponding to the specified keyset reference. Examples The following example demonstrates how to use the function to create a guard for the keyset registered as \"my-keyset\" using the function:",
    "source": "pact-5/guards/keyset-ref-guard.md",
    "title": "keyset-ref-guard"
  },
  {
    "content": "is-principal Use to determine whether a principal string conforms to the principal format without proving its validity. Basic syntax To check whether a string conforms to the principal format, use the following syntax: Arguments Use the following argument to specify the string you want to check using the Pact function. Argument Type Description string Specifies the principal string to be checked. Return value The function returns a boolean value indicating whether the specified string conforms to the principal format. Examples The following example demonstrates how to use the function in the Pact REPL to check whether the specified string conforms to the principal format: The following example demonstrates how to use the function in an statement: In this example, the function ensures that the account conforms to the format for principal accounts. If the format is valid, the statement returns true and the LOCK_DEPOSIT capability is granted. If the isn't a valid principal format, the enforce statement returns the \"Sender must be a principal account\" error message. The following example checks the format of a principal account associated with a capability guard in an statement: In this example, the length of the specified string doesn't conform to the format for a principal account, so the statement returns the error message.",
    "source": "pact-5/guards/is-principal.md",
    "title": "is-principal"
  },
  {
    "content": "create-user-guard Use to define a custom guard whose arguments are strictly evaluated at definition time and supplied to the indicated function at enforcement time. Basic syntax To define a custom guard for use in Pact, use the following syntax: Arguments Use the following argument to specify the for the Pact function. Argument Type Description closure Specifies the custom guard closure to define. The closure is a function that takes no arguments and returns a boolean value. Return value The function returns a guard that uses the specified custom function that returns a boolean value. Example The following example demonstrates how to use the function to obtain a keyset, then use the keyset as a custom guard closure function: In this example, is used as the closure function to capture a keyset to use when the user guard is enforced. This code allows you to define custom user guards based on specific keysets or conditions. The following example defines a user guard for the function that must evaluate to true to allow a fungible transfer:",
    "source": "pact-5/guards/create-user-guard.md",
    "title": "create-user-guard"
  },
  {
    "content": "create-principal Use to create a principal account that unambiguously identifies a specified predicate function. For an introduction to principal accounts, see Accounts, keys, and principals. Basic syntax To create a principal that identifies a predicate function, use the following syntax: Arguments Use the following argument to specify the for the Pact function. Argument Type Description guard Specifies the guard for which to create a principal. Return value The function returns a string representing a principal that unambiguously identifies the specified predicate function. Example The following example demonstrates how to use the function to create a principal that unambiguously identifies the guard: This principal can then be used for various purposes such as access control in Pact code.",
    "source": "pact-5/guards/create-principal.md",
    "title": "create-principal"
  },
  {
    "content": "create-pact-guard Use to define a predicate function with the specified that captures the results of the function for a transaction. When enforced, the guard will only return true if the at enforcement is the same as the captured by the function. This check ensures that the guard will only succeed within the multi-step transaction identified by the . Basic syntax To define a predicate function by that captures the results of the function, use the following syntax: Arguments Use the following argument to specify the for the Pact function. Argument Type Description string Specifies the name of the predicate function that captures the for a multi-step transaction. Return value The function returns a guard with the specified that captures the for a multi-step transaction. Example The following example demonstrates how to use the function to define a guard named that captures the for a multi-step transaction: This guard ensures that it will only succeed within the multi-transaction identified by the pact id.",
    "source": "pact-5/guards/create-pact-guard.md",
    "title": "create-pact-guard"
  },
  {
    "content": "create-module-guard Use to create a predicate function with the specified that ensures that specific conditions are true for the current module. Module guards are typically used to enable a module to perform administrative operations independently outside of the module itself, for example, to own coins in an external ledger, or to perform administrative operations internally on its database, for example, to own and manage certain assets. Basic syntax To define a predicate function that guards administrative activity for the current module, use the following syntax: Arguments Use the following argument to specify the for the Pact function. Argument Type Description string Specifies the name of the predicate function that guards administrative activity for the current module. Return value The function returns a guard with the specified that enables the current module to perform administrative operations. Example The following example demonstrates how to use the function to define a guard named for the current module: If the evaluation of the returns true, the current module is granted administrative privileges.",
    "source": "pact-5/guards/create-module-guard.md",
    "title": "create-module-guard"
  },
  {
    "content": "create-capability-pact-guard Use to create a predicate function that ensures that specific conditions are true and can be enforced to grant the specified for steps defined in a multi-step transaction. By convention, capabilities are defined using all uppercase letters. Basic syntax To create a predicate function that guards the specified in a multi-step transaction, use the following syntax: Arguments Use the following argument to specify the for the Pact function. Argument Type Description capability Specifies the capability that the predicate function guards. Return value The function returns a guard that enables the code associated with the specified to be executed in the context of a multi-step transaction. Examples The following example demonstrates how to use the function to create a guard for the capability in a step: The following example creates a guard for the capability associated with the for the sales contract being executed:",
    "source": "pact-5/guards/create-capability-pact-guard.md",
    "title": "create-capability-pact-guard"
  },
  {
    "content": "create-capability-guard Use to create a predicate function that ensures that specific conditions are true and can be enforced to grant the specified . By convention, capabilities are defined using all uppercase letters. Basic syntax To create a predicate function that guards the specified , use the following syntax: Arguments Use the following argument to specify the for the Pact function. Argument Type Description capability Specifies the capability that the predicate function guards. Return value The function returns a guard that enforces the acquisition of the specified . Examples The following example demonstrates how to use the function to create a guard for the GOVERNANCE capability: The conditions specified for the GOVERNANCE capability must evaluate to true for the capability to be acquired and related code where the capability is required to be executed. The following example illustrates how to create a guard for an ESCROW_MANAGEMENT account:",
    "source": "pact-5/guards/create-capability-guard.md",
    "title": "create-capability-guard"
  },
  {
    "content": "zip Use the function to combine two lists using a specified function into a new list. The length of the resulting list is determined by the length of the shortest input list. Basic syntax To combine two lists with a specified function into a new list, use the following syntax: Arguments Use the following arguments to specify the function and the lists that you want to combine using the Pact function. Argument Type Description function Specifies the function to combine elements from the two lists. [any] Specifies the first list to be combined. [any] Specifies the second list to be combined. Return value The function returns a new list containing elements combined from the input lists according to the specified function . Examples The following examples demonstrate how to use the function in the Pact REPL. This example combines two lists of numbers using the specified addition (+) function a new list: The following example combines two lists of numbers using the specified subtraction (-) function to create a new list: The following example illustrate combining two lists using the multiplication (*) function to create a new list with its length determined by input list with the fewest items",
    "source": "pact-5/general/zip.md",
    "title": "zip"
  },
  {
    "content": "yield Use to yield an object for use with the function in the subsequent Pact step. Optionally, you can specify a target chain for executing the next step using automated a simplified payment verification (spv) endorsement-based dispatch. Basic syntax To yield an for use with the function, use the following syntax: Arguments Use the following arguments to specify the object and, optionally, the target chain for executing the subsequent step using the Pact function. Argument Type Description object Specifies the object to be yielded for use with 'resume'. string Specifies the chain ID on which the subsequent step should execute (optional). Return value The function returns the yielded object. Examples The following examples demonstrate how to use the function in a Pact script. In the following example, the function creates an object with one key and value that can be passed to the function, Optionally, you can specify a target chain for resuming the transaction. For example, to set the target chain to chain 8: The following example illustrates using and functions in steps:",
    "source": "pact-5/general/yield.md",
    "title": "yield"
  },
  {
    "content": "where Use the function to apply a specified application function () to a field () to evaluate the field value (). The function returns a boolean value based on the result of the application. This function is most often used in conjunction with and operations. Basic syntax To apply an application function to a in a value, use the following syntax: Arguments Use the following arguments to specify the field, application function, and value for evaluation using the Pact function. Argument Type Description string Specifies the field in the value to be evaluated. function Specifies the application function to be applied to the field. Specifies the value containing the field to be evaluated. Return value The function returns a value based on the result of applying the specified application function to the field in the value. Examples The following example demonstrates how to use the function in the Pact REPL. This example applies a condition for filtering a list of objects where the field value is less than :",
    "source": "pact-5/general/where.md",
    "title": "where"
  },
  {
    "content": "typeof Use to return the data type of the specified . The data type of the specified value is as a string. Basic syntax To determine the data type for a , use the following syntax: Arguments Use the following argument to specify the value for which to determine the type using the Pact function. Argument Type Description any Specifies the value for which to determine the type. Return value The function returns the data type of the provided as a string. Examples The following example demonstrates how to use the function in the Pact REPL. This example returns the data type of the value : The following example returns the data type of the value : The following example returns the data type of the value :",
    "source": "pact-5/general/typeof.md",
    "title": "typeof"
  },
  {
    "content": "tx-hash Use to get the hash of the current transaction as a string. Basic syntax To obtain the hash of the current transaction, use the following syntax: Return value The function returns the hash of the current transaction as a string. Examples The following example demonstrates how to use the function in the Pact REPL. This example gets the hash of the current transaction:",
    "source": "pact-5/general/tx-hash.md",
    "title": "tx-hash"
  },
  {
    "content": "try Use the function to attempt a pure action, returning a default value in the case of failure. Pure functions and pure expressions perform operations that produce a resulting value with no side effects. In most programming languages, pure functions and expressions always return identical results for identical arguments and don't allow mutable variables or input and output operations. In Pact, you can use the built-in function to read from database tables and there's no guarantee that a value in a table remains that same between two calls of the same pure action. You can't use the built-in function to write to database tables. Basic syntax To attempt a pure action and return a default value if the action fails, use the following syntax: Arguments Use the following arguments to specify the default value and the action to be attempted using the Pact function. Argument Type Description any Specifies the default value to be returned if the action fails. any Specifies the action to be attempted. Return value The function returns the result of the attempted action. If the action fails, it returns the specified default value. Examples The following example demonstrates how to use the function in the Pact REPL. This example attempts to use the function to specify a condition. If the condition fails, the function returns the default value : If the function specifies a condition that succeeds, the function returns the result. For example, if the condition succeeds, the result is : In the following example, the default value is a string:",
    "source": "pact-5/general/try.md",
    "title": "try"
  },
  {
    "content": "take Use the function to retrieve a specified number of values from a list (or string), or entries with keys specified in from an object. If the argument is negative, values are taken from the end of the list. If the exceeds the interval (-2^63,2^63), it is truncated to that range. Basic syntax Because is an overloaded function, there are two ways to use it. To retrieve a specified number of values from a list or a string, use the following syntax: To retrieve entries with specified keys from an object, use the following syntax: Arguments Use the following arguments to specify the number of values to retrieve and the list or object to retrieve them from using the Pact function. Argument Type Description integer Specifies the number of values to retrieve from the list or string. If negative, values are taken from the end. [integer, decimal, or string] or string Specifies the list or string from which to retrieve values. [string] Specifies the keys for the information you want to retrieve from the specified object. object Specifies the object from which to retrieve entries. Return value The function returns a subset of values retrieved from the list or from the object based on the specified count or number of keys. Examples The following examples demonstrate how to use the function in the Pact REPL. To retrieve the first two characters from the string \"abcd\": To retrieve the last three values from the list [1, 2, 3, 4, 5]: To retrieve entries with the key from the object :",
    "source": "pact-5/general/take.md",
    "title": "take"
  },
  {
    "content": "str-to-list Use to convert a specified into a list where each element is a single-character string. Converting a string into a list can be useful for performing other more complex string manipulation tasks. Basic syntax To convert a string into a list of single-character strings, use the following syntax: Arguments Use the following argument to specify the to be converted into a list of single-character strings using the Pact function. Argument Type Description string Specifies the string to be converted into a list. Return value The function returns a list where each element represents a single character from the input . Examples The following examples demonstrate how to use the function within the Pact REPL. To convert the string \"hello\" into a list of single-character strings: To concatenate spaces between each character in the string \"abcde\":",
    "source": "pact-5/general/str-to-list.md",
    "title": "str-to-list"
  },
  {
    "content": "str-to-int Use to compute the integer value of the string interpreted in base 10, or in a specified ,if provided. The argument can be up to 512 characters. If you specify the argument, it must be between 2 and 16, or 64 to perform unpadded base64url conversion. Each digit in the argument must be in the correct range for the base. Basic syntax To compute the integer value of a string in base 10, use the following syntax: To compute the integer value of a string in a specified base, use the following syntax: Arguments Use the following arguments to specify the string value and, optionally, the base for conversion using the Pact function. Argument Type Description string Specifies the string value to be converted to an integer. integer Specifies the base in which to interpret the string value (optional). Must be between 2 and 16, or 64 for base64url encoding without padding. Return value The function returns the value computed from the input string . Examples The following examples demonstrate how to use the function to compute the integer value of a string in the Pact REPL. To compute the integer value of the string \"123456\" interpreted in base 10: To compute the integer value of the string \"abcdef123456\" interpreted in base 16: To compute the integer value of the string \"spirekey\" interpreted in base 64 for base64url conversion without padding:",
    "source": "pact-5/general/str-to-int.md",
    "title": "str-to-int"
  },
  {
    "content": "static-redeploy Use to redeploy any module, without any code changes. Redeploying a legacy module will store the new module in the new Pact 5 compact storage format. As a result, redeployed modules require significantly less gas to load. Note that redeploying leaves governance unchanged. Prerequisites You must have deployed the module in a namespace on at least one chain in the development, test, or main network before you can use the function to update the module storage. For information about deploying a module, see Deploy smart contracts. Basic syntax To redeploy an existing module as a Pact 5 module, use the following syntax: Arguments Use the following argument to specify the module you want to redeploy using the Pact function. Argument Type Description string Specifies the module to redeploy. Return value The function returns the unit value if redeployment is successful. Examples The following example demonstrates how to redeploy the module that was originally deployed in the namespace on and chain using a YAML transaction request file. After creating the YAML request, you can format and submit the transaction request to the appropriate network and chain endpoint. For example:",
    "source": "pact-5/general/static-redeploy.md",
    "title": "static-redeploy"
  },
  {
    "content": "sort Use to sort a list of primitive values based on the values themselves or a list of objects based on specific fields within the objects. If you're sorting primitive values, they are sorted in ascending numerical or alphabetical order. Basic syntax Because is an overloaded function, there are two ways to use it. To sort a list of primitive values, use the following syntax: To sort a list of objects based on specific fields, use the following syntax: Arguments Use the following arguments to specify the values or fields for sorting using the Pact function. Argument Type Description [integer, decimal, or string] Specifies the list of primitive values to be sorted. [list] Specifies the list of fields within objects to be used for sorting. object Specifies more or more objects to be sorted using the parameter. Return value The function returns a sorted list of values or objects based on the specified sorting criteria. Examples The following examples illustrate how to use the function to sort lists of values or objects in Pact. The following example demonstrates how to the sort a list of primitive values using of the function: If you sort a list of string primitive values, they are sorted in alphabetical order. For example: To sort a list of objects based on the field:",
    "source": "pact-5/general/sort.md",
    "title": "sort"
  },
  {
    "content": "show Use to convert a specified into a string. Basic syntax To convert a into a string, use the following syntax: Arguments Use the following argument to specify the value to be converted to a string using the Pact function. Argument Type Description any Specifies the value to be converted to a string. Return value The function returns the argument as a string. Examples The following examples demonstrate how to use the function to convert a value to a string in a Pact REPL:",
    "source": "pact-5/general/show.md",
    "title": "show"
  },
  {
    "content": "round Use the function to round numbers to integers or decimals using banker's rounding. The function returns an integer value if you don't specify as an argument. If you specify the argument, the function returns a decimal value with the specified precision. Basic syntax To round a decimal value to the nearest integer, use the following syntax: To round a decimal value to a specified precision, use the following syntax: Arguments Use the following arguments to specify the value to be rounded and, optionally, the precision to round to using the Pact function. Argument Type Description decimal Specifies the decimal value to be rounded. integer Specifies the precision to round to, if applicable (optional). Return value If no precision is specified, the function returns the rounded value as an . If precision is specified, it returns the rounded value as a value. Examples The following examples demonstrate the usage of the function within the Pact REPL. To round the decimal value 3.5 to the nearest integer: To round the decimal value 100.15234 to 2 decimal places:",
    "source": "pact-5/general/round.md",
    "title": "round"
  },
  {
    "content": "reverse Use to reverse the order of specified in a list. Basic syntax To reverse a specified list of , use the following syntax: Arguments Use the following argument to specify the to be reversed using the Pact function. Argument Type Description [any] Specifies the elements in the list you want to be reversed. Return value The function returns a new list with the elements in reverse order. Example The following example demonstrates how to use the function in the Pact REPL. This example reverses the order of numbers in the list: In the following example, the function reverses the order of strings in a list: You can also reverse the order of objects in a list. For example: This example illustrates how to use the function to reverse the order of elements in a list in Pact.",
    "source": "pact-5/general/reverse.md",
    "title": "reverse"
  },
  {
    "content": "resume Use the function to resume execution of a step in a . This function binds to an object produced by the function in the prior step of a . If the function is executed on a different chain, the function requires a simple payment verification (SPV) proof. Basic syntax To bind to a yielded object produced by a prior step execution, use the following syntax: Arguments Use the following argument to specify the to be resumed using the Pact function. Argument Type Description object Specifies the binding representing the yielded object from the prior step execution. Return value The function returns the value bound to the specified . Example The following example demonstrates how to use the function in a Pact script to bind to the yielded object produced by the previous step in the execution of a pact: The following example illustrates using and functions in steps:",
    "source": "pact-5/general/resume.md",
    "title": "resume"
  },
  {
    "content": "remove Use to remove an entry associated with a specified from a specified . Basic syntax To remove an entry for a from an , use the following syntax: Arguments Use the following arguments to specify the and for removing an entry using the Pact function. Argument Type Description string Specifies the key for the entry to be removed from the object. object Specifies the object from which to remove the entry. Return value The function returns the modified object with the entry associated with the specified removed. Example The following example demonstrates how to use the function in the Pact REPL. This example removes the entry for the key from the given object:",
    "source": "pact-5/general/remove.md",
    "title": "remove"
  },
  {
    "content": "read-string Use to parse the specified string or number value from the top level of the message data body as a . Basic syntax To parse a string as a string, use the following syntax: Arguments Use the following argument to specify the to be parsed as a string using the Pact function. Argument Type Description string Specifies the key string or number value to parse as a string. Return value The function returns the parsed value as a . Example The following example demonstrates how to use the function in a Pact script. This example parses the from the data body of a message as a string:",
    "source": "pact-5/general/read-string.md",
    "title": "read-string"
  },
  {
    "content": "read-msg Use to read a specific from the top level of the message data body, or to read the data body itself if a is not provided. In reading the value, this function enforces its corresponding Pact type, such as , , , , or . Basic syntax To read the value for a specified from the body of a message, use the following syntax: To read the complete message data body, use the following syntax: Arguments Use the following argument to specify the to be read from the top level of the message data body using the Pact function. Argument Type Description string Specifies the key to be read from the message data body (optional). If you don't provide this argument, the function reads the entire data body. Return value The function returns the value corresponding to the specified from the message data body, or the entire data body if no is provided. The data type for the return is its corresponding Pact type. Example The following example demonstrates how to use the function in a Pact script. This example reads the and keys from the data body of a message as strings and the as a decimal: This example illustrates how to use the function to extract specific values from the body of a message for further processing in a Pact script.",
    "source": "pact-5/general/read-msg.md",
    "title": "read-msg"
  },
  {
    "content": "read-keyset Use to read the specified from the message data body as a keyset. A keyset consists of a list of keys () and, optionally, a predicate function (). Basic syntax To read a from the message data body as a keyset, use the following syntax: Arguments Use the following argument to specify the to be read as a keyset using the Pact function. Argument Type Description string Specifies the name of the key to be read from the message data body as a keyset. Return value The function returns the keyset object corresponding to the specified string. Example The following example demonstrates how to use the function in a Pact script. This example reads the object specified for the key from the body of a message as the name of a keyset object:",
    "source": "pact-5/general/read-keyset.md",
    "title": "read-keyset"
  },
  {
    "content": "read-integer Use to parse a string or number value from the top level of the message data body as an integer. Basic syntax To parse a string as an integer, use the following syntax: Arguments Use the following argument to specify the to be parsed as an integer using the Pact function. Argument Type Description string Specifies the key string or number value to parse as an integer. Return value The function returns the parsed value as an integer. Example The following example demonstrates how to use the function in a Pact script. This example parses the value specified for the key in the body of a message as an integer:",
    "source": "pact-5/general/read-integer.md",
    "title": "read-integer"
  },
  {
    "content": "read-decimal Use to parse a string or number value from the top level of the message data body as a decimal. Basic syntax To parse a string as a decimal, use the following syntax: Arguments Use the following argument to specify the to be parsed as a decimal using the Pact function. Argument Type Description string Specifies the key string or number value to parse as a decimal. Return value The function returns the parsed value as a decimal. Example The following example demonstrates how to use the function in a Pact script. This example parses the value specified for the key in the body of a message as a decimal and transfers it from one account to another: You can also use to read values from JSON object payloads.",
    "source": "pact-5/general/read-decimal.md",
    "title": "read-decimal"
  },
  {
    "content": "poseidon-hash-hack-a-chain Use to compute the Poseidon Hash Function. Note: This is a reference version of the Poseidon hash function used by Hack-a-Chain. Basic syntax To compute the Poseidon Hash Function using the reference version, use the following syntax: Arguments Use the following arguments to specify the inputs for computing the Poseidon hash using the Pact function. Argument Type Description , , , , , , , Specifies the inputs for the Poseidon hash function. Return value The function returns an integer representing the computed Poseidon hash. Examples The following examples demonstrate the use of in the Pact REPL: In these examples, different sets of inputs are provided to compute the Poseidon hash using the reference version. The function returns the computed hash value as an integer.",
    "source": "pact-5/general/poseidon-hash-hack-a-chain.md",
    "title": "poseidon-hash-hack-a-chain"
  },
  {
    "content": "pact-version Use to obtain the current Pact build version. Basic syntax To obtain the current Pact build version, use the following syntax: Return value The function returns a string representing the current Pact build version. Examples The function is called without any arguments to obtain the current Pact build version. In this example, is called, which returns the current Pact build version as a string.",
    "source": "pact-5/general/pact-version.md",
    "title": "pact-version"
  },
  {
    "content": "pact-id Use to return the ID if called during the current pact execution, failing if not. Basic syntax To return the ID during the current pact execution, use the following syntax: Return value The function returns a string representing the ID of the current pact execution. Examples The function is called without any arguments. It returns the ID if called during the current pact execution. In this example, is called to retrieve the ID of the current pact execution.",
    "source": "pact-5/general/pact-id.md",
    "title": "pact-id"
  },
  {
    "content": "negate Use to negate a specified integer or decimal value. Note that the integer can be a positive or negative value. Basic syntax To negate a specified , use the following syntax: Arguments Use the following argument to specify the value for negation. Argument Type Description integer or decimal Specifies the value to be negated. Return value The function returns the negation of the specified . Examples The following example demonstrates how to use the function to negate a positive decimal value in a Pact REPL: The following example demonstrates how to use the function to negate a negative decimal value in a Pact REPL:",
    "source": "pact-5/general/negate.md",
    "title": "negate"
  },
  {
    "content": "namespace Use to set the current working environment to the specified namespace value. After you declare the namespace you want to work with, all of the modules and functions you define are contained within that namespace. You can access the modules and functions in a namespace by using their fully qualified name. The fully-qualified name includes the namespace string as a prefix before the module name. For example, if you declare a principal namespace such as for the module , you can call functions in the module using a fully-qualified name similar to the following: If you call the function after the initial declaration, Pact creates a new namespace for all subsequent declarations until either the next call or the end of the transaction. Prerequisites You must define a namespace before you can set your working context to use the function. For information about defining a namespace, see define-namespace. Basic syntax To set the current to a specified value, use the following syntax: Arguments Use the following argument to specify the namespace to be set using the Pact function. Argument Type Description string Specifies the name of the namespace you want to use as your working context. Return value The function returns the string representing the namespace that has been set. Examples The following example demonstrates the use of in a Pact script: In this example, the current namespace is set to . All subsequent expressions within the same transaction will be contained in this namespace until a new namespace is set or the transaction ends.",
    "source": "pact-5/general/namespace.md",
    "title": "namespace"
  },
  {
    "content": "map Use to apply an application function () to each element in a list (), returning a new list of results. You can use any data type for the argument as long as the first function can take that same data type. By convention, data type notation like and are used to represent type-bound parameters that serve as input for functions and expressions or for generic arguments. Basic syntax To apply an application function to each element in a list, use the following syntax: Arguments Use the following arguments to specify the application function and the list of elements to be mapped using the Pact function. Argument Type Description function x: Specifies the application function to be applied to each element in the list. Specifies the list of elements to be mapped. Return value The function returns a new list containing the results of applying the application function to each element in the input list. Examples The following example demonstrates the use of in the Pact REPL: In this example, the application function is applied to each element in the list , resulting in a new list .",
    "source": "pact-5/general/map.md",
    "title": "map"
  },
  {
    "content": "make-list Use to create a list by repeating a specified value a certain number of times. Basic syntax To create a list by repeating a a specified number of , use the following syntax: Arguments Use the following arguments to specify the length of the list and the value to be repeated using the Pact function. Argument Type Description Specifies the length of the list to be created. Specifies the value to be repeated to create the list. Return value The function returns a list containing the specified value repeated the specified number of times. Examples The following example demonstrates the use of in the Pact REPL: In this example, a list containing the value repeated 5 times is created using the function.",
    "source": "pact-5/general/make-list.md",
    "title": "make-list"
  },
  {
    "content": "list-modules Use to list the modules that are deployed in your current environment and available for loading. Basic syntax To list the modules deployed and available for loading, use the following syntax: Arguments The function takes no arguments. Return value The function returns a list of strings representing the modules that are deployed in your current environment and available for loading. Examples The following example demonstrates how to use the function in the Pact REPL: In this example, the contract modules that are deployed by default on the development, test, and main network are listed as available for loading. If there are no contracts deployed, the function returns a empty list. For example:",
    "source": "pact-5/general/list-module.md",
    "title": "list-module"
  },
  {
    "content": "length Use to return the number of elements in a list, a string, or an object. Basic syntax To compute the length of a list, string, or object, use the following syntax: Arguments Use the following argument to specify the value for which you want to compute the length using the Pact function. Argument Type Description list, string, or object Specifies the list, string, or object that you want to compute the length of. Return value The function returns an integer representing the length of the specified list, string, or object. Examples The following example demonstrates calculating the length of the list in the Pact REPL: The following example calculates the length of the string , resulting in 8. The following example calculates the length of the object , resulting in 2.",
    "source": "pact-5/general/length.md",
    "title": "length"
  },
  {
    "content": "is-charset Use to check whether a string conforms to a supported character set. The character sets currently supported are (ISO-8859-1) and (ASCII). Support for additional sets, including those up through ISO 8859-5 supplement, will be added in the future. Basic syntax To check whether a string conforms to a specified character set, use the following syntax: Arguments Use the following arguments to specify the character set and input string you want to check using the Pact function. Argument Type Description Specifies the character set to which the input string should conform. Currently supported values are for 'CHARSET_LATIN1' (ISO-8859-1) and for 'CHARSET_ASCII' (ASCII). Specifies the input string to be checked for conformity to the specified character set. Return value The function returns a boolean value indicating whether the input string conforms to the specified character set. Examples The following examples demonstrate the use of in the Pact REPL: In this example, the input string \"hello world\" conforms to the ASCII character set. In this example, the input string \"I am nÖt ascii\" contains characters that are not part of the ASCII character set. In this example, the input string \"I am nÖt ascii, but I am latin1!\" conforms to the ISO-8859-1 (Latin-1) character set.",
    "source": "pact-5/general/is-charset.md",
    "title": "is-charset"
  },
  {
    "content": "int-to-str Use to represent an integer as a string in a specified . The base can be any integer from 2 to 16, or 64 for unpadded base64URL representation. Only positive values are allowed for base64URL conversion. Basic syntax To represent an integer as a string in a specified , use the following syntax: Arguments Use the following arguments to specify the base and integer value you want to convert using the Pact function. Argument Type Description Specifies the base in which the integer value will be represented as a string. It can be any integer from 2 to 16, or 64 for unpadded base64URL representation. Specifies the integer value to be converted into a string representation. Return value The function returns the string representation of the integer value in the specified base. Examples The following examples demonstrate the use of in the Pact REPL: In this example, the integer value 65535 is represented as a string in base 16, resulting in \"FFFF\". In this example, the integer value 43981 is represented as a string in base 64 (unpadded base64URL), resulting in \"XA\".",
    "source": "pact-5/general/int-to-str.md",
    "title": "int-to-str"
  },
  {
    "content": "if Use to test a condition. If the condition is true, evaluate the expression; otherwise, evaluate the expression. By convention, the data type is used to represent type-bound parameters that serve as input for functions and expressions or for generic arguments. Basic syntax To test a condition and execute different expressions based on the result, use the following syntax: Arguments Use the following arguments to define the condition and expressions to be evaluated based on the outcome of the condition using the Pact function. Argument Type Description boolean Specifies the condition to be tested. Specifies the expression to be evaluated if the condition is true. Specifies the expression to be evaluated if the condition is false. Return value The function returns the result of evaluating either the expression or the expression, depending on the outcome of the condition. Examples The following example demonstrates the use of to test a condition in the Pact REPL: In this example, the condition evaluates to true, so the expression is returned. In this example, the condition evaluates to false, so the expression is returned.",
    "source": "pact-5/general/if.md",
    "title": "if"
  },
  {
    "content": "identity Use to return the provided value. Basic syntax To return the provided value, use the following syntax: Arguments Use the following argument to specify the value you want to return using the Pact function. Argument Type Description Specifies the value to be returned. Return value The function returns the provided value. Examples The following example demonstrates the use of within a function in the Pact REPL: This example applies the function to each element in the list , effectively returning the same list.",
    "source": "pact-5/general/identity.md",
    "title": "identity"
  },
  {
    "content": "hash Use to compute the BLAKE2b 256-bit hash of a specified . The resulting hash value is a Base64Url-encoded string without padding. Strings values are converted directly. Other data type values are converted using their JSON representation. Non-value-level arguments are not allowed. By convention, the data type is used to represent a type-bound parameter like the argument in this function. Basic syntax To compute the BLAKE2b 256-bit hash of a value, use the following syntax: Arguments Use the following argument to specify the value for the Pact function: Argument Type Description Specifies the value to be hashed. Return value The function returns a string representing the computed hash value. Examples The following example demonstrates how to use the function to compute a hash for the string value: Because is a string value, the function computes the BLAKE2b 256-bit hash of the string \"hello\" and returns the hash value. In this example, is a JSON object. The function computes the BLAKE2b 256-bit hash of the JSON representation of the object and returns the hash value. The function is useful for generating hash values of data for various cryptographic operations in Pact contracts.",
    "source": "pact-5/general/hash.md",
    "title": "hash"
  },
  {
    "content": "hash-poseidon Use to compute the Poseidon Hash Function. Note that this is a reference version of the Poseidon hash function. Basic syntax To compute the Poseidon Hash Function using the reference version, use the following syntax: Arguments Use the following arguments to specify the inputs for computing the Poseidon hash using the Pact function. Argument Type Description , , , , , , , integer Specifies the inputs for the Poseidon hash function. Return value The function returns an integer representing the computed Poseidon hash. Examples The following examples demonstrate the use of in the Pact REPL: In these examples, different sets of inputs are provided to compute the Poseidon hash using the reference version. The function returns the computed hash value as an integer.",
    "source": "pact-5/general/hash-poseidon.md",
    "title": "hash-poseidon"
  },
  {
    "content": "hash-keccak256 Use to compute the hash of a list of unpadded base64url-encoded inputs . The hash is computed incrementally over all of the decoded inputs. Basic syntax To compute the hash of a list of inputs, use the following syntax: Arguments Use the following argument to specify the list of inputs for the Pact function: Argument Type Description Specifies the list of unpadded base64url-encoded inputs. Return value The function returns a string representing the computed hash value. Examples The following examples demonstrate the function: In this example, an empty list is provided as input. The function computes the hash of the empty list and returns the hash value. In this example, a list containing multiple base64url-encoded strings is provided as input. The function computes the hash of all the inputs and returns the hash value. The function is useful for computing hash values of data for various cryptographic operations in Pact contracts.",
    "source": "pact-5/general/hash-keccak256.md",
    "title": "hash-keccak256"
  },
  {
    "content": "format Use to input specified into a string in the location specified using curly braces () as template placeholders. Basic syntax To input variables into a template string where specified by the placeholders, use the following syntax: Arguments Use the following arguments to specify the template string and variables for the Pact function: Argument Type Description string Specifies the template string with placeholders. [any] Specifies the variables to insert into the template placeholders. Return value The function returns a new string with the values from the specified variables replacing the placeholder curly braces from the template string. Examples The following example demonstrates how to use the function with as the template string with two placeholders: In this example, the function replaces the placeholders in the template string with the specified values to return the result . The function is often used to create dynamic strings with variables inserted into specific locations in Pact contracts. For example, you can use the variables to store dynamic values like the current time:",
    "source": "pact-5/general/format.md",
    "title": "format"
  },
  {
    "content": "fold Use to iteratively reduce a list by applying the function to the last result for each element in the list, starting with the specified initial value. You can use any data type for the argument as long as the first functions can take that same data type. By convention, data type notation like and are used to represent type-bound parameters like the and arguments in this function. Basic syntax To iteratively reduce a list by applying a function to each element, starting with an initial value, use the following syntax: Arguments Use the following arguments to specify the function, initial value, and list for the Pact function: Argument Type Description function x: y: Specifies the function to apply to each element and the last result. Specifies the initial value for the reduction. [] Specifies the list to iterate over. Return value The function returns the final result of the iterative reduction of the list. Examples The following example demonstrates the function: In this example, is used as the function to apply, which is addition in this case. The function starts with an initial value of and iteratively adds each element of the list to the previous result. Here's the breakdown: Initial value: First iteration: Second iteration: Third iteration: The final result of the operation is . The function is commonly used for operations that require accumulating results over a list in Pact contracts.",
    "source": "pact-5/general/fold.md",
    "title": "fold"
  },
  {
    "content": "filter Use to filter a list of by applying the specified function to each element in the list. For each element in the list, the function should return true or flase to identify the elements that should be included in the filtered list. Each element that returns a result of from the function is included in the resulting list with its original value. With the function, you can include elements in a list based on a specific condition. Basic syntax To filter a list by applying a function to each element, use the following syntax: Arguments Use the following arguments to specify the function and list for the Pact function: Argument Type Description function Specifies the function to apply to each element of the list. The return value for the function must be a Boolean ( or ) to identify elements to be included in the resulting list. [any] Specifies the list of elements to filter. The elements in the list can be any data type. Return value The function returns a new list containing elements from the original list for which the function returns . Examples The following example demonstrates how to use with a function that evaluates the length of strings to only include the strings with more than two characters: In this example, is used as the function that is applied to each element. This function checks the length of each element in the list. The function then filters the list based on this condition. The resulting list only contains the elements that returned when the function was applied. In this case, the resulting list is . In the following example, is the function applied to each element: Like the previous example, the function checks the length of each element in the list. The function then filters the list based on this condition and the resulting list only contains the elements that returned when the function was applied. In this case, the resulting list is .",
    "source": "pact-5/general/filter.md",
    "title": "filter"
  },
  {
    "content": "enumerate Use to return a sequence of numbers from the specified number to the specified number, inclusively, as a list. By default, the sequence increments by one from the number to the number. Optionally, you can specify an increment other than one to use between numbers in the sequence. If you specify a number that’s greater than the number, the sequence decrements by one from the number to the number. Basic syntax To increment or decrement the sequence by one, use the following syntax: To specify a value to increment or decrement the sequence by, use the following syntax: Arguments Use the following arguments to define the beginning and end of the sequence you want to list using the Pact function. Argument Type Description Specifies the first number in the sequence. Specifies the last number in the sequence. Options Use the following option to define the increment to use between the beginning and end of the sequence in the Pact function. Option Type Description Specifies the increment to use between numbers in the sequence. The value can be a positive or negative integer. Return value The function returns the resulting sequence of numbers as a list. Examples The following example enumerates a sequence of numbers using the default increment of one in the Pact REPL: The following example enumerates a sequence of numbers using an increment of two between numbers in the sequence: The following example illustrates decrementing a sequence of numbers using an value of -2 between numbers in the sequence:",
    "source": "pact-5/general/enumerate.md",
    "title": "enumerate"
  },
  {
    "content": "enforce Use to test whether a pure evaluates to true or false. If the specified evaluates to true, the function returns true. If the specified evaluates to false, the function fails the transaction and displays the specified error . Basic syntax To fail a transaction with a specified error message if an expression evaluates to false, use the following syntax: Arguments Use the following arguments to specify the test expression and error message for the Pact function: Argument Type Description expression bool Specifies the expression to evaluate. string Specifies the error message to display if the evaluates as false. Return value The function returns if the specified is true. If the is false, the function fails the transaction with the specified error message. Examples The following example demonstrates how to use the function to evaluate the expression : Because the specified expression () is true, the function returns true and the transaction continues. The following example demonstrates how to use the function to evaluate the expression : Because the expression is false, the transaction fails with the error message specified.",
    "source": "pact-5/general/enforce.md",
    "title": "enforce"
  },
  {
    "content": "enforce-verifier Use to enforce that a verifier plugin with the specified is in scope. Basic syntax To enforce that a verifier is in scope, use the following syntax: Arguments Use the following argument to specify the for the Pact function: Argument Type Description string Specifies the name of the verifier to enforce. Return value The function returns a boolean value indicating whether the specified verifier is in scope. Examples The following example demonstrates the function: In this example, is used to enforce that the verifier named 'COOLZK' is in scope. If the verifier 'COOLZK' is in scope, the function returns . If the verifier is not in scope, the function fails. The function provides a way to ensure that a specific verifier is available for use within a Pact contract.",
    "source": "pact-5/general/enforce-verifier.md",
    "title": "enforce-verifier"
  },
  {
    "content": "enforce-pact-version Use to enforce the runtime Pact version to be within a specified range, where the version is greater than or equal to the argument and less than or equal to the argument. The argument is optional. Version values are matched numerically from the left, meaning versions like '2', '2.2', and '2.2.3' would all allow '2.2.3'. Basic syntax To enforce the runtime Pact version within a specified range, use the following syntax: Arguments Use the following arguments to specify the minimum and maximum Pact versions for the Pact function: Argument Type Description string Specifies the minimum Pact version to enforce. string Specifies the maximum Pact version to enforce (optional). Return value The function returns a boolean value indicating whether the runtime Pact version is within the specified range. Examples The following example demonstrates how to use the function to ensure that the runtime Pact version is at least \"4.10\": If the current Pact version is \"4.10\" or higher, the function returns . If the Pact version is lower than \"4.10\" or you specify an invalid version, the function fails. You can also specify a maximum Pact version:",
    "source": "pact-5/general/enforce-pact-version.md",
    "title": "enforce-pact-version"
  },
  {
    "content": "enforce-one Use to run a series of tests in order (in a pure context, plus keyset enforces). If all tests fail, the transaction fails. This function short-circuits on the first successful test. Basic syntax To run a series of tests in order and short-circuit on the first successful test, use the following syntax: Arguments Use the following arguments to specify the error message and tests for the Pact function: Argument Type Description string Specifies the error message if all tests fail. bool Specifies the list of tests to run in order. Return value The function returns if at least one test succeeds. If all tests fail, the function fails the transaction with the specified error message. Examples The following example demonstrates the function: In this example, is used to run two tests in order. The first test is , which fails intentionally. The second test is , which succeeds because is true. Because the second test succeeds, the function returns . If all tests had failed, the transaction would have failed with the specified error message \"Should succeed on second test\".",
    "source": "pact-5/general/enforce-one.md",
    "title": "enforce-one"
  },
  {
    "content": "enforce-guard Use to execute a specified or a defined keyset named to enforce the predicate logic. Basic syntax To use a to enforce specific conditions defined in predicate logic, use the following syntax: To use a defined keyset as a to enforce specific conditions defined in predicate logic, use the following syntax: Arguments Use the following arguments to specify the or for the Pact function: Argument Type Description guard Specifies the name of the guard to execute. string Specifies the name of the defined keyset to enforce. Return value The function returns a boolean value indicating whether the conditions specified in the predicate logic that the guard or keyset is there to enforce were met. Examples The following example demonstrates using the keyset guard named to enforce specific signing requirements defined in the keyset predicate function, for example with the or predicate: In most cases, you use in the context of contract logic to ensure a specific condition is before allowing a specific operation to be executed. For example, you might have logic to validate a sender account before allowing a transfer operation. You can then call the to ensure the sender meets the specified conditions—returning as a result—before executing further logic:",
    "source": "pact-5/general/enforce-guard.md",
    "title": "enforce-guard"
  },
  {
    "content": "drop Use to remove a specified number of values from a list, string, or object. Basic syntax Because is an overloaded function, there are two ways to use it. To remove the specified number of values from a or string, use the following syntax: To remove the specified and corresponding values from an or string, use the following syntax: Arguments Use the following arguments to specify the and or and for the Pact function: Argument Type Description integer Specifies the number of values to drop from the list or a string. [any] or string Specifies the list (or string) from which to drop values. [string] Specifies the keys to drop from the object. object Specifies the object from which to drop entries with specified keys. Return value The function returns the modified list, string, or object after removing the specified number of values or specified keys. Examples The following example demonstrates how to use the function to drop the first two characters from the specified string: The following example illustrates how to drop the last two values from the specified list: The following example drops the key and its corresponding value from the specified object:",
    "source": "pact-5/general/drop.md",
    "title": "drop"
  },
  {
    "content": "do Use to evaluate a sequence of expressions in order and only return the result from the last expression. Basic syntax Use the following syntax: Examples Notice how the return value is the last addition of . evaluates every expression supplied, so if any expression errors along the way, the subsequent expressions will never be evaluated, as such:",
    "source": "pact-5/general/do.md",
    "title": "do"
  },
  {
    "content": "distinct Use to return a list with duplicates removed from a homogeneous list of . The original order of the values is preserved. Basic syntax To return a list with duplicates removed from a list of , use the following syntax: Arguments Use the following argument to specify the list of for the Pact function. Argument Type Description [any] Specifies the list of values that includes duplicates. Return value The function returns a list with duplicates removed from the specified list of . Examples The following example demonstrates how to use the function to remove duplicates from a list of numeric values: The function returns , preserving the original order of the values.",
    "source": "pact-5/general/distinct.md",
    "title": "distinct"
  },
  {
    "content": "describe-namespace Use to describe the specified , returning a row object containing the keyset guards for the administrative owner of the namespace and the user allowed to access the namespace for the specified namespace. Basic syntax To describe the namespace , use the following syntax: Prerequisites You must define a namespace with the function before you can use the function. For information about defining a namespace, see define-namespace. Arguments Use the following argument to specify the for the Pact function. Argument Type Description string Specifies the name of the namespace to describe. Return value The function returns an object with detailed information about the specified . Examples The following example demonstrates the function: In this example, is used to describe the namespace named \"my-namespace\". The function returns a row object containing the keyset guards for the administrative owner of the namespace and the user allowed to access the namespace for the specified namespace.",
    "source": "pact-5/general/describe-namespace.md",
    "title": "describe-namespace"
  },
  {
    "content": "define-namespace Use to create a new namespace or update the guards of an existing namespace. The ownership and use of the namespace are controlled by the specified guards. Note: This function can only be used at the top level of your code. It will fail if used within module code. Basic syntax To define the namespace , use the following syntax: Arguments Use the following arguments to specify the namespace and guards when using the Pact function. Argument Type Description string Specifies the name of the namespace to create or update. guard Specifies the guard that controls who can use the namespace. guard Specifies the guard that controls the ownership and administrative tasks in the namespace. Return value The function returns the name of the created or updated namespace as a string. Example The following example creates a new namespace called with user and admin guards defined by the and keysets, respectively:",
    "source": "pact-5/general/define-namespace.md",
    "title": "define-namespace"
  },
  {
    "content": "continue Use to continue a previously-started multi-step transaction. Transactions that have multiple steps executed in a sequence are called pacts and are defined using the keyword. Steps can be nested in structures and the function enables you to continue execution with a specified value. Basic syntax To continue a previously-started transaction, use the following syntax: Arguments Use the following argument to specify the to continue the nested . Argument Type Description Specifies the value to continue the nested . Return value The function continues the execution of the nested with the specified . Examples The following example demonstrates the use of within the context of a to resume its execution with a specified value.",
    "source": "pact-5/general/continue.md",
    "title": "continue"
  },
  {
    "content": "contains Use to test whether a contains a , an has a entry, or a contains a substring . Basic syntax Because is an overloaded function, there are a few different ways to use it. To test whether a contains a , use the following syntax: To test whether an has a entry, use the following syntax: To test whether a contains a substring , use the following syntax: Arguments Use the following arguments to specify the , , , , for the Pact function. Argument Type Description any Specifies the value to search for in a or . [any] Specifies the list to search for the specified . any Specifies the key to check for in an . object Specifies the object to check for the specified . string Specifies the string to search for the specified . Return value The function returns a boolean value indicating whether the specified or the specified was found. Examples The following examples demonstrate the function in the Pact REPL. To check whether a contains a specified : In this example, the functions checks whether the value is included in the list. Because the list contains the specified value, the function returns . To check whether a specified has as a key field: To check whether the string contains the substring , In this example, checks which it does, so it returns .",
    "source": "pact-5/general/contains.md",
    "title": "contains"
  },
  {
    "content": "constantly Use to lazily ignore the specified arguments and return the specified . Basic syntax To lazily ignore arguments and return a value, use the following syntax: Arguments Use the following arguments to specify the to return and the arguments for the Pact function. Argument Type Description any Specifies the value to return. any Specifies the arguments to ignore. You can have multiple ignore arguments (optional). Return value The function returns the specified , ignoring any additional arguments. Examples The following example demonstrates the function in the Pact REPL: In this example, is used as the predicate function for the function. The function always returns and ignores the elements of the list argument, so the function always returns the entire list. The following example illustrate specifying multiple arguments and argument using different data types:",
    "source": "pact-5/general/constantly.md",
    "title": "constantly"
  },
  {
    "content": "cond Use to evaluate multiple branching conditional expressions. This function allows you to evaluate a series of expression in a more concise manner. Basic syntax Use the following syntax: Examples",
    "source": "pact-5/general/cond.md",
    "title": "cond"
  },
  {
    "content": "concat Use to take a list of strings and concatenate each of the strings in the list, returning the resulting string. Basic syntax To concatenate each string in a list, use the following syntax: Arguments Use the following argument to specify the list of strings for the Pact function. Argument Type Description [string] Specifies the list of strings to concatenate. Return value The function returns the resulting string after concatenating all the strings in the . Examples The following example demonstrates the function in the Pact REPL: In this example, takes the list and concatenates each string in the list, resulting in the string . The following example shows how to concatenate a list of strings after mapping each element with a function: In this example, converts the string into a list of characters . Then, maps the function to each character, adding a space after each character. Finally, concatenates all the strings in the resulting list, producing the string .",
    "source": "pact-5/general/concat.md",
    "title": "concat"
  },
  {
    "content": "compose Use to compose functions where performs an operation using the specified and takes the results from as input to produce the result for the composed function. You can use any data type for the argument as long as the first functions can take that same data type. By convention, the data type is used to represent a type-bound parameter like the argument in this function. Basic syntax To compose a function using and with the specified , use the following syntax: Arguments Use the following arguments to specify the functions and for composing with using the Pact function. Argument Type Description function: Specifies the first function to operate on the specified and return a result to provide input to the second function. function: Specifies the second function to operate on the results of the function. Specifies the value on which operates. Return value The function returns the result of applying to the result returned by for the specified . Examples In the following example, uses the function to evaluate the specified list for a string, then uses the function to operate on the results of the function to display the final result:",
    "source": "pact-5/general/compose.md",
    "title": "compose"
  },
  {
    "content": "CHARSET_LATIN1 is a constant used to indicate the standard Latin-1 (ISO-8859-1) character set. Constant value Description The constant represents the Latin-1 (ISO-8859-1) character set, which is a widely used single-byte character encoding. It includes characters from various Western European languages. When working with functions or modules that require specifying a character set, you can use to indicate that the Latin-1 character set should be used.",
    "source": "pact-5/general/charset-latin1.md",
    "title": "charset-latin1"
  },
  {
    "content": "CHARSET_ASCII is a constant used to indicate the standard ASCII character set. Constant value Description The constant represents the ASCII (American Standard Code for Information Interchange) character set, which is a widely used character encoding that includes 128 characters. It consists of control characters, digits, lowercase and uppercase English letters, and various symbols. When working with functions or modules that require specifying a character set, you can use to indicate that the ASCII character set should be used.",
    "source": "pact-5/general/charset-ascii.md",
    "title": "charset-ascii"
  },
  {
    "content": "chain-data Use to retrieve the blockchain-specific public metadata for a transaction. This function returns an object with the following fields: : The chain identifier (0-19) for the blockchain where the transaction was executed. : The height of the block that includes the transaction. : The timestamp of the block that includes the transaction. : The hash of the previous block. : The sender of the transaction. : The gas limit for the transaction. : The gas price for the transaction. : The gas fee for the transaction. Basic syntax To retrieve the public metadata for a transaction using , use the following syntax: Arguments You can use the function without arguments in code that identifies the transaction that you want to return metadata for. Return value The function returns the public metadata for a transaction as an object with the following fields Field Type Description string The chain identifier (0-19) for the blockchain where the transaction was executed. integer The height of the block that includes the transaction. time The timestamp of the block that includes the transaction. string The hash of the previous block. string The sender of the transaction. integer The gas limit for the transaction. decimal The gas price for the transaction. decimal The gas fee for the transaction. Examples If you call the function in the Pact REPL without providing a transaction context in the surrounding code, the function returns the object with placeholder fields. For example: If you provide context for the call, the function returns an object with fields similar to the following: In most cases, you use in Pact modules or in combination with frontend libraries to return information in the context of a specific transaction. The following example illustrates using chain-data in a Pact module to get the block time from a transaction:",
    "source": "pact-5/general/chain-data.md",
    "title": "chain-data"
  },
  {
    "content": "bind Use to evaluate a object, then apply the specified to bind field variables to values over subsequent body statements. Basic syntax To evaluate to an object and bind it with over subsequent body statements, use the following syntax: Arguments Use the following arguments to specify the object and for the special form. Argument Type Description Specifies the source object to evaluate. Specifies the bindings to apply to the object. Return value The returns the result of evaluating the object with the specifies . The data type depends on the data type of the field you specify for the argument. Examples The following example demonstrates the special form in the Pact REPL: In this example, evaluates the object and binds the value of \"a\" to . It then returns the value , which is the value bound to .",
    "source": "pact-5/general/bind.md",
    "title": "bind"
  },
  {
    "content": "base64-encode Use to convert the specified to an unpadded base64-encoded string. Basic syntax To encode a as unpadded base64, use the following syntax: Arguments Use the following argument to specify the to encode using the Pact function. Argument Type Description string Specifies the to encode as unpadded base64. Return value The function returns the unpadded base64 encoded . Examples The following example converts the \"hello world!\" into the unpadded base64-encoded string \"aGVsbG8gd29ybGQh\" in the Pact REPL:",
    "source": "pact-5/general/base64-encode.md",
    "title": "base64-encode"
  },
  {
    "content": "base64-decode Use to convert a previously-encoded from unpadded base64 encoding to a string. Basic syntax To decode a from unpadded base64 encoding, use the following syntax: Arguments Use the following argument to specify the to decode using the Pact function. Argument Type Description string Specifies the base64-encoded to decode. Return value The function returns the decoded . Examples The following example decodes a base64-encoded \"aGVsbG8gd29ybGQh\" string to the decoded \"hello world!\" string in the Pact REPL:",
    "source": "pact-5/general/base64-decode.md",
    "title": "base64-decode"
  },
  {
    "content": "at Use to retrieve the value at the location specified by an number or by a string in a collection. If you specify an number, the collection must be a list of values. If you specify a string, the collection must be an object. Basic syntax Because is an overloaded function, there are two ways to use it. To get a value using the specified location from a list of values, use the following syntax: To get a value using the specified string from an object, use the following syntax: Arguments Use one of the following argument to define the value you want to retrieve using the Pact function. Argument Type Description integer Specifies the information you want to retrieve. If you specify an number, the function returns the value from that location in a list of values. [integer or decimal] Specifies the list of values to retrieve the value from using the specified location. string Specifies the information you want to retrieve. If you specify a string, the function returns the value corresponding to that key from an object. object Specifies the set of key and value pairs to retrieve the value from using the specified . Return value The function returns the value found at the specified or using the specified . The return value can be any data type. Examples The following example returns the value found at the location—starting with 0—from a list of values. For example, the value at location is : You can use the function to return any type of data from a list. For example: The following example returns the value found at the specified key from an object: You can use the function to return any type of data using the specified key from an object. For example:",
    "source": "pact-5/general/at.md",
    "title": "at"
  },
  {
    "content": "acquire-module-admin Use to grant module admin privileges for a particular module . You must already own admin for this particular module; that is, you must either be the owner of the keyset that grants the governance, or be able to pass the governance capability acquisition. Basic syntax Assume you have some module To grant module admin, use It will attempt to acquire the governance cap and if successful, it will grant module admin for the rest of the transaction. Arguments Argument Type Description modref Specifies the module to acquire administrative capabilities for. Return value Module admin acquisition will either fail, or return \"Module admin for module acquired\" Examples See: Basic Syntax.",
    "source": "pact-5/general/acquire-module-admin.md",
    "title": "acquire-module-admin"
  },
  {
    "content": "title: kadena wallet description: The library commands for creating applications and interacting with the Kadena network interactively or by using scripts from the command-line. The commands in this section support creating and managing wallets. id: cli-wallet sidebar_position: 8 tags: ['TypeScript', 'Kadena client', 'frontend'] kadena wallet Use to add, manage, and fund onchain accounts with fungible tokens, for example, by transferring coin. Basic usage The basic syntax for the command is: Actions Use the following actions to specify the operation you want to perform. Use this action To do this add Add a new local wallet. import Import or restore a wallet from its 12-word secret phrase. generate-key Generate a new random public and secret key pair for your wallet from its existing secret phrase. change-password Update the password for your wallet. delete Delete an existing wallet from the local filesystem. list List wallet information. Flags You can use the following optional flags with commands. Use this flag To do this -h, --help Display usage information. -q, --quiet Eliminate interactive prompts and confirmations to enable automation of tasks. -V, --version Display version information. --json Format command results sent to standard output (stdout) using JSON format. --yaml Format command results sent to standard output (stdout) using YAML format. kadena wallet add Use to add a new local wallet to the filesystem. Basic usage The basic syntax for the command is: Arguments You can use the following command-line arguments with the command: Use this argument To do this -w, --wallet-name walletName Specify the name of the wallet. --password-file passwordFile Specify the path to a file that stores the password for your wallet. If you don't have the password stored in a text file, you can enter it as standard input. -l, --legacy Generate a legacy wallet using the ED25519 signature scheme to be compatible with Chainweaver. -a, --create-account Create an account using the first wallet key. Enter true to create an account using the first public key from the wallet. Enter false to skip account creation. -l, --account-alias accountAlias Specify an account alias to store your account details. Examples To add a wallet interactively, run the following command: This command prompts you to enter the wallet name and password, and, optionally, to create a new account using the public key from the wallet. For example: To add a wallet using a password file instead of standard input (stdin), you can run a command similar to the following: This command prompts you to specify whether you want to create a new account using the public key from the wallet. If you select No, the command displays wallet information similar to the following: To create a new wallet and an account without interactive prompting, you can run a command similar to the following: kadena wallet import Use to import or restore a local wallet using an existing 12-word mnemonic phrase. Basic usage The basic syntax for the command is: Arguments You can use the following command-line arguments with the command: Use this argument To do this -m, --mnemonic-file mnemonicFile Specify the path to a file that stores your 12-word mnemonic phrase file used to generate keys for your wallet. If you don't have the mnemonic phrase stored in a text file, you can enter the 12-word phrase as standard input. --password-file passwordFile Specify the path to a file that stores the password for your wallet. If you don't have the password stored in a text file, you can enter it as standard input. -w, --wallet-name walletName Specify the name of the wallet. -l, --legacy Use the ED25519 signature scheme to generate keys from the mnemonic phrase so that the wallet is compatible with Chainweaver. Examples To import a wallet interactively, run the following command: This command prompts you to enter the 12-word mnemonic phrase, wallet name, and password as standard input. To import a Chainweaver wallet using a password stored in a text file, you can run a command similar to the following: This command prompts you to enter the 12-word mnemonic phrase, then imports the wallet with a conformation similar to the following: kadena wallet generate-key Use to generate a new public and secret key pair from the 12-word mnemonic phrase for an existing wallet. Basic usage The basic syntax for the command is: Arguments You can use the following command-line arguments with the command: Use this argument To do this -w, --wallet-name walletName Specify the name of the wallet. -n, --amount amount Specify how many public and secret key pairs to generate. The default is one (1). -i, --start-index startIndex Specify an index to start generating keys at. --password-file passwordFile Specify the path to a file that stores the password for your wallet. If you don't have the password stored in a text file, you can enter it as standard input. -a, --key-alias keyAlias Specify an optional alias for the generated keys. Examples To generate one new public and private key pair for the , you can run a command similar to the following: This command prompts you for the wallet password, number of keys to generate, and a key alias. For example: After you respond to the prompts, the command displays confirmation similar to the following: To generate keys from a wallet using a password stored in a text file, you can run a command similar to the following: This command displays confirmation similar to the following: To generate a key at a specific starting index, you can run a command similar to the following: This command prompts you for the wallet password, then displays confirmation similar to the following: kadena wallet change-password Use to change the password for an existing wallet. Basic usage The basic syntax for the command is: Arguments You can use the following command-line arguments with the command: Use this argument To do this -w, --wallet-name walletName Specify the name of the wallet. --password-file passwordFile Specify the path to a file that stores the current password for your wallet. If you don't have the password stored in a text file, you can enter it as standard input. --new-password-file newPasswordFile Specify the path to a file that stores the new password for your wallet. If you don't have the password stored in a text file, you can enter it as standard input. -c, --confirm Confirm that you want to change the wallet password. Examples To change the password for your wallet interactively, run the following command: This command prompts you to select a wallet, enter your current password, enter a new password, and confirm your changes. For example: If you select Yes to change the wallet password, the command displays conformation of the change similar to the following: To change the password for your wallet using passwords stored in local files, you can run a command similar to the following: kadena wallet delete Use to delete an existing wallet. Basic usage The basic syntax for the command is: Arguments You can use the following command-line arguments with the command: Use this argument To do this -w, --wallet-name walletName Specify the name of the wallet. -c, --confirm Confirm that you want to delete the specified wallet. Examples To delete wallets interactively, run the following command: This command prompts you to select all wallets or a specific wallet and confirm that you want to delete the selected wallet. To delete a single specific wallet deletion, you can run a command similar to the following: This command displays conformation similar to the following: To delete all wallets, run the following command: kadena wallet list Use to list information for an existing wallet or for all wallets. Basic usage The basic syntax for the command is: Arguments You can use the following command-line arguments with the command: Use this argument To do this -w, --wallet-name walletName Specify the name of the wallet. Examples To list information about a specific wallet, you can run a command similar to the following: This command displays key information similar to the following: To list information for all wallets and display the output in YAML format, you can run a command similar to the following: This command displays information for all wallets similar to the following: kadena wallet export Use to export a public and secret key pair from a wallet as unencrypted text. This command returns the exported keys to standard output (stdout) in YAML format by default. Basic usage The basic syntax for the command is: Arguments You can use the following command-line arguments with the command: Use this argument To do this -w, --wallet-name walletName Specify the name of the wallet. -i, --key-index keyIndex Specify the index of the key you want to export. --password-file passwordFile Specify the path to a file that stores the password for your wallet. If you don't have the password stored in a text file, you can enter it as standard input. Examples To export key information for the sf-wallet key at index 3 in YAML format, you can run a command similar to the following: This command prompts you for the wallet password, then displays the public and secret keys as unencrypted text. For example: To use the password stored in a local file and save the exported key to a file in JSON format, you can run a command similar to the following:",
    "source": "reference/cli/cli-wallet.md",
    "title": "cli-wallet"
  },
  {
    "content": "title: kadena tx description: The library provides commands for creating applications and interacting with the Kadena network interactively or by using scripts from the command-line. The commands in this section support creating and managing transactions. id: cli-tx sidebar_position: 7 tags: ['TypeScript', 'Kadena client', 'frontend'] kadena tx Use and transaction templates to create, sign, test, send, and manage transactions. Basic usage The basic syntax for the command is: Actions Use the following actions to specify the operation you want to perform. Use this action To do this add Select a template and add a transaction. sign Sign a transaction using your wallet or using a key pair. test Test a signed transaction using a local endpoint without submitting it to the blockchain. send Send a signed transaction to the network. status Get the status of a transaction. list List transactions. local Submit Pact code as a local call. history Display a formatted list of transactions with their details. Flags You can use the following optional flags with commands. Use this flag To do this -h, --help Display usage information. -q, --quiet Eliminate interactive prompts and confirmations to enable automation of tasks. -V, --version Display version information. --json Format command results sent to standard output (stdout) using JSON format. --yaml Format command results sent to standard output (stdout) using YAML format. kadena tx add Use to create transactions from transaction templates. Transaction templates enable you to provide and customize input to generate transactions for multiple networks and across chains using common patterns. After you provide values for template variables, you can generate and save transaction as API request files that are ready for you to sign, test, and submit for execution. Basic usage The basic syntax for the command is: Arguments You can use the following command-line arguments with the command: Use this argument To do this -t, --template templateName Specify the path to the transaction template file you want to use. Template files are located in the directory and have the file extension. This argument is required. -d, --template-data templateData Specify the path to a file with the values that you want to use for template variables. This argument is optional. -o, --out-file generatedOutput Specify the path for the generated transaction file. -l, --holes Display a list of the template variables that are required for the specified transaction template. Templates The Kadena CLI automatically creates and stores default templates in the configuration folder on your local computer. By default, the templates are located in the folder in your working directory. The default templates in the folder cover the most common types of transactions: The template simplifies the process of transferring tokens between accounts. The template simplifies safe transfer operations that validatethe sender and receiver account information to prevent common mistakes like sending to an incorrect address. These templates make it easier to construct and execute common operations without writing custom code. You can also add your own templates to the folder to make them available for generating transactions using the command. Examples The command enables you to create transactions using templates in combination with the input values you specify. The default templates— and —to enable to you create transactions that transfer tokens between accounts. After you use to generate the transaction request and save it in a file, you can use other commands to sign and submit the request with minimal effort. To generate a transaction from a template interactively, you can run the following command: This command then prompts you to select the template to use and to provide information about the account to transfer from and the account to transfer to. For example: Be sure to use the account name—for example, the principal account name with the k: prefix—for transferring funds between account and not the account alias. WHen specifying the network, you must use the network identifier—for example, development, testnet04, or mainnet01—rather than the network name. After you respond to the prompts, the command displays the transaction you constructed and confirms the location of the file containing the unsigned transaction. For example: kadena tx sign Use to sign a transaction you've previously created. You can sign the transaction using your wallet key or by manually entering one or more public and secret key pairs. Basic usage The basic syntax for the command is: Arguments You can use the following command-line arguments with the command: Use this argument To do this -s, --tx-sign-with signingMethod Specify the signing method. The valid values are wallet or keyPair. -w, --wallet-name walletName Specify the name of the wallet if you are signing with a wallet. --password-file passwordFile Specify the path to a file that stores the password for your wallet. If you don't have the password stored in a text file, you can enter it as standard input. -k, --key-pairs keyPairs Specify each public and secret key pair as comma-separated strings. For example, specify the key pair using the following format publicKey=xxx,secretKey=xxx. If specifying more than one key pair, use a semi-colon (;) between key pairs. -u, --tx-unsigned-transaction-files unsignedTransactionFiles Specify one or more the unsigned transaction file to sign. If specifying more than one file, use a comma-separated list. -d, --directory configDirectory Specify the path to the configuration folder. The default is the current working directory. -l, --legacy Sign using the ED25519 signature scheme for compatibility with Chainweaver. Examples To sign a transaction interactively, run the following command: This command prompts you to select a signing method, the transaction to sign, and keys to use. For example: After you enter the password, the transaction is signed and saved to a file. For example, you should see output similar to the following: To sign a transaction with a public and secret key pair, you can run a command similar to the following: kadena tx test Use to test the execution of a signed transaction against a specified network by making a Local call. By executing the transaction using the /local API endpoints, you can verify Pact smart contracts with actual data in the coin contract tables. You can use this command to check account information and to determine whether transactions will be executed successfully and without incurring transaction fees. Basic usage The basic syntax for the command is: Arguments You can use the following command-line arguments with the command: Use this argument To do this -d, --directory configDirectory Specify the path to the configuration folder. The default is the current working directory. -s, --tx-signed-transaction-files signedTxFiles Specify one or more signed transaction files to sign in a comma-separated list. -n, --tx-transaction-network network Specify a comma-separated list of networks to be used for executing the transaction in order of transaction. For example, to test executing a transaction on the Kadena development, test, and main networks in that order, you can set this argument to devnet,testnet, mainnet. Examples To sign a transaction interactively, run the following command: This command prompts you to select a signed transaction file, then displays the execution results with output similar to the following: kadena tx send Use to send a signed transaction to the specified network. Basic usage The basic syntax for the command is: Arguments You can use the following command-line arguments with the command: Use this argument To do this -d, --directory configDirectory Specify the path to the configuration folder. The default is the current working directory. -s, --tx-signed-transaction-files signedTxFiles Specify one or more signed transaction files to sign in a comma-separated list. --tx-transaction-network network Specify a comma-separated list of networks to be used for executing the transaction in order of execution. For example, to execute a transaction on the Kadena development, test, and main networks in that order, you can set this argument to devnet,testnet, mainnet. --poll Poll the blockchain repeatedly for the current status of a sent transaction. Examples To send a transaction interactively, run the following command: This command prompts you to select a signed transaction file, then displays the execution results with output similar to the following: To poll the blockchain for the transaction results until the transaction is executed, you can run a command similar to the following: kadena tx status Use to retrieve the status of a transaction on the Kadena blockchain. By providing a transaction request key and specifying the network and chain id, you can query the current state of your transactions. This command supports additional options for polling, allowing for real-time status updates until the transaction is finalized. Basic usage The basic syntax for the command is: Arguments You can use the following command-line arguments with the command: Use this argument To do this -k, --request-key requestKey Specify the request key for the transaction you submitted. -n, --network network Specify the Kadena network that you sent the transaction to. For example, you can set this argument to devnet, testnet, or mainnet. -c, --chain-id chainId Specify the Kadena chain identifier that you sent the transaction to. --poll Poll the blockchain repeatedly for the current status of a sent transaction. Examples To check the status of a transaction interactively, you can run a command similar to the following: This command prompts you to specify the request key, network, and chain identifier and returns the current status of the transaction identified by the provided request key. If the transaction hasn't been completed, you can use the option to continuously monitor the status of the transaction until it Polling checks the transaction status every 60 seconds until the transaction is confirmed. To poll the blockchain for transaction results using a request key, you can run a command similar to the following: If the specified transaction has been executed, you should see output similar to the following: kadena tx list Use to list the transactions you've created from transaction templates. The output from the command indicates whether the transaction has been signed. Basic usage The basic syntax for the command is: Arguments You can use the following command-line arguments with the command: Use this argument To do this -d, --directory configDirectory Specify the path to the configuration folder. The default is the current working directory. Examples To list the transactions in your current working directory, you can run the following command: This command displays output similar to the following: kadena tx local Use to submit Pact code as a local call. This command can be useful for testing Pact code without submitting the transaction to the blockchain. Basic usage The basic syntax for the command is: Arguments You can use the following command-line arguments with the command: Use this argument To do this -n, --network networkName Specify the Kadena network to connect to for calling the endpoint. The default is the endpoint on the Kadena test network. -c, --chain-id chainID Specify the chain identifier to connect to for calling the endpoint. Valid values are \"0\" to \"19\". The default is the endpoint on chain 0. -g, --gas-limit gasLimit Specify a gas limit for executing the local transaction. Examples To execute a simple Pact expression using the endpoint on the default network and chain, you can run a command similar to the following: This command evaluates the expressions displays the following output: To execute a Pact expression using the endpoint on a specific chain and set a gas limit for the transaction, you can run a command similar to the following: If the gas limit is too low, the command fails with an error message similar to the following: If you adjust the gas limit, the command succeeds: To execute a Pact command that includes strings, you can escape the inner quotations marks with a command similar to the following: The command evaluates the expression and displays the following output: kadena tx history Use to list your transactions history. Basic usage The basic syntax for the command is: Arguments You can use the following command-line arguments with the command: Use this argument To do this -d, --directory configDirectory Specify the path to the configuration folder. The default is the current working directory. Examples To list the transaction history in your current working directory, you can run the following command: This command displays output similar to the following: To format the output in JSON, you can include the command-line options:",
    "source": "reference/cli/cli-tx.md",
    "title": "cli-tx"
  },
  {
    "content": "title: kadena network description: The library provides commands for creating applications and interacting with the Kadena network interactively or by using scripts from the command-line. The commands in this section support creating and managing network configuration settings. id: cli-network sidebar_position: 6 tags: ['TypeScript', 'Kadena client', 'frontend'] kadena network Use to set up and manage network settings for your development environment. The command creates default network settings for the Kadena development, test, and main networks. You can use the subcommands to view and modify the network settings to suit your needs. Basic usage The basic syntax for the command is: Actions Use the following actions to specify the operation you want to perform. Use this action To do this add Add a new network. set-default Set a network to be the default choice in selection prompts. list List all available networks. update Update properties for an existing network. delete Delete an existing network. Flags You can use the following optional flags with commands. Use this flag To do this -h, --help Display usage information. -q, --quiet Eliminate interactive prompts and confirmations to enable automation of tasks. -V, --version Display version information. --json Format command results sent to standard output (stdout) using JSON format. --yaml Format command results sent to standard output (stdout) using YAML format. kadena network add Use to add a new set of network settings to your development environment. Basic usage The basic syntax for the command is: Arguments You can use the following command-line arguments with the command: Use this argument To do this -a, --network-name networkName Set the name of the network. The valid values are devnet, testnet, and mainnet. -i, --network-id networkId Set the identifier for the network. The network identifier is a similar to the network name but uniquely identifies the network. For example, valid values include development, testnet04, and mainnet01. -s, --network-host networkHost Set the host for the network. -e, --network-explorer-url networkExplorerUrl Set the block explorer URL for the network. -o, --network-overwrite Confirm that you want to overwrite existing network configuration settings. Examples To add network information interactively, run the following command: To add network settings for the Kadena test network, run a command similar to the following: kadena network set-default Use to specify the network to use as your default network in your development environment. You can specify the network as to remove a previously-set default network. Basic usage The basic syntax for the command is: Arguments You can use the following command-line arguments with the command: Use this argument To do this -n, --network networkName Specify the name of network you want to set as the default. The valid values are devnet, testnet, and mainnet. --confirm Confirm the change you are making to set or remove the default network. Examples To add network information interactively, run the following command: To set as the default network for your development environment, run the following command: To remove the default network setting, run the following command: kadena network update Use to update properties for an existing network. Basic usage The basic syntax for the command is: Arguments You can use the following command-line arguments with the command: Use this argument To do this -n, --network networkName Specify the network you want to update. The valid values are , , and . -a, --network-name networkName Update the name of the specified network. -i, --network-id networkId Update the identifier for the network. The network identifier is a similar to the network name but uniquely identifies the network. For example, valid values include development, testnet04, and mainnet01. -s, --network-host networkHost Update the host for the specified network. -e, --network-explorer-url networkExplorerUrl Update the block explorer URL for the specified network Examples To update network information interactively, run the following command: To update the network name and identifier for the development network, run a command similar to the following: To update network settings for the Kadena main network, run a command similar to the following: kadena network list Use to list all available networks. Basic usage The basic syntax for the command is: Examples To display information about all available networks, run the following command: The command displays network information similar to the following: To display the output for this command using YAML format, you can run the following command: The command displays network information in YAML format similar to the following: kadena network delete Use to remove a network and its configuration settings from your development environment. Basic usage The basic syntax for the command is: Arguments You can use the following command-line arguments with the command: Use this argument To do this -n, --network networkName Specify the name of the network you want to delete. The valid values are , , and . -d, --network-delete Confirm that you want to delete the network. Examples To delete network information interactively, run the following command: To delete the network information from your development environment, run the following command:",
    "source": "reference/cli/cli-network.md",
    "title": "cli-network"
  },
  {
    "content": "title: kadena key description: The library provides commands for creating applications and interacting with the Kadena network interactively or by using scripts from the command-line. The commands in this section support creating and managing key pairs. id: cli-key sidebar_position: 5 tags: ['TypeScript', 'Kadena client', 'frontend'] kadena key Use to generate and manage public and secret keys. Basic usage The basic syntax for the command is: Actions Use the following actions to specify the operation you want to perform. Use this action To do this generate Generate random public and secret key pairs. list List available keys. Flags You can use the following optional flags with the command. Use this flag To do this -h, --help Display usage information. -q, --quiet Eliminate interactive prompts and confirmations to enable automation of tasks. -V, --version Display version information. --json Format command results sent to standard output (stdout) using JSON format. --yaml Format command results sent to standard output (stdout) using YAML format. kadena key generate Use to generate a random public and secret key. Basic usage The basic syntax for the command is: Arguments You can use the following command-line arguments with the command: Use this argument To do this -a, --key-alias keyAlias Set an alias for the key to store on the local filesystem. -n, --key-amount keyAmount Specify the number of key pairs to generate. The default is one key pair. -l, --legacy Generate keys using ChainWeaver key derivation methods (ED25519 signature scheme). Examples To generate one random public and secret key pair interactively, run the following command: This command prompts you to enter the alias you want to use for the key and the number of keys to generate. For example: After you respond to the prompts, the command displays confirmation that the keys were generated and where the key is stored on the local filesystem. For example: To generate three random public and secret key pairs that are compatible with Chainweaver, run a command similar to the following: The confirmation message displays the public keys and the files created on the local filesystem for the keys. For example: kadena key list Use to list available keys. Basic usage The basic syntax for the command is: Arguments You can use the following command-line arguments with the command: Use this argument To do this -d, --directory directory Specify the path to the configuration folder on the local filesystem. The default is the current working directory. Examples To list all keys in the current working directory, run the following command: The command displays output similar to the following: To list keys in a directory other than your current working directory and format the output as JSON, run a command similar to the following: The command returns the output using JSON format. For example:",
    "source": "reference/cli/cli-key.md",
    "title": "cli-key"
  },
  {
    "content": "title: kadena dapp description: The library provides commands for creating applications and interacting with the Kadena network interactively or by using scripts from the command-line. The commands in this section support creating a frontend application using popular frontend frameworks. id: cli-dapp sidebar_position: 4 tags: ['TypeScript', 'Kadena client', 'frontend'] kadena dapp Use to create new frontend applications. Basic usage The basic syntax for the command is: Actions Use this action To do this add Create a new application project from a frontend framework template. Flags You can use the following optional flags with commands. Use this flag To do this -h, --help Display usage information. -q, --quiet Eliminate interactive prompts and confirmations to enable automation of tasks. -V, --version Display version information. --json Format command results sent to standard output (stdout) using JSON format. --yaml Format command results sent to standard output (stdout) using YAML format. kadena dapp add Use to create a new frontend application directory from a frontend framework template. This command enables you to start a new project from the following commonly-used frontend frameworks: Angular [Nextjs]([18]: https://nextjs.org/) Vuejs Basic usage The basic syntax for the command is: Arguments You can use the following command-line arguments with the command: Use this argument To do this project-directory Specify the name of application project directory. -t, --dapp-template Specify the type of project to create by selecting a frontend framework template. The valid templates are vuejs, nextjs, and angular. Examples To create a new project called using the Angular template, you can run a command similar to the following: This command prompts you to install missing required dependencies, if needed. After you install any missing dependencies, you can change to the new project directory to see the template files and folders for an Angular project plus a folder with some starter code for a Pact module () and for testing the Pact module in the Pact REPL (). For example",
    "source": "reference/cli/cli-dapp.md",
    "title": "cli-dapp"
  },
  {
    "content": "title: kadena config description: The library provides commands for creating applications and interacting with the Kadena network interactively or by using scripts from the command-line. The commands in this section support creating and viewing an initial configuration folder and default settings for the development environment. label: cli-config sidebar_position: 3 tags: ['TypeScript', 'Kadena client', 'frontend'] kadena config Use to set up and manage configuration settings for the Kadena CLI environment. To get started with the CLI, use to create a configuration folder. The configuration folder stores information about your development environment, including: Default network settings for the Kadena development, test, and main networks. Transaction templates for constructing transactions locally and sending transactions to the blockchain. Local keys, wallets, and accounts that you create for the development environment. Keys, wallets, and accounts you import from existing chains. Basic usage The basic syntax for the command is: Actions Use the following actions to specify the operation you want to perform. Use this action To do this init Initialize the configuration folder with configuration settings for the Kadena CLI to use. path Display the path to the configuration folder currently in use. Flags You can use the following optional flags with commands. Use this flag To do this -h, --help Display usage information. -q, --quiet Eliminate interactive prompts and confirmations to enable automation of tasks. -V, --version Display version information. --json Format command results sent to standard output (stdout) using JSON format. --yaml Format command results sent to standard output (stdout) using YAML format. kadena config init Use to create a configuration folder in the directory of your choice. The command automatically initializes the configuration folder with default network settings for the Kadena development, test, and main networks and adds transaction templates to your development environment. You can also use this command to create your first wallet and account, so you can sign transactions locally for development and testing. By default, the initial configuration settings are written to a folder in your current working directory and the settings can be used from anywhere within that directory. For example, if you run in the folder, the configuration settings are available from anywhere inside that project directory. By using a working directory for the configuration folder, you can use different configuration settings in different folders. Alternatively, you can run with the command-line option to add the configuration folder as a global directory inside of your home directory. This option enables you to use the same configuration settings from any folder on your computer. Configuration settings that are defined in a local working directory take precedence over configuration settings defined in the home directory. If you add more than one configuration folder to your development environment, you can use the command to see details about the development environment you have configured in your working or global directory. Basic usage The basic syntax for the command is: Arguments You can use the following command-line arguments with the command: Use this argument To do this -g, --global Initialize the configuration folder in the current user's home directory, so that it's available globally. For example, this option creates the directory. -c, --create‑wallet Create a new wallet. Set to to generate keys and create a new wallet. ‑w, ‑‑wallet‑name walletName Specify a name for the new wallet. ‑‑password‑file passwordFile Specify the path to a file containing the password for the wallet being created. Alternatively, you can specify the password from standard input (stdin). -L, --legacy Use the ChainWeaver ED25519 signature scheme to generate keys when creating a wallet. -a, --create‑account Create an account using the first wallet key. Set to to use the first wallet key to create a new local account. -l, --account‑alias aliasName Create an account alias to store your account details, if creating an account. Examples To create the Kadena CLI configuration folder and initial settings interactively, run the following command: This command creates the configuration folder in your current working directory and prompts you to create a new wallet. To make the Kadena CLI configuration folder and initial settings available globally from your home directory, run the following command: This command creates a global folder in your home directory—for example, as —so you can use the configuration settings from any folder. The command then prompts you to create a new wallet. To create the Kadena CLI configuration folder with a new wallet and account in the current working directory, run a command similar to the following: To create the Kadena CLI configuration folder without creating a new wallet or account, run the following command: kadena config show Use to display the location of the configuration folder currently being used and details about the development environment you have configured in your working or global directory. If you add more than one configuration folder to your development environment, you can use the command to see the location of the configuration folder that's used for your current directory. To display the location of the configuration folder currently being used, run the following command: The command displays the path to the Kadena CLI configuration folder and additional details about your development environment. For example:",
    "source": "reference/cli/cli-config.md",
    "title": "cli-config"
  },
  {
    "content": "title: kadena account description: The library provides commands for creating applications and interacting with the Kadena network interactively or by using scripts from the command-line. The commands in this section support creating and managing accounts. id: cli-account sidebar_position: 2 toc_max-heading_level: 2 tags: ['TypeScript', 'Kadena client', 'frontend'] kadena account Use to add, manage, and fund onchain accounts with fungible tokens, for example, by transferring coin. Basic usage The basic syntax for the command is: Actions Use the following actions to specify the operation you want to perform. Use this action To do this add Add an account from an existing key or from an existing wallet. delete Delete one or more existing accounts. details Get details for an account. fund Fund an existing or new account. list List available account information. name-to-address Resolve a .kda name to a k:address (kadena names) address-to-name Resolve a k:address to a .kda name (kadena names) Flags You can use the following optional flags with commands. Use this flag To do this -h, --help Display usage information. -q, --quiet Eliminate interactive prompts and confirmations to enable automation of tasks. -V, --version Display version information. --json Format command results sent to standard output (stdout) using JSON format. --yaml Format command results sent to standard output (stdout) using YAML format. kadena account add Use to add a new local account manually from existing keys or from a wallet. The parameters required depend on the type of account you specify using the command-line option. Use to add an account manually from existing local keys. Use to add an account to an existing wallet. Basic usage The basic syntax for the command is: Arguments for using a local key You can use the following command-line arguments with the command: Use this argument To do this -f --from key Specify the type of account to add. Use to add an account manually from existing keys. -l, --account-alias aliasName Specify an alias for the account. -f, --fungible fungible Specify the fungible module name. The default is . -p, --predicate predicate Specify the predicate to use for the account. You can specify on the the , , or built-in predicates or a custom predicate. -k, --public-keys publickey1, publickey2, ... Specify a comma-separated list of public keys. -v, --verify Verify account details on the blockchain. -n, --network networkName Specify the name of the network if you want to verify the account details on the blockchain. -c, --chain-id id Specify the chain identifier if you want to verify the account details on the blockchain. -a, --account-name accountName Provide an account name. If you want to verify the account details on the blockchain, you must provide the network name and chain identifier. Arguments for using a wallet You can use the following command-line arguments with the command: Use this argument To do this -f, --from wallet Specify the type of account to add. Use to add a wallet account. -l, --account-alias aliasName Specify an alias for the account. -a, --account-name accountName Provide an account name. -f, --fungible fungible Specify the fungible module name. The default is . -k, --public-keys publickey1, publickey2, ... Specify a comma-separated list of public keys. -p, --predicate predicate Specify the predicate to use for the account. You can specify on the the , , or built-in predicates or a custom predicate. -w, --wallet-name walletName Provide the name of the wallet. --password-file passwordFile Specify the path to a file containing the password for the wallet. Alternatively, passwords can be passed via stdin. This option is only required only if you choose auto generate keys from the wallet. Examples To add account information interactively, run the following command: This command prompts you to select the method for providing the public keys for the new account. If you have a wallet, you can add a new account based on the public key and secret key pair generated for that wallet. If you have other public keys that you want to use, you can add an account by entering the keys manually. To add an account locally from an account that exists on the Kadena test network and chain identifier 1, run a command similar to the following: This command verifies the account details on the Kadena test network and displays a confirmation message similar to the following: To add an account by providing public keys manually, you can run a command similar to the following: This command prompts you to specify whether you want to verify the account information before adding the account. For example: To add an account from a wallet, you can run a command similar to the following: To add an account from a wallet and automatically generate new keys, you can run a command similar to the following: kadena account details Use to retrieve information about a specified account. The account details include the account balance, the guard public keys and predicate, and the account name. To get this information, you must specify the Kadena network and chain identifier for the account. Basic usage The basic syntax for the command is: Arguments You can use the following command-line arguments with the command: Use this argument To do this -a, --account accountAlias Specify the account alias or account name you want to retrieve details about. This argument is required. -n, --network networkName Specify the name of the network where the account exists. This argument is required. -f, --fungible fungible Specify the type of fungible asset, for example, or . This argument is required. -c, --chain-ids id Specify the chain identifier or a range of chain identifiers. For example, you can specify a single chain identifier (1), a continuous range of chain identifiers (0-3), individual chain identifiers (0,1,5) or all chains (all). This argument is required. Examples To get account details for a specific account alias on the Kadena test network and chain 0 formatted as JSON output, you can run a command similar to the following: This command returns output similar to the following: To get account details for a specific account name on the Kadena test network and chain 1, you can run a command similar to the following: This command prompts you to specify fungible type. For example: You can press Return to accept the default and display account details similar to the following: You can specify a range of chain identifiers to query multiple chains at once. Use a comma to specify discrete chains or a hyphen to specify a continuous range of chain identifiers. For example, to get details for an account on the development network chains 1 and 5, you can run a command similar to the following: This command displays account details similar to the following: To get account information for a continuous range of chain identifiers, you can run a command similar to the following: This command displays account details similar to the following: To get account information for all chain identifiers, you can run a command similar to the following: kadena account fund Use to add funds to an account on the testnet or development networks. This command also creates the account, if it doesn't exist. Note that you can't use this command to fund an account on the Kadena main network. If a faucet contract isn't available on the development network for the specified chain identifier, you can use the option to fund accounts on the development network. Although you can run this command multiple times, there's a limit to the number of coins you can request. You can request up to 20 coins per network. If you select more than one chain in the request, the coins are distributed equally over the chain identifiers you specify. For example, if you request 20 coins for the development network and chains 0-3, each chain receives five coins. Arguments You can use the following command-line arguments with the command: Use this argument To do this -a, --account accountAlias Specify an alias to store your account information. This argument is required. -m, --amount amount Specify the number of coins to transfer to fund the account. This argument is required. -n, --network networkName Specify the name of the network where you want to fund an account. The valid values are devnet and testnet. This argument is required. -c, --chain-ids chainIds Specify the chain identifiers where you want to fund the account. You can specify individual identifiers, ranges, or all for all chains. This argument is required. -d, --deploy-faucet Deploy a coin faucet contract to fund the account on the local development network. Examples To fund an account on a single specific chain, you can run a command similar to the following: If the account doesn't exist on the specified chain, the command displays information similar to the following: To fund an account on a local development network by deploying a faucet contract, you can run a command similar to the following: This command requires you to have the development network running on your local host or accessible from your local computer. For information about setting up a local development network, see Set up a local development network. You can specify a range of chain identifiers to fund an account across multiple chains. Use a comma to specify discrete chains or a hyphen to specify a continuous range of chain identifiers. For example, to fund an account on the development network chains 1 and 3, you can run a command similar to the following: To fund an account across a continuous range of chain identifiers, you can run a command similar to the following: This command displays the request keys for the transaction on each chain, then confirmation similar to the following: To fund an account across all chains on the testnet, you can run a command similar to the following If you try to fund an account too soon after a previous fund request, the command will fail with an error similar to the following: kadena account name-to-address Use to resolve a name to a account name By convention, accounts with the prefix are Kadena account principals with a single public key and the keys-all predicate. Arguments You can use the following command-line arguments with the command: Use this argument To do this -n, --network networkName Specify the name of the network where the account exists. -a, --account-kdn-name kdaAccountName Specify the name to resolve to a account. Examples To map the specified name to an account that uses the prefix followed by a public key, you can run a command similar to the following: kadena account address-to-name Use to resolve an account name with the prefix to a name. Arguments You can use the following command-line arguments with the command: Use this argument To do this -n, --network networkName Specify the name of the network where the account exists. -a, --account-kdn-address accountName Specify the account name to resolve to a name Examples To map the specified account name to a address, you can run a command similar to the following: kadena account list Use to list information for a specific account or for all available accounts. Arguments You can use the following command-line arguments with the command: Use this argument To do this -a, --account-alias accountAlias Specify the alias for the account to list. Examples To list information for a specific account, you can run a command similar to the following: This command displays information similar to the following for the specified account: To list information for all account, you can run a command similar to the following: This command displays information similar to the following for all available account: kadena account delete Use to delete a local account. Arguments You can use the following command-line arguments with the command: Use this argument To do this -a, --account-alias accountAlias Specify the alias of the account you want to delete. -c, --confirm Confirm that you want to delete the specified account. Examples To delete an account interactively, run the following command: This command prompts you to select the account alias that you want to delete, then confirm your selection. To delete a specific account, you can run a command similar to the following: This command displays confirmation similar to the following: To delete all accounts, you can run the following command:",
    "source": "reference/cli/cli-account.md",
    "title": "cli-account"
  },
  {
    "content": "hyperlane-message-id Use to get the Message Id of a Hyperlane Message object. Basic syntax To get the Message Id of a Hyperlane Message object using , use the following syntax: Arguments Name Type Description object:* A Hyperlane Message object The Hyperlane Message object should have the following structure: : integer : integer : integer : integer : string : string : integer Return value The function returns a string representing the Message Id of the given Hyperlane Message object. Examples Here's an example of using to get the Message Id of a Hyperlane Message object: In this example, the function takes a Hyperlane Message object with the following properties: : 1 : 325 : 626 : \"AAAAAAAAAADpgrOqkM0BOY-FQnNzkDXuYlsVcf50GRU\" : \"AAAAAAAAAAAAAAAAf6k4W-ECrD6sKXSD3WIz1is-FJY\" : \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHsABHsicHJlZCI6ICJrZXlzLWFsbCIsICJrZXlzIjpbImRhMWEzMzliZDgyZDJjMmU5MTgwNjI2YTAwZGMwNDMyNzVkZWIzYWJhYmIyN2I1NzM4YWJmNmI5ZGNlZThkYjYiXX0\" : 1 The function returns the Message Id \"9lxextceVw0b18kUdfwSze-3Iw7OE-Z5Kq9I8HTDKGE\" for this Hyperlane Message object.",
    "source": "pact-5/commitments/hyperlane-message-id.md",
    "title": "hyperlane-message-id"
  },
  {
    "content": "hyperlane-encode-token-message Use to encode an object into a Hyperlane Token message as an unpadded base64url string. Basic syntax To encode an object into a Hyperlane Token message using , use the following syntax: Arguments Name Type Description object An object containing , , and The object should have the following structure: : string (base64 encoded representation of a guard) : decimal : string Return value The function returns a string representing the encoded Hyperlane Token message in unpadded base64url format. Examples Here's an example of using to encode an object into a Hyperlane Token message: In this example, the function encodes the provided object into a Hyperlane Token message. The object contains: A represented as a base64 encoded string (which itself represents a guard) An of 123000000000000000.0 A of \"4\" The function returns the encoded message as an unpadded base64url string.",
    "source": "pact-5/commitments/hyperlane-encode-token-message.md",
    "title": "hyperlane-encode-token-message"
  },
  {
    "content": "hyperlane-decode-token-message Use to decode a base-64-unpadded encoded Hyperlane Token Message into an object containing recipient, amount, and chainId information. Basic syntax To decode a Hyperlane Token Message using , use the following syntax: Arguments Name Type Description string A base-64-unpadded encoded Hyperlane Token Message Return value The function returns an object with the following fields: Field Type Description GUARD The recipient of the token message DECIMAL The amount of tokens STRING The chain identifier Examples Here's an example of using to decode a Hyperlane Token Message: In this example, the function decodes the provided base-64-unpadded string and returns an object containing the decoded information: The is 0.000000000000000123 The is \"4\" The is a KeySet with one key and a predicate",
    "source": "pact-5/commitments/hyperlane-decode-token-message.md",
    "title": "hyperlane-decode-token-message"
  },
  {
    "content": "title: Manage node databases id: manage-databases Manage node databases Because a blockchain continuously adds new transactions in new blocks that change the state of the database, it's important to monitor and manage the databases that store chain data and transactional history. For example, as a node operator, you should plan for routine maintenance such as backing up or purging old data. The specific details of your maintenance plan—such as how often you back up or compact node databases—will depend on your specific use-case for the node. For example, if you are running a node as an indexer and want access to full node history, you'll need to consider adding storage or compacting databases more often to reduce disk space requirements. Back up databases Chainweb nodes have two separate databases. One database—the RocksDB database—stores information about blocks and chains. A second database—the Pact Sqlite database—stores information about smart contracts and state. You can configure a Chainweb node to enable database backup operations by starting the node with the and command-line options. For example: Alternatively, you can configure a node to enable database backup operations by specifying the following configuration settings in a node configuration file: If you enable database backups in a configuration file, you can then restart the node with the modified configuration file. For example: After you enable the backup API for a node, you can use the endpoint to a start backup job and the endpoint to check the status of a previously started backup job. You should note that when you call the endpoint, the backup job always backs up the RocksDB database. Backing up the Pact Sqlite database is optional. Backing up both databases takes significantly more time than only backing up the RockDB database. In addition, Pact database backups always require as much space as the active Pact database. For more information about starting backup jobs using the endpoint, see Start a database backup job. For more information about checking the status of a database backup, see Check the status of a database backup. Compact node databases Because a healthy blockchain continuously adds new transactions in new blocks that change the state of the database, managing the storage requirements on individual nodes can be challenging. To address this storage issue, Chainweb provides the command-line program. The program enables you to delete historical unused state from the RocksDB database and the Pact SQLite database. Removing old state that isn't required to validate transactions or reach consensus enables your node to use far less disk space overall while maintaining the semantic integrity of node operations. Note that, if possible, you should run the program on a computer or instance with higher input/output operations per second (IOPs). For nodes that run as virtual machines or instances on a cloud platform, you can typically configure this setting to optimize performance. After you compact the state and restart the node to use the compacted database, you can delete the old database to further reduce your storage overhead or save the old database in another location as a backup. To reduce storage for Chainweb node databases: Open a terminal shell on a computer with access to the you manage. For example, if you run the node in a Docker container, open a terminal in the container. If you installed from a release binary or built it from source, open a terminal or secure shell on the computer where the binary is installed. Verify that you have access to the command-line program by running the following command: If you have access to the program, you should see usage information similar to the following: Compact your and databases by running the command with the following arguments: to specify the path to the database directory you want to compact. You should specify the database root directory that contains the and subdirectories. For example, the directory is the root directory for the directory and the directory. to specify the path to the compacted database. The compact program writes the compacted databases to the and subdirectories within the directory you specify. to specify the directory where you want the program to put the log files it creates, one for each chain. If the directory doesn’t exist, the program creates it. These logs can be useful for debugging if something goes wrong. to specify the network identifier for the node. This argument is optional if you're compacting a database for the network. If you're compacting a database for another network—for example, the Kadena test network—you must specify the network identifier. Valid values are \"\", \"\", and \"\". For example, if you are using the default location for the database directory and a node connected to the Kadena test network, run a command similar to the following: Note that the location of the Chainweb root database directory— in this example—depends on the configuration of the node. If you haven't specified a location in the configuration file, the default location is , for example for a node in the Kadena test network. If your node isn't synchronized with the current block height of the network or doesn't have enough history to ensure proper validation, you might see the operation fail with any error similar to the following: If you have enough history for compaction to succeed, you should see a message in the terminal similar to the following: All other messages are recorded in the log files in the directory you specified for the command-line argument. Stop your node. Restart your node with the new compacted database directory. You can specify the new compacted database directory as a command-line option or edit the node configuration file you use to set the new compacted database directory. For example, you can restart the node with a command similar to the following: If you're editing the configuration file, update the YAML or JSON file to set the field to the location of the compacted database. For example: After you restart the node, it should run normally with the reduced database size as though nothing has changed. You can delete the old database files or keep them locally or in another location as a backup. If you encounter errors or warnings, open a new issue for chainweb-node or contact Kadena developers in the infrastructure channel on the Kadena Discord server.",
    "source": "guides/nodes/manage-databases.md",
    "title": "manage-databases"
  },
  {
    "content": "title: Testnet deployment guide description: \"Deploy your Solidity and EVM-compatible smart contract the Kadena Chainweb EVM test network.\" id: howto-evm sidebar_position: 2 tags: [evm, chainweb, network, node operator] Chainweb EVM testnet deployment If you are a smart contract developer used to building decentralized applications for Ethereum and EVM-compatible chains, deploying on the Kadena Chainweb EVM Testnet is no different that deploying on any other EVM-based chain. At a high level, there are three basic steps: Get test tokens from the Chainweb EVM Testnet faucet application. Configure your development environment or wallet to use one or more Chainweb EVM Testnet chains. Deploy your application the way you would on any other chain. This guide provides detailed instructions for each step. Because Hardhat is one of the most common development environment for Ethereum, this guide focuses on configuring and deploying Hardhat and the plugin to deploy Solidity smart contracts on the Chainweb EVM testnet. Additional guides that focus on other development tools might be provided later, it there's sufficient interest from the broader community. Get a wallet and tokens Before you can deploy any smart contracts, you must have a wallet that supports the Kadena network and Chainweb EVM nodes. You can add the Kadena Chainweb EVM network to any EVM-compatible wallet, such as MetaMask, Ledger, or Coinbase Wallet. Note that you must use an EVM-compatible wallet to deploy on Chainweb EVM. Wallets that are used for traditional Kadena development—such as Chainweaver, Koala, Ecko, or Linx—only support Pact smart contracts at this time. Most EVM-compatible wallets provide an Add Network or a Connect option where you can specify details about the network you want to add or connect to. However, navigating to the network settings will vary depending on the specific wallet and version you use. For example, if you use MetaMask: Expand Ethereum Mainnet to display the list of networks: Click Add a custom network. Add the network settings for Kadena Chainweb EVM. Use the following information to add Kadena Chainweb EVM Testnet to your wallet: Network Name: Kadena RPC: https://testnet.kadena.io (placeholder) Chain ID: 4269 (placeholder) Currency Symbol: KDA Block Explorer URL: https://kadenascan.io (placeholder) After you connect your wallet account to the Kadena Chainweb EVM Testnet, you need to fund the account with testnet KDA token to deploy contracts and pay transaction fees. Testnet KDA tokens or tKDA have no monetary value but they are required to execute transactions on the network. To get tokens for Chainweb EVM Testnet: Official Kadena faucet: Kadena provides a public faucet interface for testnet KDA. Open faucet.evmtestnet.chainweb.com in a browser, enter your account address, and select Testnet. The faucet contract will transfer 20 tKDA to the account you specify. Alternate faucet: You can opt to use third-party faucet services—such as Tatum—to obtain tKDA tokens for Kadena Chainweb EVM Testnet. The Tatum faucet can transfer up to 100 tKDA tokens to your wallet address. However, you might be required to sign up for services to access the Tatum Dashboard. The official faucet should be sufficient for most testing scenarios, but an alternate faucet can be a useful resource if the official faucet rate-limits your usage. Important: Your Chainweb EVM testnet account is on EVM chain 0 in the network. By default, all smart contract will be deployed on a single chain during the initial phase of deployment to Chainweb EVM. For more information about the Kadena multi-chain ecosystem, see Multi-chain support. Configure the development environment After you have a Chainweb EVM testnet account with funds, the next step is to configure your development environment to use the Kadena Chainweb EVM Testnet network. These steps assume you are on using Hardhat, which a popular Ethereum development framework, and the Kadena Hardhat plugin @kadena/hardhat-chainweb for multi-chain support. Before you begin Verify that your development environment meets the following basic requirements: You have the Node.js runtime environment, npm or yarn package manager, and npx installed. This tooling is required to deploy Solidity contracts with Hardhat. Yoy have Git installed for managing your project. Configure Hardhat settings To configure the development environment to deploy to one chain: Create a new project directory by running a command similar to the following: Initialize the Hardhat project in the directory by running the following commands: Follow the prompts displayed to generate a default file and a sample project structure. Modify the default file to configure Hardhat to connect to Kadena Chainweb EVM testnet chain 0: When you connect to Chainweb EVM Testnet to deploy, use the account you funded with testnet KDA. Consider using environment variables for private keys—for example, use the package and —so to avoid hardcoding secret keys in your configuration file. If you prefer not to expose your private keys, you can configure Hardhat to use a wallet provider and enter your keys manually when you deploy. However, using Hardhat scripts is more automation-friendly. Deploy a smart contract using Hardhat After you configure your development environment to connect to Chainweb EVM Testnet, you are ready to deploy smart contracts on the network. To deploy using Hardhat: Run the deployment script and specify the and command-line options: With this command, Hardhat attempts to connect to the RPC endpoint for chain 0 and send the transaction from your account. If the contract is deployed successfully, the console will display the contract address and the transaction hash. Wait for confirmation that the transaction has been mined into a block. As a proof-of-work network, it takes 30 seconds on average to produce a block. You should allow time for the transaction to be mined into a block and for the block to be confirmed by consensus and added to the chain. If Hardhat doesn't report errors during deployment, it's likely that the contract will be successfully deployed. You can double-check by querying the contract or looking up the transaction in a block explorer. Troubleshooting If the deployment script times out or cannot connect to the network, check that the RPC URL is correct and verify internet connectivity. If you see an insufficient funds error, make sure the account you are using has enough testnet KDA tokens on the chain where you are deploying the contract. The transaction fee for deploying a simple contract typically costs less than 0.1 KDA, so you should have enough funds from the official faucet to deploy multiple contracts. If you see a nonce or chainId error, check that the chainId in Hardhat configuration file matches the network you are deploying to. Unlike Ethereum, the Kadena Chainweb EVM testnet doesn’t yet have an Etherscan type of service to verify contracts. Because Chainweb EVM doesn't have an official contract verification tool at this time, you can't upload your Solidity source and have an explorer show “Verified” code. Contract verification tooling is in early stages of development. Congrats – you have deployed a Solidity smart contract on Kadena’s testnet! Your contract lives on Chainweb EVM chain 0. Multi-chain support",
    "source": "guides/nodes/evm-testnet.md",
    "title": "evm-testnet"
  },
  {
    "content": "title: Get started with Chainweb EVM description: \"Deploy a private Chainweb EVM node to set up a local development network for testing.\" id: evm-devnet sidebar_position: 2 tags: [pact, chainweb, network, node operator] Get started with Kadena Chainweb EVM The Kadena network relies on the Chainweb consensus protocol that enables multiple independent chains to share a common view of state beyond a certain block depth. This common view of state enables any chain in the network to verify whether historical events beyond the required block depth occurred on any other chain. For example, if a transaction occurs on chain 3, chain 3 can produce a simple payment verification (SPV) proof that chain 6 can verify by checking the shared history. The only requirement for verifying the transaction is that the proof must be conveyed from the original chain, in this example, chain 3—to the target chain, in this example, chain 6. With this approach, security relies strictly on the shared consensus across the chains in the network. There are no relayers, oracles, validators, archives, or third-party coordinators. The chains in the Kadena Chainweb EVM network run in parallel, but independently, allowing for concurrent transaction processing without the risk of collisions or delays. Because Chainweb provides a single common view of state, global security, and concurrent payload processing, Kadena Chainweb EVM enables cross-chain transactions to be executed more efficiently and at a lower cost than traditional bridging techniques. How it works At a high level, Kadena Chainweb EVM bridging involves three main steps: An event occurs on a source chain For a cross-chain transfer, a user initiates a transaction to transfer tokens from a source chain using a smart contract. The smart contract emits a well-defined cross-chain event. An off-chain endpoint generates proof of a specific event For a cross-chain transfer, a user queries an endpoint that generates a simple payment verification proof or another type of proof that can be validated. The proof must encode all of the information required to uniquely identify the event on the source chain and the contract on the target chain. The event is observed on the target chain For a cross-chain transfer, a user relays the proof to the target chain, where it is verified against the history shared by the source and target chains. By checking the shared history, the contract on the target chain validates that the transfer event claimed by the user occurred on the source chain. The smart contract on the target chain completes the transaction, for example, by minting the number of tokens transferred from the source chain. Chainweb EVM preview The kadena-evm-sandbox repository presents a preview of the support for the Ethereum Virtual Machine (EVM) execution environment running on Chainweb nodes in the Kadena blockchain. This preview demonstrates how to set up EVM-compatible nodes and execute cross-chain transactions to transfer assets from one chain to another. In the preview, there are two EVM-compatible chains and a Solidity contract that demonstrates transferring tokens between the two EVM chains. The preview is the first step toward an integrated and feature-rich multi-chain proof-of-work consensus network for Solidity and Pact developers to deploy smart contracts. What's included in the preview With the preview, you can set up a local Kadena development network that runs a single Chainweb node and a single mining client. The development network consists of twenty (20) chains with two chains that use EVM as the payload provider for processing transactions. Because the development network is intended for demonstration purposes, proof-of-work consensus is disabled and blocks are produced at a constant rate of two seconds per chain, or ten blocks per second across the whole network. The repository for the preview includes the following directories and components: Name What it provides allocations Files to set up an ethers project that describes a set of BIP-44 wallets and allocations to be created in the genesis block for the development network. apps Files to set up the contract, server, and frontend application that demonstrates cross-chain transactions. blockscout Files to set up an optional block explorer for the EVM chains in the development network. Blockscout instances provide an explorer interface and API similar to Etherscan. devnet A Docker compose project and files to set up the Chainweb node for the development network. docker‑bake.hcl A script to build multi-platform images for the development network Docker compose project. docs Technical documentation about the functions and events proposed for the Kadena Chainweb EVM cross-chain bridging protocol in draft form. network An optional command-line program for managing and monitoring the development network in the Kadena Chainweb EVM sandbox. solidity A Hardhat project that demonstrates the implementation of a simple ERC-20 token with support for burn and mint style transfers between the two EVM chains in the network. Prerequisites and system requirements Before you set up the preview development environment, verify that your local computer has the required tools installed and meets the following basic requirements: You must have Docker and Docker Compose or an Open Container Initiative (OCI) compliant alternative. You must have at least 4 CPU cores and 8 GB of memory available for Docker. You can configure CPU and memory for Docker using command-line options or Resource settings. You must have a network connection to download the container images for the development network. You must have a POSIX-compliant terminal shell for running command-line programs and scripts. You should have and jq programs installed. You must have JavaScript tooling installed, including Node.js version , the npm or yarn package manager, and npx to deploy Solidity contracts with Hardhat. You must have at least 6 CPU cores and 12 GB of memory available for Docker to run the Blockscout block explorer:. Quick start To download and install the Chainweb EVM preview: Open a terminal shell on your computer. Clone the kadena-evm-sandbox repository by running the following command: Change to the directory by running the following command: The kadena-evm-sandbox directory includes the command-line program that you can use to perform common tasks to manage and monitor the development network. The program supports many commands that are similar to Docker commands. You can explore all of the commands available by running the following command: Pull the latest container images using the command-line program by running the following command: You can execute commands for convenience or use commands directly. Pulling the latest container images isn't strictly required, but it's recommended before you start the development network for the first time. Start the network by running the following command: This command starts the development blockchain and allocates the test account addresses. You should see output similar to the following excerpt: Check that blocks are being produced by running the following command: This command displays the current block height and cut height for the development network with output similar to the following excerpt: You can call the command repeatedly to verify that the block height and cut height values are increasing. Test the simple token contract To test the simple token contract: Install Hardhat and related dependencies in the development network by running the following command: If the package manager reports any issues, address them before continuing to the next step. For example, you might be prompted to to address issues. Test the simple token contract by running the following command: This command executes a set of tests that deploy the ERC-20 token contract and check that token transfer operations succeed or revert as expected when tokens are transferred between addresses on the two Chainweb EVM chains. For example, you should see output similar to the following excerpt: Restarting the development network If the development network stops producing blocks or seems stuck, you can restart the chainweb-node service without stopping or restarting other network components. To restart the development network: Stopping the development network When you're finished testing, you can shut down the development network, remove all containers, and reset the database to a clean state. To shut down the network and remove containers: Integrating with other Hardhat projects If you want to experiment with using the Chainweb EVM development network with other Hardhat projects, you must configure the Hardhat project to connect to the Chainweb EVM development network. You must also configure the Hardhat project to include account information—addresses and balances—for all available accounts. In the directory, the directory provides an example of a simple Hardhat project with a Hardhat configuration file, Solidity smart contract, and a test file. The project includes the following files to configure the Chainweb EVM development network: The file contains all of the account information generated from a test BIP-44 wallet using a seed entropy value of (16 zero bytes). The file reads the account information from the file, sets the properties that describe the Chainweb EVM nodes, and configures the network as the default Hardhat network for the project. After a project is configured to use the Chainweb EVM development network settings and accounts, you can run unit tests for the project using the standard command. For example: Modifying the Hardhat project To integrate with the Chainweb EVM development network: Copy the file into the root directory of your Hardhat project. Open the file for your Hardhat project in your code editor. Copy and paste the code to read account information from the file into the file for your project. For example: Copy and paste the code to configure network information from the file into the file for your project. For example: (Optional) Copy and paste the code to configure etherscan settings from the file into the file for your project. For example: Save your changes and close the file. Compiling and testing integration After configuring your Hardhat project to use the Chainweb EVM development network, you can compile, test, and deploy the project using standard commands. For example, compile the project by running the following command: Run unit tests using the standard command: Similarly, if you have a deployment script in a directory, you can deploy the project using the standard command to run scripts: Changing the default network If you prefer to keep the network as the default network for your Hardhat project, you can remove the setting that configures to be the default network. To change the default network: Open the file for your Hardhat project in your code editor. Remove or comment out the following line from the network settings: Run commands using the or command-line option. For example, run unit tests on the Chainweb EVM development network like this: Similarly, you can run scripts on the Chainweb EVM development network like this: You can then run the same commands without the command-line option to execute them on the default Hardhat network instance. If your smart contract uses any Kadena-specific precompile functions or other Kadena-specific or Chainweb-specific features, you might be unable to run the contract on the Hardhat network. If you have a smart contract that requires Hardhat-specific features, you might be unable to run the contract on the Kadena development network. Signing transactions and switching chains By default, when you call a Solidity smart contract from a test file or a script using , the transaction is executed by the first signer address and private key for the local development environment. This is the true whether the local development environment is the default Hardhat network or the Kadena development network. For example, the following transaction is signed by the account that corresponds to the first address in the list of addresses for the current network context: This address is the for the transaction. In the test files in the directory, this address is to the deploying signer you see displayed when you execute the tests: This deploying signer is simply the first signer retrieved by the function in the file. Typically, if you wanted to call a smart contract function using a different signer—for example, —you could call the function like this: If you call this function in the default Hardhat network, the call creates a new contract instance using the new signer in the background. However, if you want to call a contract in the Kadena development network, you must be aware of the network context to get the correct signing address. For example, if is the default network and you want to call a contract that is on instead of , you must first switch to and then get the signer address. This difference in behavior is because signers in Hardhat have a specific network context. In the Kadena development network, the signer retrieved on has the same address as the signer on but is not the same signer object. Therefore, you must specifically switch to the network context to get the signer for that network before you execute the transaction using that account address. For an example of how to switch the network context, see the \"Should transfer tokens to different address from chain 1 to chain 0\" test the in the file. Blockscout You can explore the Chainweb EVM development network chains using the optional Blockscout. Blockscout is a blockchain monitor that provides a user experience that is similar to Etherscan. For additional information, see the Blockscout README. To use Blockscout: Open a terminal shell and change to the directory, if needed: Pull the latest images by running the following command: Start a Blockscout instance by running the following command: After running this command, it can take several minutes before you can open Blockscout in a browser. Open the appropriate URL for the chain you want to explore: The Blockscout UIs for the EVM chains are available at the following URLs. Chainweb EVM chain 0 Chainweb EVM chain 1 Network components and chain specifications software: chainweb-node exported ports: 1848 (Chainweb service API) software: [chainweb-mining-client][https://github.com/kadena-io/chainweb-mining-client) worker: constant-delay with a 2s rate per chain software: kadena-reth exported ports: 8545 (HTTP ETH RPC), 8546 (Websocket ETH RPC) Chainweb chain-id: 0 Ethereum chain-id: 1789 chain specification: software: kadena-reth exported ports: 8555 (HTTP ETH RPC), 8556 (Websocket ETH RPC) Chainweb chain-id: 1 Ethereum chain-id: 1790 chain specification: Account allocations in the development network The chain specifications include the initial account allocations for the genesis block. All of the initial accounts are generated from a BIP-44 wallet using a seed entropy value of (16 zero bytes). You can view details about how the wallet is generated in the file. You can view the addresses, private keys, and starting balances by running the following command: The allocations in the genesis block use the following path values: (address: 0x8849BAbdDcfC1327Ad199877861B577cEBd8A7b6) (address: 0xFB8Fb7f9bdc8951040a6D195764905138F7462Ed) (address: 0x28f2d8ef4e0fe6B2E945cF5C33a0118a30a62354) (address: 0xa24a79678c9fffEF3E9A1f3cb7e51f88F173B3D5) (address: 0x47fAE86F6416e6115a80635238AFd2F18D69926B) (address: 0x87466A8266b9DFB3Dc9180a9c43946c4AB2c2cb2) (address: 0xA310Df9740eb6CC2F5E41C59C87e339142834eA4) (address: 0xD4EECE51cf451b60F59b271c5a748A8a9F16bC01) (address: 0xE08643a1C4786b573d739625FD268732dBB3d033) (address: 0x33018A42499f10B54d9dBCeBB71831C805D64cE3) (address: 0xa3659D39C901d5985450eE18a63B5b0811fDa521) (address: 0x7e99c2f1731D3750b74A2a0623C1F1DcB8cCa45e) (address: 0xFd70Bef78778Ce8554e79D97521b69183960C574) (address: 0xEE2722c39db6014Eacc5FBe43601136825b00977) (address: 0xeDD5a9185F9F1C04a011117ad61564415057bf8F) (address: 0x99b832eb3F76ac3277b00beADC1e487C594ffb4c) (address: 0xda1380825f827C6Ea92DFB547EF0a341Cbe21d77) (address: 0xc201d4A5E6De676938533A0997802634E859e78b) (address: 0x03e95Af0fC4971EdCa12E6d2d1540c28314d15d5) (address: 0x3492DA004098d728201fD82657f1207a6E5426bd) The mining accounts are: (address: 0xd42d71cdc2A0a78fE7fBE7236c19925f62C442bA) (address: 0x38a6BD13CC381c68751BE2cef97BD79EBcb2Bb31) Running the frontend application demo The kadena-evm-sandbox repository includes an folder with the files for an application that demonstrates deploying contracts, funding accounts, and transferring assets between the two Chainweb EVM chains in the development network. The demonstration requires the package manager to install dependencies. If you don't have installed in your local environment, follow the steps in Prepare your workspace to get started. If you have installed and defined in your shell profile, you can continue to Start the application server. Prepare your workspace Open a new terminal shell and change to the directory created when you cloned the repository: If necessary, you can pull the latest files for the directory by running the following command: Install by running the following command: Set up your workspace for by running the following command, then following the instructions displayed in the terminal: Start the application server In the current terminal shell, check that the Kadena development network is up and producing blocks by running the following command: In the current terminal shell, change to the directory: Install dependencies and generate types for the by running the following command: Start the by running the following command: After you run this command, the server must continue to run in the terminal, so you need to open a new terminal shell in the next step. Start the transfer demonstration application The sample application includes a set of playlists that demonstrate common transactions executing on the Kadena Chainweb EVM development network. The playlists include transactions that demonstrate the following activities: Deploy contracts Fund accounts Transfer assets between accounts on the same chain Transfer assets between account on different chains The details of the transactions—including the chains, accounts, and amounts transferred—are defined in the file. To start the application: Open a new terminal shell and change to the directory. For example, if you open a new terminal in your home directory, change to the directory: Install frontend dependencies for the application by running the following command: Start the application in the terminal by running the following command: Open a browser and navigate to the application URL displayed in the terminal. By default, the application runs on the localhost and port 3000, so the default address in http://localhost:3000/. You should see that the application displays a message that indicates no contracts are deployed and a control panel similar to the following: Click the Eject control in the application to deploy the initial contract with playlists for chain0 and chain1. In the terminal where the application server runs, you should see messages similar to the following to indicate that contracts are successfully deployed on and and the accounts for Alice and Bob are funded with an initial balance: Click the Play control in the application to start running the selected playlist of transactions. In the terminal where the application server runs, you should see messages similar to the following to indicate You can click on different playlists, tracks, and operations to explore additional transaction details. Click the Stop control in the application to reset and restart the playlist at the current block height. Stop the transfer demonstration To stop the transfer demonstration: Switch to the terminal where the application frontend runs, then press Control-c to stop the application process. Switch to the terminal where the application server runs, then press Control-c to stop the application server process. Navigate back to the directory, then shut down the Kadena Chainweb EVM development network by running the following command: Related resources For additional information about Kadena Chainweb EVM, see the following resources: Kadena Chainweb EVM repository Proposal: Cross-Chain Bridging Protocol (Draft) Cross-chain bridging (draft summary) Cross-chain bridging (draft summary) This Kadena Improvement Proposal (KIP) defines an interface and conventions for performing cross-chain bridging for Kadena Chainweb EVM-compatible chains. The proposal introduces a protocol to standardize how transactions are initiated, verified, and completed across chains in an EVM-based network where information about event history is known to both the source and target chain. The protocol describes the smart contract functions and events required to perform the following steps for secure cross-chain bridging: Initiate a cross-chain burn transaction on a source chain that emits a well-defined event with expected metadata. Transmit proof that the transaction initiated on the source chain completed to be verified by the target chain. Validate the proof that the event occurred—guaranteeing the provenance and uniqueness of transferred data—using a precompile function on the target chain. Complete the cross-chain transfer with a mint transaction on the target chain.",
    "source": "guides/nodes/evm-get-started.md",
    "title": "evm-get-started"
  },
  {
    "content": "title: Get started running a node description: \"Become a Chainweb node operator to support the Kadena network infrastructure.\" id: howto-node-operator sidebar_position: 2 tags: [pact, chainweb, network, node operator] Get started running a node Computers that run the Chainweb consensus protocol—by installing and managing the software—provide the resources that power the Kadena public blockchain network by participating in consensus and validating transactions to produce blocks. By installing and running and connecting to the Kadena test or production network, you can extend the peer-to-peer communication infrastructure and have direct access to the blockchain state. You can help to improve the security and scalability of the network just by participating. You can also earn rewards if you choose to add resources to calculate proof-of-work solutions to validate transactions as a miner. Minimum system requirements Before installing Chainweb, you should verify that your computer meets the following minimum recommended hardware requirements for running a node: CPU: Minimum of two (2) CPU cores. RAM: Minimum of four (4) GB of RAM. Storage: Minimum 250 GB using a solid state drive (SSD) or fast hard disk drive (HDD). Network: Publicly-accessible IP address. Operating system: Linux AMD64 architecture. If you also plan to use the node for mining, to submit transactions, or to query blockchain data, you should verify that your computer meets the following minimum recommended hardware requirements: Four (4) CPU cores. Eight (8) GB of RAM. Operating system architecture Most software runs on Linux or macOS with AMD64 architectures. If you want to run a Chainweb node on Linux or macOS with ARM64 architecture, you'll need to build the binaries yourself from the source code. You might experience some unexpected behavior when running a node on ARM64 architecture. Note that you should not configure mining for nodes on ARM64 architecture. Running a mining node on ARM64 architecture could cause your node to fork from the network. If you want to run a Chainweb node on Microsoft Windows, you should note that this isn't a supported configuration and requires you to install the latest Windows Services for Linux (WSL) software. If you choose to proceed after installing WSL, you can install the software in the WSL virtual environment rather than using the native Windows operating system. Incoming and outgoing network rules In addition to a publicly-accessible IP address, nodes must be able to communicate with peers and accept incoming messages from other computers in the network. If your computer is behind a firewall or is a virtual guest connecting to the internet through a host computer, you should review your network configuration and open required ports to allow inbound and outbound traffic. For example, you might need to configure port forwarding for port 1789 on your router or host computer to allow inbound connections from remote nodes. Installation options There are several options for setting up a Chainweb node in a physical or virtual environment. For example, you can run a Chainweb node image in a Docker container or build the binaries directly from the source code. You can install release binaries directly on a physical Linux server or run them using the infrastructure from a cloud services provider. For more information about your installation options, see the following topics: Install release binaries Run in a Docker container Build from source code Install release binaries You can download compressed archive files with release binaries for Ubuntu Linux directly from the Releases page in the chainweb-node repository. If you have Ubuntu 20.04 or Ubuntu 22.04 on a physical or virtual machine, downloading the binary is the most straightforward installation path. To install from a release archive: Open a terminal shell on the physical or virtual host with the Ubuntu Linux operating system. Update the system with the latest software by running the following command: Install the required packages by running the following command: If your computer uses the Ubuntu 20.04 operating system, install the package instead of the package. Download the archive file from the Releases page. Note that the archive file naming convention includes the version, compiler version, Ubuntu version, and a commit hash identifier using the following format: For example, the archive file for Ubuntu 22.04 and version 2.26.1 looks like this: Keep in mind that if you attempt to run a version of the that's out-of-date, the program displays an error message similar to the following: Be sure to check the chainweb-node repository for the latest release. Change to the directory that contains the downloaded file—typically, the Downloads folder—or move the file to a new location. Unzip and extract the compressed archive by running a command similar to the following: Verify the binary is ready to use and review command-line configuration options by running the following command: You should see usage information about the configuration settings you can specify as command-line options similar to the following truncated output: From the usage information, you can see that there are a large number of configuration options that you can use to control and operation and behavior of the Chainweb node. Before you start the node, you should review the configuration options and the default values to determine whether you want to make any changes to the configuration of the node. For information about this next step, see Review the default configuration. Run in a Docker container If you have Docker installed, you can download a image and run a node in a Docker container. If you want to run the node in a Docker container but don't have Docker installed yet, see the instructions provided in Install Docker Engine to download and install Docker for your operating system. After you have Docker installed, use the following instructions to pull the Docker image and run in a Docker container. To run in a Docker container: Open a terminal shell on the physical or virtual host where you have Docker installed. Verify that Docker is installed and the process is running with the following command: This commands should return information similar to the following: Pull the latest image by running the following command: Verify the binary is ready to use and review command-line configuration options by running the following command: You should see usage information about the configuration settings you can specify as command-line options similar to the following truncated output: From the usage information, you can see that there are a large number of configuration options that you can use to control and operation and behavior of the Chainweb node. Before you start the node, you should review the configuration options and the default values to determine whether you want to make any changes to the configuration of the node. For information about this next step, see Review the default configuration. Build from source In most cases, you should run Chainweb nodes using officially released binaries or from the binary packaged in officially released Docker images that you can download from the Releases page. However, if you choose to build the chainweb-node binary yourself, you should first ensure that you have an officially released and tagged version of the source code. Tagged versions of the source code are tested extensively to ensure that they are compatible with all nodes in the Chainweb network. You shouldn't build from the branch if you plan to run the node as part of a Kadena public network. Download source code To download tagged source code: Open the Releases page. Download the compressed archive for your working environment: Unzip and extract the compressed archive by double-clicking or by running a command similar to the following: Change to the source code directory. After you have downloaded and unpacked the source code, you have two options for building the binary from the source: You can build the binary using the native Haskell toolchain. You can build the binary using the Nix package manager. Build with Haskell To build with the native Haskell toolchain: Download and install the following Haskell tools: Glasgow Haskell Compiler (GHC), , or later. Haskell build tool CABAL, , version 3.4, or later. You can download, install and manage the Haskell toolchain using . To install on Linux, macOS, FreeBSD, or WSL2, go to GHCup to download the main Haskell installer, then follow the installation instructions to install the toolchain. Install the development versions of the following required libraries: gflags-dev snappy-dev zlib-dev lz4-dev bz2-dev zstd-dev If the host uses the advanced package tool (apt), you can install these libraries by running the following command: On macOS, if you have Apple Developer Tools () and installed, you can install these libraries by running the following command: Ensure the build tool is up-to-date by running the following command: Build a binary by running the following command: Locate the executable binary by running the following command: Verify that is ready to use and review command-line configuration options by running the following command: You should see usage information about the configuration settings you can specify as command-line options similar to the following truncated output: From the usage information, you can see that there are a large number of configuration options that you can use to control and operation and behavior of the Chainweb node. Before you start the node, you should review the configuration options and the default values to determine whether you want to make any changes to the configuration of the node. For information about this next step, see Review the default configuration. Build with Nix One advantage of using the Nix package manager to build and run the chainweb-node binary is that Nix caches binary dependencies, so you can download pre-built binaries for for the libraries and packages that Chainweb requires. To build with the Nix package manager: Download and install Nix by clicking Get Nix, then follow the instructions. Open your shell startup profile file for the shell you use in a text editor. For example, if you are using the shell, open the file. If you are using the shell, open the file. Add the following line to the startup profile: If you don't want to edit the profile directly using a text editor or don't have a text editor installed, you can run a command similar to the following: If you are using a different shell, change to the appropriate startup script for your shell. Open the file in a text editor and add the following lines to the file: If the directory doesn't exist, you should switch to the root user and create it, then add the file to the directory. Restart the process. Most installations of Nix are multi-user and require you to restart the nix daemon to make your changes take effect. You can check whether Nix is running in multi-user or single-user mode by running the following command: If you see only the command, then you are using single-user mode and you don't have to do anything else. If you see a process, then you are using multi-user mode and you need to restart the process On macOS, run the following commands: On Linux, run the following command: Build by running a command similar to the following for a specific release , such as 2.26.1: After starting the build, you should see messages similar to the following: These messages indicate that the pre-built artifacts are being successfully downloaded from the cache. When the build is finished, the directory with the source code contains a subdirectory with a symbolic link to the Nix cache. Verify that is ready to use and review command-line configuration options by running the following command: You should see usage information about the configuration settings you can specify as command-line options similar to the following truncated output: From the usage information, you can see that there are a large number of configuration options that you can use to control and operation and behavior of the Chainweb node. Before you start the node, you should review the configuration options and the default values to determine whether you want to make any changes to the configuration of the node. For information about this next step, see Review the default configuration. Review the default configuration Now that you have a Chainweb node binary ready to run, you should review the default configuration options and the default values. Configuration options and settings control many types of node behavior, operation, and features. For example, you can use configuration options to enable or disable the backup API for the node. You can also modify configuration settings to change the logging level for node messages. To review the default node configuration: Open a terminal shell on a computer with access to the binary. Change to the directory that contains the binary. View the default configuration settings in the terminal by running the following command: If you're running the node in a Docker container, you can view the configuration settings by running the following command: Extract the default configuration settings to create a configuration file for the node by running the following command: If you're running the node in a Docker container, you can create a configuration file for the node by running the following command: This command creates the default configuration file in the host environment outside of the Docker container so that you can review configuration options and settings before starting the node in the container. After you create a node configuration file from the default settings, you should determine whether you want to make any changes to the configuration of the node. If you want to modify any of the default settings or add features that are disabled by default, you can: Edit settings in one or more configuration files. Use corresponding command-line options to control node operations. For more information about editing configuration settings in the configuration file, see Edit the configuration settings. For information about using command-line options to control node operations, see the chainweb-node command-line reference. Edit the configuration settings After you create a node configuration file from the default settings, you can edit the configuration to suit your environment. For example, you can edit the configuration file to make the following types of changes: Enable the backup API and specify the directory for backup files. Connect the node to the Kadena test network instead of the Kadena main network. Specify a directory for blockchain database files. Ignore or connect to a subset of bootstrap nodes. To edit the node configuration: Open a terminal shell on a computer with access to the node configuration file. Copy the default configuration file to save as a backup. For example, copy the to save a copy of it as the file: Open the configuration file in a text editor and edit the settings you want to change. For example, the following excerpt illustrates some common changes: Start the Chainweb node After you've made any changes needed in the node configuration file, you can start the node with the modified configuration file or by specifying the command-line options you want to set. Start the node from the executable To start the node from the release binary or after building from the source, you can run a command similar to the following: The node immediately begins trying to synchronize state with other nodes in the network. If the network is correctly configured to allow communication, you should start seeing the block height for your node catching up with its peers. If you see errors or warning messages, you should review the Troubleshooting section for potential causes and solutions. Start the node in a container To start the node in a Docker container, you can run a command similar to the following to use the default configuration settings: After starting the node in a Docker container, you can view the contents of the container and interact with it using basic shell commands. For example, you can get the container identifier by running , then open a shell in the container by running a command similar to the following: However, the container doesn't include a text editor for modifying the configuration file. If you want to run the node with modified configuration settings in a Docker container, you can add the appropriate command-line options when starting the node. For example: For more information about using command-line options to control node operations, see the chainweb-node command-line reference. After you start the node in the container, it immediately begins trying to synchronize state with other nodes in the network. If the network is correctly configured to allow communication, you should start seeing the block height for your node catching up with its peers. If you see errors or warning messages, you should review the Troubleshooting section for potential causes and solutions or post a question on the Kadena Discord server #infrastructure channel.",
    "source": "guides/nodes/chainweb-get-started.md",
    "title": "chainweb-get-started"
  },
  {
    "content": "title: Deploy smart contracts description: \"A guide to deploying smart contracts using an API call, the Kadena CLI, and Kadena.js\" id: howto-deploy-contracts Deploy smart contracts This guide provides instructions and examples for deploying a smart contract by using an API call, the Kadena CLI, or the Kadena client TypeScript library. Using a YAML request and curl One way you can deploy a new smart contract is by constructing a YAML execution request, formatting the request as a JSON object, and sending the request to an API endpoint using the command. You could also submit the request using Postman or other tools that enable you to call API endpoints directly. However, formatting an API request manually is typically an error-prone process and inserting full contract code—even for a simple contract—into a YAML configuration file can often lead to unexpected results or errors. In most cases, constructing a transaction to deploy a smart contract is less error-prone if you use the Kadena CLI. The Kadena CLI uses the Kadena client library as a foundation for abstracting and simplifying interaction with the blockchain. If you want to deploy a contract by using the command directly, the following example illustrates the steps involved. To deploy a smart contract with a command: Generate a public and secret key pair and save them to a file. For this example, the following keys are used: Use the public key to create and fund an account on at least one chain in the development, test, or main network, For example: Use to add an account for the public key manually in the development network and one or more chains. Use to fund the account on one or more chains. Construct the transaction using the YAML transaction request format. For example, using the account values associated with the 3bdb1d3c48a1bb5f072b067e265ce5d9a5eabf5e290128be4d2623dd559ca698 public key account, the YAML file looks like this: Convert the YAML transaction request to a valid transaction JSON object. Use to connect to the endpoint to deploy the contract. For example, you can run a command similar to the following to deploy a contract on the network: The command returns a request key that you can use to view the transaction results in the block explorer. Using kadena-cli commands With the , you can construct a transaction template to deploy smart contracts. You can then customize the transactions to deploy the same contract on different chains or different networks. Depending on how you create your template, you can also use it to deploy different types of contracts with interactive prompting for values or by setting command-line options. To deploy a smart contract using : Create a template file with the template variables for deploying a contract. Note that you can embed Pact code directly in a template or data file using the key. Alternatively, you can use the key to specify the path to a Pact file. For example, you might create a template file similar to the following: For convenience, you can move the template to the directory, so that the template is listed when you add transactions with interactive prompting. Create a new unsigned transaction using the command and the template and follow the prompts displayed to set the appropriate information. For the template value, specify the path to the Pact file you want to deploy. The path should be relative to the directory. For the template value, specify the account name of the contract owner. In this example, it's the Chainweaver wallet account and the public key is . For the and template values, specify the chain and network where you want to deploy the contract. In this example, the contract is deployed on chain in the network. For example, the prompts and output for creating the transaction look similar to the following: Sign the unsigned transaction using the command and the transaction file name generated by the command. For example, the prompts and output for the transaction look similar to the following: Send the signed transaction using the command and the signed transaction file name generated by the command. For example, the prompts and output for the transaction look similar to the following: After the transaction is sent to the blockchain, you can verify deployment in the block explorer by using the request key. Using the Kadena client library If you prefer to work with JavaScript, you can use the library to write you own scripts to deploy contracts and perform other tasks. The library implements a TypeScript-based API for interacting with smart contracts and Chainweb nodes. The library provides functions that simplify building transactions with Pact commands and connecting to blockchain nodes. You should note that creating the client connection is separate from using the function to construct transactions. The following example illustrates what a script using to deploy a smart contract would look like. This example deploys the in the namespace on the network. The following example illustrates using a helper script.",
    "source": "guides/contracts/deploy-a-contract.md",
    "title": "deploy-a-contract"
  },
  {
    "content": "title: Check account balances description: \"How to check account balances for existing account using an API call to the coin contract get-balance function, Kadena command-line interface, and Kadena client library functions.\" id: howto-get-balances import Link from '@docusaurus/Link'; import CodeBlock from '@theme/CodeBlock'; Check account balances This guide provides instructions and examples for checking an account balance using an API call, Kadena CLI commands, and the Kadena client TypeScript library. These examples illustrate how you can construct calls to the blockchain to get an account balance—an important operation if you're building a wallet, exchange, game, or other application where you need to retrieve and display account information. If you're using Chainweaver or another wallet or frontend application, this information is typically available directly through the user interface, with the application performing an operation similar to these examples behind the scenes. Using a YAML request and curl One way yu can get an account balance is by calling the function that's defined in the contract deployed on the Kadena public main or test network. To make this call, you need to know the following information: The account name for the account you want to look up. The network identifier where you want to check the account balance. The specific chain identifier for the balance you want to check. For this example, you can create the request using the YAML execution file format, convert the request to JSON, then submit the API request using a command. You could also submit the request using Postman or other tools than enable you to call API endpoints. To get an account balance: Open a terminal on your local computer. Check that you have installed by running the following command: You should see the path to the file similar to the following: Create a YAML execution request in a file with content similar to the following: As you can see in this example: The transaction request calls the function. The account name is . The network identifier is . The chain identifier for the account balance is chain . The , , and values represent reasonable settings. Convert the YAML execution request to a JSON object with proper formatting using the command with a command similar to the following: This command displays the resulting JSON as standard output. For example: Alternatively, you can save the result from the command in a file with a command similar to the following: Copy the output from the command to pass as the request body in the next step. Connect to the Pact endpoint for the appropriate network with a command similar to the following: The command returns output similar to the following: In this example, the account has a balance of coins on chain of the Kadena network. Using kadena-cli commands If you have installed the package in your development environment, you can use the command to look up account balances on the development, test, or main network. To get an account balance using : Open a terminal on your local computer. Check that you have installed by running the following command: You should see the path to the file similar to the following: If you want to check the account balance for an account you added using the command, you can use the to review all of the accounts available in your development environment. For this example, running returns the following results: If you know the account name, network, and chain where you want to check the account balance, you can go directly to the next step. Check the account balance with interactive prompting by running the following command: Select an account name: Select the network: Enter one or more chain identifiers: After you provide the information required, the command returns account details including the account balance for each chain identifier you specified. For example: The command output also includes the command executed. For example: If you want to check an account balance without interactive prompting, you can specify all of the required arguments in a single command. For example: In this case, there are no warnings, so the command simply returns the account details: Using a transaction template You can also create a transaction template for checking account balances. Transaction templates are similar to YAML execution requests like the one in Using a YAML request and curl. However, transaction templates allow you to use variables for input values that can be set when adding and executing transactions using Kadena CLI commands. To get an account balance using and a transaction template: Open a terminal on your local computer. Check that you have installed by running the following command: You should see the path to the file similar to the following: Create a YAML API request file to use as a transaction template with the variables required to call the function: You can learn more about transaction templates, variables, and inputting values in Construct transactions. For more information about using YAML request files for transactions, see Formatting API requests in YAML. Save the file with the file extension in the folder. For example, save the file as in your working directory. Add a transaction that uses the template by running the following command: Select the template, then follow the prompts to enter the appropriate values for template variable. For this example, the prompts and values look like this: The values you enter for the command are saved in a JSON file. Sign the transaction by running the following command and following the prompts displayed to select the transaction: You must select a wallet or key pair to sign the transaction and the transaction file that you want to sign. After you enter the information required, the command output confirms the signature with information similar to the following: After signing the transaction, you can retrieve the account information without submitting the transaction or send the request to the blockchain for on-chain processing. Get the account balance by running the following command: In this example, the balance for account on the development network, chain 3—returned in the field—is 14. Using the Kadena client library If you're familiar with JavaScript or TypeScript, you can use the library to write scripts for common tasks. The library implements a TypeScript-based API for interacting with smart contracts and Chainweb nodes. The library provides functions that simplify building transactions with Pact commands and connecting to blockchain nodes. You should note that creating the client connection is separate from using the function to construct transactions. To get an account balance using functions: Open a terminal on your local computer. Create a new file in your code editor and add code to call the function and create the client:",
    "source": "guides/accounts/get-balances.md",
    "title": "get-balances"
  },
  {
    "content": "title: Fund on-chain accounts description: \"How to create a new Kadena account by transferring digital assets into it using the coin contract function, Kadena CLI, and Kadena client library.\" id: howto-fund-accounts import Link from '@docusaurus/Link'; import CodeBlock from '@theme/CodeBlock'; Fund on-chain accounts The Kadena contract provides two functions for funding an on-chain account: You can use the function to create and fund new accounts in a single step if you have access to funds and control a keyset with access to the funds. You can use the function any time you want to transfer assets between existing accounts. This guide provides instructions and examples for creating an on-chain account by transferring digital assets (KDA) into the account using an API call, Kadena CLI with YAML configuration, and the Kadena client TypeScript library. Using a YAML request and curl One way you can create and fund a new account is by calling the function that's defined in the contract deployed on the Kadena development, test, and main network. To make this call, you need to know the following information: The account name for a funding account with funds that you control. The public key for the receiving account you want to create. The guard for the receiving account and the amount to transfer. For this example, you can create the request using the YAML execution file format, convert the request to JSON, then submit the API request using a command. You could also submit the request using Postman or other tools that enable you to call API endpoints. To create and fund a new account: Open a terminal on your local computer. Check that you have installed by running the following command: You should see the path to the file similar to the following: Create a YAML execution request in a file with content similar to the following: As you can see in this example: The transaction request calls the function. The funding account name is . The receiving account is . The network identifier is . The chain identifier for the account balance is chain . The , , and values represent reasonable settings. Convert the YAML execution request to a JSON object with proper formatting using the command with a command similar to the following: This command displays the resulting JSON as standard output. For example: Connect to the Pact endpoint for the appropriate network with a command similar to the following: You can follow similar steps to fund an existing on-chain account using the function. Using kadena-cli commands If you have installed the package in your development environment, you can use the command to fund an existing local or testnet account that you have previously added to the local development environment. To fund an on-chain account balance using : Open a terminal on your local computer. Check that you have installed by running the following command: You should see the path to the file similar to the following: Fund the account with interactive prompting by running the following command: Follow the prompts displayed to select an account alias, network, chain identifier, and amount. Using the Kadena client library If you're familiar with JavaScript or TypeScript, you can use the library to write scripts for common tasks. The library implements a TypeScript-based API for interacting with smart contracts and Chainweb nodes. The library provides functions that simplify building transactions with Pact commands and connecting to blockchain nodes. You should note that creating the client connection is separate from using the function to construct transactions.",
    "source": "guides/accounts/fund-accounts.md",
    "title": "fund-accounts"
  },
  {
    "content": "title: Create new accounts description: \"How to create a new Kadena account without transferring any digital assets into it using the coin contract function s, Kadena CLI, and Kadena client library functions.\" id: howto-create-accounts import Link from '@docusaurus/Link'; import CodeBlock from '@theme/CodeBlock'; Create new accounts This guide provides instructions and examples for creating an on-chain account without an account balance. If you want to create a new account without transferring any digital assets (KDA) into it, you can create the account with a zero balance by using an API call, the Kadena CLI, or the Kadena client TypeScript library. These examples illustrate how you can construct calls to the blockchain to create new accounts—an important operation if you're building a wallet, exchange, game, or other application where you need to register before creating transactions or interacting with your application. If you're using Chainweaver or another wallet or frontend application, this information is typically available directly through the user interface, with the application performing an operation similar to these examples behind the scenes. Note that regardless of the method you use to create new accounts, accounts must be funded on at least one network chain before you can do more than list account names and keys. Using a YAML request and curl One way you can create a new account without transferring any assets is by calling the function that's defined in the contract deployed on the Kadena development, test, or main network. To make this call, you need to know the following information: The account name for the account you want to create. In most cases, the account name is a public key with either the prefix for accounts with a single key or the prefix for accounts with more than one key. The account guard for the account you want to create. For this example, you can create the request using the YAML execution file format, convert the request to JSON, then submit the API request using a command. You could also submit the request using Postman or other tools that enable you to call API endpoints. To create a new account: Open a terminal on your local computer. Check that you have installed by running the following command: You should see the path to the file similar to the following: Create a YAML execution request in a file with content similar to the following: As you can see in this example: The transaction request calls the function. The account name is . The network identifier is . The chain identifier for the account balance is chain . The , , and values represent reasonable settings. Convert the YAML execution request to a JSON object with proper formatting using the command with a command similar to the following: This command displays the resulting JSON as standard output. For example: Connect to the Pact endpoint for the appropriate network with a command similar to the following: The command returns JSON output similar to the following: Using kadena-cli commands If you have installed the package in your development environment, you can use the command to add a new account to the local development environment for interacting with the development, test, or main network. To add an account balance using : Open a terminal on your local computer. Check that you have installed by running the following command: You should see the path to the file similar to the following: Add the account with interactive prompting by running the following command: You can add the account by manually providing a public key or add an account from a wallet. Follow the prompts displayed to enter an account alias, account name, fungible type, public key, network, and chain. After you provide the information required, the command returns confirmation of the account. For example: Using the Kadena client library If you're familiar with JavaScript or TypeScript, you can use the library to write scripts for common tasks. The library implements a TypeScript-based API for interacting with smart contracts and Chainweb nodes. The library provides functions that simplify building transactions with Pact commands and connecting to blockchain nodes. You should note that creating the client connection is separate from using the function to construct transactions. For an example of creating a new account using the Kadena client (@kadena) library functions in a TypeScript program, see the create-account sample code.",
    "source": "guides/accounts/create-new-accounts.md",
    "title": "create-new-accounts"
  },
  {
    "content": "title: Sign and submit transactions description: \"A guide to crafting blockchain calls using Traditional API, Kadena CLI, and Kadena.js\" id: howto-sign-submit-tx import Tabs from '@theme/Tabs'; import TabItem from '@theme/TabItem'; import CodeBlock from '@theme/CodeBlock'; Sign and submit transactions There are several ways you can sign and submit transactions. This guide provides instructions and examples for signing and submitting transactions using different tools and in different scenarios. For example, this guide describes how to use the Pact command-line interpreter HTTP server and REST API to sign and submit transactions locally using Pact commands and how to format transactions requests so that they can be executed using commands or Postman API calls. Use the Pact built-in server To use the built-in Pact server: Open a terminal shell on your local computer. Create a configuration file using YAML format with the following properties: For example, create a file with properties similar to the following: Start the built-in server by using the command-line option and your configuration file with a command similar to the following: Create an API request for the server in a YAML file. For example, use a text editor to create a YAML file called with the following content: Format the YAML version of the API request using the Pact command-line option to generate a valid JSON API request that you can send to any Chainweb node. For example, you can run the following command to display formatted output that's suitable for the CHainweb node endpoint: This command displays the formatted JSON API request as standard output: To format a request for the built-in server and endpoint, you can add the command-line option. For example: To write the formatted JSON API request to a file instead of displaying it as standard output, redirect the output with a command similar to the following: Send the formatted API request to the Pact built-in HTTP server running on port 8081—as configured in the file for this example—by running the following command: This command returns the transaction result with output similar to the following: Although the command-line interpreter includes commands for generating keys, preparing unsigned transactions, and signing transactions from the command line, it's generally more straightforward to construct YAML request files and sign transactions with other tools, such as Chainweaver or the package. Use a curl command directly You can also use commands to submit transactions to Kadena development, testnet, and mainnet nodes. To sign and submit a transaction: Generate a random public and secret key pair and save them to a file. For this example, the following keys are used: Construct the transaction using the YAML transaction request format. For example: You can also construct YAML transaction requests that only include the public key by replacing the attribute with a attribute: Convert the YAML transaction request to a valid transaction JSON object. To format an unsigned YAML transaction request that only includes the attribute and public keys, you can use the command-line option. For example, you can run a command similar to the following: To add a signature to the unsigned transaction, you can run a command similar to the following: Use to connect to the endpoint on the , or network. For example, the following command connects to the endpoint on the local network: If the request is properly formatted and you can connect to the endpoint, the command returns the request key for the transaction. For example: Use kadena tx commands The package enables you to construct, sign, and submit transactions using transaction templates. Construct the transaction interactively using one of the default YAML request templates or create a custom YAML file. Convert the YAML request template to a valid transaction JSON object by using . Sign the transaction created by using . Send the request to the blockchain by using . Offline signing with a cold wallet Some cold wallet signing procedures use QR codes to get transaction data on and off the cold wallet machine. Because QR codes can only transmit a limited amount of information, cold wallet signing commands are typically designed to work with a more compact data format than produced when the full command is used to generate signatures. For example, the YAML execution request file for a safe transfer might look like this: When this YAML request is converted to an unsigned transaction, the result looks similar to the following: To get a condensed version for signing on a cold wallet, you can remove the field manually or using a script similar to the following: The result would look like this: Keep in mind that when you sign using the condensed version, you won't be able to submit the output directly to the blockchain. You'll have to restore the full command to submit the transaction to the blockchain.",
    "source": "guides/transactions/sign-submit-transactions.md",
    "title": "sign-submit-transactions"
  },
  {
    "content": "title: Transfer funds safely description: \"Guarantee safe transfer operations.\" id: howto-safe-transfers Transfer funds safely Transferring funds from one account to another involves a certain amount of risk because if you make a mistake in typing or copying a public key, you could lose access to the funds after they are transferred. Pact allows you to construct safe transfer transactions that guarantee: Someone possesses the correct private key. The private key will be able to access the funds being transferred. To provide this guarantee, you can construct a single transaction that executes two separate transfer operations. For example, if Alice wants to transfer coins to Bob, she can construct the transaction with one operation for the desired coins plus a small additional amount to use as a test transfer. She then adds a second transfer operation to return the additional coin amount that is used to verify the account owner. This type of transaction must be signed by both the Alice and Bob accounts and each signature must have the appropriate capability. It's especially important to construct this type of transaction if you are using the function because that is when you are defining the new account's keyset. Using a YAML request file and curl Wallets with frontend interfaces can make transfers, including safe transfers, transparent for end-users. However, it's often useful to step through the process from the command-line to better understand the mechanics of how a safe transfer works. In this example: Two key pairs are generated and saved to separate files for the transaction signers using and . The public key for the Alice (pact-random-key) account is 3c4fc4bcd59850704ba04704730140839ac0f0b65c1ba8fe2f3f6640475f8d67. The public key for the Bob account is 3fef2d008c1ba8c319dce5b5ce5d89ba4074fb3a3b333746420619135e305678. The keyset defined in the request is used to create the Bob account, so that public key is required. To create the transaction for a safe transfer: Create a YAML execution request that looks similar to the following example: Notice that this YAML file uses the attribute and not the attribute. Prepare the transaction for signing by using the --unsigned command-line option: Add the signature for the Alice account from the file: Add the signature for the Bob account from the file: Combine the signatures from both accounts to create the final transaction file: Send the final transaction to the blockchain: Using kadena-cli commands If you have installed the package in your development environment, you can use the and the template to construct safe transfer transactions for the development, test, or main network. With interactive prompting, the template guides you to provide the information required, so it is less error-prone than manually crafting and signing a transaction request.",
    "source": "guides/transactions/safe-transfers.md",
    "title": "safe-transfers"
  },
  {
    "content": "title: Define principal namespaces description: \"How to define a principal namespace using a transaction template and the Kadena CLI.\" id: howto-namespace-tx Define principal namespaces As discussed in Basic concepts, Kadena namespaces provide a static prefix and a secure boundary for all of the contracts, modules, functions, and keyset definitions that you control. When you are building, testing, and deploying smart contracts on your local development network, you can work directly in the root namespace without defining this boundary. For local development, your work is isolated from others because your blockchain—and any smart contracts you deploy—run exclusively on your local computer. However, if you want to deploy a smart contract on a public blockchain network, like the Kadena test network or main production network, the contract must have a unique name that distinguishes your Pact module from all the others. If you try to deploy a Pact module with a name that's already being used on the network where you are trying to deploy, the deployment will fail with an error and you'll pay a transaction fee for the failed attempt. To prevent name collisions on the same network, Kadena allows you to define your own unique namespace on the blockchain. The namespace segregates your work—your smart contracts, keyset definitions, and Pact modules—from applications and modules created and deployed by others. Within your namespace, you can control who has access to which features and who can update the namespace with changes. As long as the namespace has a unique name, everything you define inside of that namespace is automatically unique, too. To ensure every namespace has a unique name, Kadena provides a built-in module on the main, test, and development networks. You can use the module to create a uniquely-named and cryptographically-secure principal namespace on any Kadena network. The module includes a function specifically for this purpose. The function enables you to create a namespace using the prefix followed by the hash of a keyset. This naming convention ensures that your principal namespace won't conflict with any other namespaces defined in the same network. The following example demonstrates how to define a principal namespace in your development environment by using the Kadena CLI and a transaction template. Create a transaction request To define a principal namespace: Open the code editor on your computer and create a new transaction template () file in the folder. For example, create a file in the folder. Create a transaction request using the YAML API request format with content similar to the following: Create a transaction that uses the template to define a namespace with a command similar to the following: Sign the transaction with a command similar to the following: Send the transaction to the blockchain with a command similar to the following: Verify the transaction results in the block explorer:",
    "source": "guides/transactions/define-namespace.md",
    "title": "define-namespace"
  },
  {
    "content": "title: Construct transactions description: \"How to construct transactions using transaction templates and the Kadena CLI.\" id: howto-construct-tx Construct transactions There are several ways you can construct transaction requests that you want to submit to the Kadena blockchain. For example, you can construct transaction by: Manually craft API requests. Running Kadena CLI commands. Calling functions in the Kadena client library. Interacting with frontend tools like Chainweaver. The Kadena CLI provides one of the most versatile ways to construct transactions by enabling you to create and use transaction templates. With transaction templates, you can create transactions for common operations and customize the values used each time the transaction is submitted. By providing values for template variables at runtime, you can generate transactions for multiple chains, accounts, or assets that are ready to sign and submit with minimal configuration requirements. You can provide template values interactively, specify them as command-line options, or pass them as input from a data file. Default templates The Kadena CLI provides three default templates. The default templates—defined in the , , and files—are stored in the directory after you configure your local development environment using the command. These templates cover the most common transaction types, allowing for straightforward transfers of tokens between accounts. Command options The basic syntax for creating a transaction from a template is: If you run the command without any options, you are prompted to select a template and enter the information required to create the transaction interactively. If you want to create a transaction without interactive prompted, you can specify command-line options similar to the following: In this example: The argument is required to identify the template you want to use to construct the transaction. The argument specifies the file that contains the values to use for the template variables. The argument specifies the network the transaction is intended for. The argument specifies the file name for the generated transaction that is saved in the current working directory. For information about the command-line options you can use with the command, type: For additional information about using the command, see kadena tx add. Template formats, prefixes, and variables Transaction templates use the YAML API request format for execution () and continuation () transaction requests. However, templates support the use of variables for input values that can be entered interactively or from a data file. The following example illustrates the use of prefixes to identify the data types and values expected for fields in a transaciton using the template: The template uses the following prefixes to identify the expected data type and format for each field: The prefix is used for variables that should specify a valid Kadena account name. The prefix is used for variables that should specify a public key. The prefix is used for variables that should specify the appropriate network identifier for the transaction. The prefix is used for variables that should specify a numerical values with a decimal point. If you create transactions interactively, the prefixes are displayed to ensure you are prompted for the appropriate information for the transaction you are constructing. If you provide variable input on the command-line or in a file, the prefixes are ignored and you must provide the appropriate data types and formats to create valid transactions. If you aren't sure of the variables that a template requires, you can list the variables defined for a template by using the command-line option. For example, you can list the template variables for the template like this: This command returns the list of variables like this: You can create a file with input values for the template variables in YAML format similar to the following: You can then construct a transaction that uses these input values with a command similar to the following: This command creates an unsigned transaction in your working directory. After you construct the transfer transaction, you can sign it with the following command: After you sign the transfer transaction, you can send the signed transaction to the blockchain with the following command:",
    "source": "guides/transactions/construct-tx.md",
    "title": "construct-tx"
  },
  {
    "content": "title: Check transaction status description: \"A guide to crafting blockchain calls using Traditional API, Kadena CLI, and Kadena.js\" id: howto-check-tx-status Check transaction status You can check the status of transactions using the transaction request key and the or endpoints. To check the status of single transaction and wait for a result, use the endpoint. To check the status for a list of transaction request keys, use the endpoint. Using kadena-cli commands If you have installed the package in your development environment, you can use the command to check the status of a transaction on the development, test, or main network. To check transaction status using : Open a terminal on your local computer. Check that you have installed by running the following command: You should see the path to the file similar to the following: Check the transaction status with interactive prompting by running the following command: Enter the request key. Select the network. Enter the chain identifier. The command returns status information for the request key similar to the following: Using the Kadena client library If you're familar with TypeScript or JavaScript, you can use functions from the Kadena client library to write a script similar to the following:",
    "source": "guides/transactions/check-tx-status.md",
    "title": "check-tx-status"
  },
  {
    "content": "title: Get simple payment verification (spv) description: \"Provides reference information for the Pact /spv endpoint.\" id: spv sidebar_position: 7 tags: ['chainweb', 'node api', 'chainweb api', 'api reference'] Get simple payment verification (spv) You can use the endpoint to issue a blocking request to fetch a simple payment verification (spv) proof of a cross-chain transaction. The request must be sent to the chain where the transaction initiated. Request format Use the endpoint to issue a blocking request to fetch a simple payment verification (spv) proof of a cross-chain transaction. Path parameters Parameter Type Description chain (required) integer >= 0 Specifies the chain identifier of the chain you want to send the request to. Valid values are 0 to 19. For example, to submit the command on the first chain (0), the request is . Request body schema Parameter Type Description (required) string Request key for the first step in a cross-chain transaction. This request key is the transaction hash generated on the source chain. (required) string Target chain identifier for the second step in the cross-chain transaction. Response Requests to return the following response codes: 200 OK indicates that the request succeeded and the response body includes the requested payment verification proof. 400 Bad Request indicates that the request failed. The response returns content with information about why the request failed. If the request is successful and the command is accepted, the response returns content with the following information: Parameter Type Description string Backend-specific data for continuing a cross-chain proof.",
    "source": "api/pact-api/spv.md",
    "title": "spv"
  },
  {
    "content": "title: Send commands to be executed description: Provides reference information for the Pact /send endpoint. id: send sidebar_position: 6 tags: ['chainweb', 'node api', 'chainweb api', 'api reference'] Send commands to be executed You can use the endpoint to submit one or more unencrypted Pact commands to the blockchain for execution. Request format Use the endpoint to submit one or more public unencrypted Pact commands to the blockchain for execution. Path parameters Parameter Type Description chain (required) integer >= 0 Specifies the chain identifier of the chain you want to send the request to. Valid values are 0 to 19. For example, to submit the command on the first chain (0), the request is . Request body schema Content type: application/json Parameter Type Description (required) Array of objects Specifies an array of individual Pact command objects. Responses Requests to return the following response codes: 200 OK indicates that the request succeeded and the response body includes the request keys for each command successfully submitted. 400 Bad Request indicates that the request failed. The response returns content with information about why the command couldn't be submitted for execution. For example, the response might indicate that the command wasn't executed because the request body specified an invalid gas payer, was missing required metadata, or there were other environment issues. If the request is successful, the response returns content with the following information: Parameter Type Description (required) Array of strings Each request key is a base64Url-encoded string that consists of 43 characters from the [] character set. You can use these request keys with the or endpoints to retrieve transaction results. Examples You can send a request to the Kadena test network and chain 1 by calling the endpoint like this: The request body for this example looks like this: This API request returns the request key for the transaction: You can use the request key returned to poll or listen for the transaction results.",
    "source": "api/pact-api/send.md",
    "title": "send"
  },
  {
    "content": "title: Send a private Pact command description: Provides reference information for the Pact /private endpoint. id: private sidebar_position: 5 tags: ['chainweb', 'node api', 'chainweb api', 'api reference'] Send a private Pact command You can use the endpoint for asynchronous submission of a single command transmitted with end-to-end encryption between addressed entity nodes. Private payload metadata is required. Request format Use the endpoint for asynchronous submission of a single command transmitted with end-to-end encryption between addressed entity nodes. Request body schema Parameter Type Description (required) string Stringified JSON payload object with signed transaction data that can't be modified. (required) string An unpadded base64Url-encoded string created using the Blake2s-256 hash function for the field value. Serves as a command request key because each transaction must be unique. (required) Array of objects List of signatures corresponding one-to-one with the signers array in the payload. Responses Requests to return the following response codes: 200 OK indicates that the request succeeded and the response body includes the command results. 400 Bad Request indicates that the request failed. The response returns content with information about why the request failed. For example, the response might indicate that the command wasn't executed because the request body specified an invalid gas payer, was missing required metadata, or there were other environment issues. If the request is successful and the command is accepted, the response returns content with the following information: Parameter Type Description (required) Array of strings Unique identifier for the Pact transaction. The transaction hash is a base64Url-encoded string that consists of 43 characters from the [] character set. You can use the request key to call the or endpoint to retrieve results.",
    "source": "api/pact-api/private.md",
    "title": "private"
  },
  {
    "content": "title: Poll for transaction results description: Provides reference information for the Pact /poll endpoint. id: poll sidebar_position: 4 tags: ['chainweb', 'node api', 'chainweb api', 'api reference'] Poll for transaction results You can use the endpoint to check for one or more command results by request key. Request format Use the endpoint to check for one or more command results by request key. Path parameters Parameter Type Description chain (required) integer >= 0 Specifies the chain identifier of the chain you want to send the request to. Valid values are 0 to 19. For example, to submit the command on the first chain (0), the request is . Query parameters Parameter Type Description integer >= 0 Configures how many blocks should be mined before the requested transaction results should be considered to be confirmed. Request body schema Parameter Type Description (required) Array of strings Each request key is a base64Url-encoded string that consists of 43 characters from the [] character set. Responses Requests to return the following response codes: 200 OK indicates that the request succeeded and the response body includes the transaction results. 400 Bad Request indicates that the request failed. The response returns content with information about why the request failed. For example, the response might indicate that the command wasn't executed because the request body specified an invalid gas payer, was missing required metadata, or there were other environment issues. If the request is successful, the response returns content with the following information for one or more of the request keys included in the request. Parameter Type Description (required) number Gas consumed by the transaction. (required) object Success (object) or Failure (object). (required) string Unique identifier for the Pact transaction. The transaction hash is a base64Url-encoded string that consists of 43 characters from the [] character set. (required) string Backend-specific value providing image of database logs. Array of object Array of event objects. (required) object Metadata included with the transaction. object Describes the result of a execution. number Database-internal transaction tracking identifier. Examples You can send a request to the Kadena test network and chain 1 by calling the endpoint like this: For this example, the request body specifies one request key: This request returns the following results:",
    "source": "api/pact-api/poll.md",
    "title": "poll"
  },
  {
    "content": "title: Simulate a transaction description: Provides reference information for the Pact /local endpoint. id: local sidebar_position: 3 tags: ['chainweb', 'node api', 'chainweb api', 'api reference'] Simulate a transaction You can use the endpoint to submit a command to simulate the execution of a transaction. Requests sent to the endpoint don't change the blockchain state. Any database writes or changes to the environment are rolled back. You can use this type of call to perform a node-local “dirty read” for testing purposes or as a dry-run to validate a transaction. The request body must contain a properly-formatted Pact command. In response to the request, the endpoint returns the command result and hash. Request format Use the endpoint to submit a command to simulate the execution of a transaction. Path parameters Parameter Type Description chain (required) integer >= 0 Specifies the chain identifier of the chain you want to send the request to. Valid values are 0 to 19. For example, to submit the command on the first chain (0), the request is . Query parameters Parameter Type Description boolean Trigger a fully-gassed mainnet transaction execution simulation and transaction metadata validation. integer >= 0 Rewind transaction execution environment by a specified number of block heights. boolean Require user signature verification when validating the transaction metadata. Request body schema Parameter Type Description (required) string Stringified JSON payload object with signed transaction data that can't be modified. (required) string An unpadded base64Url-encoded string created using the Blake2s-256 hash function for the field value. Serves as a command request key because each transaction must be unique. (required) Array of objects List of signatures corresponding one-to-one with the signers array in the payload. Responses Requests to return the following response codes: 200 OK indicates that the request succeeded and the response body includes either the command results or the preflight results. 400 Bad Request indicates that the request failed. The response returns content with information about why the command couldn't be executed. For example, the response might indicate that the command wasn't executed because the request body specified an invalid gas payer, was missing required metadata, or there were other environment issues. If the request is successful, the response returns content with the following information: Parameter Type Description (required) string Unique identifier for the Pact transaction. The transaction hash is a base64Url-encoded string that consists of 43 characters from the [] character set. (required) object Success (object) or Failure (object). number Database-internal transaction tracking identifier. (required) string Backend-specific value providing an image of database logs. (required) object Metadata included with the transaction. Array of objects Array of event objects. object Describes the result of a execution. (required) number Gas required to execute the transaction. If you specify the query parameter, the command results include the following additional parameters: Parameter Type Description (required) object The result of attempting to execute a single well-formed Pact command. (required) Array of strings A list of warnings associated with deprecated features in upcoming Pact releases. Examples You can send a request to the Kadena test network and chain 1 by calling the endpoint like this: The request body for this example looks like this: The request returns command results similar to the following: You can specify the query parameter in the API request like this: The request returns preflight results similar to the following:",
    "source": "api/pact-api/local.md",
    "title": "local"
  },
  {
    "content": "title: Listen for a single transaction description: Provides reference information for the Pact /listen endpoint. id: listen sidebar_position: 2 tags: ['chainweb', 'node api', 'chainweb api', 'api reference'] Listen for a transaction result You can use the endpoint to submit a blocking API request to return the results for a single transaction. The request must specify the request key that uniquely identifies the Pact transaction. Requests to the endpoint keep the connection to the network open waiting for a response. Request format Use the endpoint to submit a blocking request for the results of a single transaction. Note that service API endpoints don't strictly require you to use secure connections (HTTPS). However, node operators can require it and connecting over HTTPS is strongly recommended to protect data in transit and to prevent potential browser issues. Path parameters Parameter Type Description chain (required) integer >= 0 Specifies the chain identifier of the chain you want to send the request to. Valid values are 0 to 19. For example, to submit the command on the first chain (0), the request is . Request body schema Parameter Type Description (required) string Unique identifier for the Pact transaction. The transaction hash is a base64Url-encoded string that consists of 43 characters from the [] character set. Responses Requests to return the following response codes: 200 OK indicates that the request succeeded and the response body includes the transaction results. 400 Bad Request indicates that the request failed. The response returns content with information about why the request failed. For example, the response might indicate that the command wasn't executed because the request body specified an invalid gas payer, was missing required metadata, or there were other environment issues. If the request is successful, the response returns content with the following information for one or more of the request keys included in the request. Parameter Type Description (required) number Gas consumed by the transaction. (required) object Success (object) or Failure (object). (required) string Unique identifier for the Pact transaction. The transaction hash is a base64Url-encoded string that consists of 43 characters from the [] character set. (required) string Backend-specific value providing image of database logs. Array of object Array of event objects. (required) object Metadata included with the transaction. object Describes the result of a execution. number Database-internal transaction tracking identifier. Examples You can send a request to the Kadena test network and chain 1 by calling the endpoint like this: For this example, the request body specifies one request key to listen for: This request returns the following results:",
    "source": "api/pact-api/listen.md",
    "title": "listen"
  },
  {
    "content": "title: Publish the current state description: Use the POST /cut endpoint to publish the cut height for a Chainweb node. id: publish-cut sidebar_position: 3 tags: ['chainweb', 'node api', 'chainweb api', 'api reference', 'block height cut'] Publish the current state In the Kadena network, a cut height represents the distributed state from a Chainweb node. Each cut height—much like a database snapshot or a block height—references one block header for each chain, compared with concurrent blocks on other chains. Two blocks from two different chains are considered concurrent if either block is an adjacent parent and a direct dependency of the other or if the blocks do not depend at all on each other. Request format Use to publish a cut to a Chainweb node. The cut must contain an property that is not null. The receiving node will first try to obtain all missing dependencies from the node specified for the property before searching for the dependencies in the peer-to-peer network. Use the following parameters to specify a with an property that is not null. Parameter Type Description origin (required) object Describes a peer information object that consists of an string and an object for a Chainweb node. The parameter is required to use the endpoint. For more information, see the Peer information data model. height (required) integer >= 0 Specifies the cut height to publish. The cut height is the sum of the height for all of the blocks included in the cut. You should avoid using this value because its semantics may change in the future. weight (required) string Specifies the cut weight. The cut weight is the sum of the weights from all of the blocks included in the cut. The weight string consists of 43 characters from the [] character set. hashes (required) object Specifies an object that maps chain identifiers 0-19 to their respective block hash and block height for the cut. instance string Specifies the network identifier for the cut. id string Specifies a cut identifier. The id string consists of 43 characters from the [] character set. Responses Requests to return the following response codes: 204 No Content indicates that the request was successful and the cut was added to the cut processing pipeline on the remote Chainweb node. 401 Unauthorized indicates that the node where you are trying to publish the cut is not a peer of the node identified in the property, and therefore cannot process the cut you're attempting to publish. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. Parameter Type Description x-peer-addr string Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: . x-server‑timestamp integer >= 0 Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: . x‑chainweb‑node‑version string Specifies the version of the remote Chainweb node. For example: . Examples You can send a request to publish a cut on a node with a call to the endpoint similar to the following: The request body for publishing a cut contains parameters similar to the following: If the request is successful, you'll see the 204 No Content response returned.",
    "source": "api/peer-to-peer/publish-cut.md",
    "title": "publish-cut"
  },
  {
    "content": "title: Look up transactions description: Provides reference information for the chainweb-node mempool endpoints. id: lookup-tx-mempool sidebar_position: 6 tags: ['chainweb', 'node api', 'chainweb api', 'api reference'] Look up transactions When transactions are submitted to the blockchain for processing, they are queued in the node memory pool to await delivery to a mining node as new work to be validated. Endpoints related to memory pool activity are peer-to-peer endpoints that enable communication between memory pools on different nodes. With the endpoint, you can specify a list of transaction request keys to look for in the mempool. For each transaction request key, the endpoint returns the Pending tag and details about the transaction or the Missing tag. Request format Use to look up pending transactions in the memory pool. Path parameters Parameter Type Description chain (required) integer >= 0 Specifies the chain identifier of the chain you want to send the payload request to. Valid values are 0 to 19. For example, to get block payload for the first chain (0), the request is . Request body schema The request body consists of an array of transaction request keys to check for in the memory pool. Each request key for a Pact transaction is a Base64Url-encoded string—without padding—that consists of 43 characters from the character set. The request body is an array of these strings. Responses Requests to return the following response code: 200 OK indicates that the request succeeded and the response body returns an array of lookup results for each specified transaction. The array has the same size as the request body. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. Parameter Type Description x-peer-addr string Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: . x-server‑timestamp integer >= 0 Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: . x‑chainweb‑node‑version string Specifies the version of the remote Chainweb node. For example: . Successful response schema If the request is successful, the response returns content with an array of lookup results for each request key in the request body. Parameter Type Description tag string Specifies the lookup result. The valid return values are \"Missing\" or \"Pending\". contents string Specifies the JSON-encoded text for a signed Pact transaction. Examples You can send a request to a bootstrap node for the Kadena test network and chain id 1 with a call like this: For this example, the request body consists of two request keys: In this example, the first transaction is \"Pending\" and the second transaction is \"Missing\" in the memory pool:",
    "source": "api/peer-to-peer/lookup-tx-mempool.md",
    "title": "lookup-tx-mempool"
  },
  {
    "content": "title: Insert transactions description: Provides reference information for the chainweb-node mempool endpoints. id: insert-tx-mempool sidebar_position: 6 tags: ['chainweb', 'node api', 'chainweb api', 'api reference'] Insert transactions When transactions are submitted to the blockchain for processing, they are queued in the node memory pool to await delivery to a mining node as new work to be validated. Endpoints related to memory pool activity are peer-to-peer endpoints that enable communication between memory pools on different nodes. The endpoint is included for reference. However, you shouldn't use this endpoint to insert transactions into the memory pool directly. You should always use the appropriate Pact REST API endpoints to submit and check the status of transactions. Request format Nodes can use the endpoint to move transactions into the memory pool. You shouldn't use this endpoint directly. Path parameters Parameter Type Description chain (required) integer >= 0 Specifies the chain identifier of the chain you want to send the payload request to. Valid values are 0 to 19. For example, to get block payload for the first chain (0), the request is . Request body schema The request body consists of an array of JSON-encoded strings representing signed Pact transactions. Responses Requests to return the following response code: 200 OK indicates that the request succeeded and that transactions were inserted into the memory pool. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. Parameter Type Description x-peer-addr string Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: . x-server‑timestamp integer >= 0 Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: . x‑chainweb‑node‑version string Specifies the version of the remote Chainweb node. For example: . Examples The following example illustrates the content of the request body with an array that only contains one transaction:",
    "source": "api/peer-to-peer/insert-tx-mempool.md",
    "title": "insert-tx-mempool"
  },
  {
    "content": "title: Get payload description: Provides reference information for the chainweb-node block payload endpoints. id: get-payload sidebar_position: 7 tags: ['chainweb', 'node api', 'chainweb api', 'api reference'] Get payload You can use the endpoint to return raw block payloads in the same form as they are stored on the chain. By default, only the payload data is returned. The raw payload data is sufficient for validating the blockchain Merkle tree and to use as input to Pact for executing the Pact transactions of the block and recomputing the outputs. You can also send requests to query the transaction outputs along with the payload data. Request format Use to get the raw payload data for the specified payload hash. Path parameters Parameter Type Description chain (required) integer >= 0 Specifies the chain identifier of the chain you want to send the payload request to. Valid values are 0 to 19. For example, to get block payload for the first chain (0), the request is . payloadHash (required) string Specifies the payload hash for the request. The block payload hash is a Base64Url-encoded string—without padding—that consists of 43 characters from the character set. For example: . Query parameters Parameter Type Description height integer >= 0 Height of a block. For example: . Responses Requests to return the following response codes: 200 OK indicates that the request succeeded and the response body returns the payload data for the specified payload hash. 404 Not Found indicates that the payload hash wasn't found. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. Parameter Type Description x-peer-addr string Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: . x-server‑timestamp integer >= 0 Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: . x‑chainweb‑node‑version string Specifies the version of the remote Chainweb node. For example: . Successful response schema If the request is successful, the response returns content with the following: Parameter Type Description transactions (required) Array of strings An array of Base64Url-encoded strings—without padding—that describe signed Pact transactions in JSON format. minerData (required) string Miner information is a Base64Url-encoded string—without padding—that consists of characters from the character set. This information is included as part of the payload JSON object. transactionsHash (required) string The transaction hash is a SHA256 hash. The hash is a Base64Url-encoded string—without padding—that consists of 43 characters from the character set. outputsHash (required) string The output hash is a SHA256 hash. The hash is a Base64Url-encoded string—without padding—that consists of 43 characters from the character set. payloadHash (required) string The block payload hash is a Base64Url-encoded string—without padding—that consists of 43 characters from the character set. Not found response schema If there are no results matching the request criteria, the response returns the following: Parameter Type Description key string Specifies the base64Url-encoded block hash without padding. The block hash consists of 43 characters from the character set. reason string Provides a placeholder for specifying the reason that no block hashes were found. Examples You can send a payload request to a bootstrap node for the Kadena test network and chain id 18 with a call like this: The response header for this request looks like this for version 2.26.1: The response body for this request returns the payload data. In this example, the payload data includes three transactions: In the following example, the payload hash doesn't include any transactions: The response body indicates the empty block payload like this: If there are no results matching the request criteria, the response body indicates the reason no results were found. For example:",
    "source": "api/peer-to-peer/get-payload.md",
    "title": "get-payload"
  },
  {
    "content": "title: Request multiple payloads description: Provides reference information for the chainweb-node block payload endpoints. id: get-payload-batch sidebar_position: 7 tags: ['chainweb', 'node api', 'chainweb api', 'api reference'] Request multiple block payloads Use to request multiple block payloads in a batch. Path parameters Parameter Type Description chain (required) integer >= 0 Specifies the chain identifier of the chain you want to get the payload from. Valid values are 0 to 19. For example, to get block payload for the first chain (0), the request is . Request body schema Use an array of payload hash strings and an array of block heights in a JSON object to specify the payloads you want to include in your batch request. Parameter Type Description hashes Array of strings Specifies the block payload hashes to include in the query request. Each block payload hash is a Base64Url-encoded string—without padding—that consists of 43 characters from the character set. For example: . heights Array of integers Specifies the block heights to include in the request. Responses Requests to return the following response codes: 200 OK indicates that the request succeeded and the response body returns some or all of the requested block payloads. The payloads are returned in any order. 404 Not Found indicates that the no payloads matching the request criteria were found. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. Parameter Type Description x-peer-addr string Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: . x-server‑timestamp integer >= 0 Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: . x‑chainweb‑node‑version string Specifies the version of the remote Chainweb node. For example: . Successful response schema If the request is successful, the response returns content with the following: Parameter Type Description transactions (required) Array of strings An array of Base64Url-encoded strings—without padding—that describe signed Pact transactions in JSON format. minerData (required) string Miner information is a Base64Url-encoded string—without padding—that consists of characters from the character set.This information is included as part of the payload JSON object. transactionsHash (required) string The transaction hash is a SHA256 hash. The hash is a Base64Url-encoded string—without padding—that consists of 43 characters from the character set. outputsHash (required) string The output hash is a SHA256 hash. The hash is a Base64Url-encoded string—without padding—that consists of 43 characters from the character set. payloadHash (required) string The block payload hash is a Base64Url-encoded string—without padding—that consists of 43 characters from the character set. Examples You can send a request to a bootstrap node for the Kadena test network and chain id 18 with a call like this: In this example, the request body includes a payload hash array for two payloads and three blook heights like this: If there are no payoads matching your query request, the endpoint returns an empty array. A successful response with two payloads looks similar to the following: Get block payload with outputs Use to get payload data with output. Path parameters Parameter Type Description chain (required) integer >= 0 Specifies the chain identifier of the chain you want to send the payload request to. Valid values are 0 to 19. For example, to get block payload for the first chain (0), the request is . payloadHash (required) string The block payload hash is a Base64Url-encoded string—without padding—that consists of 43 characters from the character set. For example: . Query parameters Parameter Type Description height integer >= 0 Height of a block. For example: . Responses Requests to return the following response codes: 200 OK indicates that the request succeeded and the response body returns the payload data and output for the specified payload hash. 404 Not Found indicates that the payload hash wasn't found. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. Parameter Type Description x-peer-addr string Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: . x-server‑timestamp integer >= 0 Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: . x‑chainweb‑node‑version string Specifies the version of the remote Chainweb node. For example: . Successful response schema If the request is successful, the response returns content with the following: Parameter Type Description transactions (required) Array of strings An array of Base64Url-encoded strings—without padding—that describe signed Pact transactions in JSON format. minerData (required) string Miner information is a Base64Url-encoded string—without padding—that consists of characters from the character set.This information is included as part of the payload JSON object. transactionsHash (required) string The transaction hash is a SHA256 hash. The hash is a Base64Url-encoded string—without padding—that consists of 43 characters from the character set. outputsHash (required) string The output hash is a SHA256 hash. The hash is a Base64Url-encoded string—without padding—that consists of 43 characters from the character set. payloadHash (required) string The block payload hash is a Base64Url-encoded string—without padding—that consists of 43 characters from the character set. coinbase (required) string Coinbase output is a Base64Url-encoded string—without padding—that consists of characters from the character set. This information is included as part of the payload output JSON object. Not found response schema If there are no results matching the request criteria, the response returns the following: Parameter Type Description key string Specifies the base64Url-encoded block hash without padding. The block hash consists of 43 characters from the character set. reason string Provides a placeholder for specifying the reason that no block hashes were found. Examples You can send a request to a bootstrap node for the Kadena main network and chain id 4 with a call like this: This request returns a response body that looks like this: If there are no results matching the request criteria, the response body indicates the reason no results were found. For example: Request multiple block payloads with outputs Use to request multiple block payloads with output in a batch. Path parameters Parameter Type Description chain (required) integer >= 0 Specifies the chain identifier of the chain you want to get the payload from. Valid values are 0 to 19. For example, to get block payload for the first chain (0), the request is . Request body schema Use an array of payload hash strings in a JSON object to specify the payloads you want to include in your batch request, with or without heights. Parameter Type Description hashes (required) Array of strings Each block payload hash is a Base64Url-encoded string—without padding—that consists of 43 characters from the character set. For example: . heights (required) Array of integers Specifies the block heights to include in the request. Responses Requests to return the following response codes: 200 OK indicates that the request succeeded and the response body includes some or all of the requested block payloads. The payloads are returned in any order. 404 Not Found indicates that no payloads mateching the request criteris were found. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. Parameter Type Description x-peer-addr string Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: . x-server‑timestamp integer >= 0 Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: . x‑chainweb‑node‑version string Specifies the version of the remote Chainweb node. For example: . Successful response schema If the request is successful, the response returns content with the following: Parameter Type Description transactions (required) Array of strings An array of Base64Url-encoded strings—without padding—that describe signed Pact transactions in JSON format. minerData (required) string Miner information is a Base64Url-encoded string—without padding—that consists of characters from the character set.This information is included as part of the payload JSON object. transactionsHash (required) string The transaction hash is a SHA256 hash. The hash is a Base64Url-encoded string—without padding—that consists of 43 characters from the character set. outputsHash (required) string The output hash is a SHA256 hash. The hash is a Base64Url-encoded string—without padding—that consists of 43 characters from the character set. payloadHash (required) string The block payload hash is a Base64Url-encoded string—without padding—that consists of 43 characters from the character set. coinbase (required) string Coinbase output is a Base64Url-encoded string—without padding—that consists of characters from the character set. This information is included as part of the payload output JSON object. Examples You can send a request to a bootstrap node for the Kadena main public blockchain network and chain id 4 with a call like this: In this example, the batch request includes three payload hashes and two block heights like this: The request returns the results matching the request criteria like this:",
    "source": "api/peer-to-peer/get-payload-batch.md",
    "title": "get-payload-batch"
  },
  {
    "content": "title: Get mempool peers description: Provides reference information for the chainweb-node peer endpoints. id: api-get-mempool-peers sidebar_position: 8 tags: ['chainweb', 'node api', 'chainweb api', 'api reference'] Get mempool peer information For peer-to-peer connections, Chainweb nodes have two separate communication channels with specialized independent peer-to-peer networks that different nodes can be part of: The peer-to-peer network is responsible for communicating the consensus state across the distributed network nodes. The peer-to-peer network is responsible for queuing and managing the pending transactions for each chain independently. Request format Use to retrieve peer information about the peer-to-peer network for a specific Chainweb node and chain. Path parameters Parameter Type Description chain (required) integer >= 0 Specifies the chain identifier of the chain you want to send the request to. Valid values are 0 to 19. For example, to get block hashes for the first chain (0), the request is . Query parameters Parameter Type Description limit integer >= 0 Specifies the maximum number of records that should be returned. The actual number of records returned might be lower than the value you specify. For example: . next string Specifies the cursor value to retrieve the next page of results. You can find the value to specify in the property returned by the previous page in a successful response. For example: . Responses Requests to return the following response code: 200 OK indicates that the request succeeded and the response body returns the blockchain state for each chain at the specified block height. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. Parameter Type Description x-peer-addr string Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: . x-server‑timestamp integer >= 0 Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: . x‑chainweb‑node‑version string Specifies the version of the remote Chainweb node. For example: . Successful response schema If the request is successful, the response returns content with the following: Parameter Type Description items (required) Array of objects Returns an array of peer information objects. limit (required) integer >= 0 Specifies the maximum number of items in the page. This number can be smaller but never larger than the number of requested items. next (required) string or null Returns a value that can be used to query the next page. You can use this value for the parameter in a follow-up request. The format for this parameter consists of two parts. The first part of the string can be , , or null. The second part is the value that calls the next page of results or null if there are no more results to query. Examples You can send a request to retrieve information about the memory pool peer-to-peer network with a call to the endpoint similar to the following: The response body for this request returns the peer information for the nodes in the peer-to-peer network: Add peer information to the mempool peer-to-peer network Use to add peer information to the mempool peer-to-peer network for a specific chain. Path parameters Parameter Type Description chain (required) integer >= 0 Specifies the chain identifier of the chain you want to send the request to. Valid values are 0 to 19. For example, to get block hashes for the first chain (0), the request is . Request body schema Use the following parameters to specify the peer information you want to add to the peer database of the memory pool peer-to-peer network on the remote host. Parameter Type Description id (required) string or null Specifies the Base64Url-encoded string—without padding—that represents the SHA256 fingerprint of the SSL certificate for the remote node. This field can only be if the node uses an official certificate authority (CA) signed certificate. In all other cases, the string consists of 43 characters from the character set. address (required) object Specifies the host and port number of the peer you want to add to the peer database of the memory pool peer-to-peer network for the specified chain. Responses Requests to return the following response codes: 204 No Content indicates that the request was successful and the peer was added to the peer database of the remote node. 400 Bad Request indicates that the request itself is invalid or that the hostname and port provided for the peer is not reachable. Before a Chainweb node adds a peer to its peer database, the node checks whether the peer can be reached using the information provided. If this check fails, an error is returned. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. Parameter Type Description x-peer-addr string Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: . x-server‑timestamp integer >= 0 Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: . x‑chainweb‑node‑version string Specifies the version of the remote Chainweb node. For example: . Examples You can send a request to add a peer to the peer node database with a call to the endpoint similar to the following: The request body for adding a peer contains parameters similar to the following: If the request is successful, you'll see the 204 No Content response returned. If the host name or IP address wasn't reachable, you'll see an error message similar to the following:",
    "source": "api/peer-to-peer/get-mempool-peers.md",
    "title": "get-mempool-peers"
  },
  {
    "content": "title: Query the current state description: Use the GET /cut endpoint to return the cut height for a Chainweb node. id: get-cut sidebar_position: 2 tags: ['chainweb', 'node api', 'chainweb api', 'api reference', 'block height cut'] Query the current state In the Kadena network, a cut height represents the distributed state from a Chainweb node. Each cut height—much like a database snapshot or a block height—references one block header for each chain, compared with concurrent blocks on other chains. Two blocks from two different chains are considered concurrent if either block is an adjacent parent and a direct dependency of the other or if the blocks do not depend at all on each other. Request format Use to query a Chainweb node for the current cut height on all chains. You can specify the following optional query parameter for the request: Parameter Type Description maxheight integer >= 0 Maximum cut height of the returned cut. Responses Requests to return the following response code: 200 OK indicates that the request succeeded and the response body returns the blockchain state for each chain at the specified block height. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. Parameter Type Description x-peer-addr string Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: . x-server‑timestamp integer >= 0 Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: . x‑chainweb‑node‑version string Specifies the version of the remote Chainweb node. For example: . Response schema The response returns content with the following information: Parameter Type Description origin object Describes a peer information object that consists of an string and an object for a Chainweb node. The parameter is required to use the endpoint. For more information, see the Peer information data model. height (required) integer >= 0 Specifies the cut height. The cut height is the sum of the height for all of the blocks included in the cut. You should avoid using this value because its semantics may change in the future. weight (required) string Specifies the cut weight. The cut weight is the sum of the weights from all of the blocks included in the cut. The weight string consists of 43 characters from the [] character set. hashes (required) object Specifies an object that maps chain identifiers 0-19 to their respective block hash and block height for the cut. instance string Specifies the network identifier for the cut. id string Specifies a cut identifier. The id string consists of 43 characters from the [] character set. Examples You can send a request to a bootstrap node for the Kadena main network with a call like this: The response header for this request looks like this: The response body for this request returns the state for each chain with the maximum block height of 483314: Note that this sample request was sent to a bootstrap node for the Kadena public blockchain, so the is . If you want to publish a cut, you must send the request to a Chainweb node that returns a value for the property. Publish a cut Use to publish a cut to a Chainweb node. The cut must contain an property that is not null. The receiving node will first try to obtain all missing dependencies from the node specified for the property before searching for the dependencies in the peer-to-peer network. Request body schema Use the following parameters to specify a with an property that is not null. Parameter Type Description origin (required) object Describes a peer information object that consists of an string and an object for a Chainweb node. The parameter is required to use the endpoint. For more information, see the Peer information data model. height (required) integer >= 0 Specifies the cut height to publish. The cut height is the sum of the height for all of the blocks included in the cut. You should avoid using this value because its semantics may change in the future. weight (required) string Specifies the cut weight. The cut weight is the sum of the weights from all of the blocks included in the cut. The weight string consists of 43 characters from the [] character set. hashes (required) object Specifies an object that maps chain identifiers 0-19 to their respective block hash and block height for the cut. instance string Specifies the network identifier for the cut. id string Specifies a cut identifier. The id string consists of 43 characters from the [] character set. Responses Requests to return the following response codes: 204 No Content indicates that the request was successful and the cut was added to the cut processing pipeline on the remote Chainweb node. 401 Unauthorized indicates that the node where you are trying to publish the cut is not a peer of the node identified in the property, and therefore cannot process the cut you're attempting to publish. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. Parameter Type Description x-peer-addr string Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: . x-server‑timestamp integer >= 0 Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: . x‑chainweb‑node‑version string Specifies the version of the remote Chainweb node. For example: . Examples You can send a request to publish a cut on a node with a call to the endpoint similar to the following: The request body for publishing a cut contains parameters similar to the following: If the request is successful, you'll see the 204 No Content response returned.",
    "source": "api/peer-to-peer/get-cut.md",
    "title": "get-cut"
  },
  {
    "content": "title: Get cut peers description: Provides reference information for the chainweb-node peer endpoints. id: api-get-cut-peers sidebar_position: 8 tags: ['chainweb', 'node api', 'chainweb api', 'api reference'] Get cut peer information For peer-to-peer connections, Chainweb nodes have two separate communication channels with specialized independent peer-to-peer networks that different nodes can be part of: The peer-to-peer network is responsible for communicating the consensus state across the distributed network nodes. The peer-to-peer network is responsible for queuing and managing the pending transactions for each chain independently. Request format Use to retrieve peer node information about the peer-to-peer network for a specific Chainweb node. Query parameters Parameter Type Description limit integer >= 0 Specifies the maximum number of records that should be returned. The actual number of records returned might be lower than the value you specify. For example: . next string Specifies the cursor value to retrieve the next page of results. You can find the value to specify in the property returned by the previous page in a successful response. For example: . Responses Requests to return the following response code: 200 OK indicates that the request succeeded. The response body describes the peers from the peer database on the remote node. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. Parameter Type Description x-peer-addr string Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: . x-server‑timestamp integer >= 0 Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: . x‑chainweb‑node‑version string Specifies the version of the remote Chainweb node. For example: . Successful response schema If the request is successful, the response returns content with the following: Parameter Type Description items (required) Array of objects Returns an array of peer information objects. limit (required) integer >= 0 Specifies the maximum number of items in the page. This number can be smaller but never larger than the number of requested items. next (required) string or null Returns a value that can be used to query the next page. You can use this value for the parameter in a follow-up request. The format for this parameter consists of two parts. The first part of the string can be , , or null. The second part is the value that calls the next page of results or null if there are no more results to query. Examples You can send a request to a Kadena main network bootstrap node by calling the peer-to-peer endpoint like this: This request returns two items with peer information in the response body: To send a follow-up request to get peer information for the next two peers, you can add the parameter to the request: This request returns the next two items from the peer database in the response body: Add cut peer information Use to add peer information to the peer database of the peer-to-peer network on the remote host. Request body schema Use the following parameters to specify the peer information you want to add to the peer database of the cut peer-to-peer network on the remote host. Parameter Type Description id (required) string or null Specifies the Base64Url-encoded string—without padding—that represents the SHA256 fingerprint of the SSL certificate for the remote node. This field can only be if the node uses an official certificate authority (CA) signed certificate. In all other cases, the string consists of 43 characters from the character set. address (required) object Specifies the host and port number of the peer. Responses Requests to return the following response codes: 204 No Content indicates that the request was successful and the peer was added to the peer database of the remote node. 400 Bad Request indicates that the request itself is invalid or that the hostname and port provided for the peer is not reachable. Before a Chainweb node adds a peer to its peer database, the node checks whether the peer can be reached using the information provided. If this check fails, an error is returned. Examples You can send a request to add a peer to the peer node database with a call to the endpoint similar to the following: The request body for adding a peer contains parameters similar to the following: If the request is successful, you'll see the 204 No Content response returned. If the host name or IP address wasn't reachable, you'll see an error message similar to the following:",
    "source": "api/peer-to-peer/get-cut-peers.md",
    "title": "get-cut-peers"
  },
  {
    "content": "title: Check request keys description: Provides reference information for the chainweb-node mempool endpoints. id: boolean-tx-mempool sidebar_position: 6 tags: ['chainweb', 'node api', 'chainweb api', 'api reference'] Check request keys When transactions are submitted to the blockchain for processing, they are queued in the node memory pool to await delivery to a mining node as new work to be validated. Endpoints related to memory pool activity are peer-to-peer endpoints that enable communication between memory pools on different nodes. With the endpoint, you can specify a list of transaction request keys to check the status of. The request returns true for each transaction found waiting in the mempool and false for each transaction that wasn't found in the mempool. Request format Use to check the whether specific transactions are currently in the memory pool using their transaction request keys. Path parameters Parameter Type Description chain (required) integer >= 0 Specifies the chain identifier of the chain you want to send the payload request to. Valid values are 0 to 19. For example, to get block payload for the first chain (0), the request is . Request body schema The request body consists of an array of transaction request keys to check for in the memory pool. Each request key for a Pact transaction is a Base64Url-encoded string—without padding—that consists of 43 characters from the character set. The request body is an array of these strings. Responses Requests to return the following response code: 200 OK indicates that the request succeeded and the response body returns an array of boolean values that indicate whether each specified transaction is in the memory pool. The array has the same size as the request body. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. Parameter Type Description x-peer-addr string Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: . x-server‑timestamp integer >= 0 Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: . x‑chainweb‑node‑version string Specifies the version of the remote Chainweb node. For example: . Successful response schema If the request is successful, the response returns content with an array of boolean values for each request key in the request body. Examples You can send a request to a bootstrap node for the Kadena main network and chain id 0 with a call like this: For this example, the request body consists of one request key: If the transaction isn't found in the memory pool, the response body returns false: You can send a request to a bootstrap node for the Kadena test network and chain id 1 with a call like this: For this example, the request body consists of two request keys: In this example, the second transaction was found in the memory pool: Look up pending transactions in the mempool Use to look up pending transactions in the memory pool. Path parameters Parameter Type Description chain (required) integer >= 0 Specifies the chain identifier of the chain you want to send the payload request to. Valid values are 0 to 19. For example, to get block payload for the first chain (0), the request is . Request body schema The request body consists of an array of transaction request keys to check for in the memory pool. Each request key for a Pact transaction is a Base64Url-encoded string—without padding—that consists of 43 characters from the character set. The request body is an array of these strings. Responses Requests to return the following response code: 200 OK indicates that the request succeeded and the response body returns an array of lookup results for each specified transaction. The array has the same size as the request body. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. Parameter Type Description x-peer-addr string Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: . x-server‑timestamp integer >= 0 Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: . x‑chainweb‑node‑version string Specifies the version of the remote Chainweb node. For example: . Successful response schema If the request is successful, the response returns content with an array of lookup results for each request key in the request body. Parameter Type Description tag string Specifies the lookup result. The valid return values are \"Missing\" or \"Pending\". contents string Specifies the JSON-encoded text for a signed Pact transaction. Examples You can send a request to a bootstrap node for the Kadena test network and chain id 1 with a call like this: For this example, the request body consists of two request keys: In this example, the first transaction is \"Pending\" and the second transaction is \"Missing\" in the memory pool: Insert transactions into the mempool Nodes can use the endpoint to move transactions into the memory pool. Information about this endpoint is included for reference. You shouldn't use this endpoint directly. Instead, you should use the appropriate Pact endpoints to submit transactions to the network. Path parameters Parameter Type Description chain (required) integer >= 0 Specifies the chain identifier of the chain you want to send the payload request to. Valid values are 0 to 19. For example, to get block payload for the first chain (0), the request is . Request body schema The request body consists of an array of JSON-encoded strings representing signed Pact transactions. Responses Requests to return the following response code: 200 OK indicates that the request succeeded and that transactions were inserted into the memory pool. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. Parameter Type Description x-peer-addr string Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: . x-server‑timestamp integer >= 0 Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: . x‑chainweb‑node‑version string Specifies the version of the remote Chainweb node. For example: . Examples The following example illustrates the content of the request body with an array that only contains one transaction:",
    "source": "api/peer-to-peer/boolean-tx-mempool.md",
    "title": "boolean-tx-mempool"
  },
  {
    "content": "title: Configuration endpoint description: Provides reference information for the chainweb-node config endpoint. id: api-config sidebar_position: 3 tags: ['chainweb', 'node api', 'chainweb api', 'api reference'] Configuration endpoint Use to return configuration information for a Chainweb node. The configuration details are returned as a JSON object with sensitive information removed from the result. The JSON schema depends on the version of the software running on the node and is not part of the stable API. Responses Requests to the endpoint return the following response code: 200 OK returns the configuration details for the Chainweb node. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. Parameter Type Description x-peer-addr string Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: . x-server‑timestamp integer >= 0 Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: . x‑chainweb‑node‑version string Specifies the version of the remote Chainweb node. For example: . Response schema The content of the JSON schema depends on the version of the software running on the node and is not part of the stable API. Examples You can send a request to a Kadena main network bootstrap node by calling the endpoint. For example: You can send a request to a Kadena test network bootstrap node like this: These sample requests return the schema for version 2.26.1. For the bootstrap node, the response looks similar to the following: To get configuration for a local development network, you can call the endpoint like this:",
    "source": "api/peer-to-peer/api-config.md",
    "title": "api-config"
  },
  {
    "content": "title: Request pending transactions description: Provides reference information for the chainweb-node mempool endpoints. id: all-pending-mempool sidebar_position: 6 tags: ['chainweb', 'node api', 'chainweb api', 'api reference'] Request all transactions When transactions are submitted to the blockchain for processing, they are queued in the node memory pool to await delivery to a mining node as new work to be validated. Endpoints related to memory pool activity are peer-to-peer endpoints that enable communication between memory pools on different nodes. These API endpoints are included for reference but are not intended to be used directly. In most cases, you should use the appropriate Pact REST API endpoints to submit and check the status of transactions. With the endpoint, you can return all of the transaction hashes for the transactions found waiting in the memory pool. Request format Use to retrieve pending transactions from the memory pool. Path parameters Parameter Type Description chain (required) integer >= 0 Specifies the chain identifier of the chain you want to send the payload request to. Valid values are 0 to 19. For example, to get block payload for the first chain (0), the request is . Query parameters Parameter Type Description nonce integer >= 0 Specifies the server nonce value. since integer 64‑bit Specifies the transaction identifier value to use as a starting point for retrieving pending transactions from the memory pool. Responses Requests to return the following response code: 200 OK indicates that the request succeeded and the response body returns the pending transactions matching the request criteria. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. Parameter Type Description x-peer-addr string Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: . x-server‑timestamp integer >= 0 Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: . x‑chainweb‑node‑version string Specifies the version of the remote Chainweb node. For example: . Successful response schema If the request is successful, the response returns content with the following: Parameter Type Description hashes Array of strings Lists the transaction hashes for pending transactions in the memory pool. The hash is a Base64Url-encoded string—without padding—that consists of 43 characters from the character set. highwaterMark Array of integers Specifies a two-element array with the server nonce value and the transaction identifier representing the last transaction mined out of the memory pool. Examples You can send a request to a bootstrap node for the Kadena main network and chain id 0 with a call like this: The response body for this request returns information about the pending transactions similar to the following:",
    "source": "api/peer-to-peer/all-pending-mempool.md",
    "title": "all-pending-mempool"
  },
  {
    "content": "title: Add mempool peers description: Provides reference information for the chainweb-node peer endpoints. id: api-add-mempool-peers sidebar_position: 8 tags: ['chainweb', 'node api', 'chainweb api', 'api reference'] Add mempool peer information For peer-to-peer connections, Chainweb nodes have two separate communication channels with specialized independent peer-to-peer networks that different nodes can be part of: The peer-to-peer network is responsible for communicating the consensus state across the distributed network nodes. The peer-to-peer network is responsible for queuing and managing the pending transactions for each chain independently. Request format Use to add peer information to the mempool peer-to-peer network for a specific chain. Path parameters Parameter Type Description chain (required) integer >= 0 Specifies the chain identifier of the chain you want to send the request to. Valid values are 0 to 19. For example, to get block hashes for the first chain (0), the request is . Request body schema Use the following parameters to specify the peer information you want to add to the peer database of the memory pool peer-to-peer network on the remote host. Parameter Type Description id (required) string or null Specifies the Base64Url-encoded string—without padding—that represents the SHA256 fingerprint of the SSL certificate for the remote node. This field can only be if the node uses an official certificate authority (CA) signed certificate. In all other cases, the string consists of 43 characters from the character set. address (required) object Specifies the host and port number of the peer you want to add to the peer database of the memory pool peer-to-peer network for the specified chain. Responses Requests to return the following response codes: 204 No Content indicates that the request was successful and the peer was added to the peer database of the remote node. 400 Bad Request indicates that the request itself is invalid or that the hostname and port provided for the peer is not reachable. Before a Chainweb node adds a peer to its peer database, the node checks whether the peer can be reached using the information provided. If this check fails, an error is returned. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. Parameter Type Description x-peer-addr string Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: . x-server‑timestamp integer >= 0 Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: . x‑chainweb‑node‑version string Specifies the version of the remote Chainweb node. For example: . Examples You can send a request to add a peer to the peer node database with a call to the endpoint similar to the following: The request body for adding a peer contains parameters similar to the following: If the request is successful, you'll see the 204 No Content response returned. If the host name or IP address wasn't reachable, you'll see an error message similar to the following:",
    "source": "api/peer-to-peer/add-mempool-peers.md",
    "title": "add-mempool-peers"
  },
  {
    "content": "title: Add cut peers description: Provides reference information for the chainweb-node peer endpoints. id: api-add-cut-peers sidebar_position: 8 tags: ['chainweb', 'node api', 'chainweb api', 'api reference'] Add cut peer information For peer-to-peer connections, Chainweb nodes have two separate communication channels with specialized independent peer-to-peer networks that different nodes can be part of: The peer-to-peer network is responsible for communicating the consensus state across the distributed network nodes. The peer-to-peer network is responsible for queuing and managing the pending transactions for each chain independently. Request format Use to add peer information to the peer database of the peer-to-peer network on the remote host. Request body schema Use the following parameters to specify the peer information you want to add to the peer database of the cut peer-to-peer network on the remote host. Parameter Type Description id (required) string or null Specifies the Base64Url-encoded string—without padding—that represents the SHA256 fingerprint of the SSL certificate for the remote node. This field can only be if the node uses an official certificate authority (CA) signed certificate. In all other cases, the string consists of 43 characters from the character set. address (required) object Specifies the host and port number of the peer. Responses Requests to return the following response codes: 204 No Content indicates that the request was successful and the peer was added to the peer database of the remote node. 400 Bad Request indicates that the request itself is invalid or that the hostname and port provided for the peer is not reachable. Before a Chainweb node adds a peer to its peer database, the node checks whether the peer can be reached using the information provided. If this check fails, an error is returned. Examples You can send a request to add a peer to the peer node database with a call to the endpoint similar to the following: The request body for adding a peer contains parameters similar to the following: If the request is successful, you'll see the 204 No Content response returned. If the host name or IP address wasn't reachable, you'll see an error message similar to the following:",
    "source": "api/peer-to-peer/add-cut-peers.md",
    "title": "add-cut-peers"
  },
  {
    "content": "title: Start a database backup description: Send an API request to start a database backup job if you have enabled the backup API for a node. id: make-db-backup sidebar_position: 11 tags: ['chainweb', 'node api', 'chainweb api', 'api reference'] Start a database backup job You can configure a Chainweb node to support database backup jobs. If you enable the backup API for a node, you can use the backup endpoints to a start backup job and check the status of a previously started backup job. Enable backups The and endpoints are only valid if you enable the backup API for a node. You can enable the backup API by starting the node with the and command-line options or by specifying the following configuration settings in the node configuration file: Select a backup directory If you enable the backup API, sending a request the endpoint always backs up the RocksDB portion of the Chainweb database. In most cases, you should locate the backup directory in the same partition as the active RocksDB database. Storing RocksDB backups in the same partition as the active RocksDB database minimizes the space required and the time it takes to complete backups initially. Over time—as the active database diverges from the backup copy—the space required will increase. If you store the backup on another partition, the backup operation takes longer and the backup copy requires as much disk space as the active RocksDB database. Back up the Pact database Chainweb nodes have two separate databases. One database—the RocksDB database—stores information about blocks and chains. A second database—the Pact Sqlite database—stores information about smart contracts and state. While backup jobs always back up the RocksDB database, backing up the Pact Sqlite database is optional. If you include the parameter in your request, the backup job backs up both databases. Backing up both databases takes much longer than only backing up the RockDB database. In addition, Pact database backups always require as much space as the active Pact database. Define a retention policy Database backup jobs don't provide any type of automatic backup retention policy. You should define your own policy and delete old backup copies, as appropriate. Request format Use to start a backup job for a Chainweb node. Starting a backup job creates a UNIX timestamp identifier for the job. You can then use the identifier to check the status of the job to determine if the job is still in progress or the backup has been completed. If a backup job is already in progress, this endpoint returns the UNIX timestamp job identifier instead of starting a new backup job. Query parameters Parameter Description backupPact Indicates that you want to back up both the RockDB database and the Pact database. This option requires additional disk space and increases the time required to complete the backup. Responses Requests to the endpoint return the following response code: 200 OK indicates that a backup job has been created. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. Parameter Type Description x-peer-addr string Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: . x-server‑timestamp integer >= 0 Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: . x‑chainweb‑node‑version string Specifies the version of the remote Chainweb node. For example: . Response schema The response returns content with the following information: Parameter Type Description backupId string Specifies the backup job identifier with a UNIX timestamp from the character set. Check the status of a backup job Use to check the status of a backup job. Path parameters Parameter Type Description backupId (required) string Specifies the backup job identifier with a UNIX timestamp from the character set. For example: 1648665437000 Responses Requests to the endpoint can return the following response codes: 200 OK indicates that a backup job with the specified identifier exists and returns its current status. 404 Not Found indicates that there were no backup jobs matching the specified identifier. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. Parameter Type Description x-peer-addr string Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: . x-server‑timestamp integer >= 0 Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: . x‑chainweb‑node‑version string Specifies the version of the remote Chainweb node. For example: . Response schema The response returns content with the following information: Parameter Type Description status string Specifies the status of the backup job with the specified identifier. There are three possible status messages: , , and . Check node health Use to check whether is running and responding to API requests. To check the state of consensus, you should use the endpoint instead of this endpoint. Responses Requests to the endpoint return the following response code: 200 OK indicates that the node is running and responding to API requests. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. Parameter Type Description x-peer-addr string Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: . x-server‑timestamp integer >= 0 Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: . x‑chainweb‑node‑version string Specifies the version of the remote Chainweb node. For example: . Response schema The response returns content with the following information: Parameter Type Description check string Health check OK. Examples You can send a health check request to a node like this: This request returns a plain text message like this: Get general node information Use to return general information about the node and the Chainweb version. Responses Requests to the endpoint return the following response code: 200 OK indicates that the request succeeded and the response body returns general information about the node and the chains in the network. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. Parameter Type Description x-peer-addr string Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: . x-server‑timestamp integer >= 0 Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: . x‑chainweb‑node‑version string Specifies the version of the remote Chainweb node. For example: . Response schema If the request is successful, the response returns content with the following: Parameter Type Description nodeApiVersion (required) string Specifies the Chainweb API version information for the node. nodeBlockDelay (required) integer >= 0 Specifies the number of seconds to delay between blocks. nodeChains (required) Array of strings Specifies the chain identifiers for the chains in the network the node is part of. nodeGenesisHeights (required) Array of integers Specifies the block height for the first block of each chain in the network. nodeGraphHistory (required) Array of integers Specifies the block height and adjacent chains for all chain graphs indexed by the height of the first block with the respective graph. Graphs are encoded as adjacency lists. nodeHistoricalChains (required) Array of integers Specifies the block height and adjacent chains for all chain graphs indexed by the height of the first block for the graph. Graphs are encoded as adjacency lists. nodeLatestBehaviorHeight (required) integer Specifies the latest block height for the node. nodeNumberOfChains (required) integer >= 10 Specifies the number of chains in the network the node is part of. nodePackageVersion (required) string Specifies the release package version for the software package running on the node. nodeServiceDate (required) string Specifies the next service date for updating the software package running on the node. nodeVersion (required) string Specifies the network identifier for the network the node is part of. The valid values are \"test-singleton\", \"development\", \"mainnet01\", and \"testnet04\". Examples You can send a request for general information to a node like this: This request returns information similar to the following truncated excerpt: Blocks event stream Use to connect to a source of server events that emits a BlockHeader event for each new block header that is added to the chain database of the remote node. The stream can contain blocks that might later become orphaned. To address this potential issue, you should buffer events on the client side for the most recent block heights to allow for a desired confirmation depth to be reached. You should note that the server might terminate this event stream from time to time. It is up to the client to restart event streaming with a new request. Responses 200 OK indicates a successful requests and results in a stream of BlockHeader events. Each event consists of an event property and a data property and are separated by empty lines. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. Parameter Type Description x-peer-addr string Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: . x-server‑timestamp integer >= 0 Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: . x‑chainweb‑node‑version string Specifies the version of the remote Chainweb node. For example: . Response schema If the request is successful, the response returns content with the following: Parameter Type Description event string Specifies the type of event with the event property value of \"BlockHeader\". data object Specifies the data properties for the event. Examples You can send a request for block header updates from the Kadena main network like this: This request returns a stream of events with the BlockHeader event property and a data property: If you expand the data property for an event, the event includes details similar to the following:",
    "source": "api/service-api/start-db-backup-job.md",
    "title": "start-db-backup-job"
  },
  {
    "content": "title: Get general node information description: Send a health check API request to check the availability of a node. id: get-node-info sidebar_position: 11 tags: ['chainweb', 'node api', 'chainweb api', 'api reference'] Get general node information The endpoint enables you to request general information about the state of a node, including adjacent chains and the graph history for a node. Request format Use to return general information about the node and the Chainweb version. Responses Requests to the endpoint return the following response code: 200 OK indicates that the request succeeded and the response body returns general information about the node and the chains in the network. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. Parameter Type Description x-peer-addr string Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: . x-server‑timestamp integer >= 0 Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: . x‑chainweb‑node‑version string Specifies the version of the remote Chainweb node. For example: . Response schema If the request is successful, the response returns content with the following: Parameter Type Description nodeApiVersion (required) string Specifies the Chainweb API version information for the node. nodeBlockDelay (required) integer >= 0 Specifies the number of seconds to delay between blocks. nodeChains (required) Array of strings Specifies the chain identifiers for the chains in the network the node is part of. nodeGenesisHeights (required) Array of integers Specifies the block height for the first block of each chain in the network. nodeGraphHistory (required) Array of integers Specifies the block height and adjacent chains for all chain graphs indexed by the height of the first block with the respective graph. Graphs are encoded as adjacency lists. nodeHistoricalChains (required) Array of integers Specifies the block height and adjacent chains for all chain graphs indexed by the height of the first block for the graph. Graphs are encoded as adjacency lists. nodeLatestBehaviorHeight (required) integer Specifies the latest block height for the node. nodeNumberOfChains (required) integer >= 10 Specifies the number of chains in the network the node is part of. nodePackageVersion (required) string Specifies the release package version for the software package running on the node. nodeServiceDate (required) string Specifies the next service date for updating the software package running on the node. nodeVersion (required) string Specifies the network identifier for the network the node is part of. The valid values are \"test-singleton\", \"development\", \"mainnet01\", and \"testnet04\". Examples You can send a request for general information to a node like this: This request returns information similar to the following truncated excerpt:",
    "source": "api/service-api/get-node-information.md",
    "title": "get-node-information"
  },
  {
    "content": "title: Mining endpoints description: Provides reference information for the chainweb-node block endpoints. id: mining sidebar_position: 10 tags: ['chainweb', 'node api', 'chainweb api', 'api reference'] Mining endpoints The Chainweb node mining API is disabled by default. You must enable and configure the mining API in the node configuration file before you can use any of the mining endpoints. Get mining work Use to request a new block header to work on. Request body schema Use the following parameters to specify the miner information. Parameter Type Description account string Specifies the miner account name. Usually, this is the same as the public key. predicate key predicate Specifies the number of keys required from the enumerated values of the \"keys-all\", \"keys-any\", and \"keys-2\" key predicate options. For accounts with a single key, the predicate is usually \"keys-all\". public‑keys Array of strings Lists one or more miner public keys. Responses Requests to return the following response codes: 200 OK indicates that the request was successful and the response is an encoded stream of data. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. Parameter Type Description x-peer-addr string Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: . x-server‑timestamp integer >= 0 Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: . x‑chainweb‑node‑version string Specifies the version of the remote Chainweb node. For example: . Successful response schema If the request is successful, the response returns content with the following: Parameter Type Description chainBytes string binary Identifies the chain selected by the node with four chain identifier bytes. This is informational. Generally, miners shouldn't care about the chain. targetBytes string binary Specifies the proof-of-work target for the current block in 32 proof-of-work target bytes. The proof-of-work hash of a valid block must not be larger than this value. For arithmetic comparisons, the hash-target and the proof-of-work hash are interpreted as unsigned 256-bit integral number in little endian encoding. headerBytes string binary Specifies the proof-of-work in 286 work header bytes. The last 8 bytes are the nonce. The creation time is encoded in bytes 44-52. Miners must not change or make any assumption about the other bytes. The creation time is encoded as little endian two complement integral number that counts SI microseconds since the start of the UNIX epoch (leap seconds are ignored). It always positive (highest bit is 0). Miners are free but not required to update the creation time. The value must be strictly larger than the creation time of the parent block and must not be in the future. Examples If you have enabled mining, you can send a request for work like this: The request body should contain parameters similar to the following: If the request is successful, the response is an octet stream with: Work bytes - (ChainBytes4 + TargetBytes32 + HeaderBytes286) This is the minimum information required to perform proof-of-work validation. No knowledge of Chainweb internals is necessary. For information about the encoding of work bytes, see Binary encoding. Solved mining work Use to submit a solution for a new block. Request body schema The request body should be content with the solved proof-of-work work header bytes. The solved proof-of-work binary string of 286 bytes should consist of the original work received from the endpoint with updated nonce value such that it satisfies the proof-of-work puzzle. The nonce is defined in the last 8 bytes of the work header bytes. The proof-of-work hash of a valid block is computed using blake2s. It must not be larger than the proof-of-work target for the current block. The target was received along with the work header bytes from the endpoint. For arithmetic comparisons, the hash-target and the proof-of-work hash are interpreted as an unsigned 256-bit integral number in little endian encoding. Miners can also update the creation time. However, the value must be strictly larger than the creation time of the parent block and must not be in the future. Responses Requests to return the following response codes: 204 No Content indicates that the request was successful and the proof-of-work solution is valid. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. Parameter Type Description x-peer-addr string Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: . x-server‑timestamp integer >= 0 Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: . x‑chainweb‑node‑version string Specifies the version of the remote Chainweb node. For example: . Examples If you have enabled mining, you can submit a proof-of-work solution like this: The request body should be 286 bytes from the original work received from the endpoint with updated the nonce. If the request is successful, you'll see the 204 No Content response returned. Notification of updated work Use to receive notifications from a server when new mining work becomes available. This server-sent event stream is terminated by the server in regular intervals. It's the responsibility of the miner to periodically request a new stream. Request body The request body should be content with the first four bytes—the chain identifier bytes—received from a call to the endpoint. With this request body, Node only informs the miner of a new cut when the chain identified by the first four bytes has updated. Responses Requests to return the following response code: 200 OK for each update event. Each event consists of a single line with the message event:New Cut. Events are separated by empty lines. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. Parameter Type Description x-peer-addr string Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: . x-server‑timestamp integer >= 0 Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: . x‑chainweb‑node‑version string Specifies the version of the remote Chainweb node. For example: . Successful response schema If the request is successful, the response returns content with the following: Parameter Type Description event string Indicates a chain update with the message event:New Cut on a single line. Examples If you have enabled mining, you can request notification for chain updates like this: The request body should be content with the first four chain identifier bytes from a work header. The server-send events look like this:",
    "source": "api/service-api/get-mining-work.md",
    "title": "get-mining-work"
  },
  {
    "content": "title: Retrieve full blocks description: Provides reference information for the chainweb-node service API block endpoints. id: get-block sidebar_position: 9 tags: ['chainweb', 'node api', 'chainweb api', 'api reference'] Retrieve full blocks You can use the API endpoint to return full blocks—that is, headers and payloads—from the specified chain database. Generally, blocks are returned in ascending order and include orphaned blocks. If you only want to retrieve blocks that are included in the winning branch of the chain, you can call the endpoint. Branch endpoints return blocks in descending order starting from the leafs of branches of the block chain. Blocks are returned in only one format, with block headers and payloads in JSON encoding. Request format Use to return blocks matching the request criteria in ascending order. All blocks that match the criteria are returned from the chain database, including orphaned blocks. Path parameters Parameter Type Description chain (required) integer >= 0 Specifies the chain identifier of the chain you want to send the request to. Valid values are 0 to 19. For example, to get block hashes for the first chain (0), the request is . Query parameters Parameter Type Description limit integer >= 0 Specifies the maximum number of records that should be returned. The actual number of records returned might be lower than the value you specify. For example: . next string Specifies the cursor value to retrieve the next page of results. You can find the value to specify in the property returned by the previous page in a successful response. For example: . minheight integer >= 0 Specifies the minimum block height for the blocks to return. For example: . maxheight integer >= 0 Specifies the maximum block height for the blocks to return. For example: . Responses Requests to can return the following response codes: 200 OK indicates that the request succeeded. The response body includes all of the blocks matching the criteria specified, including any orphaned blocks. 404 Not Found indicates that no blocks matching the request criteria were found or that the or parameter wasn't valid. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. Parameter Type Description x-peer-addr string Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: . x-server‑timestamp integer >= 0 Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: . x‑chainweb‑node‑version string Specifies the version of the remote Chainweb node. For example: . Successful response schema If the request is successful, the response returns content with the following: Parameter Type Description items (required) Array of objects Returns an array of JSON-encoded objects representing full blocks. limit (required) integer >= 0 Specifies the maximum number of items in the page. This number can be smaller but never larger than the number of requested items. next (required) string or null Returns a value that can be used to query the next page. You can use this value for the parameter in a follow-up request. The format for this parameter consists of two parts. The first part of the string can be , or null. The second part is the value that calls the next page of results or null if there are no more results to query. Examples You can send a request to the Kadena main network—mainnet01—and chain 19 by calling the main network service endpoint like this: This request returns one whole block in the response body: Get block branches Use to return blocks from branches of the block chain in descending order. A request sent to this endpoint returns blocks that are ancestors of any block specified for the upper bounds and that are not ancestors of any block specified for the lower bounds. Path parameters Parameter Type Description chain (required) integer >= 0 Specifies the chain identifier of the chain you want to send the request to. Valid values are 0 to 19. For example, to get block hashes for the first chain (0), the request is . Query parameters Parameter Type Description limit integer >= 0 Specifies the maximum number of records that should be returned. The actual number of records returned might be lower than the value you specify. For example: . next string Specifies the cursor value to retrieve the next page of results. You can find the value to specify in the property returned by the previous page in a successful response. For example: . minheight integer >= 0 Specifies the minimum block height for the blocks to return. For example: . maxheight integer >= 0 Specifies the maximum block height for the blocks to return. For example: . Request body schema Use the following parameters to specify the upper and lower bounds for the queried branches. Parameter Type Description lower Array of strings Specifies the lower bound for the query. No block hashes are returned that are predecessors of any block with a hash from this array. Each block hash consists of 43 characters from the character set. upper Array of strings Specifies the upper bound for the query. All returned block hashes are predecessors of a block with an hash from this array. Each block hash consists of 43 characters from the character set. Responses Requests to can return the following response codes: 200 OK indicates that the request succeeded. The response body includes all of the blocks matching the criteria specified. 400 Bad Request indicates that the branch bounds were exceeded. 404 Not Found indicates that no blocks matching the request criteria were found or that the or parameter wasn't valid. 406 Not Acceptable indicates that the endpoint can't generate content in the format specified by the Accept header. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. Parameter Type Description x-peer-addr string Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: . x-server‑timestamp integer >= 0 Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: . x‑chainweb‑node‑version string Specifies the version of the remote Chainweb node. For example: . Successful response schema If the request is successful, the response returns content with the following: Parameter Type Description items (required) Array of objects Returns an array of JSON-encoded objects representing full blocks. limit (required) integer >= 0 Specifies the maximum number of items in the page. This number can be smaller but never larger than the number of requested items. next (required) string or null Returns a value that can be used to query the next page. You can use this value for the parameter in a follow-up request. The format for this parameter consists of two parts. The first part of the string can be , or null. The second part is the value that calls the next page of results or null if there are no more results to query. Examples You can send a request to the Kadena main network—mainnet01—and chain 19 by calling the main network service endpoint like this: In this example, the request returns the ancestors for a specific upper bound: This request returns a whole block similar to the following excerpt:",
    "source": "api/service-api/get-block.md",
    "title": "get-block"
  },
  {
    "content": "title: Stream block header events description: Send API requests to this endpoint to monitor a node for new blocks. id: api-update-event-stream sidebar_position: 11 tags: ['chainweb', 'node api', 'chainweb api', 'api reference'] Stream block header events The block updates endpoint enables you to connect to a server-side event stream to be notified when new blocks are added to the blockchain. The stream can contain blocks that might later become orphaned. To address this potential issue, you should buffer events on the client side for the most recent block heights to allow for a desired confirmation depth to be reached. You should note that the server might terminate this event stream from time to time. It is up to the client to restart event streaming with a new request. Request format Use to connect to a source of server events that emits a BlockHeader event for each new block header that is added to the chain database of the remote node. Responses 200 OK indicates a successful requests and results in a stream of BlockHeader events. Each event consists of an event property and a data property and are separated by empty lines. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. Parameter Type Description x-peer-addr string Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: . x-server‑timestamp integer >= 0 Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: . x‑chainweb‑node‑version string Specifies the version of the remote Chainweb node. For example: . Response schema If the request is successful, the response returns content with the following: Parameter Type Description event string Specifies the type of event with the event property value of \"BlockHeader\". data object Specifies the data properties for the event. Examples You can send a request for block header updates from the Kadena main network like this: This request returns a stream of events with the BlockHeader event property and a data property: <!-- --> If you expand the data property for an event, the event includes details similar to the folloiwng:",
    "source": "api/service-api/get-block-updates.md",
    "title": "get-block-updates"
  },
  {
    "content": "title: Get block headers description: Provides reference information for the chainweb-node block header endpoints. id: get-block-header sidebar_position: 3 tags: ['chainweb', 'node api', 'chainweb api', 'api reference', 'block header'] Get block headers Block header endpoints return block headers from the specified chain database. Similar to the block service and block hash endpoints, block headers are generally returned in ascending order and include headers of orphaned blocks. If you only want to query for blocks that are included in the canonical branch of the chain, you can use the endpoint. The endpoint returns blocks in descending order starting from the leafs of branches of the block chain. Block headers are returned in three different formats depending on the content type specified in the Accept header of the request: returns block headers in as a base64Url-encoded strings without padding. returns block headers as JSON-encoded objects. returns block headers as binary data if supported by the endpoint. Request format Use to get block headers for the specified chain. This call returns a collection of block headers in ascending order that satisfies the query parameters. All block headers that match the query criteria are returned from the chain database, including headers for orphaned blocks. Path parameters Parameter Type Description chain (required) integer >= 0 Specifies the chain identifier of the chain you want to send the request to. Valid values are 0 to 19. For example, to get block headers for the first chain (0), the request is . Query parameters Parameter Type Description limit integer >= 0 Specifies the maximum number of records that should be returned. The actual number of records returned might be lower than the limit you set. For example: . next string Specifies the cursor to retrieve the next page of results. This value can be found as the value of the next property of the previous page. For example: . minheight integer >= 0 Specifies the minimum block height for the returned headers. For example: . maxheight integer >= 0 Specifies the maximum block height for the returned headers. For example: . Responses Requests to return the following response codes: 200 OK indicates that the request succeeded and returns a collection of block headers in ascending order. All block headers that match the specified criteria are returned from the chain database, including headers for orphaned blocks. 404 Not Found indicates that the or parameter specifies a nonexistent block height. 406 Not Acceptable indicates that the endpoint can't generate content in the format specified by the Accept header. Response headers The response header parameters are the same for all successful and unsuccessful Chainweb node requests. Parameter Type Description x-peer-addr string Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: . x-server‑timestamp integer >= 0 Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: . x‑chainweb‑node‑version string Specifies the version of the remote Chainweb node. For example: . Successful response schemas The format of the information returned in the response depends on the content type specified in the Accept header of the request. Parameter Type Description items (required) Array of block headers Returns an array of block headers as base64Url-encoded strings (), JSON-encoded objects (), or a binary data stream (, if supported). limit (required) integer >= 0 Specifies the number of items in the page. This number can be smaller but never be larger than the number of requested items. next (required) string or null Returns a cursor that can be used in a follow up request to query the next page. It should be used literally as the value for the parameter in the follow-up request. It can be specified as inclusive or exclusive. Not found response schema If you specified in the Accept header of the request and there are no results matching the request criteria, the response returns the following: Parameter Type Description key string Specifies the base64Url-encoded block hash (without padding). The block hash consists of 43 characters from the a-zA-Z0-9_- character set. reason string Provides a placeholder for specifying the reason that no block headers were found. Examples You can send a request to the Kadena test network—testnet04—and chain 18 by calling the testnet service endpoint like this: With the Accept header set to , this request returns five items in the response body and each item is a base64Url-encoded string like this: With the Accept header set to , each item in the response body is a JSON-encoded object like this: If there are no results matching the request criteria, the response body indicates the reason no results matching the request criteria were found. For example: Get block header by hash Use to get a block header by using its hash. Path parameters Parameter Type Description chain (required) integer >= 0 Specifies the chain identifier of the chain you want to send the request to. Valid values are 0 to 19. For example, to get block headers for the first chain (0), the request is . blockHash (required) string Specifies the block hash of a block. The block hash consists of 43 characters from the character set. For example: . Responses Requests to return the following response codes: 200 OK indicates that the request succeeded and returns the block header matching the specified hash. 404 Not Found indicates that no block header with the specified block hash was found. 406 Not Acceptable indicates the endpoint can't generate content in the format specified by the Accept header. Response headers The response header parameters are the same for all successful and unsuccessful Chainweb node requests. Parameter Type Description x-peer-addr string Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: . x-server‑timestamp integer >= 0 Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: . x‑chainweb‑node‑version string Specifies the version of the remote Chainweb node. For example: . Successful response schemas The format of the information returned in the response depends on the content type specified in the Accept header of the request. Not found response schema If you specified in the Accept header of the request and there are no results matching the request criteria, the response returns the following: Parameter Type Description key string Specifies the base64Url-encoded block hash (without padding). The block hash consists of 43 characters from the character set. reason string Provides a placeholder for specifying the reason that no block headers were found. Examples You can send a request to the Kadena main network—mainnet01—and chain 4 by calling the service endpoint like this: With the Accept header set to , this request returns the block header as a base64Url-encoded string without padding: With the Accept header set to , the request returns the block header as a JSON-encoded object like this: If you set the Accept header to and the content type is supported, the request returns a binary representation of the block header. If the content type isn't support, the reguest fails with a 406 Not Acceptable response code. If there are no results matching the request criter, the response body indicates the reason no results matching the request criteria were found. For example: Get block header branches Use to return a page of block headers from branches of the block chain in descending order. Only blocks that are ancestors of the same block in the set of upper bounds and are not ancestors of any block in the set of lower bounds are returned. Path parameters Parameter Type Description chain (required) integer >= 0 Specifies the chain identifier of the chain you want to send the request to. Valid values are 0 to 19. For example, to get block headers for the first chain (0), the request is . Query parameters Parameter Type Description limit integer >= 0 Specifies the maximum number of records that should be returned. The actual number of records might be lower. For example: . next string Specifies the cursor to retrieve the next page of results. This value can be found as the value of the next property of the previous page. For example: . minheight integer >= 0 Specifies the minimum block height for the returned headers. For example: . maxheight integer >= 0 Specifies the maximum block height for the returned headers. For example: . Request schema These parameters specify the upper and lower bounds for the queried branches. Parameter Type Description lower Array of strings Specifies the lower bound block header hash for the query. No block headers are returned that are predecessors of any block with a hash from this array. The block hash consists of 43 characters from the character set. upper Array of strings Specifies the upper bound block header for the query. All block hashes returned are predecessors of a block with a hash from this array. The block hash consists of 43 characters from the character set. The following examples illustrate the results to expect based on setting the lower and upper bound parameters. To return all ancestors of one block: For example, to return all of the ancestors of a block that are not ancestors of another block, you might specify bounds similar to the following: Responses Requests to return the following response codes: 200 OK indicates that the request succeeded and returns the block headers matching the specified criteria as base64Url-encoded or JSON-encoded. 400 Bad Request indicates that the branch bounds were exceeded. 404 Not Found indicates that the block header indicated by a required parameter was not found. 406 Not Acceptable indicates that the value of the Accept header is not supported. Response headers The response header parameters are the same for all successful and unsuccessful Chainweb node requests. Parameter Type Description x-peer-addr string Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: . x-server‑timestamp integer >= 0 Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: . x‑chainweb‑node‑version string Specifies the version of the remote Chainweb node. For example: . Successful response schemas The format of the information returned in the response depends on the content type specified in the Accept header of the request. Parameter Type Description items (required) Array of block headers Returns an array of block headers as base64Url-encoded strings (), JSON-encoded objects (), or a binary data stream (, if supported) limit (required) integer >= 0 Specifies the number of items in the page. This number can be smaller but never be larger than the number of requested items. next (required) string or null Returns a cursor that can be used in a follow up request to query the next page. It should be used literally as the value for the parameter in the follow-up request. It can be specified as inclusive or exclusive. Examples You can send a request to the Kadena main network—mainnet01—and chain 4 with a limit of three items per request and a minimum block height of 4953300 by calling the service endpoint like this: With the Accept header set to , this request returns the block headers as a base64Url-encoded strings without padding: With the Accept header set to , the request returns the block headers as JSON-encoded objects like this: If you set the Accept header to and the content type is supported, the request returns a binary representation of the block header. If the content type isn't support, the reguest fails with a 406 Not Acceptable response code.",
    "source": "api/service-api/get-block-header.md",
    "title": "get-block-header"
  },
  {
    "content": "title: Get a block header by hash description: Provides reference information for the chainweb-node block header endpoints. id: get-block-header-by-hash sidebar_position: 3 tags: ['chainweb', 'node api', 'chainweb api', 'api reference', 'block header'] Get a block header by hash You can request a specific block header by using the block header hash. Request format Use to get a block header by using its hash. Path parameters Parameter Type Description chain (required) integer >= 0 Specifies the chain identifier of the chain you want to send the request to. Valid values are 0 to 19. For example, to get block headers for the first chain (0), the request is . blockHash (required) string Specifies the block hash of a block. The block hash consists of 43 characters from the character set. For example: . Responses Requests to return the following response codes: 200 OK indicates that the request succeeded and returns the block header matching the specified hash. 404 Not Found indicates that no block header with the specified block hash was found. 406 Not Acceptable indicates the endpoint can't generate content in the format specified by the Accept header. Response headers The response header parameters are the same for all successful and unsuccessful Chainweb node requests. Parameter Type Description x-peer-addr string Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: . x-server‑timestamp integer >= 0 Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: . x‑chainweb‑node‑version string Specifies the version of the remote Chainweb node. For example: . Successful response schemas The format of the information returned in the response depends on the content type specified in the Accept header of the request. Not found response schema If you specified in the Accept header of the request and there are no results matching the request criteria, the response returns the following: Parameter Type Description key string Specifies the base64Url-encoded block hash (without padding). The block hash consists of 43 characters from the character set. reason string Provides a placeholder for specifying the reason that no block headers were found. Examples You can send a request to the Kadena main network—mainnet01—and chain 4 by calling the service endpoint like this: With the Accept header set to , this request returns the block header as a base64Url-encoded string without padding: With the Accept header set to , the request returns the block header as a JSON-encoded object like this: If you set the Accept header to and the content type is supported, the request returns a binary representation of the block header. If the content type isn't support, the reguest fails with a 406 Not Acceptable response code. If there are no results matching the request criter, the response body indicates the reason no results matching the request criteria were found. For example: Get block header branches Use to return a page of block headers from branches of the block chain in descending order. Only blocks that are ancestors of the same block in the set of upper bounds and are not ancestors of any block in the set of lower bounds are returned. Path parameters Parameter Type Description chain (required) integer >= 0 Specifies the chain identifier of the chain you want to send the request to. Valid values are 0 to 19. For example, to get block headers for the first chain (0), the request is . Query parameters Parameter Type Description limit integer >= 0 Specifies the maximum number of records that should be returned. The actual number of records might be lower. For example: . next string Specifies the cursor to retrieve the next page of results. This value can be found as the value of the next property of the previous page. For example: . minheight integer >= 0 Specifies the minimum block height for the returned headers. For example: . maxheight integer >= 0 Specifies the maximum block height for the returned headers. For example: . Request schema These parameters specify the upper and lower bounds for the queried branches. Parameter Type Description lower Array of strings Specifies the lower bound block header hash for the query. No block headers are returned that are predecessors of any block with a hash from this array. The block hash consists of 43 characters from the character set. upper Array of strings Specifies the upper bound block header for the query. All block hashes returned are predecessors of a block with a hash from this array. The block hash consists of 43 characters from the character set. The following examples illustrate the results to expect based on setting the lower and upper bound parameters. To return all ancestors of one block: For example, to return all of the ancestors of a block that are not ancestors of another block, you might specify bounds similar to the following: Responses Requests to return the following response codes: 200 OK indicates that the request succeeded and returns the block headers matching the specified criteria as base64Url-encoded or JSON-encoded. 400 Bad Request indicates that the branch bounds were exceeded. 404 Not Found indicates that the block header indicated by a required parameter was not found. 406 Not Acceptable indicates that the value of the Accept header is not supported. Response headers The response header parameters are the same for all successful and unsuccessful Chainweb node requests. Parameter Type Description x-peer-addr string Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: . x-server‑timestamp integer >= 0 Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: . x‑chainweb‑node‑version string Specifies the version of the remote Chainweb node. For example: . Successful response schemas The format of the information returned in the response depends on the content type specified in the Accept header of the request. Parameter Type Description items (required) Array of block headers Returns an array of block headers as base64Url-encoded strings (), JSON-encoded objects (), or a binary data stream (, if supported) limit (required) integer >= 0 Specifies the number of items in the page. This number can be smaller but never be larger than the number of requested items. next (required) string or null Returns a cursor that can be used in a follow up request to query the next page. It should be used literally as the value for the parameter in the follow-up request. It can be specified as inclusive or exclusive. Examples You can send a request to the Kadena main network—mainnet01—and chain 4 with a limit of three items per request and a minimum block height of 4953300 by calling the service endpoint like this: With the Accept header set to , this request returns the block headers as a base64Url-encoded strings without padding: With the Accept header set to , the request returns the block headers as JSON-encoded objects like this: If you set the Accept header to and the content type is supported, the request returns a binary representation of the block header. If the content type isn't support, the reguest fails with a 406 Not Acceptable response code.",
    "source": "api/service-api/get-block-header-by-hash.md",
    "title": "get-block-header-by-hash"
  },
  {
    "content": "title: Get branch block headers description: Provides reference information for the chainweb-node block header endpoints. id: get-block-header-branch sidebar_position: 3 tags: ['chainweb', 'node api', 'chainweb api', 'api reference', 'block header'] Get branch block headers You can request only blocks that are included in the canonical branch of the chain by using the endpoint. The endpoint returns blocks in descending order starting from the leafs of branches of the blockchain. Block headers are returned in three different formats depending on the content type specified in the Accept header of the request: returns block headers in as a base64Url-encoded strings without padding. returns block headers as JSON-encoded objects. returns block headers as binary data if supported by the endpoint. Note that this endpoint uses the method so you can specify lower and upper bounds for retrieving blocks in the request body. Request format Use to return a page of block headers from branches of the block chain in descending order. Only blocks that are ancestors of the same block in the set of upper bounds and are not ancestors of any block in the set of lower bounds are returned. Path parameters Parameter Type Description chain (required) integer >= 0 Specifies the chain identifier of the chain you want to send the request to. Valid values are 0 to 19. For example, to get block headers for the first chain (0), the request is . Query parameters Parameter Type Description limit integer >= 0 Specifies the maximum number of records that should be returned. The actual number of records might be lower. For example: . next string Specifies the cursor to retrieve the next page of results. This value can be found as the value of the next property of the previous page. For example: . minheight integer >= 0 Specifies the minimum block height for the returned headers. For example: . maxheight integer >= 0 Specifies the maximum block height for the returned headers. For example: . Request schema These parameters specify the upper and lower bounds for the queried branches. Parameter Type Description lower Array of strings Specifies the lower bound block header hash for the query. No block headers are returned that are predecessors of any block with a hash from this array. The block hash consists of 43 characters from the character set. upper Array of strings Specifies the upper bound block header for the query. All block hashes returned are predecessors of a block with a hash from this array. The block hash consists of 43 characters from the character set. The following examples illustrate the results to expect based on setting the lower and upper bound parameters. To return all ancestors of one block: For example, to return all of the ancestors of a block that are not ancestors of another block, you might specify bounds similar to the following: Responses Requests to return the following response codes: 200 OK indicates that the request succeeded and returns the block headers matching the specified criteria as base64Url-encoded or JSON-encoded. 400 Bad Request indicates that the branch bounds were exceeded. 404 Not Found indicates that the block header indicated by a required parameter was not found. 406 Not Acceptable indicates that the value of the Accept header is not supported. Response headers The response header parameters are the same for all successful and unsuccessful Chainweb node requests. Parameter Type Description x-peer-addr string Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: . x-server‑timestamp integer >= 0 Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: . x‑chainweb‑node‑version string Specifies the version of the remote Chainweb node. For example: . Successful response schemas The format of the information returned in the response depends on the content type specified in the Accept header of the request. Parameter Type Description items (required) Array of block headers Returns an array of block headers as base64Url-encoded strings (), JSON-encoded objects (), or a binary data stream (, if supported) limit (required) integer >= 0 Specifies the number of items in the page. This number can be smaller but never be larger than the number of requested items. next (required) string or null Returns a cursor that can be used in a follow up request to query the next page. It should be used literally as the value for the parameter in the follow-up request. It can be specified as inclusive or exclusive. Examples You can send a request to the Kadena main network—mainnet01—and chain 4 with a limit of three items per request and a minimum block height of 4953300 by calling the service endpoint like this: With the Accept header set to , this request returns the block headers as a base64Url-encoded strings without padding: With the Accept header set to , the request returns the block headers as JSON-encoded objects like this: If you set the Accept header to and the content type is supported, the request returns a binary representation of the block header. If the content type isn't support, the reguest fails with a 406 Not Acceptable response code.",
    "source": "api/service-api/get-block-header-branch.md",
    "title": "get-block-header-branch"
  },
  {
    "content": "title: Get block hashes description: Provides reference information for the chainweb-node block hash endpoints. id: get-block-hash sidebar_position: 2 tags: ['chainweb', 'node api', 'chainweb api', 'api reference', 'block hash'] Get block hashes Block hash endpoints return block hashes from the specified chain database. Generally, block hashes are returned in ascending order and include hashes from orphaned blocks. If you only want to query for blocks that are included in the canonical version of the chain, you can use the endpoint. The endpoint returns blocks in descending order starting from the leafs of branches of the block chain. Request format Use to get block hashes for the specified chain. Path parameters Parameter Type Description chain (required) integer >= 0 Specifies the chain identifier of the chain you want to send the request to. Valid values are 0 to 19. For example, to get block hashes for the first chain (0), the request is . Query parameters Parameter Type Description limit integer >= 0 Specifies the maximum number of records that should be returned. The actual number of records returned might be lower than the value you specify. For example: . next string Specifies the cursor value to retrieve the next page of results. You can find the value to specify in the property returned by the previous page in a successful response. For example: . minheight integer >= 0 Specifies the minimum block height for the returned hashes. For example: . maxheight integer >= 0 Specifies the maximum block height for the returned hashes. For example: . Responses Requests to return the following response codes: 200 OK indicates that the request succeeded and the response body includes the collection of block hashes matching the request criteria in ascending order. All block hashes that match the specified criteria are returned from the chain database, including hashes for orphaned blocks. 404 Not Found indicates that the request failed to find any block hashes matching the request criteria. For example, if you specify a Chainweb node version or chain identifier that doesn't exist, you'll see this response code. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. Parameter Type Description x-peer-addr string Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: . x-server‑timestamp integer >= 0 Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: . x‑chainweb‑node‑version string Specifies the version of the remote Chainweb node. For example: . Successful response schema If the request is successful, the response returns content with the following information: Parameter Type Description items (required) Array of strings Lists the block hashes matching the request criteria. Each block hash string consists of 43 characters from the [] character set. limit (required) integer >= 0 Specifies the maximum number of items to include in the page of results. This number can be smaller but never larger than the number of requested items. next (required) string or null Returns a value that can be used to query the next page. You can use this value for the parameter in a follow-up request. The format for this parameter consists of two parts. The first part of the string can be , or . The second part is the value that calls the next page of results or if there are no more results to query. Examples You can send a request to the Kadena main network and chain 19 by calling the service endpoint like this: This request returns a maximum of three items in the response body like this: To send a follow-up request to get block hashes for the next three blocks, you can add the parameter to the request. In this example, the follow-up request looks like this: The follow-up request returns three more hashes and a new value:",
    "source": "api/service-api/get-block-hash.md",
    "title": "get-block-hash"
  },
  {
    "content": "title: Get branch block hashes description: Provides reference information for the chainweb-node block hash endpoints. id: get-block-hash-branch sidebar_position: 2 tags: ['chainweb', 'node api', 'chainweb api', 'api reference', 'block hash'] Get branch block hashes Block hash endpoints return block hashes from the specified chain database. Generally, block hashes are returned in ascending order and include hashes from orphaned blocks. If you only want to query for blocks that are included in the canonical version of the chain, you can use this endpoint. The endpoint returns blocks in descending order starting from the leafs of branches of the block chain. Note that this endpoint uses the method so you can specify lower and upper bounds for retrieving blocks in the request body. Request format Use to get block hashes from the branches of the block chain in descending order. This call only returns blocks that are ancestors of the same block in the set of upper bounds and that are not ancestors of any block in the set of lower bounds. Path parameters Parameter Type Description chain (required) integer >= 0 Specifies the chain identifier of the chain you want to send the request to. Valid values are 0 to 19. For example, to get block hashes for the first chain (0), the request is . Query parameters Parameter Type Description limit integer >= 0 Specifies the maximum number of records that should be returned. The actual number of records returned might be lower than the limit you set. For example: . next string Specifies the cursor value to retrieve the next page of results. You can find the value to specify in the property returned by the previous page in a successful response. For example: . minheight integer >= 0 Specifies the minimum block height for the returned hashes. For example: . maxheight integer >= 0 Specifies the maximum block height for the returned hashes. For example: . Request body schema Use the following parameters to specify the upper and lower bounds for the queried branches. Parameter Type Description lower Array of strings Specifies the lower bound for the query. No block hashes are returned that are predecessors of any block with a hash from this array. Each block hash consists of 43 characters from the character set. upper Array of strings Specifies the upper bound for the query. All returned block hashes are predecessors of a block with an hash from this array. Each block hash consists of 43 characters from the character set. The following examples illustrate setting lower and upper bounds for the query parameters. To return all of the ancestors of the block: To return all of the ancestors of the block that are not ancestors of the block, you might specify bounds similar to the following: Responses Requests to return the following response codes: 200 OK indicates that the request succeeded and returns the requested block hashes. All block hashes that match the specified criteria are returned from the chain database, including hashes for orphaned blocks. 404 Not Found indicates that the requested block hashes could not be found. Response headers The response header parameters are the same for all successful and unsuccessful Chainweb node requests. Parameter Type Description x-peer-addr string Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: . x-server‑timestamp integer >= 0 Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: . x‑chainweb‑node‑version string Specifies the version of the remote Chainweb node. For example: . Successful response schema If the request is successful, the response returns content with the following: Parameter Type Description items (required) Array of strings Returns an array of block hashes. Each block hash consists of 43 characters from the [] character set. limit (required) integer >= 0 Specifies the maximum number of items in the page. This number can be smaller but never larger than the number of requested items. next (required) string or null Returns a value that can be used to query the next page. You can use this values for the parameter in a follow-up request. The format for this parameter consists of two parts. The first part of the string can be , or null. The second part is the value that calls the next page of results or null if there are no more results to query. Not found response schema If there are no results matching the request criteria, the response returns the following: Parameter Type Description key string Specifies the base64Url-encoded block hash without padding. The block hash consists of 43 characters from the [] character set. reason string Provides a placeholder for specifying the reason that no block hashes were found. Examples You can send a request to the Kadena main network—mainnet01—and chain 0 by calling the main network service endpoint: The request body for this query is: This request returns one item in the response body: You can send a request to the Kadena test network—testnet04—and chain 18 by calling the testnet service endpoint like this: The request body for this query is: This request returns four items in the response body: If you specify an upper or lower bound doesn't exist on the chain where you're sending the request, the response body indicates the reason no results matching the request criteria were found. For example:",
    "source": "api/service-api/get-block-hash-branch.md",
    "title": "get-block-hash-branch"
  },
  {
    "content": "title: Retrieve full branch blocks description: Provides reference information for the chainweb-node service API block endpoints. id: get-block-branch sidebar_position: 9 tags: ['chainweb', 'node api', 'chainweb api', 'api reference'] Retrieve full branch blocks You can use the API endpoint to return full blocks—that is, headers and payloads—from the specified chain database in descending order starting from the leafs of branches of the blockchain. Blocks are returned in only one format, with block headers and payloads in JSON encoding. Note that this endpoint uses the method so you can specify lower and upper bounds for retrieving blocks in the request body. Request format Use to return blocks from branches of the block chain in descending order. A request sent to this endpoint returns blocks that are ancestors of any block specified for the upper bounds and that are not ancestors of any block specified for the lower bounds. Path parameters Parameter Type Description chain (required) integer >= 0 Specifies the chain identifier of the chain you want to send the request to. Valid values are 0 to 19. For example, to get block hashes for the first chain (0), the request is . Query parameters Parameter Type Description limit integer >= 0 Specifies the maximum number of records that should be returned. The actual number of records returned might be lower than the value you specify. For example: . next string Specifies the cursor value to retrieve the next page of results. You can find the value to specify in the property returned by the previous page in a successful response. For example: . minheight integer >= 0 Specifies the minimum block height for the blocks to return. For example: . maxheight integer >= 0 Specifies the maximum block height for the blocks to return. For example: . Request body schema Use the following parameters to specify the upper and lower bounds for the queried branches. Parameter Type Description lower Array of strings Specifies the lower bound for the query. No block hashes are returned that are predecessors of any block with a hash from this array. Each block hash consists of 43 characters from the character set. upper Array of strings Specifies the upper bound for the query. All returned block hashes are predecessors of a block with an hash from this array. Each block hash consists of 43 characters from the character set. Responses Requests to can return the following response codes: 200 OK indicates that the request succeeded. The response body includes all of the blocks matching the criteria specified. 400 Bad Request indicates that the branch bounds were exceeded. 404 Not Found indicates that no blocks matching the request criteria were found or that the or parameter wasn't valid. 406 Not Acceptable indicates that the endpoint can't generate content in the format specified by the Accept header. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. Parameter Type Description x-peer-addr string Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: . x-server‑timestamp integer >= 0 Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: . x‑chainweb‑node‑version string Specifies the version of the remote Chainweb node. For example: . Successful response schema If the request is successful, the response returns content with the following: Parameter Type Description items (required) Array of objects Returns an array of JSON-encoded objects representing full blocks. limit (required) integer >= 0 Specifies the maximum number of items in the page. This number can be smaller but never larger than the number of requested items. next (required) string or null Returns a value that can be used to query the next page. You can use this value for the parameter in a follow-up request. The format for this parameter consists of two parts. The first part of the string can be , or null. The second part is the value that calls the next page of results or null if there are no more results to query. Examples You can send a request to the Kadena main network—mainnet01—and chain 19 by calling the main network service endpoint like this: In this example, the request returns the ancestors for a specific upper bound: This request returns a whole block similar to the following excerpt:",
    "source": "api/service-api/get-block-branch.md",
    "title": "get-block-branch"
  },
  {
    "content": "title: Check a database backup description: Send an API request to check the status of a database backup job. id: check-db-backup sidebar_position: 11 tags: ['chainweb', 'node api', 'chainweb api', 'api reference'] Check the status of a database backup Use to check the status of a backup job. Path parameters Parameter Type Description backupId (required) string Specifies the backup job identifier with a UNIX timestamp from the character set. For example: 1648665437000 Responses Requests to the endpoint can return the following response codes: 200 OK indicates that a backup job with the specified identifier exists and returns its current status. 404 Not Found indicates that there were no backup jobs matching the specified identifier. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. Parameter Type Description x-peer-addr string Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: . x-server‑timestamp integer >= 0 Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: . x‑chainweb‑node‑version string Specifies the version of the remote Chainweb node. For example: . Response schema The response returns content with the following information: Parameter Type Description status string Specifies the status of the backup job with the specified identifier. There are three possible status messages: , , and .",
    "source": "api/service-api/check-status-backup-job.md",
    "title": "check-status-backup-job"
  },
  {
    "content": "title: Check node health description: Send a health check API request to check the availability of a node. id: check-node-health sidebar_position: 11 tags: ['chainweb', 'node api', 'chainweb api', 'api reference'] Check node health The endpoint checks whether is running and responding to service API requests. To check the state of consensus, you should use the endpoint instead of this endpoint. Request format Use to check whether is running and responding to API requests. Responses Requests to the endpoint return the following response code: 200 OK indicates that the node is running and responding to API requests. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. Parameter Type Description x-peer-addr string Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: . x-server‑timestamp integer >= 0 Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: . x‑chainweb‑node‑version string Specifies the version of the remote Chainweb node. For example: . Response schema The response returns content with the following information: Parameter Type Description check string Health check OK. Examples You can send a health check request to a node like this: This request returns a plain text message like this: Get general node information Use to return general information about the node and the Chainweb version. Responses Requests to the endpoint return the following response code: 200 OK indicates that the request succeeded and the response body returns general information about the node and the chains in the network. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. Parameter Type Description x-peer-addr string Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: . x-server‑timestamp integer >= 0 Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: . x‑chainweb‑node‑version string Specifies the version of the remote Chainweb node. For example: . Response schema If the request is successful, the response returns content with the following: Parameter Type Description nodeApiVersion (required) string Specifies the Chainweb API version information for the node. nodeBlockDelay (required) integer >= 0 Specifies the number of seconds to delay between blocks. nodeChains (required) Array of strings Specifies the chain identifiers for the chains in the network the node is part of. nodeGenesisHeights (required) Array of integers Specifies the block height for the first block of each chain in the network. nodeGraphHistory (required) Array of integers Specifies the block height and adjacent chains for all chain graphs indexed by the height of the first block with the respective graph. Graphs are encoded as adjacency lists. nodeHistoricalChains (required) Array of integers Specifies the block height and adjacent chains for all chain graphs indexed by the height of the first block for the graph. Graphs are encoded as adjacency lists. nodeLatestBehaviorHeight (required) integer Specifies the latest block height for the node. nodeNumberOfChains (required) integer >= 10 Specifies the number of chains in the network the node is part of. nodePackageVersion (required) string Specifies the release package version for the software package running on the node. nodeServiceDate (required) string Specifies the next service date for updating the software package running on the node. nodeVersion (required) string Specifies the network identifier for the network the node is part of. The valid values are \"test-singleton\", \"development\", \"mainnet01\", and \"testnet04\". Examples You can send a request for general information to a node like this: This request returns information similar to the following truncated excerpt: Blocks event stream Use to connect to a source of server events that emits a BlockHeader event for each new block header that is added to the chain database of the remote node. The stream can contain blocks that might later become orphaned. To address this potential issue, you should buffer events on the client side for the most recent block heights to allow for a desired confirmation depth to be reached. You should note that the server might terminate this event stream from time to time. It is up to the client to restart event streaming with a new request. Responses 200 OK indicates a successful requests and results in a stream of BlockHeader events. Each event consists of an event property and a data property and are separated by empty lines. Response header The response header parameters are the same for all successful and unsuccessful Chainweb node requests. Parameter Type Description x-peer-addr string Specifies the host address and port number of the client as observed by the remote Chainweb node. The host address can be a domain name or an IP address in IPv4 or IPv6 format. For example: . x-server‑timestamp integer >= 0 Specifies the clock time of the remote Chainweb node using the UNIX epoch timestamp. For example: . x‑chainweb‑node‑version string Specifies the version of the remote Chainweb node. For example: . Response schema If the request is successful, the response returns content with the following: Parameter Type Description event string Specifies the type of event with the event property value of \"BlockHeader\". data object Specifies the data properties for the event. Examples You can send a request for block header updates from the Kadena main network like this: This request returns a stream of events with the BlockHeader event property and a data property: <!-- --> If you expand the data property for an event, the event includes details similar to the folloiwng:",
    "source": "api/service-api/check-node-health.md",
    "title": "check-node-health"
  },
  {
    "content": "title: What is Marmalade? description: \"Use the Kadena Marmalade token standard and policy contracts to build non-fungible or poly-fungible token marketplaces.\" id: marmalade sidebar_position: 1 What is Marmalade? Marmalade is the name of the Kadena token standard. This token standard defines the interfaces for minting digital items with Kadena smart contracts and protecting those digital items with Kadena token policies. Digital items that are unique, one-of-a-kind assets are most commonly referred to as non-fungible tokens (NFTs). However, the Kadena token standard is implemented as a multi-token or poly-fungible standard that enables you to define, mint, and secure tokens that are fully fungible as interchangeable coins, partially fungible as a limited edition with a fixed supply, or completely non-fungible as unique items. Tokens can also be restricted to a single owner with rules for transferring ownership or support shared ownership with multiple potential stakeholders. As a creator, you have complete control over your token properties and the rules for minting, owning, and transferring tokens. Traditional marketplaces for non-fungible tokens Non-fungible tokens defined using other token standards have two main drawbacks: Most token standards assume that a change of ownership is always a transfer operation. However, a transfer-based model doesn't take into account the non-transferable nature of a unique asset. Marmalade supports both transfers and sales, with the additional flexibility to use token policies for either operation. Most token standards don't provide any guarantees that creators will be paid royalties for their work or what they'll be paid from the exchanges that host their work. With Marmalade, Kadena eliminates these issues by making sales contracts and token policies core components of the token standard. Sales contracts In the simplest sense, a sale is typically a three-step process: A seller lists an item for sale with a price. A buyer agrees to pay the seller for the item at a mutually agreed-upon price. The seller receives payment and transfers the item to the buyer. On the Kadena network, Pact smart contracts use functions to define multi-step operations like cross-chain transfers and automatic gas payments. The Marmalade token standard also uses functions to handle the multi-step nature of a sale. By using functions, contracts can define explicit steps that must be executed in a fixed order. The definition forms an enforceable sequence of actions that are executed on-chain. The sequence can't be altered and no steps can be skipped. For a transaction to be successful, all parties must complete the actions they are responsible for. All of the sequencing and cryptography required to enforce a sales contract is handled automatically by the Pact language itself. To complete a sale, the function defines the following steps: Offer: A seller who wants to list a digital asset for sale creates an offer. This operation puts the asset into a trustless escrow account that can only be released by later steps in the definition. Buy: A buyer initiates a buy operation with a promised payment and the escrowed asset waits for the step to be completed successfully by the buyer. Withdraw: If the buyer doesn't complete the transaction within a certain period of time, the function can roll back the first step of the transaction and the seller can withdraw the sale. If the seller withdraws, the transfers the asset back to the seller's account from the escrow account. Token policies The Marmalade token standard enables creators to specify token policies to control how their assets can be minted, sold, and transferred and how royalties are paid. For example, a token policy might specify that an asset can't be transferred directly to a buyer until a purchase is complete and the royalty distributed to the creator. Token policies are implemented as smart contracts based on the interfaces defined in the standard. There are several built-in policies—called concrete policies—that are configured to handle the most common marketplace use cases. For example, if you apply the to a token, the token is automatically configured to be minted only once. You can apply built-in policies to any token or write custom policies based on the standard. You can also create collections of tokens using the to establish marketplace communities that share a common approach to token ownership or token sales. After you create the group of tokens that make up the collection, the entire collection can be discovered from Chainweb events. For example, you can use token policies to define the following types of rules: You can create tokens with a royalty policy to specify a royalty rate and the account that should receive royalties. You can use policies to control mint operations such as whether a token is unique, part of a limited series, or a fully fungible coin. You can use policies to prevent certain tokens from being burned or to be burned only when specific conditions are met. You can use policies to restrict how tokens are owned and transferred. Preparing to mint a token Before you can mint a token on the blockchain, you must create the digital item and upload it to at least one accessible location such as InterPlanetary File System (IPFS), Arweave, or another content delivery or hosting service. After you have a uniform resource identifier (URI) for locating the digital item, you must also create a metadata file using the JSON schema to record the name, location, and other properties about the item to be minted. You can then create and mint the token for the digital item, generating an on-chain token identifier with a prefix. The token identifier includes the hash for the metadata that describes the token to ensure that a digital item can be cryptographically verified to be the original NFT. However, if you update the properties used to create a token—for example, to change a token that represents a character in a game each time the character completes a quest—the hash for the metadata will be different from the original hash and you are, in essence, creating a new token. Optionally, you can use a policy to prevent a token from being updated. Depending on how you apply or configure token policies, you might be the sole owner of the token you mint or share ownership with others. If you're the owner of a token, you have the option to offer the token for sale or transfer the token to another owner. Token sales and trustless escrow If you're the owner of a token, you can start the sales process to find a buyer by selecting and configuring a smart contract. You've already seen that a sale is essentially a with two steps: the offer step and the buy step. Smart contracts with the pact also use a special feature of pacts—pact guards—to govern the trustless escrow account for the token sale. After you offer an asset for sale, the asset is transferred to an account governed by a pact guard. From that point, only that pact guard—identified by its pact ID—can manage the asset in subsequent steps. Let's take a closer look at how a sale takes place, starting with an offer. Offer A seller creates an offer for the asset to be sold. For this example, the offer is a simple sale with a quoted asking price. There are other ways you can sell assets—including conventional auctions and dutch auctions—that implement different sale mechanics, but the general use of the trusted escrow account applies to all types of sales. The offer step transfers the asset from the seller's account in the token ledger to the escrow account. The pact assigns an identifier to the SALE event that results from the transfer operation. For example, Bob submits a transaction to offer NFT1 for sale with a price quote of 50 KDA. This transaction: Removes NFT1 from Bob's account in the token ledger. Transfers NFT1 to an escrow account associated with a specific sale identifier——in the token ledger. By initiating the sale, Bob loses custody of the asset for a period of time. The pact guard takes ownership of the asset. Buy The buyer who wants to acquire the asset that's been offered for sale sends a continuation transaction for the identifier assigned to the SALE event. For example, Alice sends a continuation transaction for the pact identifier to transfer NFT1 out of the escrow account in the token ledger and into her account. The ledger then debits the sale price of 50.0 from Alice’s KDA account to credit Bob and executes any other offsetting transaction needed to release the escrowed NFT. For example, the token policy pays any royalty fees or returns any funds as specified in the policy. With this separation of duties, the pact is responsible for transferring the NFT out of escrow and enforcing the timeout. Any other transaction requirements are handled by token policies. Withdraw Sellers can specify a timeout as part of the offer step. If they set the timeout to zero (0) for a sale contract, they can withdraw from the sale at any time if there are no interested buyers for a token. If they set a specific timeout value—for example, to have an offer expire at midnight on 30 June 2024 with a timeout value of 1719705600—they can't pull out of the sale until after the specified timestamp. After the timeout, the seller can send a rollback continuation transaction for the identifier assigned to the SALE event. The withdraw operation then transfers the token out of the escrow account and returns it to the seller. Completing a logical sequence All of the logic required to step through the sales process is automatically handled by the Pact language. The pact definition ensures that step two can only happen after step one and only under the following conditions: If step one hasn't been rolled back. If step two hasn't already happened. Similarly, a rollback can’t occur if step one hasn’t happened, or if step two has already happened. With Pact, this logic isn't left to contract programmers. Instead, Pact prevents the contract developer from introducing faulty logic in sequencing the transaction. Using built-in policies The Marmalade token standard defines interfaces for policy-based token management. To simplify token creation using the standard, Kadena provides several built-in token policies for the most common features. You can use the built-in policies—called concrete policies—independently or in combination to provide the specific features you want to implement. For example: Use the guard policy to prevent unauthorized token activity like minting or burning. Use the non-fungible policy to ensure that a token can only be minted once and never burned. Use the royalty policy to specify the account for depositing royalty payments from sales. Use the collection policy to create token collections for a marketplace. Use the non-updatable policy to prevent a token URI from being updated. To illustrate how you can use these policies, assume that you want to offer a non-fungible token. You want to ensure that you are the only person authorized to mint the token and that only one token can be minted and owned. You also want to require that the token can only be transferred to a new owner through a sale contract and you'll be paid a royalty any time the token ownership changes. To accomplish this, you can create the token using the ,, and policies. These policies help to ensure that you are the only person authorized to mint the token, only one token can be minted, and any time the token is transferred to a new owner, you're paid the royalty you specify. After you mint the token, all future sales respect the policies you've put in place. Any new NFT owner can only resell the NFT using the offer, trustless escrow, and royalty enforcement process with a new buyer. Creating custom policies If you find that some combination of concrete policies doesn't meet your needs, you can also use the built-in policies as models for creating your own custom token policies. You can find several examples of custom policies in Marmalade examples. Like concrete policies, custom policies must adhere to the interface to be valid.",
    "source": "reference/marmalade/what-is-marmalade.md",
    "title": "what-is-marmalade"
  },
  {
    "content": "title: Token standard architecture description: Build a non-fungible token (NFT) marketplace using the Marmalade token standard and Pact smart contracts. id: token-standard-architecture order: 3 layout: full Token standard architecture Marmalade contracts define a poly-fungible token standard and token policy management for the Kadena blockchain. These contracts provide interfaces for defining, minting, and managing digital items like non-fungible tokens and token collections using Pact smart contracts on the Kadena network. The Marmalade token standard architecture depends on several smart contracts that enable you to manage how tokens are minted, offered for sale, and transferred between accounts. This multi-layered contract architecture simplifies how you create and manage tokens, define marketplace policies, and implement common token features. Core contracts The Marmalade contract architecture provides separate contracts to handle specific tasks. For example, there are separate contracts for managing policies applied to token and for managing auction rules for token sales. This architecture ensures that functions are called in the correct order to complete multi-step transactions. At a high level, the Marmalade architecture consists of the following main contracts: The Marmalade ledger () contract provides the core functionality of the marketplace with the ability to create, mint, burn, transfer, buy, and sell tokens. The Marmalade policy manager () contract enables token creators to configure rules to control token properties and allowed operations. Marmalade sale () contracts enable tokens to be offered for sale using sales models that don't rely on a fixed price. Ledger contract The Marmalade ledger contract——is the primary contract that enables buyers and sellers use to interact with the marketplace. This contract keeps track of important information for everyone participating in the marketplace and records every transaction that takes place involving tokens minted with Marmalade. The ledger stores information about tokens, including the token metadata, the policies associated with the token, and the record of token ownership. The main functions in the ledger contract are The Marmalade Ledger plays a central role in enabling you to manage the lifecycle of non-fungible tokens and other digital assets. The ledger contract provides the core functions—such as , , , , and —that are required to create, transfer, and track the ownership of tokens. The ledger contract ensures that all token-related activity is recorded accurately and securely in a transparent, traceable, and tamper-proof way. The ledger contract defines the tables and schemas to store information about accounts and tokens. The ledger contract also defines specific capabilities to perform specific actions and enforce specific conditions when those actions are performed. The tables, schemas, and capabilities defined in the ledger contract ensure that token creators, token owners, and token buyers comply with predefined rules and constraints when they interact. By enforcing rules and constraints through token policies, Marmalade promotes more secure and trustworthy transactions for all marketplace participants. For more technical information about the Marmalade ledger contract, see Ledger contract. Policy manager The Marmalade policy manager contract——enables token creators to select multiple policies to configure the specific token features they want to implement. The policy manager acts as a middle layer between the ledger and the individual policies applied to a token. The policy manager gives token creators greater flexibility in defining rules for transferring ownership and managing transactions between buyers and sellers. For example, it's the policy manager contract that enables a sale to require a secure escrow account to complete a token transfer or to guarantee royalty payments. The following diagram provides a simplified view of how the policy manager contract acts as a middle layer between the ledger contract and policies applied to a token in the token creation process: By using the policy manager contract, you can standardize the rules for creating asset properties, collecting payments, and transferring ownership within a marketplaces, providing a more consistent experience for marketplace participants. With the policy manager contract, you can choose token properties from built-in policies—like the non-fungible policy and royalty policy—or create custom policies to use on their own or in combination with the built-in policies. For more technical details about the Marmalade policy manager contract, see Policy manager contract. Sales-specific contracts Marmalade supports sales-specific contracts to provide flexibility for how tokens can be sold. Sales-specific contracts allow you to define different sales models with different sales mechanics—like auctions or limited offering periods—instead of simply quoting an asking price. When you offer a token for sale in the ledger, you can provide a reference to a specific contract that defines the rules for the sale. For example, the sale contract you reference might have auction rules that specify an opening price and how to handle incoming bids. Depending on the rules defined in the referenced sale contract, the policy manager contract updates the final price of the quote during the buy process. By using a separate contract to define and manage the mechanics of the sales process, you can ensure that buyers and sellers can participate safely without compromising royalty payments. It's important to note that contracts that define a sales model—the sale contract—must be reviewed and registered in the policy manager so that the policy manager can enforce the contract rules. The following diagram provides a simplified view of the interaction between the ledger, policy manager, and a sale contract: For information about registered sales-specific contracts, see the conventional sale and dutch sale contract reference. For more information about how to implement the sale contract interface or create a custom sale contract, see Custom sales contracts. Policies Individual policies give you granular control over token properties and token-related activity, including minting, burning, transferring, and buying tokens. Token policies are implemented as smart contracts based on the interfaces defined in the standard. There are several built-in policies—called concrete policies—that are configured to handle the most common marketplace use cases. The built-in concrete policies are officially released and maintained to provide ready-to-use implementations of common features that don't require any custom development work. The concrete policies currently available provide the following features: Guard enforcement policy. If the is applied to a token, a keyset or another type of guard must be specified to initiate any token-related activity, bolstering security against unauthorized minting. Non-fungible token enforcement policy. If the is applied to a token, the token is guaranteed to be unique with a maximum supply of one and precision set to zero. Royalty enforcement policy. If the is applied to a token, you can designate an account to receive royalties each time the token is transferred to a new owner, fostering an ongoing revenue stream from NFT sales. Collection identification policy. If the is applied to a token, the token is identified as part of a collection and can be discovered as an item in a toke list. You can also create custom policies to implement unique rules or enforce specific behavior not covered by the concrete policies. You can find examples of custom policies in the examples/policies repository. Example policies aren't officially released and maintained, but can be useful models for developing your own custom policies. If an example or custom policy seems broadly useful to a general audience, it can be promoted to a concrete policy, contributing to the overall evolution of the Marmalade marketplace.",
    "source": "reference/marmalade/token-standard-architecture.md",
    "title": "token-standard-architecture"
  },
  {
    "content": "title: Royalty policy description: \"Describes the schemas, tables, capabilities, and functions defined in the royalty policy.\" id: royalty sidebar_position: 7 Royalty policy The royalty policy extends the functionality of the base interface to provide specific rules for token actions and royalty payouts during the sale of a non-fungible token. Source code: royalty-policy.pact Schema and table : Stores royalty-related information for NFTs, like the creator, royalty rate, and the associated fungible token. Table: Maintains royalty configurations for NFTs managed under the policy, including the token ID and its associated royalty details. Capabilities : Governs contract upgrades. @event: Emits the token-id and registered royalty information during . @event: Emits royalty payout information during if a royalty is paid. Functions : Sets initial royalty information for a token, ensuring artists get their royalties. : Manages royalty payouts during sales. Validates and abides by the agreed terms between buyer and seller. Payload message : Initializes and validates a royalty for a fungible token. The object contains necessary fields like , , , , and . Events : Triggered within the function when a sale concludes, and a royalty payment is made to the token's creator. Emitting line:",
    "source": "reference/marmalade/royalty-policy.md",
    "title": "royalty-policy"
  },
  {
    "content": "title: Policy manager description: \"Functions and capabilities defined in the Marmalade policy manager contract enforce the policies you select for tokens and token-related operations.\" id: policy-manager sidebar_position: 2 Policy manager contract As discussed in Token standard architecture, the policy manager provides a standard for collecting and distributing fungibles and ensures that all of the policies applied to tokens are enforced. The policy manager provides the following key features: The ability to customize and manage token behavior and attributes by enforcing built-in and custom policies. Consistent and predictable policy enforcement. The ability to stack multiple policies to craft the exact behavior requirement for every token. A standardized interface for all policies through . Source code: policy-manager.pact Tables and schemas The policy manager contract defines the following tables and schemas: Ledgers table: Ensures functions are initiated only from the ledger. Concrete policies table: Maintains concrete policy information for each token. Sale whitelist table: Lists valid whitelisted sale contracts. Quotes table: Archives quotes for quoted sales. Ledger schema: Contains the module reference governed by the policy manager, adhering strictly to the ledger-v1 interface. Concrete policies schema: Includes the module reference, strictly using the token-policy-v2 interface. Capabilities The policy manager supports a comprehensive set of capabilities to cover a wide array of functionalities: Functions As a general rule, all of the functions require the capability to be in scope to ensure that functions are initiated from the ledger. The functions then extract the policy list from the token input, which lists the associated policies. The policy manager defines the following functions: enforce-init: Initiates at . enforce-mint: Executes at . enforce-burn: Activates at . enforce-offer: Runs at (step 0 of ). Here, an optional parameter can be accessed in the field. If a quote is identified, the offer saves this quote, and escrow accounts are generated. Otherwise, the offer continues without quotes. enforce-withdraw: Operates at (step 1 rollback of ). enforce-buy: Engages at (step 1 of ). write-concrete-policy: This function registers a concrete policy modref into the concrete policies table. get-escrow-account: Returns the fungible escrow account created for quoted sales at enforce-offer. The escrow account receives the fungible from the buyer and distributes the fungibles to the policies and the seller at the buy step. write-concrete-policy: Registers concrete policy into the concrete-policies table. get-concrete-policy: Returns the of the concrete policy. enforce-sale-pact: Ensures that the sale parameter provided to the function is equal to the ID of the currently executing pact. It does this by calling the function to retrieve the ID of the currently executing pact and comparing it to the provided sale parameter. If they are not equal, an exception will be thrown.",
    "source": "reference/marmalade/policy-manager.md",
    "title": "policy-manager"
  },
  {
    "content": "title: Non-fungible policy description: \"Describes the schemas, tables, capabilities, and functions defined in the non-fungible policy.\" id: non-fungible sidebar_position: 6 Non-fungible policy The non-fungible policy ensures the uniqueness of digital assets. If you apply this policy to a token, the policy guarantees that the token supply is one with a precision of zero. Source code: non-fungible-policy.pact Capabilities The non-fungible policy smart contract defines the following capability to manage permissions: : Oversees access control for contract modifications. Functions The guard policy smart contract defines the following functions to enforce restrictions of different token activities: : Ensures proper initiation of tokens using a ledger guard. This sets the stage for minting by storing the mint guard associated with the token. : Regulates the minting process, maintaining a fixed supply of 1 for each token, thus preserving its non-fungible nature.",
    "source": "reference/marmalade/non-fungible-policy.md",
    "title": "non-fungible-policy"
  },
  {
    "content": "title: Marmalade client utilities description: \"The @kadena/client-utils library includes a TypeScript-based API for interacting with Marmalade smart contracts on the Kadena network.\" id: marmalade-client-utils sidebar_position: 10 Marmalade client utilities The library provides a TypeScript-based API for interacting with marmalade smart contracts on the Kadena network. This library is designed to facilitate the creation, management, and utilization of NFTs, leveraging Marmalade’s advanced features such as enforceable royalties, secure escrow accounts, and flexible token policies. Whether you're building applications for minting, transferring, or auctioning NFTs, provides the necessary tools to create and send commands to the Kadena network efficiently. This guide will help you get started with installing the library, using its various functions, and integrating it into your projects. Install You can install the library with the following command: You can import Marmalade functions into TypeScript programs with statements similar to the following example: CommonProps Use the interface to access common properties—including metadata for transaction control, additional capabilities, or additional signers—that are used by other functions. IClientConfig Use the interface to specify the network location to send transactions to when connecting to the Kadena network. burnToken Use function to eliminate a specified amount of a token. This operation reduces the total supply of the token. Inputs Parameter Type Description policyConfig object Specifies which types of policies are configured for the specified token. This object is used to validate that you have expected types defined for the all of the policies you have selected for a token. tokenId string Specifies the token identifier for the token you want to burn. accountName string Specifies the account that owns the token you want to burn. chainId ChainId Specifies the chain identifier for the chain where you want to burn the specified token. Valid values are 0 to 19. guard object Specifies the token owner or the burn guard, if you've configured a burn guard. amount IPactDecimal Specifies the amount to burn. Policy configuration object The interface identifies the types of policies that are configured for a token as boolean values. The resulting object contains properties similar to the following: Guard object Depending on whether a token has the guard policy applied and a burn guard defined, the object account information might be required to be the token owner or the account specified for the burn guard. For either account, the object contains properties similar to the following: Return value This function returns a value to indicate whether the burn operation was successful or failed. Example buyToken Use to enable the purchase of a specified token within a defined sale configuration. This function handles the transaction between the seller and buyer, including any applicable auction logic. Inputs Parameter Type Description auctionConfig IAuctionPurchaseConfig Specifies the type of auction if the token is offered for sale using a conventional or dutch auction. policyConfig object Specifies which types of policies are configured for the specified token. This object is used to validate that you have expected types defined for the all of the policies you have selected for a token. tokenId string Specifies the token identifier for the token you want to buy. saleId string Specifies the Pact identifier for the token sale. amount IPactDecimal Specifies the number of tokens you want to buy. chainId ChainId Specifies the chain identifier for the chain where the token is offered for sale. Valid values are 0 to 19. seller object Specifies account information for the token seller. buyer object Specifies the buyer account information and guard. buyerFungibleAccount? string Specifies the fungible name if the fungible for the sale is not using the coin contract. Policy configuration object The interface identifies the types of policies that are configured for a token as boolean values. The resulting object contains properties similar to the following: Account information objects Depending on the function, account information objects might consist of different properties. For example, in the context of the function, the object only contains the account name, but the object includes the account information and a keyset guard. Auction-specific parameters There are additional inputs for auctions. The interface for conventional auctions (IConventionalAuctionPurchaseInput) and the interface for dutch auctions (IDutchAuctionPurchaseInput) have the following additional inputs: Parameter Type Description updatedPrice IPactDecimal Specifies the current auction price. escrow object Specifies the escrow sale account in the Marmalade ledger. Return value This function returns the as a value. Example createAuction Use to create an auction for a specified token. This function supports both conventional and dutch auction types, allowing the seller to define start and end dates, prices, and other relevant parameters. Inputs Both conventional auctions and dutch auctions use the following parameters: Parameter Type Description auctionConfig IAuctionPurchaseConfig Specifies the type of auction to create. Valid vales are conventional and dutch. chainId ChainId Specifies the chain identifier for the chain where where you want to create the auction. Valid values are 0 to 19. seller object Specifies the account information for the token seller. saleId string Specifies the Pact identifier for the token sale. tokenId string Specifies the token identifier for the token you want to list. startDate IPactInt Specifies the time when auction starts. endDate IPactInt Specifies the time when auction ends. reservedPrice IPactDecimal Specifies the reserved price for the sale. The following parameters are only used for creating a dutch auction: Parameter Type Description startPrice IPactDecimal Specifies the initial asking price for the token auction. priceIntervalInSeconds IPactInt Specifies the interval for lowering the asking price for the token. Return value This function returns a value to indicate whether creating the auction was successful or failed. Example createBidId Use to generate a unique bid identifier for a specified auction. Inputs Parameter Type Description saleId string Specifies the Pact identifier for the token sale. bidderAccount string Specifies the bidder account information. chainId ChainId Specifies the chain identifier for the chain where where you want to create a bid identifier. Valid values are 0 to 19. networkId NetworkId Specifies the target network for the bid. Valid values are development, testnet04, and mainnet01. host IClientConfig['host'] Specifies the target node for the bid. Return value This function returns the as a value. Example createCollectionId Use to generate a unique collection identifier. Inputs Parameter Type Description collectionName string Specifies the name of the collection. operator string Specifies the collection operator. chainId ChainId Specifies the chain identifier for the chain where where you want to create the collection identifier. Valid values are 0 to 19. networkId NetworkId Specifies the target network for the collection identifier. Valid values are development, testnet04, and mainnet01. host IClientConfig['host'] Specifies the target node for the collection identifier. Return value This function returns the as a value. Example createCollection Use to initiate the creation of a new collection, specifying its name, size, operator, and other relevant metadata. Inputs Parameter Type Description id string Specifies the collection identifier. name string Specifies the collection name. size IPactInt or PactReference Specifies the number of tokens in the collection. chainId ChainId Specifies the chain identifier for the chain where where you want to create the collection. Valid values are 0 to 19. operator object Specifies the operator account and guard. meta object Specifies the transaction metadata. Return value This function returns a value to indicate whether creating the collection was successful or failed. Example createTokenId Use to generate a unique token identifier. Inputs Parameter Type Description policyConfig object Specifies which types of policies are configured for the specified token. This object is used to validate that you have expected types defined for the all of the policies you have selected for a token. policies Array of strings Specifies the list of policy names applied to the token. uri string Specifies the location of the token metadata JSON file in the form of uniform resource identifier (URI). precision IPactInt or PactReference Specifies the token precision. collectionName string Specifies the name of the token collection, if applicable. creator string Specifies the token creator account information. chainId ChainId Specifies the chain identifier for the chain where where you want to create the token identifier. Valid values are 0 to 19. networkId NetworkId Specifies the target network for the token identifier. Valid values are development, testnet04, and mainnet01. host IClientConfig['host'] Specifies the target node for the token identifier. Policy configuration object The interface identifies the types of policies that are configured for a token as boolean values. The resulting object contains properties similar to the following: Return value This function returns the as a value. Example createToken Use to create a new token with all relevant policies applied. Inputs Parameter Type Description policyConfig object Specifies which types of policies are configured for the specified token. This object is used to validate that you have expected types defined for the all of the policies you have selected for a token. policies Array of strings Specifies the list of policy names applied to the token. uri string Specifies the location of the token metadata JSON file in the form of uniform resource identifier (URI). precision IPactInt or PactReference Specifies the token precision. collectionName string Specifies the name of the token collection, if applicable. creator string Specifies the token creator account information. chainId ChainId Specifies the chain identifier for the chain where where you want to create the token. Valid values are 0 to 19. guards IGuardInfoInput Specifies the parameters for the guard policy, if applicable. royalty IRoyaltyInfoInput Specifies the parameters for the royalty policy, if applicable. collection ICollectionInfoInput Specifies the parameters for the collection policy, if applicable. Additional inputs for guard policy (IGuardInfoInput) Parameter Type Description mintGuard KeysetGuard or FunctionGuard Specifies the guard for minting tokens. uriGuard KeysetGuard or FunctionGuard Specifies the guard for updating the token metadata and uri. saleGuard KeysetGuard or FunctionGuard Specifies the guard for selling tokens. burnGuard KeysetGuard or FunctionGuard Specifies the guard for burning tokens. transferGuard KeysetGuard or FunctionGuard Specifies the guard for transferring tokens. Additional inputs for royalty policy (IRoyaltyInfoInput) Parameter Type Description fungible object Specifies the module reference where a fungible token is defined, for example, in the contract for KDA. creator object Specifies the creator account information and guard. royaltyRate IPactDecimal Specifies the royalty percentage to be paid to the creator's account each time a token with this policy applied is sold. The fungible module object identifies the contracts where specified fungible tokens are defined. For Marmalade and KDA tokens, the fungible object contains the following reference specifications: Additional inputs for collection policy (ICollectionInfoInput) Parameter Type Description collectionId string Specifies the collection to add the token to. Return value This function returns a value to indicate whether creating the token was successful or failed. Example escrowAccount Use to retrieve the details for a specified escrow account. Inputs Parameter Type Description saleId string Specifies the Pact identifier for the token sale. chainId ChainId Specifies the chain identifier for the chain where the escrow account is created. Valid values are 0 to 19. networkId NetworkId Specifies the target network for the escrow account. Valid values are development, testnet04, and mainnet01. host IClientConfig['host'] Specifies the target node for the escrow account. Return value This function returns the as a value. Example getAccountDetails Use to retrieve detailed information, including the token balance, for a specified account. Inputs Parameter Type Description tokenId string Specifies the token identifier for the token that you want to retrieve information for. accountName string Specifies the account name that you want to retrieve information for. chainId ChainId Specifies the chain identifier for the chain from which you want to get account details. Valid values are 0 to 19. networkId NetworkId Specifies the target network for retrieving account details. Valid values are development, testnet04, and mainnet01. host IClientConfig['host'] Specifies the target node for retrieving account details. Return value This functions returns an object with account details. Example getAuctionDetails Use to retrieve detailed information for a specified auction. Inputs Parameter Type Description auctionConfig IAuctionConfig Specifies the type of the auction. saleId string Specifies the Pact identifier for the sale you want to retrieve information for. chainId ChainId Specifies the chain identifier for the chain from which you want to get auction details. Valid values are 0 to 19. networkId NetworkId Specifies the target network for retrieving auction details. Valid values are development, testnet04, and mainnet01. host IClientConfig['host'] Specifies the target node for retrieving auction details. Return value This functions returns an object with auction details. Example getBid Use to retrieve detailed information, including the bidder and bid amount, for a specific bid placed in the context of a specific auction. Inputs Parameter Type Description bidId string Specifies the identifier for the bid you want to retrieve information for. chainId ChainId Specifies the chain identifier for the chain from which you want to get bid details. Valid values are 0 to 19. networkId NetworkId Specifies the target network for retrieving bid details. Valid values are development, testnet04, and mainnet01. host IClientConfig['host'] Specifies the target node for retrieving bid details. Return value This functions returns an object with bid details. Example getCollectionToken Use to retrieve information about a specific token within a collection. Inputs Parameter Type Description tokenId string Specifies the token identifier for the token that you want to retrieve information for. chainId ChainId Specifies the chain identifier for the chain from which you want to get information about a token in a collection. Valid values are 0 to 19. networkId NetworkId Specifies the target network for retrieving information about a token in a collection. Valid values are development, testnet04, and mainnet01. host IClientConfig['host'] Specifies the target node for retrieving information about a token in a collection. Return value This functions returns an object with details about a token in a collection. Example getCollection Use to retrieve detailed information about a specified collection. Inputs Parameter Type Description collectionId string Specifies the collection identifier for the collection that you want to retrieve information for. chainId ChainId Specifies the chain identifier for the chain from which you want to get information about a collection. Valid values are 0 to 19. networkId NetworkId Specifies the target network for retrieving information about a collection. Valid values are development, testnet04, and mainnet01. host IClientConfig['host'] Specifies the target node for retrieving information about a collection. Return value This functions returns an object with collection details. Example getCurrentPrice Use to retrieve the current price of a token in an auction, reflecting any price adjustments due to auction rules. Inputs Parameter Type Description saleId string Specifies the Pact identifier for the sale you want to retrieve information for. chainId ChainId Specifies the chain identifier for the chain from which you want to get information about the current price for a token. Valid values are 0 to 19. networkId NetworkId Specifies the target network for retrieving information about the current price for a token. Valid values are development, testnet04, and mainnet01. host IClientConfig['host'] Specifies the target node for retrieving information about the current price for a token. Return value This functions returns an object with the current price. Example getEscrowAccount Use to retrieve information about an escrow account. Inputs Parameter Type Description saleId string Specifies the Pact identifier for the sale you want to retrieve information for. chainId ChainId Specifies the chain identifier for the chain from which you want to get information about an escrow account. Valid values are 0 to 19. networkId NetworkId Specifies the target network for retrieving information about an escrow account. Valid values are development, testnet04, and mainnet01. host IClientConfig['host'] Specifies the target node for retrieving information about an escrow account. Return value This functions returns an object with details about an escrow account. Example getQuoteInfo Use to retrieve information about a specific sale quote. Inputs Parameter Type Description saleId string Specifies the Pact identifier for the sale you want to retrieve information for. chainId ChainId Specifies the chain identifier for the chain from which you want to get information about a quote. Valid values are 0 to 19. networkId NetworkId Specifies the target network for retrieving information about a quote. Valid values are development, testnet04, and mainnet01. host IClientConfig['host'] Specifies the target node for retrieving information about a quote. Return value This functions returns an object with quote details. Example getTokenBalance Use to retrieve the balance recorded in the ledger for a specified token and a specified account. Inputs Parameter Type Description tokenId string Specifies the token identifier for the token that you want to retrieve information for. accountName string Specifies the account name that you want to retrieve information for. chainId ChainId Specifies the chain identifier for the chain from which you want to get balance information for a token. Valid values are 0 to 19. networkId NetworkId Specifies the target network for retrieving information about the balance for a token. Valid values are development, testnet04, and mainnet01. host IClientConfig['host'] Specifies the target node for retrieving information about the balance for a token. Return value This functions returns an IPactDecimal value representing the token balance. Example getTokenInfo Use to retrieve detailed information about a specific token. Inputs Parameter Type Description tokenId string Specifies the token identifier for the token that you want to retrieve information for. chainId ChainId Specifies the chain identifier for the chain from which you want to get information for the token. Valid values are 0 to 19. networkId NetworkId Specifies the target network for retrieving information about the token. Valid values are development, testnet04, and mainnet01. host IClientConfig['host'] Specifies the target node for retrieving information about the token. Return value This functions returns an object with token details. Example getUri Use to retrieve the URI associated with a specific token. Inputs Parameter Type Description tokenId string Specifies the token identifier for the token that you want to retrieve information for. chainId ChainId Specifies the chain identifier for the chain from which you want to get the URI for the token. Valid values are 0 to 19. networkId NetworkId Specifies the target network for retrieving the URI for the token. Valid values are development, testnet04, and mainnet01. host IClientConfig['host'] Specifies the target node for retrieving the URI for the token. Return value This function returns the token uRI as a value. Example mintToken Use function to mint a specified amount of a specified token. Minting a token increases its total supply and assigns ownership of the token to a target account. Inputs Parameter Type Description policyConfig object Specifies which types of policies are configured for the specified token. This object is used to validate that you have expected types defined for the all of the policies you have selected for a token. tokenId string Specifies the token identifier for the token you want to mint. accountName string Specifies the account that you want to assign ownership of the token to. chainId ChainId Specifies the chain identifier for the chain where the token is being minted. Valid values are 0 to 19. guard object Specifies the token owner or the mint guard, if applicable. amount IPactDecimal Specifies the amount to mint. Return value This function returns a value to indicate whether minting the token was successful or failed. Example offerToken Use to put a specified token up for sale. Note that you must be the token owner to offer the specified token for sale. Inputs Parameter Type Description policyConfig object Specifies which types of policies are configured for the specified token. This object is used to validate that you have expected types defined for the all of the policies you have selected for a token. tokenId string Specifies the token identifier for the token that you want to offer for sale. amount IPactDecimal Specifies the amount that you want to offer for sale. timeout IPactInt Specifies the timeout for when the offer can be withdrawn. You can set this value using the number of seconds from the start of the UNIX epoch or set the timeout to zero (0) to allow an offer to be withdrawn at any time. chainId ChainId Specifies the chain identifier for the chain where the token is being offered. Valid values are 0 to 19. seller object Specifies the seller account information and guard. auction ISaleAuctionInfoInput Additional parameters if you are offering the token using an auction contract. guards ISaleGuardInfoInput Additional parameters if you are offering a token that has the guard policy applied. royalty IRoyaltyInfoInput Additional parameters if you are offering a token that has the royalty policy applied. Additional inputs for auction contract (ISaleAuctionInfoInput) Parameter Type Description fungible object Specifies the identifier to specify a fungible token, such as coin or a custom fungible token. price IPactDecimal Specifies the price that the token is being offered at. For auction contracts, this setting should be zero (0). sellerFungibleAccount IPactDecimal Specifies the seller account information if you are using a custom fungible. saleType string Specifies the auction contract type. Valid values are conventional and dutch. Additional inputs for guard policy (ISaleGuardInfoInput) Parameter Type Description saleGuard KeysetGuard or FunctionGuard Specifies the guard for selling tokens. Additional inputs for royalty policy (IRoyaltyInfoInput) Parameter Type Description fungible object Specifies the identifier to specify a fungible token, such as coin or a custom fungible token. creator object Specifies the creator account information and guard. royaltyRate IPactDecimal Specifies the royalty percentage to be paid to the creator's account each time a token with this policy applied is sold. Return value This function returns a value to indicate whether creating the offer was successful or failed. Example placeBid Use to place a bid on a specified token in an active auction. Inputs Parameter Type Description marketplaceConfig object Specifies the configuration to collect marketplace fees. saleId string Specifies the Pact identifier for the sale. bid IPactDecimal Specifies the amount to bid on the token. bidder object Specifies the bidder account information and guard. escrowAccount string Specifies the escrow account for the bid. chainId ChainId marketplaceFee IPlaceBidInput Additional parameters, if using marketplace fees. Marketplace object The object specifies whether a marketplace charges fees. For example: If true, the IPlaceBidInput interface requires the following additional parameters: Parameter Type Description mkAccount string Specifies the marketplace account information. mkFeePercentage IPactDecimal Specifies the marketplace fee percentage. Return value This function returns a value to indicate whether placing the bid was successful or failed. Example transferCreateToken Use to transfer a specified amount of a specified token from one account to another. Inputs Parameter Type Description policyConfig object Specifies which types of policies are configured for the specified token. This object is used to validate that you have expected types defined for the all of the policies you have selected for a token. tokenId string Specifies the token identifier for the token that you want to transfer. amount IPactDecimal Specifies the amount that you want to transfer. sender object Specifies the sender account information and guard. receiver object Specifies the receiver account information and guard. chainId ChainId Specifies the chain identifier for the chain where the transfer takes place. Valid values are 0 to 19. Return value This function returns a value to indicate whether transferring the token was successful or failed. Example transferToken Use to transfer a specified amount of a specified token from one account to another. Inputs Parameter Type Description policyConfig object Specifies which types of policies are configured for the specified token. This object is used to validate that you have expected types defined for the all of the policies you have selected for a token. tokenId string token identifier for the token that you want to transfer. amount IPactDecimal Specifies the amount that you want to transfer. sender object Specifies the sender account information and guard. receiver object Specifies the receiver account information and guard. chainId ChainId Specifies the chain identifier for the chain where the transfer takes place. Valid values are 0 to 19. Return value This function returns a value to indicate whether transferring the token was successful or failed. Example updateAuction Use to modify an existing auction's details. This function supports updates to both conventional and dutch auction types, enabling changes to start and end dates, prices, and other relevant parameters. Inputs Both conventional auctions and dutch auctions use the following parameters: Parameter Type Description auctionConfig IAuctionPurchaseConfig Specifies the type of auction to update. Valid vales are conventional and dutch. chainId ChainId Specifies the chain identifier for the chain where where you want to update the auction. Valid values are 0 to 19. seller object Specifies the account information for the token seller. saleId string Specifies the Pact identifier for the token sale. tokenId string Specifies the token identifier for the token you want to list. startDate IPactInt Specifies the time when auction starts. endDate IPactInt Specifies the time when auction ends. reservedPrice IPactDecimal Specifies the reserved price for the sale. The following parameters are only used for updating a dutch auction: Parameter Type Description startPrice IPactDecimal Specifies the initial asking price for the token auction. priceIntervalInSeconds IPactInt Specifies the interval for lowering the asking price for the token. Return value This function returns a value to indicate whether the update to the auction was successful or failed. Example updateUri Use to update the URI associated with a specified token. You can use this function to modify the metadata associated with the specified token. Note that modifying the metadata for a token also updates the token identifier. You can prevent a token from being upgradeable by applying the to the token. Inputs Parameter Type Description policyConfig object Specifies which types of policies are configured for the specified token. This object is used to validate that you have expected types defined for the all of the policies you have selected for a token. tokenId string Specifies the token identifier for the token that you want to update. uri string Specifies the location of the token metadata JSON file in the form of uniform resource identifier (URI) that you want to update. guard object Specifies the update URI (uriGuard) account information and guard. chainId ChainId Specifies the chain identifier for the chain where the token is being updated. Valid values are 0 to 19. Return value This function returns a value to indicate whether updating the token URI was successful or failed. Example withdrawToken Use to withdraw a specified token from a sale. Inputs Parameter Type Description policyConfig object Specifies which types of policies are configured for the specified token. This object is used to validate that you have expected types defined for the all of the policies you have selected for a token. tokenId string Specifies the token identifier for the token that you want to transfer. saleId string Specifies the Pact identifier for the sale. amount IPactDecimal Specifies the amount to withdraw. timeout IPactInt Specifies the timeout for when the offer can be withdrawn. seller object Specifies the seller account information and guard. chainId ChainId Specifies the chain identifier for the chain where the token is being withdrawn. Valid values are 0 to 19. Return value This function returns a value to indicate whether withdrawing the token was successful or failed. Example",
    "source": "reference/marmalade/marmalade-client-utils.md",
    "title": "marmalade-client-utils"
  },
  {
    "content": "title: Ledger contract description: \"Functions and capabilities defined in the Marmalade Ledger contract enable you to manage the token lifecycle and keep track of all token-related activity.\" id: ledger sidebar_position: 1 Ledger contract The Marmalade token standard provides interfaces that enable you to define, mint, and secure tokens. As discussed in Token standard architecture, the Marmalade ledger contract provides the core functionality to create, manage, and transfer tokens minted using the Marmalade token standard. The ledger contract records and manages all token-related activity to ensure every transaction is accurate, every policy is enforced, and every account is up-to-date. This part of the documentation describes the functions and capabilities defined in the Marmalade ledger contract in the namespace. The namespace is available on all twenty chains (0-19) in the Kadena test network and the Kadena main network. Source code: ledger.pact create-token-id Use to generate a unique token identifier with the specified token identifier. Arguments Use the following arguments to create the token identifier. Argument Type Description object Defines token properties using the metadata schema in JSON file format. guard Specifies the temporary guard—for example, a keyset—used to generate the token identifier. This guard isn't stored and ensure that only the owner of the creation key can create a specific token identifier. Before creating a token, you must choose a temporary guard. The guard can be A keyset you've already defined or used in the guard-policy. A single-use keyset that won't be used again. Another type guard. This guard becomes part of the hashed data in the string prefixed with . Including the guard in the hashed token identifier protects anyone else from creating the token. With this mechanism, only you—as the owner of the creation key—can create the token specified by the string. Example Generate a unique by calling the following function: create-token Use to create a token with the specified token identifier. You can apply one or more policies to a token when you create it. Depending on the policies you apply, you might need to grant additional capabilities or pass environment data to execute the function. Arguments Use the following arguments to create a token. Argument Type Description string Specifies the unique token identifier generated using the function and formatted as . integer Specifies the number of decimals allowed for the token supply amount. For non-fungible tokens, the precision must be 0, and should be enforced in the policy's . string Specifies the uniform resource identifier (uri) to an external JSON file containing token metadata. list Specifies one or more policy contracts with custom functions to execute at marmalade functions. guard Specifies the temporary guard—for example, a keyset—used to generate the token identifier. This guard isn't stored and ensure that only the owner of the creation key can create a specific token identifier. When you submit the transaction, the function calls the function in the stored token policies and the function is executed. To create a token with this function: Generate a unique by calling Create the token by calling Capabilities The transaction must include the capability signed with the keyset that you used to generate the token identifier. The transaction also requires the capability if you apply the collection-policy to create token. Required capabilities and parameters for the function: marmalade-v2.ledger.CREATE-TOKEN id marmalade-v2.collection-policy-v1.TOKEN-COLLECTION collection-id token-id Environment data If you apply the guard-policy to create a token, you can add the following information as raw data: mint_guard [guard] (optional) burn_guard [guard] (optional) sale_guard [guard] (optional) transfer_guard [guard] (optional) uri_guard [guard] (optional) If you apply the collection-policy to create a token, you can add the following information as raw data: collection_id [string] If you apply the royalty-policy to create a token, you can add the following information as raw data: royalty_spec [object] The royalty_spec object includes the following properties: fungible [string] creator [string] creator-guard [guard] royalty-rate [decimal] mint Use to mint the specified token amount to the specified account. Arguments Use the following arguments to mint a token. Argument Type Description string Specifies the unique token identifier generated using function and formatted as . string Specifies the account that will receive the minted token. guard Specifies the guard for the minted token account. decimal Specifies the number of tokens to be minted. When you submit the transaction, the function calls the function in the stored token policies and the function is executed. Capabilities The transaction must include the capability signed with the that receives the token. The transaction also requires the capability if you apply the guard-policy and define a mint guard for the token. Required capabilities and parameters for the function: marmalade-v2.ledger.MINT id account (receiver of the token) amount marmalade-v2.guard-policy-v1.MINT token-id account (receiver of the token) amount burn Use to destroy the specified token amount from the specified token owner account. Arguments Use the following arguments to burn a token. Argument Type Description string Specifies the unique token identifier generated using function and formatted as . string Specifies the token owner account for the token amount to be burned. decimal Specifies the number of tokens to be burned. When you submit the transaction, the function calls the function in the stored token policies and the function is executed. Capabilities The transaction must include the capability signed with the that owns the token. The transaction also requires the capability if you apply the guard-policy and define a burn guard for the token. Required capabilities and parameters for the function: marmalade-v2.ledger.BURN id account (owner of the token) amount marmalade-v2.guard-policy-v1.BURN token-id account (owner of the token) amount transfer Use to transfer the specified token amount from the specified sender to the specified receiver. Arguments Use the following arguments to transfer a token. Argument Type Description string Specifies the unique token identifier generated using function and formatted as . string Specifies the sender account that the token will be transferred from. string Specifies the receiver account that the token will be transferred to. decimal Specifies the number of tokens to be transferred. When you submit the transaction, the function calls the function in the stored token policies and the function is executed. Capabilities The transaction must include the capability signed with the that owns the token. The transaction also requires the capability if you apply the guard-policy and define a transfer guard for the token. Required capabilities and parameters for the function: marmalade-v2.ledger.TRANSFER id sender receiver amount marmalade-v2.guard-policy-v1.TRANSFER token-id sender receiver amount transfer-create Use to transfer the specified token amount from the specified sender to the specified receiver and creates the receiver account, if the account doesn't exist. Arguments Use the following arguments to transfer a token. Argument Type Description string Specifies the unique token identifier generated using function and formatted as . string Specifies the sender account that the token will be transferred from. string Specifies the receiver account that the token will be transferred to. guard Specifies the guard for the receiver account that the token will be transferred to. decimal Specifies the number of tokens to be transferred. When you submit the transaction, the function calls the function in the stored token policies and the function is executed at . The difference between and is that can be used for both non-existent and existing receiver accounts, with an additional check for the receiver guard if already exists. The can only be used for existing account. Capabilities The transaction must include the capability signed with the that owns the token. The transaction also requires the capability if you apply the guard-policy and define a transfer guard for the token. Required capabilities and parameters for the function: marmalade-v2.ledger.TRANSFER id sender receiver amount marmalade-v2.guard-policy-v1.TRANSFER token-id sender receiver amount sale Use to execute a two-step transaction using the offer and buy steps with a trustless escrow account. Because a sale requires two steps that must be completed in a specific order, the transaction is defined using a pact. For information about the syntax used to define a pact, see defpact. Arguments Use the following arguments to initiate the sale of a token. Argument Type Description string Specifies the unique token identifier generated using function and formatted as . string Specifies the seller account that the token will be offered from. decimal Specifies the number of tokens to be offered for sale. integer Specifies when the offer is set to expire using a timestamp for the number of seconds from UNIX epoch before the offer can be withdrawn. For example, if you want an offer to expire at midnight on 30 June 2024, you specify the timeout as 1719705600. You can set the argument to zero (0) to allow an offer to be withdrawn at any time by the token owner. offer The first step of a pact (step 0) executes the function. The function transfers the token from the seller's account to the escrow account. The function calls the function in the stored token policies and the function is executed at step 0 of the . Capabilities The transaction must include the capability signed with the that owns the token. The transaction also requires the capability if you apply the guard-policy and define a sales guard for the token. Required capabilities and parameters for the function: marmalade-v2.ledger.OFFER id seller amount timeout marmalade-v2.guard-policy-v1.SALE token-id seller amount Environment data If the offer is a dutch or conventional auction, you can add the following information as raw data: quote [object] The quote object includes the following properties: fungible [string] sale-price [decimal] seller-fungible-account [object] account [string] guard [guard] sale-type [string] (optional) withdraw (cont) The pact includes a rollback step (step 0-rollback). The rollback step executes the function. The function transfers the tokens held in the escrow account for the sale back to the seller. If a is specified, the function can only be executed after the timeout period has passed. You can execute the function by sending a continuation () command with the following information: For more information about formatting continuation commands, see Transaction formats. The function calls the function in the stored token policies and the function is executed at step 0-rollback of . Capabilities The transaction must include the capability signed with the that owns the token. The transaction also requires the capability if you apply the guard-policy and define a sales guard for the token. Required capabilities and parameters for the function: marmalade-v2.ledger.WITHDRAW id seller amount timeout sale-id marmalade-v2.guard-policy-v1.SALE token-id seller amount buy (cont) The second step of a pact (step 1) executes the function. The function transfers the tokens held in the escrow account to the buyer. The function can be executed before . The and information is read from the of the command instead of passing in arguments. Like the function, the function is executed using a continuation () command: The function calls the function in the stored token policies and the function is executed at step 1 of . Capabilities The transaction must include the capability signed with the that is buying the token. The transaction also requires the capability if you apply the guard-policy and define a sales guard for the token. Required capabilities and parameters for the function: marmalade-v2.ledger.BUY id seller buyer amount sale-id marmalade-v2.guard-policy-v1.SALE token-id seller amount Environment data If the sale is a dutch or conventional auction, you need to add the following information as raw data: buyer [string] buyer-guard [guard] buyer_fungible_account [string] updated_price [decimal] update-uri Use to update the for an existing token. Arguments Argument Type Description string Specifies the unique token identifier generated using function and formatted as . string Specifies the new . When you submit the transaction, the function calls the function in the stored token policies and the function is executed at . Token creators should configure the entity that will be authorized to update the uri's in the , or in their custom policies. Capabilities The transaction must include the capability signed with the that is buying the token. The transaction also requires the capability if you apply the guard-policy and define a uri guard for the token. Required capabilities and parameters for the function: marmalade-v2.ledger.UPDATE-URI token-id new-uri marmalade-v2.guard-policy-v1.UPDATE-URI token-id new-uri",
    "source": "reference/marmalade/ledger.md",
    "title": "ledger"
  },
  {
    "content": "title: Guard policy description: \"Describes the schemas, tables, capabilities, and functions defined in the guard policy.\" id: guard-policy sidebar_position: 4 Guard policy The guard policy ensures that all token-related actions—minting, burning, transferring, buying, and selling—can only be performed by authorized parties. If you apply the guard policy when you create a token, you can specify who is authorized to perform each type of token activity. This part of the documentation describes the schemas, tables, capabilities, and functions defined in the Marmalade guard policy contract. Source code: guard-policy.pact Schema and table The guard policy smart contract defines one schema and one table. The schema describes guard values for , , , and operations. The table maps token identifiers to their guard values. Capabilities The guard policy smart contract defines the following capabilities to manage permissions: : Governs contract upgrade access. @event: Emits guard info during . : Applies the in . : Applies the in . : Uses the during , , and . : Uses the in . Functions The guard policy smart contract defines the following functions to enforce restrictions of different token activities: : Initializes the table with token ID and guard values. : Validates minting processes. : Validates burning processes. : Confirms sale offers with guards and verifies the sale-id. : Checks sale withdrawals and the sale-id. : Validates buying processes and the sale-id. : Validates transfers, checking sender, receiver, and amount.",
    "source": "reference/marmalade/guard-policy.md",
    "title": "guard-policy"
  },
  {
    "content": "title: Dutch auction reference description: \"Describes the capabilities, schemas, tables, functions, and constants defined in the sales-specific contracts for a dutch auction.\" id: dutch-sale sidebar_position: 3 Dutch auction sale contract This section provides reference information for writing a smart contract to conduct a dutch auction using Marmalade on the Kadena network. The reference information includes the capabilities, schemas, tables, functions, and constants defined for a dutch auction. Source code: dutch-auction.pact Capabilities The dutch auction smart contract defines the following capabilities to manage permissions: : Defines governance for the contract and is controlled by the keyset defined under the constant. : Specifies the event emitted after the auction is created by the seller. : Specifies the event emitted after the buyer successfully executes the function in a sales contract. : Acts as a placeholder capability for the field. Schema and table The describes the following information for a dutch auction: The dutch auction contract stores auction information in the table. Functions The dutch auction contract defines the following functions to manage token sales using the dutch auction format: : Enforces a quote update when required for sale contracts. This function is called by the function to validate that the buyer has transferred the fungible amount equal to set by the dutch auction. The function updates the table with the winner information. : Enforces a withdrawal when required for sale contracts. This function is called by the function to validate that the auction has expired, or that the bid has already been placed. : Validates that the auction information adheres to contract logic in the and functions. : Allows sellers to create the dutch auction for their token after providing auction information. : Allows sellers to update auction information before the auction start time. : Retrieves auction information from the table. : Calculates the current auction price by starting with the and gradually reducing the price per , always ending with the last time interval at the . Constants The dutch auction contract defines the following constants: : Sets the for the capability. : Acts as a placeholder guard constant for the field.",
    "source": "reference/marmalade/dutch-auction-ref.md",
    "title": "dutch-auction-ref"
  },
  {
    "content": "title: Custom sales contracts description: \"Provides a technical overview of how to create a custom sales type contract or call an existing sales contract.\" id: custom-sale sidebar_position: 9 Custom sales contracts As discussed in Contract architecture, you can use a sales-specific contract to manage how tokens are sold—for example, by offering tokens for sale in a conventional auction sale contract or a dutch auction sale contract. Although this is a flexible system for managing sales, sales-specific contracts must be registered in the policy manager to ensure that the policy manager can enforce the proper collection and distribution of tokens and funds. Before you can register a sales-specific contract, the contract must be reviewed by an auditor to ensure that the contract logic is safe to use. If you want to create your own sales-specific contract, you can implement the interface in your contract, then open a pull request in the Marmalade Github repository to begin the review process. Note that creating a sales-specific contract isn't necessary in most cases. You can implement sales-related logic directly in a policy and attach the policy to a token instead of creating a separate contract. Implement the sale contract interface The sale contract interface is a lightweight interface that must be implemented in any sale contract. The interface is used by the policy manager to enforce the logic defined in the contract. The interface is defined as follows: The function is called from the step in the ledger and takes two parameters: : This parameter represents the that is created when the token is offered up for sale in the ledger. : This parameter represents the final price associated with the sale. Using a sales-specific contract You can specify the sale contract to use by providing the module name for the contract as part of the specification when calling the function in the ledger. The following example illustrates the specification with the set to use the sale contract: Note that when you reference a specific , the for the must be because the referenced contract is responsible for updating the final price during the step.",
    "source": "reference/marmalade/custom-sales-contracts.md",
    "title": "custom-sales-contracts"
  },
  {
    "content": "title: Conventional auction reference description: \"Describes the capabilities, schemas, tables, functions, and constants defined in the sales-specific contracts for a conventional auction.\" id: conventional-sale sidebar_position: 2 Conventional auction sale contract This section provides reference information for writing a smart contract to conduct a conventional auction using Marmalade on the Kadena network. The reference information includes the capabilities, schemas, tables, functions, and constants defined for a conventional auction. Source code: conventional-auction.pact Capabilities The conventional auction smart contract defines the following capabilities to manage permissions: : Defines governance for the contract and is controlled by the keyset defined under the constant. : Specifies the event emitted when the function is executed. The emitted event includes the , , and fields. : Identifies a guard to control who can create and update an auction. You must specify the and parameters when you use this capability in and functions. : Specifies the event emitted when a bid is place. The emitted event includes the , , and fields. : Ensures that the bidder signs the transaction to place the bid. : Protects funds held in escrow to ensure refunds can be made, if necessary. Schemas The conventional auction smart contract defines two schemas. The describes the following information for a conventional auction: The describes the following information for a conventional auction: Tables The conventional auction contract stores auction information in the table and bid information in the table. Functions The conventional auction contract defines the following functions to manage token sales using the conventional auction format: : Returns the auction's fungible escrow account name. : Returns the account guard of the escrow account. : Requires that capability is in scope. : Enforces a quote update when required for sale contracts. This function is called by the function to validate that only the winning bidder processes the call, the escrow payment, and the marketplace fee. : Enforces a withdrawal when required for sale contracts. This function is called by the function to validate that the auction has expired, or that the bid has already been placed. : Generates a unique bid identifier by hashing the , , and fields. : Allows sellers to create a conventional auction for their token after providing auction information. : Allows sellers to update auction information before the auction start time. : Retrieves auction information from the table. : Retrieves bid information from the table. : Transfers the bid amount in a fungible currency from the bidder account to an escrow account and records the bids in the blockchain. Constants The conventional auction contract defines the following constant: : Sets the for the capability.",
    "source": "reference/marmalade/conventional-auction-ref.md",
    "title": "conventional-auction-ref"
  },
  {
    "content": "title: Collection policy description: \"Describes the schemas, tables, capabilities, and functions defined in the collection policy contract enable you to manage a token collection.\" id: collection-policy sidebar_position: 1 Collection policy The collection policy implements the interface to simplify how you can organize tokens into collections. This part of the documentation describes the functions and capabilities defined in the collection policy contract. Source code: collection-policy.pact Schemas and tables The schema describes the following information for a token collection: id:string name:string size:integer max-size:integer operator-guard:guard operator-account:string This information is stored in the table. The schema describes the following information for a token in a collection: id:string collection-id:string This information is stored in the table. Capabilities The collection policy smart contract defines the following capabilities to manage permissions: : Restricts authority to the keyset and ensures only authorized entities can upgrade the contract. @event: Regulates collection creation and broadcasts of the COLLECTION event. @event: Manages token addition to collections and announces such additions. Functions The dutch auction contract defines the following functions to manage token collections: Initiates a collection by defining its name, size, and overseeing entity. Adds tokens to the collection while abiding by the collection's set size. It also determines the entity permitted to mint the token. : Ascertain that the minting entity has appropriate permissions. Retrieves a collection identifier using the collection's name. Extracts collection details using a collection ID. Gleans token details, focusing on its association with a collection, via the token ID.",
    "source": "reference/marmalade/collection-policy.md",
    "title": "collection-policy"
  }
]
